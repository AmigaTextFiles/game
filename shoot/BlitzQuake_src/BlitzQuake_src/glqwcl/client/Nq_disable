/*
================
R_BlendLightmaps
================
*/

/* replaced by surgeon

R_BlendLightmaps (void)
{
  register int     i, j;
  register glpoly_t  *p;
  register float   *v;
  register glRect_t  *theRect;

#if 0   
  if (r_fullbright.value)
    return;
#endif

  if (!gl_texsort.value)
    return;

  glDepthMask (0);    // don't bother writing Z
                                                 //30/01/2000 modified: M.Tretene
  if (gl_lightmap_format == GL_LUMINANCE)
    glBlendFunc (GL_ZERO, GL_ONE_MINUS_SRC_COLOR);

  else if (gl_lightmap_format == GL_INTENSITY)
  {
    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
    glColor4f (0,0,0,1);
    glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  }

  if (!r_lightmap.value)
  {
    glEnable (GL_BLEND);
  }

  glEnable(MGL_Z_OFFSET);
    
  for (i=0 ; i<MAX_LIGHTMAPS ; i++)
  {
    p = lightmap_polys[i];
    if (!p)
      continue;
    GL_Bind(lightmap_textures+i);
    if (lightmap_modified[i])
    {
      lightmap_modified[i] = false;
      theRect = &lightmap_rectchange[i];
//      glTexImage2D (GL_TEXTURE_2D, 0, lightmap_bytes
//        , BLOCK_WIDTH, BLOCK_HEIGHT, 0, 
//        gl_lightmap_format, GL_UNSIGNED_BYTE, lightmaps+i*BLOCK_WIDTH*BLOCK_HEIGHT*lightmap_bytes);
//      glTexImage2D (GL_TEXTURE_2D, 0, lightmap_bytes
//        , BLOCK_WIDTH, theRect->h, 0, 
//        gl_lightmap_format, GL_UNSIGNED_BYTE, lightmaps+(i*BLOCK_HEIGHT+theRect->t)*BLOCK_WIDTH*lightmap_bytes);
      glTexSubImage2D(GL_TEXTURE_2D, 0, 0, theRect->t, 
        BLOCK_WIDTH, theRect->h, gl_lightmap_format, GL_UNSIGNED_BYTE,
        lightmaps+(i* BLOCK_HEIGHT + theRect->t) *BLOCK_WIDTH*lightmap_bytes);        
      theRect->l = BLOCK_WIDTH;
      theRect->t = BLOCK_HEIGHT;
      theRect->h = 0;
      theRect->w = 0;
    }
    for ( ; p ; p=p->chain)
    {
      if (p->flags & SURF_UNDERWATER)
        DrawGLWaterPolyLightmap (p);
      else
      {
        glBegin (GL_POLYGON);
        v = p->verts[0];
        for (j=0 ; j<p->numverts ; j++, v+= VERTEXSIZE)
        {
          glTexCoord2f (v[5], v[6]);
          glVertex3fv (v);
        }
        glEnd (); 
      }
    }
  }

  glDisable(MGL_Z_OFFSET);

  glDisable (GL_BLEND);
                                                   // 30/01/2000 modified: M.Tretene
  if (gl_lightmap_format == GL_LUMINANCE)
    glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  else if (gl_lightmap_format == GL_INTENSITY)
  {
    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
    glColor4f (1,1,1,1);
  }

  glDepthMask (1);    // back to normal Z buffering
}
*/
