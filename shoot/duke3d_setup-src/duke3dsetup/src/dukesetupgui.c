/*
 *  Source machine generated by GadToolsBox V2.0b
 *  which is (c) Copyright 1991-1993 Jaba Development
 *
 *  GUI Designed by : -- dante --
 */

#include <exec/types.h>
#include <intuition/intuition.h>
#include <intuition/classes.h>
#include <intuition/classusr.h>
#include <intuition/imageclass.h>
#include <intuition/gadgetclass.h>
#include <libraries/gadtools.h>
#include <graphics/displayinfo.h>
#include <graphics/gfxbase.h>
#include <clib/exec_protos.h>
#include <clib/intuition_protos.h>
#include <clib/gadtools_protos.h>
#include <clib/graphics_protos.h>
#include <clib/utility_protos.h>
#include <string.h>
#include <clib/diskfont_protos.h>

#include "dukesetupgui.h"

struct Screen         *Scr = NULL;
UBYTE                 *PubScreenName = NULL;
APTR                   VisualInfo = NULL;
struct Window         *mainWnd = NULL;
struct Window         *soundWnd = NULL;
struct Window         *keyboardWnd = NULL;
struct Window         *screenWnd = NULL;
struct Window         *mouseWnd = NULL;
struct Window         *mactsWnd = NULL;
struct Gadget         *mainGList = NULL;
struct Gadget         *soundGList = NULL;
struct Gadget         *keyboardGList = NULL;
struct Gadget         *screenGList = NULL;
struct Gadget         *mouseGList = NULL;
struct Gadget         *mactsGList = NULL;
struct Gadget         *mainGadgets[6];
struct Gadget         *soundGadgets[7];
struct Gadget         *keyboardGadgets[4];
struct Gadget         *screenGadgets[6];
struct Gadget         *mouseGadgets[22];
struct Gadget         *mactsGadgets[2];
UWORD                  mainLeft = 0;
UWORD                  mainTop = 15;
UWORD                  mainWidth = 257;
UWORD                  mainHeight = 168;
UWORD                  soundLeft = 0;
UWORD                  soundTop = 15;
UWORD                  soundWidth = 430;
UWORD                  soundHeight = 160;
UWORD                  keyboardLeft = 0;
UWORD                  keyboardTop = 15;
UWORD                  keyboardWidth = 358;
UWORD                  keyboardHeight = 236;
UWORD                  screenLeft = 0;
UWORD                  screenTop = 15;
UWORD                  screenWidth = 362;
UWORD                  screenHeight = 116;
UWORD                  mouseLeft = 0;
UWORD                  mouseTop = 15;
UWORD                  mouseWidth = 591;
UWORD                  mouseHeight = 220;
UWORD                  mactsLeft = 35;
UWORD                  mactsTop = 39;
UWORD                  mactsWidth = 243;
UWORD                  mactsHeight = 229;
UBYTE                 *mainWdt = (UBYTE *)"Duke3D Setup";
UBYTE                 *soundWdt = (UBYTE *)"Sound Setup";
UBYTE                 *keyboardWdt = (UBYTE *)"Keyboard Setup";
UBYTE                 *screenWdt = (UBYTE *)"Screen Setup";
UBYTE                 *mouseWdt = (UBYTE *)"Mouse Setup";
UBYTE                 *mactsWdt = (UBYTE *)"Available Actions";
struct TextAttr       *Font, Attr;
UWORD                  FontX, FontY;
UWORD                  OffX, OffY;
struct TextFont       *mainFont = NULL;
struct TextFont       *soundFont = NULL;
struct TextFont       *keyboardFont = NULL;
struct TextFont       *screenFont = NULL;
struct TextFont       *mouseFont = NULL;
struct TextFont       *mactsFont = NULL;

UBYTE *sound_voices1Labels[] = {
	(UBYTE *)"1",
	(UBYTE *)"2",
	(UBYTE *)"3",
	(UBYTE *)"4",
	(UBYTE *)"5",
	(UBYTE *)"6",
	(UBYTE *)"7",
	(UBYTE *)"8",
	NULL };

UBYTE *mouse_aimmode4Labels[] = {
	(UBYTE *)"Mouse Aiming is a toggle Button",
	(UBYTE *)"Mouse Aiming is a momentary button",
	NULL };

UWORD mainGTypes[] = {
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND
};

UWORD soundGTypes[] = {
	TEXT_KIND,
	BUTTON_KIND,
	CYCLE_KIND,
	SLIDER_KIND,
	CHECKBOX_KIND,
	BUTTON_KIND,
	BUTTON_KIND
};

UWORD keyboardGTypes[] = {
	LISTVIEW_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND
};

UWORD screenGTypes[] = {
	BUTTON_KIND,
	TEXT_KIND,
	CHECKBOX_KIND,
	CHECKBOX_KIND,
	BUTTON_KIND,
	BUTTON_KIND
};

UWORD mouseGTypes[] = {
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	TEXT_KIND,
	TEXT_KIND,
	TEXT_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	TEXT_KIND,
	TEXT_KIND,
	TEXT_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	SLIDER_KIND,
	MX_KIND,
	TEXT_KIND,
	TEXT_KIND,
	TEXT_KIND,
	TEXT_KIND,
	CHECKBOX_KIND
};

UWORD mactsGTypes[] = {
	LISTVIEW_KIND,
	BUTTON_KIND
};

struct NewGadget mainNGad[] = {
	38, 13, 181, 21, (UBYTE *)"Sound Setup", NULL, GD_main_soundsetup, PLACETEXT_IN, NULL, NULL,
	38, 42, 181, 21, (UBYTE *)"Screen Setup", NULL, GD_main_screensetup, PLACETEXT_IN, NULL, NULL,
	38, 100, 181, 21, (UBYTE *)"Keyboard Setup", NULL, GD_main_kbsetup, PLACETEXT_IN, NULL, NULL,
	6, 141, 121, 21, (UBYTE *)"Save & Exit", NULL, GD_main_ok, PLACETEXT_IN, NULL, NULL,
	130, 141, 121, 21, (UBYTE *)"Quit", NULL, GD_main_cancel, PLACETEXT_IN, NULL, NULL,
	38, 71, 181, 21, (UBYTE *)"Mouse Setup", NULL, GD_main_mousesetup, PLACETEXT_IN, NULL, NULL
};

struct NewGadget soundNGad[] = {
	147, 15, 268, 21, NULL, NULL, GD_sound_selecteddevice, 0, NULL, NULL,
	16, 15, 129, 21, (UBYTE *)"AHI-Setup", NULL, GD_sound_ahisetup, PLACETEXT_IN, NULL, NULL,
	16, 64, 129, 21, (UBYTE *)"Number of Voices", NULL, GD_sound_voices, PLACETEXT_ABOVE, NULL, NULL,
	99, 101, 276, 13, (UBYTE *)"SFX Volume", NULL, GD_sound_sfxvolume, PLACETEXT_LEFT, NULL, NULL,
	292, 64, 26, 11, (UBYTE *)"Reverse Stereo", NULL, GD_sound_rvstereo, PLACETEXT_LEFT, NULL, NULL,
	6, 133, 129, 21, (UBYTE *)"OK", NULL, GD_sound_ok, PLACETEXT_IN, NULL, NULL,
	296, 133, 129, 21, (UBYTE *)"Cancel", NULL, GD_sound_cancel, PLACETEXT_IN, NULL, NULL
};

struct NewGadget keyboardNGad[] = {
	16, 25, 321, 180, (UBYTE *)"Choose a key definition to modify", NULL, GD_kb_listview, PLACETEXT_ABOVE, NULL, NULL,
	6, 210, 97, 21, (UBYTE *)"OK", NULL, GD_kb_ok, PLACETEXT_IN, NULL, NULL,
	255, 210, 97, 21, (UBYTE *)"Cancel", NULL, GD_kb_cancel, PLACETEXT_IN, NULL, NULL,
	130, 211, 97, 21, (UBYTE *)"Defaults", NULL, GD_kb_defaults, PLACETEXT_IN, NULL, NULL
};

struct NewGadget screenNGad[] = {
	16, 15, 121, 21, (UBYTE *)"Screenmode", NULL, GD_screen_mode, PLACETEXT_IN, NULL, NULL,
	153, 15, 197, 21, NULL, NULL, GD_screen_modedesc, 0, NULL, NULL,
	16, 60, 26, 11, (UBYTE *)"double buffer", NULL, GD_screen_dblbuffer, PLACETEXT_RIGHT, NULL, NULL,
	153, 60, 26, 11, (UBYTE *)"direct access", NULL, GD_screen_directaccess, PLACETEXT_RIGHT, NULL, NULL,
	6, 89, 121, 21, (UBYTE *)"OK", NULL, GD_screen_ok, PLACETEXT_IN, NULL, NULL,
	234, 89, 121, 21, (UBYTE *)"Cancel", NULL, GD_screen_cancel, PLACETEXT_IN, NULL, NULL
};

struct NewGadget mouseNGad[] = {
	16, 27, 129, 21, (UBYTE *)"Left Button", NULL, GD_mouse_scl, PLACETEXT_IN, NULL, NULL,
	16, 52, 129, 21, (UBYTE *)"Middle Button", NULL, GD_mouse_scm, PLACETEXT_IN, NULL, NULL,
	16, 77, 129, 21, (UBYTE *)"Right Button", NULL, GD_mouse_scr, PLACETEXT_IN, NULL, NULL,
	149, 27, 129, 21, NULL, NULL, GD_mouse_scl_text, 0, NULL, NULL,
	149, 52, 129, 21, NULL, NULL, GD_mouse_scm_text, 0, NULL, NULL,
	149, 77, 129, 21, NULL, NULL, GD_mouse_scr_text, 0, NULL, NULL,
	308, 26, 129, 21, (UBYTE *)"Left Button", NULL, GD_mouse_dcl, PLACETEXT_IN, NULL, NULL,
	308, 51, 129, 21, (UBYTE *)"Middle Button", NULL, GD_mouse_dcm, PLACETEXT_IN, NULL, NULL,
	308, 76, 129, 21, (UBYTE *)"Right Button", NULL, GD_mouse_dcr, PLACETEXT_IN, NULL, NULL,
	440, 26, 129, 21, NULL, NULL, GD_mouse_dcl_text, 0, NULL, NULL,
	440, 51, 129, 21, NULL, NULL, GD_mouse_dcm_text, 0, NULL, NULL,
	440, 76, 129, 21, NULL, NULL, GD_mouse_dcr_text, 0, NULL, NULL,
	6, 195, 129, 19, (UBYTE *)"OK", NULL, GD_mouse_ok, PLACETEXT_IN, NULL, NULL,
	229, 195, 129, 19, (UBYTE *)"Defaults", NULL, GD_mouse_defaults, PLACETEXT_IN, NULL, NULL,
	453, 195, 129, 19, (UBYTE *)"Cancel", NULL, GD_mouse_cancel, PLACETEXT_IN, NULL, NULL,
	16, 147, 225, 21, NULL, NULL, GD_mouse_sensi, 0, NULL, NULL,
	308, 134, 17, 9, NULL, NULL, GD_mouse_aimmode, PLACETEXT_RIGHT, NULL, NULL,
	6, 109, 257, 20, NULL, NULL, GD_mstext, 0, NULL, NULL,
	6, 1, 257, 20, NULL, NULL, GD_mouse_sctext, 0, NULL, NULL,
	298, 1, 257, 20, NULL, NULL, GD_dcltext, 0, NULL, NULL,
	298, 109, 257, 20, NULL, NULL, GD_matext, 0, NULL, NULL,
	308, 167, 26, 11, (UBYTE *)"Invert Mouse Aiming up and down", NULL, GD_mouse_invert, PLACETEXT_RIGHT, NULL, NULL
};

struct NewGadget mactsNGad[] = {
	16, 25, 207, 168, (UBYTE *)"Choose an entry from the list", NULL, GD_mact_list, PLACETEXT_ABOVE, NULL, NULL,
	54, 193, 130, 21, (UBYTE *)"Abort", NULL, GD_mact_abort, PLACETEXT_IN, NULL, NULL
};

ULONG mainGTags[] = {
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE)
};

ULONG soundGTags[] = {
	(GTTX_Text), (ULONG)"(none)", (GTTX_Border), TRUE, (TAG_DONE),
	(TAG_DONE),
	(GTCY_Labels), (ULONG)&sound_voices1Labels[ 0 ], (TAG_DONE),
	(GTSL_Max), 255, (GTSL_Level), 128, (GTSL_MaxLevelLen), 3, (GTSL_LevelFormat), (ULONG)"%ld", (GTSL_LevelPlace), (PLACETEXT_RIGHT), (PGA_Freedom), LORIENT_HORIZ, (GA_RelVerify), TRUE, (TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE)
};

ULONG keyboardGTags[] = {
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE)
};

ULONG screenGTags[] = {
	(TAG_DONE),
	(GTTX_Text), (ULONG)"(none)", (GTTX_Border), TRUE, (TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE)
};

ULONG mouseGTags[] = {
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(GTTX_Border), TRUE, (TAG_DONE),
	(GTTX_Border), TRUE, (TAG_DONE),
	(GTTX_Border), TRUE, (TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(GTTX_Border), TRUE, (TAG_DONE),
	(GTTX_Border), TRUE, (TAG_DONE),
	(GTTX_Border), TRUE, (TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(GTSL_Max), 400, (GTSL_MaxLevelLen), 5, (GTSL_LevelFormat), (ULONG)"%ld%%", (GTSL_LevelPlace), (PLACETEXT_RIGHT), (PGA_Freedom), LORIENT_HORIZ, (GA_RelVerify), TRUE, (TAG_DONE),
	(GTMX_Labels), (ULONG)&mouse_aimmode4Labels[ 0 ], (TAG_DONE),
	(GTTX_Text), (ULONG)"Mouse Sensitivity:", (TAG_DONE),
	(GTTX_Text), (ULONG)"Single Clicked Mouse Buttons:", (TAG_DONE),
	(GTTX_Text), (ULONG)"Double Clicked Mouse Buttons:", (TAG_DONE),
	(GTTX_Text), (ULONG)"Mouse Aiming Mode:", (TAG_DONE),
	(TAG_DONE)
};

ULONG mactsGTags[] = {
	(TAG_DONE),
	(TAG_DONE)
};

static UWORD ComputeX( UWORD value )
{
	return(( UWORD )((( FontX * value ) + 3 ) / 7 ));
}

static UWORD ComputeY( UWORD value )
{
	return(( UWORD )((( FontY * value ) + 6 ) / 12 ));
}

static void ComputeFont( UWORD width, UWORD height )
{
	Forbid();
	Font = &Attr;
	Font->ta_Name = (STRPTR)GfxBase->DefaultFont->tf_Message.mn_Node.ln_Name;
	Font->ta_YSize = FontY = GfxBase->DefaultFont->tf_YSize;
	FontX = GfxBase->DefaultFont->tf_XSize;
	Permit();

	OffX = Scr->WBorLeft;
	OffY = Scr->RastPort.TxHeight + Scr->WBorTop + 1;

	if ( width && height ) {
		if (( ComputeX( width ) + OffX + Scr->WBorRight ) > Scr->Width )
			goto UseTopaz;
		if (( ComputeY( height ) + OffY + Scr->WBorBottom ) > Scr->Height )
			goto UseTopaz;
	}
	return;

UseTopaz:
	Font->ta_Name = (STRPTR)"topaz.font";
	FontX = FontY = Font->ta_YSize = 8;
}

int SetupScreen( void )
{
	if ( ! ( Scr = LockPubScreen( PubScreenName )))
		return( 1L );

	ComputeFont( 0, 0 );

	if ( ! ( VisualInfo = GetVisualInfo( Scr, TAG_DONE )))
		return( 2L );

	return( 0L );
}

void CloseDownScreen( void )
{
	if ( VisualInfo ) {
		FreeVisualInfo( VisualInfo );
		VisualInfo = NULL;
	}

	if ( Scr        ) {
		UnlockPubScreen( NULL, Scr );
		Scr = NULL;
	}
}

void mainRender( void )
{
	ComputeFont( mainWidth, mainHeight );

	DrawBevelBox( mainWnd->RPort, OffX + ComputeX( 7 ),
					OffY + ComputeY( 6 ),
					ComputeX( 243 ),
					ComputeY( 123 ),
					GT_VisualInfo, VisualInfo, TAG_DONE );
	DrawBevelBox( mainWnd->RPort, OffX + ComputeX( 6 ),
					OffY + ComputeY( 5 ),
					ComputeX( 245 ),
					ComputeY( 125 ),
					GT_VisualInfo, VisualInfo, GTBB_Recessed, TRUE, TAG_DONE );
}

int OpenmainWindow( void )
{
	struct NewGadget	ng;
	struct Gadget	*g;
	UWORD		lc, tc;
	UWORD		wleft = mainLeft, wtop = mainTop, ww, wh;

	ComputeFont( mainWidth, mainHeight );

	ww = ComputeX( mainWidth );
	wh = ComputeY( mainHeight );

	if (( wleft + ww + OffX + Scr->WBorRight ) > Scr->Width ) wleft = Scr->Width - ww;
	if (( wtop + wh + OffY + Scr->WBorBottom ) > Scr->Height ) wtop = Scr->Height - wh;

	if ( ! ( mainFont = OpenDiskFont( Font )))
		return( 5L );

	if ( ! ( g = CreateContext( &mainGList )))
		return( 1L );

	for( lc = 0, tc = 0; lc < main_CNT; lc++ ) {

		CopyMem((char * )&mainNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

		ng.ng_VisualInfo = VisualInfo;
		ng.ng_TextAttr   = Font;
		ng.ng_LeftEdge   = OffX + ComputeX( ng.ng_LeftEdge );
		ng.ng_TopEdge    = OffY + ComputeY( ng.ng_TopEdge );
		ng.ng_Width      = ComputeX( ng.ng_Width );
		ng.ng_Height     = ComputeY( ng.ng_Height);

		mainGadgets[ lc ] = g = CreateGadgetA((ULONG)mainGTypes[ lc ], g, &ng, ( struct TagItem * )&mainGTags[ tc ] );

		while( mainGTags[ tc ] ) tc += 2;
		tc++;

		if ( NOT g )
			return( 2L );
	}

	if ( ! ( mainWnd = OpenWindowTags( NULL,
				WA_Left,	wleft,
				WA_Top,		wtop,
				WA_Width,	ww + OffX + Scr->WBorRight,
				WA_Height,	wh + OffY + Scr->WBorBottom,
				WA_IDCMP,	BUTTONIDCMP|IDCMP_GADGETDOWN|IDCMP_INTUITICKS|IDCMP_MOUSEBUTTONS|IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW,
				WA_Flags,	WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_ACTIVATE,
				WA_Gadgets,	mainGList,
				WA_Title,	mainWdt,
				WA_ScreenTitle,	"Duke Nukem 3D Atomic Edition Setup V1.0 by dante/oxyron",
				WA_PubScreen,	Scr,
				WA_AutoAdjust,	TRUE,
				TAG_DONE )))
	return( 4L );

	GT_RefreshWindow( mainWnd, NULL );

	mainRender();

	return( 0L );
}

void ClosemainWindow( void )
{
	if ( mainWnd        ) {
		CloseWindow( mainWnd );
		mainWnd = NULL;
	}

	if ( mainGList      ) {
		FreeGadgets( mainGList );
		mainGList = NULL;
	}

	if ( mainFont ) {
		CloseFont( mainFont );
		mainFont = NULL;
	}
}

void soundRender( void )
{
	ComputeFont( soundWidth, soundHeight );

	DrawBevelBox( soundWnd->RPort, OffX + ComputeX( 7 ),
					OffY + ComputeY( 6 ),
					ComputeX( 417 ),
					ComputeY( 120 ),
					GT_VisualInfo, VisualInfo, TAG_DONE );
	DrawBevelBox( soundWnd->RPort, OffX + ComputeX( 6 ),
					OffY + ComputeY( 5 ),
					ComputeX( 419 ),
					ComputeY( 122 ),
					GT_VisualInfo, VisualInfo, GTBB_Recessed, TRUE, TAG_DONE );
}

int OpensoundWindow( void )
{
	struct NewGadget	ng;
	struct Gadget	*g;
	UWORD		lc, tc;
	UWORD		wleft = soundLeft, wtop = soundTop, ww, wh;

	ComputeFont( soundWidth, soundHeight );

	ww = ComputeX( soundWidth );
	wh = ComputeY( soundHeight );

	if (( wleft + ww + OffX + Scr->WBorRight ) > Scr->Width ) wleft = Scr->Width - ww;
	if (( wtop + wh + OffY + Scr->WBorBottom ) > Scr->Height ) wtop = Scr->Height - wh;

	if ( ! ( soundFont = OpenDiskFont( Font )))
		return( 5L );

	if ( ! ( g = CreateContext( &soundGList )))
		return( 1L );

	for( lc = 0, tc = 0; lc < sound_CNT; lc++ ) {

		CopyMem((char * )&soundNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

		ng.ng_VisualInfo = VisualInfo;
		ng.ng_TextAttr   = Font;
		ng.ng_LeftEdge   = OffX + ComputeX( ng.ng_LeftEdge );
		ng.ng_TopEdge    = OffY + ComputeY( ng.ng_TopEdge );
		ng.ng_Width      = ComputeX( ng.ng_Width );
		ng.ng_Height     = ComputeY( ng.ng_Height);

		soundGadgets[ lc ] = g = CreateGadgetA((ULONG)soundGTypes[ lc ], g, &ng, ( struct TagItem * )&soundGTags[ tc ] );

		while( soundGTags[ tc ] ) tc += 2;
		tc++;

		if ( NOT g )
			return( 2L );
	}

	if ( ! ( soundWnd = OpenWindowTags( NULL,
				WA_Left,	wleft,
				WA_Top,		wtop,
				WA_Width,	ww + OffX + Scr->WBorRight,
				WA_Height,	wh + OffY + Scr->WBorBottom,
				WA_IDCMP,	TEXTIDCMP|BUTTONIDCMP|CYCLEIDCMP|SLIDERIDCMP|CHECKBOXIDCMP|IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW,
				WA_Flags,	WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_ACTIVATE,
				WA_Gadgets,	soundGList,
				WA_Title,	soundWdt,
				WA_ScreenTitle,	"Duke Nukem 3D Atomic Edition - Sound Setup",
				WA_PubScreen,	Scr,
				WA_AutoAdjust,	TRUE,
				TAG_DONE )))
	return( 4L );

	GT_RefreshWindow( soundWnd, NULL );

	soundRender();

	return( 0L );
}

void ClosesoundWindow( void )
{
	if ( soundWnd        ) {
		CloseWindow( soundWnd );
		soundWnd = NULL;
	}

	if ( soundGList      ) {
		FreeGadgets( soundGList );
		soundGList = NULL;
	}

	if ( soundFont ) {
		CloseFont( soundFont );
		soundFont = NULL;
	}
}

void keyboardRender( void )
{
	ComputeFont( keyboardWidth, keyboardHeight );

	DrawBevelBox( keyboardWnd->RPort, OffX + ComputeX( 7 ),
					OffY + ComputeY( 6 ),
					ComputeX( 344 ),
					ComputeY( 199 ),
					GT_VisualInfo, VisualInfo, TAG_DONE );
	DrawBevelBox( keyboardWnd->RPort, OffX + ComputeX( 6 ),
					OffY + ComputeY( 5 ),
					ComputeX( 346 ),
					ComputeY( 201 ),
					GT_VisualInfo, VisualInfo, GTBB_Recessed, TRUE, TAG_DONE );
}

int OpenkeyboardWindow( void )
{
	struct NewGadget	ng;
	struct Gadget	*g;
	UWORD		lc, tc;
	UWORD		wleft = keyboardLeft, wtop = keyboardTop, ww, wh;

	ComputeFont( keyboardWidth, keyboardHeight );

	ww = ComputeX( keyboardWidth );
	wh = ComputeY( keyboardHeight );

	if (( wleft + ww + OffX + Scr->WBorRight ) > Scr->Width ) wleft = Scr->Width - ww;
	if (( wtop + wh + OffY + Scr->WBorBottom ) > Scr->Height ) wtop = Scr->Height - wh;

	if ( ! ( keyboardFont = OpenDiskFont( Font )))
		return( 5L );

	if ( ! ( g = CreateContext( &keyboardGList )))
		return( 1L );

	for( lc = 0, tc = 0; lc < keyboard_CNT; lc++ ) {

		CopyMem((char * )&keyboardNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

		ng.ng_VisualInfo = VisualInfo;
		ng.ng_TextAttr   = Font;
		ng.ng_LeftEdge   = OffX + ComputeX( ng.ng_LeftEdge );
		ng.ng_TopEdge    = OffY + ComputeY( ng.ng_TopEdge );
		ng.ng_Width      = ComputeX( ng.ng_Width );
		ng.ng_Height     = ComputeY( ng.ng_Height);

		keyboardGadgets[ lc ] = g = CreateGadgetA((ULONG)keyboardGTypes[ lc ], g, &ng, ( struct TagItem * )&keyboardGTags[ tc ] );

		while( keyboardGTags[ tc ] ) tc += 2;
		tc++;

		if ( NOT g )
			return( 2L );
	}

	if ( ! ( keyboardWnd = OpenWindowTags( NULL,
				WA_Left,	wleft,
				WA_Top,		wtop,
				WA_Width,	ww + OffX + Scr->WBorRight,
				WA_Height,	wh + OffY + Scr->WBorBottom,
				WA_IDCMP,	LISTVIEWIDCMP|BUTTONIDCMP|IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW,
				WA_Flags,	WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_ACTIVATE,
				WA_Gadgets,	keyboardGList,
				WA_Title,	keyboardWdt,
				WA_ScreenTitle,	"Duke Nukem 3D Atomic Edition - Keyboard Setup",
				WA_PubScreen,	Scr,
				WA_AutoAdjust,	TRUE,
				TAG_DONE )))
	return( 4L );

	GT_RefreshWindow( keyboardWnd, NULL );

	keyboardRender();

	return( 0L );
}

void ClosekeyboardWindow( void )
{
	if ( keyboardWnd        ) {
		CloseWindow( keyboardWnd );
		keyboardWnd = NULL;
	}

	if ( keyboardGList      ) {
		FreeGadgets( keyboardGList );
		keyboardGList = NULL;
	}

	if ( keyboardFont ) {
		CloseFont( keyboardFont );
		keyboardFont = NULL;
	}
}

void screenRender( void )
{
	ComputeFont( screenWidth, screenHeight );

	DrawBevelBox( screenWnd->RPort, OffX + ComputeX( 7 ),
					OffY + ComputeY( 6 ),
					ComputeX( 348 ),
					ComputeY( 77 ),
					GT_VisualInfo, VisualInfo, TAG_DONE );
	DrawBevelBox( screenWnd->RPort, OffX + ComputeX( 6 ),
					OffY + ComputeY( 5 ),
					ComputeX( 350 ),
					ComputeY( 79 ),
					GT_VisualInfo, VisualInfo, GTBB_Recessed, TRUE, TAG_DONE );
}

int OpenscreenWindow( void )
{
	struct NewGadget	ng;
	struct Gadget	*g;
	UWORD		lc, tc;
	UWORD		wleft = screenLeft, wtop = screenTop, ww, wh;

	ComputeFont( screenWidth, screenHeight );

	ww = ComputeX( screenWidth );
	wh = ComputeY( screenHeight );

	if (( wleft + ww + OffX + Scr->WBorRight ) > Scr->Width ) wleft = Scr->Width - ww;
	if (( wtop + wh + OffY + Scr->WBorBottom ) > Scr->Height ) wtop = Scr->Height - wh;

	if ( ! ( screenFont = OpenDiskFont( Font )))
		return( 5L );

	if ( ! ( g = CreateContext( &screenGList )))
		return( 1L );

	for( lc = 0, tc = 0; lc < screen_CNT; lc++ ) {

		CopyMem((char * )&screenNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

		ng.ng_VisualInfo = VisualInfo;
		ng.ng_TextAttr   = Font;
		ng.ng_LeftEdge   = OffX + ComputeX( ng.ng_LeftEdge );
		ng.ng_TopEdge    = OffY + ComputeY( ng.ng_TopEdge );
		ng.ng_Width      = ComputeX( ng.ng_Width );
		ng.ng_Height     = ComputeY( ng.ng_Height);

		screenGadgets[ lc ] = g = CreateGadgetA((ULONG)screenGTypes[ lc ], g, &ng, ( struct TagItem * )&screenGTags[ tc ] );

		while( screenGTags[ tc ] ) tc += 2;
		tc++;

		if ( NOT g )
			return( 2L );
	}

	if ( ! ( screenWnd = OpenWindowTags( NULL,
				WA_Left,	wleft,
				WA_Top,		wtop,
				WA_Width,	ww + OffX + Scr->WBorRight,
				WA_Height,	wh + OffY + Scr->WBorBottom,
				WA_IDCMP,	BUTTONIDCMP|TEXTIDCMP|CHECKBOXIDCMP|IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW,
				WA_Flags,	WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_ACTIVATE,
				WA_Gadgets,	screenGList,
				WA_Title,	screenWdt,
				WA_ScreenTitle,	"Duke Nukem 3D Atomic Edition - Screen Setup",
				WA_PubScreen,	Scr,
				WA_AutoAdjust,	TRUE,
				TAG_DONE )))
	return( 4L );

	GT_RefreshWindow( screenWnd, NULL );

	screenRender();

	return( 0L );
}

void ClosescreenWindow( void )
{
	if ( screenWnd        ) {
		CloseWindow( screenWnd );
		screenWnd = NULL;
	}

	if ( screenGList      ) {
		FreeGadgets( screenGList );
		screenGList = NULL;
	}

	if ( screenFont ) {
		CloseFont( screenFont );
		screenFont = NULL;
	}
}

void mouseRender( void )
{
	ComputeFont( mouseWidth, mouseHeight );

	DrawBevelBox( mouseWnd->RPort, OffX + ComputeX( 299 ),
					OffY + ComputeY( 20 ),
					ComputeX( 283 ),
					ComputeY( 87 ),
					GT_VisualInfo, VisualInfo, TAG_DONE );
	DrawBevelBox( mouseWnd->RPort, OffX + ComputeX( 7 ),
					OffY + ComputeY( 128 ),
					ComputeX( 283 ),
					ComputeY( 57 ),
					GT_VisualInfo, VisualInfo, TAG_DONE );
	DrawBevelBox( mouseWnd->RPort, OffX + ComputeX( 7 ),
					OffY + ComputeY( 20 ),
					ComputeX( 283 ),
					ComputeY( 87 ),
					GT_VisualInfo, VisualInfo, TAG_DONE );
	DrawBevelBox( mouseWnd->RPort, OffX + ComputeX( 299 ),
					OffY + ComputeY( 128 ),
					ComputeX( 283 ),
					ComputeY( 57 ),
					GT_VisualInfo, VisualInfo, TAG_DONE );
	DrawBevelBox( mouseWnd->RPort, OffX + ComputeX( 6 ),
					OffY + ComputeY( 19 ),
					ComputeX( 285 ),
					ComputeY( 89 ),
					GT_VisualInfo, VisualInfo, GTBB_Recessed, TRUE, TAG_DONE );
	DrawBevelBox( mouseWnd->RPort, OffX + ComputeX( 6 ),
					OffY + ComputeY( 127 ),
					ComputeX( 285 ),
					ComputeY( 59 ),
					GT_VisualInfo, VisualInfo, GTBB_Recessed, TRUE, TAG_DONE );
	DrawBevelBox( mouseWnd->RPort, OffX + ComputeX( 298 ),
					OffY + ComputeY( 19 ),
					ComputeX( 285 ),
					ComputeY( 89 ),
					GT_VisualInfo, VisualInfo, GTBB_Recessed, TRUE, TAG_DONE );
	DrawBevelBox( mouseWnd->RPort, OffX + ComputeX( 298 ),
					OffY + ComputeY( 127 ),
					ComputeX( 285 ),
					ComputeY( 59 ),
					GT_VisualInfo, VisualInfo, GTBB_Recessed, TRUE, TAG_DONE );
}

int OpenmouseWindow( void )
{
	struct NewGadget	ng;
	struct Gadget	*g;
	UWORD		lc, tc;
	UWORD		wleft = mouseLeft, wtop = mouseTop, ww, wh;

	ComputeFont( mouseWidth, mouseHeight );

	ww = ComputeX( mouseWidth );
	wh = ComputeY( mouseHeight );

	if (( wleft + ww + OffX + Scr->WBorRight ) > Scr->Width ) wleft = Scr->Width - ww;
	if (( wtop + wh + OffY + Scr->WBorBottom ) > Scr->Height ) wtop = Scr->Height - wh;

	if ( ! ( mouseFont = OpenDiskFont( Font )))
		return( 5L );

	if ( ! ( g = CreateContext( &mouseGList )))
		return( 1L );

	for( lc = 0, tc = 0; lc < mouse_CNT; lc++ ) {

		CopyMem((char * )&mouseNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

		ng.ng_VisualInfo = VisualInfo;
		ng.ng_TextAttr   = Font;
		ng.ng_LeftEdge   = OffX + ComputeX( ng.ng_LeftEdge );
		ng.ng_TopEdge    = OffY + ComputeY( ng.ng_TopEdge );
		ng.ng_Width      = ComputeX( ng.ng_Width );
		ng.ng_Height     = ComputeY( ng.ng_Height);

		mouseGadgets[ lc ] = g = CreateGadgetA((ULONG)mouseGTypes[ lc ], g, &ng, ( struct TagItem * )&mouseGTags[ tc ] );

		while( mouseGTags[ tc ] ) tc += 2;
		tc++;

		if ( NOT g )
			return( 2L );
	}

	if ( ! ( mouseWnd = OpenWindowTags( NULL,
				WA_Left,	wleft,
				WA_Top,		wtop,
				WA_Width,	ww + OffX + Scr->WBorRight,
				WA_Height,	wh + OffY + Scr->WBorBottom,
				WA_IDCMP,	BUTTONIDCMP|TEXTIDCMP|SLIDERIDCMP|MXIDCMP|CHECKBOXIDCMP|IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW,
				WA_Flags,	WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_ACTIVATE,
				WA_Gadgets,	mouseGList,
				WA_Title,	mouseWdt,
				WA_ScreenTitle,	"Duke Nukem 3D Atomic Edition - Mouse Setup",
				WA_PubScreen,	Scr,
				WA_AutoAdjust,	TRUE,
				TAG_DONE )))
	return( 4L );

	GT_RefreshWindow( mouseWnd, NULL );

	mouseRender();

	return( 0L );
}

void ClosemouseWindow( void )
{
	if ( mouseWnd        ) {
		CloseWindow( mouseWnd );
		mouseWnd = NULL;
	}

	if ( mouseGList      ) {
		FreeGadgets( mouseGList );
		mouseGList = NULL;
	}

	if ( mouseFont ) {
		CloseFont( mouseFont );
		mouseFont = NULL;
	}
}

void mactsRender( void )
{
	ComputeFont( mactsWidth, mactsHeight );

	DrawBevelBox( mactsWnd->RPort, OffX + ComputeX( 7 ),
					OffY + ComputeY( 6 ),
					ComputeX( 228 ),
					ComputeY( 215 ),
					GT_VisualInfo, VisualInfo, TAG_DONE );
	DrawBevelBox( mactsWnd->RPort, OffX + ComputeX( 6 ),
					OffY + ComputeY( 5 ),
					ComputeX( 230 ),
					ComputeY( 217 ),
					GT_VisualInfo, VisualInfo, GTBB_Recessed, TRUE, TAG_DONE );
}

int OpenmactsWindow( void )
{
	struct NewGadget	ng;
	struct Gadget	*g;
	UWORD		lc, tc;
	UWORD		wleft = mactsLeft, wtop = mactsTop, ww, wh;

	ComputeFont( mactsWidth, mactsHeight );

	ww = ComputeX( mactsWidth );
	wh = ComputeY( mactsHeight );

	if (( wleft + ww + OffX + Scr->WBorRight ) > Scr->Width ) wleft = Scr->Width - ww;
	if (( wtop + wh + OffY + Scr->WBorBottom ) > Scr->Height ) wtop = Scr->Height - wh;

	if ( ! ( mactsFont = OpenDiskFont( Font )))
		return( 5L );

	if ( ! ( g = CreateContext( &mactsGList )))
		return( 1L );

	for( lc = 0, tc = 0; lc < macts_CNT; lc++ ) {

		CopyMem((char * )&mactsNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

		ng.ng_VisualInfo = VisualInfo;
		ng.ng_TextAttr   = Font;
		ng.ng_LeftEdge   = OffX + ComputeX( ng.ng_LeftEdge );
		ng.ng_TopEdge    = OffY + ComputeY( ng.ng_TopEdge );
		ng.ng_Width      = ComputeX( ng.ng_Width );
		ng.ng_Height     = ComputeY( ng.ng_Height);

		mactsGadgets[ lc ] = g = CreateGadgetA((ULONG)mactsGTypes[ lc ], g, &ng, ( struct TagItem * )&mactsGTags[ tc ] );

		while( mactsGTags[ tc ] ) tc += 2;
		tc++;

		if ( NOT g )
			return( 2L );
	}

	if ( ! ( mactsWnd = OpenWindowTags( NULL,
				WA_Left,	wleft,
				WA_Top,		wtop,
				WA_Width,	ww + OffX + Scr->WBorRight,
				WA_Height,	wh + OffY + Scr->WBorBottom,
				WA_IDCMP,	LISTVIEWIDCMP|BUTTONIDCMP|IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW,
				WA_Flags,	WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_ACTIVATE,
				WA_Gadgets,	mactsGList,
				WA_Title,	mactsWdt,
				WA_ScreenTitle,	"Duke Nukem 3D Atomic Edition - Mouse Setup",
				WA_PubScreen,	Scr,
				WA_AutoAdjust,	TRUE,
				TAG_DONE )))
	return( 4L );

	GT_RefreshWindow( mactsWnd, NULL );

	mactsRender();

	return( 0L );
}

void ClosemactsWindow( void )
{
	if ( mactsWnd        ) {
		CloseWindow( mactsWnd );
		mactsWnd = NULL;
	}

	if ( mactsGList      ) {
		FreeGadgets( mactsGList );
		mactsGList = NULL;
	}

	if ( mactsFont ) {
		CloseFont( mactsFont );
		mactsFont = NULL;
	}
}

