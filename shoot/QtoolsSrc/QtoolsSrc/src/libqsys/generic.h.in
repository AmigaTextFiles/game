/*
 * <one line to give the program's name and a brief idea of what it does.>
 * Copyright (C) 1998  Niels Froehling <Niels.Froehling@Informatik.Uni-Oldenburg.de>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#ifndef	GENERIC_H
#define	GENERIC_H
#include "rawkeys.h"
#include "rawmouse.h"

/*
 * ============================================================================
 * structures
 * ============================================================================
 */
#include "generic-compiler.h"

#undef	FALSE
#undef	TRUE
typedef enum {
  FALSE =  0,							/* nothing */
  TRUE  = ~0							/* everything */
} __packed bool;

#include "generic-debug.h"
#include "generic-memory.h"
#include "generic-messages.h"
#include "generic-devices.h"

/*
 * canonical system
 *
 * everything you would like to replace you must replace
 * in the include-files for your system, that could be a
 * cpu-type or os-type
 */
#include "@target_cpu@/@target_cpu@.h"
#include "@target_cpu@/@target_os@/@target_os@.h"

/*
 * if you like you can specify a global register to pass the base
 * in, then it is like indirect variable-access via the framepointer
 */
#ifndef	__memBase
#define	__memBase	register struct memory *bspMem
#endif

/*
 * some system aspecially little-endian systems requires some
 * special kind of file-attributes, textfiles could be opened
 * as standard, binary file must have the binary-attribute
 * upto now i dont know if the low-level-io functions support
 * that behaviour
 */
#ifndef	READ_BINARY
# if (WORDS_BIGENDIAN == 1)
#   define H_READ_BINARY		O_RDONLY
#   define F_READ_BINARY		"r"
# else
#   define H_READ_BINARY		O_RDONLY
#   define F_READ_BINARY		"rb"
# endif
#endif
#ifndef	WRITE_BINARY
# if (WORDS_BIGENDIAN == 1)
#  define H_WRITE_BINARY		(O_WRONLY | O_CREAT | O_TRUNC)
#  define F_WRITE_BINARY		"w"
# else
#  define H_WRITE_BINARY		(O_WRONLY | O_CREAT | O_TRUNC)
#  define F_WRITE_BINARY		"wb"
# endif
#endif
#ifndef	READWRITE_BINARY_OLD
# if (WORDS_BIGENDIAN == 1)
#  define H_READWRITE_BINARY_OLD	(O_RDWR | O_CREAT)
#  define F_READWRITE_BINARY_OLD	"r+"
# else
#  define H_READWRITE_BINARY_OLD	(O_RDWR | O_CREAT)
#  define F_READWRITE_BINARY_OLD	"rb+"
# endif
#endif
#ifndef	READWRITE_BINARY_NEW
# if (WORDS_BIGENDIAN == 1)
#  define H_READWRITE_BINARY_NEW	(O_RDWR | O_CREAT | O_TRUNC)
#  define F_READWRITE_BINARY_NEW	"w+"
# else
#  define H_READWRITE_BINARY_NEW	(O_RDWR | O_CREAT | O_TRUNC)
#  define F_READWRITE_BINARY_NEW	"wb+"
# endif
#endif
#ifndef	CHAR_FOR_DIR
# define CHAR_FOR_DIR	  "/"
#endif
#ifndef	CHAR_FOR_CURRENT
# define CHAR_FOR_CURRENT "."
#endif
#ifndef	CHAR_FOR_PARENT
# define CHAR_FOR_PARENT  ".."
#endif
#ifndef	CHAR_FOR_VOLUME
# define CHAR_FOR_VOLUME  ":"
#endif

#ifndef	MATCH
unsigned char Match(register struct rgb *rawpix, register struct rgb *Palette);
#endif

/*
 * at the moment the special compressor isnt available for other systems
 * than m68k, take a look at the LZWSfiles in this directory for the
 * growing c-version, maybe you could help
 */
#ifndef	LZWS
#define	LZWSCrunch(a, b, c, d, e) (0)
#define	LZWSDecrunch(a, b, c) (0)
#define	LZWSSize(a) (0)
#define	ERROR 0
#endif

#ifndef	OPENDISPLAY						/* our offscreen-renderer supports all display-modes */
#define	DRIVER_8BIT
#define	DRIVER_16BIT
#define	DRIVER_24BIT
#define	DRIVER_32BIT
#define	DRIVER_DEFAULT	8
#endif

/*
 * if you have choosen an unsupported defaultdriver
 * you getll get a error here
 */
#if !defined(DRIVER_8BIT) && (DRIVER_DEFAULT == 8)
#error	"unsupported default driver choosen"
#endif
#if !defined(DRIVER_16BIT) && (DRIVER_DEFAULT == 16)
#error	"unsupported default driver choosen"
#endif
#if !defined(DRIVER_24BIT) && (DRIVER_DEFAULT == 24)
#error	"unsupported default driver choosen"
#endif
#if !defined(DRIVER_32BIT) && (DRIVER_DEFAULT == 32)
#error	"unsupported default driver choosen"
#endif

staticfnc inline short SwapShort(short l);
staticfnc inline int SwapLong(int l);
staticfnc inline float SwapFloat(float l);

#ifdef INLINE_BIGENDIAN
#ifndef	SWAPSHORT
#define	SWAPSHORT
staticfnc inline short SwapShort(short l)
{
  unsigned char b1, b2;

  b1 = l & 255;
  b2 = (l >> 8) & 255;

  return (b1 << 8) + b2;
}
#endif

#ifndef	SWAPLONG
#define	SWAPLONG
staticfnc inline int SwapLong(int l)
{
  unsigned char b1, b2, b3, b4;

  b1 = l & 255;
  b2 = (l >> 8) & 255;
  b3 = (l >> 16) & 255;
  b4 = (l >> 24) & 255;

  return ((int)b1 << 24) + ((int)b2 << 16) + ((int)b3 << 8) + b4;
}

#endif

#ifndef	SWAPLONGLONG
#define	SWAPLONGLONG
staticfnc inline long long int SwapLongLong(long long int l)
{
  unsigned char b1, b2, b3, b4, b5, b6, b7, b8;

  b1 = (l      ) & 255;
  b2 = (l >>  8) & 255;
  b3 = (l >> 16) & 255;
  b4 = (l >> 24) & 255;
  b5 = (l >> 32) & 255;
  b6 = (l >> 40) & 255;
  b7 = (l >> 48) & 255;
  b8 = (l >> 56) & 255;

  return ((long long int)b1 << 56) + 
	 ((long long int)b2 << 48) +
	 ((long long int)b3 << 40) +
	 ((long long int)b4 << 32) +
	 ((long long int)b5 << 24) +
	 ((long long int)b6 << 16) +
	 ((long long int)b7 <<  8) + b8;
}
#endif

#ifndef	SWAPFLOAT
#define	SWAPFLOAT
staticfnc inline float SwapFloat(float l)
{
  union {
    unsigned char b[4];
    float f;
  } in, out;

  in.f = l;
  out.b[0] = in.b[3];
  out.b[1] = in.b[2];
  out.b[2] = in.b[1];
  out.b[3] = in.b[0];

  return out.f;
}
#endif

#ifndef	SWAPDOUBLE
#define	SWAPDOUBLE
staticfnc inline double SwapDouble(double l)
{
  union {
    unsigned char b[8];
    double d;
  } in, out;

  in.d = l;
  out.b[0] = in.b[7];
  out.b[1] = in.b[6];
  out.b[2] = in.b[5];
  out.b[3] = in.b[4];
  out.b[4] = in.b[3];
  out.b[5] = in.b[2];
  out.b[6] = in.b[1];
  out.b[7] = in.b[0];

  return out.d;
}
#endif
#endif

#if (WORDS_BIGENDIAN == 1)
#define BigShort(a) (a)
#define LittleShort(a) SwapShort(a)
#define BigLong(a) (a)
#define LittleLong(a) SwapLong(a)
#define BigLongLong(a) (a)
#define LittleLongLong(a) SwapLongLong(a)
#define BigFloat(a) (a)
#define LittleFloat(a) SwapFloat(a)
#define BigDouble(a) (a)
#define LittleDouble(a) SwapDouble(a)
#else
#define BigShort(a) SwapShort(a)
#define LittleShort(a) (a)
#define BigLong(a) SwapLong(a)
#define LittleLong(a) (a)
#define BigLongLong(a) SwapLongLong(a)
#define LittleLongLong(a) (a)
#define BigFloat(a) SwapFloat(a)
#define LittleFloat(a) (a)
#define BigDouble(a) SwapDouble(a)
#define LittleDouble(a) (a)
#endif

#ifndef	MKID
#define MKID(a, b, c, d) ((a << 24) | (b << 16) | (c << 8) | (d))
#endif

#endif
