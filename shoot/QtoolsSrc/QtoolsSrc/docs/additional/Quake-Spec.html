<!--- Remove that line, and execute under Unix, as a python script 
#!/usr/local/bin/python
## HTML document splitting, Copyright (c) 1996 Olivier Montanuy 
import regex
import sys
# save a file
def FileSave(info):
  try:
    (file, txt) = info
    fp = open(file,"w")
    fp.write(txt)
    fp.close()
  except:
    print "Can't write file ", file
  return info
# read a file
def FileRead(file):
  txt=""
  try: 
    fp=open(file,"r")
    txt=fp.read() #
    fp.close()
  except:
    print "Can't read file ", file
  return txt

class FileList: 
  debug = 0 # set to 1, for debug info
  File = ""   # current file
  Target = "" #current frame
  List = []   # list of files
  Txt = ""    # Text to parse
  TxtLen = 0  # Length of text
  Anchors = {} #dictionary of anchors
  Base = 0 
  # not ` is used to simulate "anything character"
  patHEAD=regex.compile("<HTML>[^`]*<BODY [^>]*>")     # .group(1) = header
  txtHEAD="" # HTML header
  txtTAIL="</BODY></HTML>" # HTML trailer
  patFRAME = regex.compile("<?!--FRAMES=\"\([^>]*\)\"--\([^`]*\)--NOFRAMES--?>")
  # .group(1) = file  .group(2) = frame
   
  # detects !--FILE="foo.htm#frame"--   or   A HREF="#foo"
  patHREF=regex.compile("<?!--FILE=\"\([^>#]*\)\(#[^>]*\)?\"--?>?\|<A +HREF=\"#\([^>]+\)\">")
  # detects !--FILE="foo.htm#frame"--   or   A NAME="foo"
  patNAME=regex.compile("<?!--FILE=\"\([^>#]*\)\(#[^>]*\)?\"--?>?\|<A +NAME=\"\([^>]+\)\">") 
  # add a file to the list
  def AddFile(self, file, txt):
    if (file <> "")&(file<> None): 
      if self.debug: print "New file: ", file
      self.List.append( (file, self.txtHEAD + txt + self.txtTAIL))
    return
  def __init__(self, file):
    self.Txt= FileRead(file)
    self.TxtLen= len(self.Txt)
    self.List=[]
    self.Anchors={}
    return
  def FindHtmlHeader(self):
    head= ""
    base = 0
    start= self.patHEAD.search(self.Txt,0)
    if start>=0:
      base = start + self.patHEAD.match(self.Txt,start)
      head = self.Txt[start: base]
    else:
      print "Error: Not a valid HTML file"
    self.Base = base
    self.txtHEAD = head
    if self.debug: print "HTML header: ", head
    # find FRAMES
    start= self.patFRAME.search(self.Txt,0)
    if start >=0:
      file = self.patFRAME.group(1)
      head = self.patFRAME.group(2)
      if self.debug: print "FRAME file: ", file
      if self.debug: print "FRAME content:", head
      FileSave( (file, head) )
    return
  #
  def FindHtmlAnchors(self):
    start = 0  # start of last match
    end = self.Base # end of last match
    self.File = "" 
    while end< self.TxtLen: #next expression
      start = self.patNAME.search(self.Txt,end)
      if start<0: break # no more expressions
      if self.patNAME.group(1)==None: #anchor
        anchor= self.patNAME.group(3)
        self.Anchors[anchor]= ( self.File , self.Target )
        if self.debug: print "New Anchor: File=", self.File, " Target=", self.Target
      else: #file
        self.File = self.patNAME.group(1)
        target= self.patNAME.group(2)
        if target <> None:
          self.Target = target[1:]
        else:
          self.Target = ""
        # if self.debug: print "File: ", self.File, " Target: ", self.Target
        print "File: ", self.File, " Target: ", self.Target
      end = start + self.patNAME.match(self.Txt,start)
    return
  # split text into many files
  def SplitHtmlInFiles(self): 
    start = 0  # start of last match
    end = self.Base # end of last match
    self.File = "" 
    result= ""
    while end< self.TxtLen:
      #next expression
      start = self.patHREF.search(self.Txt,end)
      #determine if anchor or not
      if start<0: 
        result = result+ self.Txt[end:]
        break
      else:
        result = result+ self.Txt[end:start]
        if self.patHREF.group(1)==None: #anchor
          anchor= self.patHREF.group(3)
          target = ""
          file = ""
          if self.Anchors.has_key(anchor): 
            (file , target) = self.Anchors[anchor]
          else:
            print "ERROR: Broken anchor: ", anchor
          href = "HREF=\"" + file + "#" + anchor + "\""
          if target <> "": 
            href = href + " TARGET=\"" + target  + "\""
          if self.debug: print "<A " + href + ">"
          result= result + "<A " + href + ">"
        else: #file
          self.AddFile( self.File, result)
          self.File = self.patHREF.group(1)
          result = ""
        end = start+ self.patHREF.match( self.Txt, start)
    #
    self.AddFile(self.File, result)
    return
  def SaveFiles(self): 
    if self.debug: print "Saving files"
    map(FileSave,self.List)
    return  
    
fl= FileList(sys.argv[0])
fl.FindHtmlHeader()
fl.FindHtmlAnchors() 
fl.SplitHtmlInFiles()
fl.SaveFiles()
"""-->
<!--FRAMES="qkframe.htm"--
<frameset rows="60%,40%">
   <frame src="qktitle.htm" name=content>
   <frame src="qkmenu.htm" name=menu>
</frameset>
<noframes>
<P>To display that page correctly, you need a frame-capable browser.</P>

<P>Obviously, your browser is not frame-capable, so please read
<A HREF="qkmenu.htm">this page</A> instead.</P>
</noframes>
--NOFRAMES-->



<HTML><HEAD>
<TITLE>Quake Specs v3.2</TITLE>
<LINK REV="MADE" HREF="mailto:100625.2622@compuserve.com">
</HEAD>  
<BODY BGCOLOR="#FFFFFF">
<!--FILE="qktitle.htm#content"-->
<!-- You know, it looks much better with a WWW browser -->
<!-- It is even better if your browser understands HTML3 tables -->
<A NAME="CTITLE"><PRE>
=============================================================================
                   _             /////    /////   //////  /////   /////
  __ _ _   _  ___ | | _____    //        //  //  //     //      //
 / _` | | | |/ _ || |/ / _ \    /////   /////   ////// //       /////  3.2
| (_| | |_| | (_|||   (  __/       //  //      //     //           //
 \__, |\__,_|\___||_|\_\___|  /////   //      //////   /////  /////
    |_|
=============================================================================
</PRE></A>
<!-- The logo is derived from Quake Talk, by Joost Schuur -->


<FONT COLOR="#004F1F">
<P ALIGN=CENTER>
 The Most Unofficial <B>Quake</B> Technical Specification.<BR>
 by Olivier Montanuy, with contributions from<BR>
 Brian Martin, Rapha&euml;l Quinet, John Wakelin, David Etherton and others<BR>
 April 1, 1996
</P></FONT>

<HR>
<P ALIGN=CENTER><SMALL>Warning: This citation is morally
challenged.</SMALL></P>
<P><CITE>
Ben l&agrave;, je viens de terminer de lester le corps, tu vois ?
[...]  Tu vois, il y a un bar&egrave;me quand tu lestes un corps,
c'est-&agrave;-dire tu fais trois fois son poids.  Normalement un
homme moyen, comme cette victime-ci, c'est trois fois son poids.  Et
sinon, par exemple, &ccedil;a change, hein.  Tu vois, pour les enfants
ou pour les nains, &ccedil;a change.  Pour un enfant, c'est [...]
quatre fois son poids.
</CITE>
<TABLE WIDTH=100%><TR>
<TD WIDTH=40% ALIGN=RIGHT VALIGN=TOP>--</TD>
<TD WIDTH=60% ALIGN=LEFT VALIGN=TOP>Body handling specifications, by
<B>Ben</B>,<BR> in &quot;<I>C'est Arriv&eacute; Pr&egrave;s de Chez
Vous</I>&quot; (&quot;<I>Man Bites Dog</I>&quot;)</TD>
</TR></TABLE></P>
<HR>

<!--FILE="qkmenu.htm#menu"-->

<H2><FONT COLOR="#007F00">List of Contents</FONT></H2>

<A NAME="CONTENTS"></A>
<PRE><TABLE BORDER><TR><TD><TABLE>
<TR VALIGN=TOP><TD>1.</TD><TD>   <A HREF="#CTITLE">Introduction</A></TD>
<TD><TABLE>
<TR><TD>1.1</TD>  <TD><A HREF="#CINTL">Legal warning</A></TD></TR>
<TR><TD>1.2</TD>  <TD><A HREF="#CINTT">Thanks</A></TD></TR>
<TR><TD>1.3</TD>  <TD><A HREF="#CINTA">A word from the authors.</A></TD></TR>
<TR><TD>1.4</TD>  <TD><A HREF="#CINTM">For more informations.</A></TD></TR>
<TR><TD>1.5</TD>  <TD><A HREF="#CINTC">Typing conventions.</A></TD></TR>
</TABLE></TD></TR>
<TR VALIGN=TOP><TD>2.</TD><TD>   <A HREF="#CPAK0">The PACK files</A></TD>
<TD><TABLE>
<TR><TD>2.1</TD>  <TD><A HREF="#CPAKF">The PACK file format</A></TD></TR>
<TR><TD>2.2</TD>  <TD><A HREF="#PRES">The Resources files</A></TD></TR>
<TR><TD>2.3</TD>  <TD><A HREF="#PWAV">The Sound files</A></TD></TR>
<TR><TD>2.4</TD>  <TD><A HREF="#PDAT">The Code lump</A></TD></TR>
</TABLE></TD></TR>
<TR VALIGN=TOP><TD>3.</TD>   <TD><A HREF="#CBSP0">The Level Map Models</A></TD><TD><TABLE>
<TR><TD>3.1</TD>  <TD><A HREF="#CBSPG">Description of .BSP files</A></TD></TR>
<TR><TD>3.2</TD>  <TD><A HREF="#CBSPF">The format of .BSP files</A></TD></TR>
<TR><TD>3.3</TD>  <TD><A HREF="#CBSPL">Level layout definition</A></TD></TR>
<TR><TD>3.4</TD>  <TD><A HREF="#CBSPN">Bsp tree definition</A></TD></TR>
<TR><TD>3.5</TD>  <TD><A HREF="#CBSPC">Pre-calculated geometric entries</A></TD></TR>
<TR><TD>3.6</TD>  <TD><A HREF="#CBSPE">Entities definitions</A></TD></TR>
<TR><TD>3.7</TD>  <TD><A HREF="#CBSPI">Additional informations</A></TD></TR>
</TABLE></TD></TR>

<TR VALIGN=TOP><TD>4.</TD>   <TD><A HREF="#CMDL0">The Entity Alias Models</A></TD><TD><TABLE>
<TR><TD>4.1</TD>  <TD><A HREF="#CMDLP">Presentation of Alias Models</A></TD></TR>
<TR><TD>4.2</TD>  <TD><A HREF="#CMDLA">Animating Alias Models</A></TD></TR>
<TR><TD>4.3</TD>  <TD><A HREF="#CMDLF">The Format of .MDL files</A></TD></TR>
</TABLE></TD></TR>

<TR VALIGN=TOP><TD>5.</TD>   <TD><A HREF="#CSPR0">The Sprites models</A></TD><TD><TABLE>
<TR><TD>5.1</TD>  <TD><A HREF="#CSPRG">General description of Sprites</A></TD></TR>
<TR><TD>5.2</TD>  <TD><A HREF="#CSPRF">The Format of .SPR files</A></TD></TR>
</TABLE></TD></TR>

<TR VALIGN=TOP><TD>6.</TD>   <TD><A HREF="#CWAD0">New WAD file</A></TD><TD><TABLE>
<TR><TD>6.1</TD>  <TD><A HREF="#CWADF">The format of WAD2 files</A></TD></TR>
<TR><TD>6.2</TD>  <TD><A HREF="#CWADS">Format of status bar pictures</A></TD></TR>
<TR><TD>6.3</TD>  <TD><A HREF="#CWADC">Format of console lumps</A></TD></TR>
<TR><TD>6.4</TD>  <TD><A HREF="#CWADP">Format of palettes</A></TD></TR>
</TABLE></TD></TR>

<TR VALIGN=TOP><TD>7.</TD>   <TD><A HREF="#CMAP0">The Level Maps</A></TD><TD><TABLE>
<TR><TD>7.1</TD>  <TD><A HREF="#CMAPG">Description of .MAP files</A></TD></TR>
<TR><TD>7.2</TD>  <TD><A HREF="#CMAPF">The format of .MAP files</A></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR></TABLE></PRE>

<HR SIZE=3> 


<!--FILE="qkspec_1.htm#content"-->

<H1><FONT COLOR="#007F00">1. <A NAME="CINT0">Introduction </A></FONT></H1>



<H2><FONT COLOR="#004F1F">1.1 <A NAME="CINTL">Legal Warning</A></FONT></H2>

<FONT COLOR="#4F1F00">
<P><B>Quake</B> and <B>Doom</B> are trademarks of <B>id Software
Inc.</B>, Mesquite, Texas.  This document is <EM>not</EM> a
publication of id Software, who should not be associated with it.  id
Software will not answer any questions related to this document.</P>
</FONT>

<P ALIGN=CENTER>This document is Copyright (C) 1996 by Olivier
Montanuy.<BR>All rights reserved.</P>

<FONT COLOR="#004F1F">
<P>Permission to use, copy and distribute unedited copies of this
whole document is hereby granted, provided that no fee is charged for
the use or availability of this document (other than the normal
connection costs for on-line services, if applicable).  The above
copyright notice and this permission notice must be left intact in all
copies of this document.  Short excerpts of this document may be
quoted in discussion groups or mailing list articles, as long as a
reference to the full document is given.</P>

<P>Commercial distribution of this document, in whole or in part,
requires prior agreement with the author.  Commercial distribution
includes any means by which the user has to pay either for the support
(e.g. book, newsletter or CD-ROM) or for the document itself.
Unauthorized commercial distribution is prohibited.</P>
</FONT>

<P><B>Disclaimer:</B> this document describes the Quake file formats
as we understand them, but we cannot guarantee that anything is
correct.  In fact, we could be totally wrong.  We cannot be held
responsible for any consequences of the use or misuse of the
information contained herein.  You have been warned.</P>



<HR>
<H2><FONT COLOR="#004F1F">1.2 <A NAME="CINTT">Thanks</A></FONT></H2>

<P><B>A lot of thanks to:</B>
<UL>
<LI> <B>John Carmack</B> and <B>Mike Abrash</B> of id Software, for the 
  sources of the Quake utility.
<LI> <B>Jay Wilbur</B> of id Software, for tolerating all that Quake
  hacking madness, and keeping his lawyers tame.
<LI> The Vandals and Cavemens, for feats best not described.
<LI> <B>Bernd Kreimeier</B> for proofreading and handling
     all the mess caused by the specs.
<LI> <B>Jens Hykkelbjerg</B> for help with 3D and HTML.
<LI> <B>Frans P. de Vries</B> for his suggestions and for proofreading.
<LI> <B>Luc Cluitmans</B> for some insights with the code.
<LI> <B>John Williston</B> for the motivation.
<LI> <B>Joost Schuur</B> and the Quake Talk guys for all those rumors<BR>
  (some of which were really helpful).
<LI> All those who reported bugs in previous specs.
</UL>
</P>


<P><B>Contributors to this document:</B>
<UL>
<LI> <B>Olivier Montanuy</B> (Bsp models, various stuff)<BR>
     (Author of WinTex, Doom tool and BSP viewer for Quake)
<LI> <B>Brian <I>ZombyWoof</I> Martin</B> (Alias models).<BR>
     (Author of the MedDLe Alias model viewer for Quake)
<LI> <B>Rapha&euml;l Quinet</B> (Sprite models, HTML layout).<BR>
     (Main author of DEU and QEU, the Doom and Quake Editing Utilities)
<LI> <B>John Wakelin</B> and <B>Mike Bond</B> (definition of entities)
<LI> <B>David Etherton</B> (visibility lists, surfaces).
<LI> <B>Stephen Crowley</B> (checking of texture animations).
<LI> <B>Rene Post</B> and <B>Jim Butcher</B> (help with models).
</UL>
</P>

<HR>

<H2><FONT COLOR="#004F1F">1.3 <A NAME="CINTA">A word from the
authors</A></FONT></H2>

<P>This document is an updated version of the Unofficial Quake Specs
3.1, adapted for the Quake Shareware release. This release is not compatible
with the previous Quake Test1 release. The .BSP and .MDL file formats have
changed.</P>

<P>Though this document is largely the result of hacking, it has been checked
against the C code of the Quake utility. Some details could not be guessed by hacking.
But the C code is so... special, that it's sometime easier to look at the bytes.
</P>

<P>You will need some working knowledge of 3D geometry to understand
this specification, and a good deal of patience too, because some
(if not all) explanations may not be crystal clear.</P>

<FONT COLOR="#FF0000">
<P>Please <EM>do not</EM> make any full-featured editor working with
the Quake shareware release.</P>
</FONT>

<P>Last, if you enjoyed editing Quake, don't forget to support <B>id
Software</B> and to buy their products. Help feed <B>John</B> and
<B>Mike</B> as they work on the next generation game engine!</P>

<P>The authors.</P>

<HR>

<H2><FONT COLOR="#004F1F">1.4 <A NAME="CINTM">For more informations</A></FONT></H2>

<H3>1.4.1 How to get the last version of the specifications?</H3>

<P>The latest version of this document will always be available on the official Quake-editing support site,
<A HREF="http://www.gamers.org/dEngine/quake/spec/qspec-current.html">http://www.gamers.org/dEngine/quake/spec/qspec-current.html</A>.
</P>

<P>You will also find it at the following locations:
<UL>
<LI><A HREF="http://www.stud.montefiore.ulg.ac.be/ftp-mirror/quake/docs/">http://www.stud.montefiore.ulg.ac.be/ftp-mirror/quake/docs/</A><BR> (filename: <TT>qkspec??.html</TT>)
<LI><A HREF="http://ftp.cdrom.com/pub/idgames2/docs/">http://ftp.cdrom.com/pub/idgames2/docs/</A><BR> (in ZIP format, filename: <TT>qkspec??.zip</TT>).
</UL>
</P>

<P>Other sites will also have a copy of this document (according to
the <A HREF="#CINTL">distribution rights</A> stated above) but we
cannot guarantee that those sites will have the most recent version.
Usually, we upload the new versions on <A HREF="http://www.stud.montefiore.ulg.ac.be/ftp-mirror/quake/docs/">www.stud.montefiore.ulg.ac.be</A>
first, then on the other sites on the same day.</P>

<H3>1.4.2 Informations about 3D rendering</H3>
<UL>
<LI>The <A HREF="http://www.gamers.org/dEngine/">Difference Engine</A> home page.
<LI><A HREF="http://www.cs.tu-berlin.de/~ki/info/3dgpl.html">3DGPL</A>, a tutorial for 3D drawing functions, by Sergei Savchenko.
<LI>The list of <A HREF="http://www.cs.tu-berlin.de/~ki/engines.html">3D game</A> engines.
<LI>the source of the Quake utilities.
</UL>

<H3>1.4.3 Cool Quake related pages</H3>
<UL>
<LI><A HREF="http://www.idsoftware.com/qss.html">id software</A>
<LI><A HREF="http://www.nuqneH.org/aftershock/">AfterShock</A>, Joost's Quake Webzine.
<LI><A HREF="http://www.stomped.com/">Stomped</A>
<LI><A HREF="http://www.daimi.aau.dk/~hykkelbj/quake/index.html">Jens</A>'s Quake page.
<LI><A HREF="http://www.pennet.com/drsleep/quake.htm">Dr Sleep</A>'s Quake page.
<LI><A HREF="http://sh1.ro.com/~rgoodwin/quake.html">Robert's</A> Quake page.
<LI><A HREF="http://doomgate.cs.buffalo.edu/games/quake/">Joost's</A> Quake page on <A HREF="http://doomgate.cs.buffalo.edu/">Doom Gate</A>.
<LI><A HREF="http://www.islandnet.com/~ccaird/idgames/quake/quake.html">Colin</A>'s Quake page.
<LI><A HREF="http://www.hal-pc.org/~jasonv/quake/">Jason</A>'s Unofficial Quake Homepage.
<LI><A HREF="http://www.net-link.net/~joedery/quake.htm">Joe</A>'s Quake Stuff and links.
<LI><A HREF="http://www.montefiore.ulg.ac.be/~quinet/games/editing.html">Rapha&euml;l's</A> game editing page.
</UL>

<H3>1.4.5 Newsgroups</H3>
<UL>
<LI><A HREF="news:rec.games.computer.quake.announce">rec.games.computer.quake.announce</A>, Info/FAQ/Announcements about Quake. (Moderated)
<LI><A HREF="news:rec.games.computer.quake.editing">rec.games.computer.quake.editing</A>, <B>Editing and hacking Quake-related files</B>.
<LI><A HREF="news:rec.games.computer.quake.misc">rec.games.computer.quake.misc</A>, General discussion of Quake.
</UL>


<HR>

<H2><FONT COLOR="#004F1F">1.5 <A NAME="CINTC">Typing conventions</A></FONT></H2>

<P>All the code structures are written in <B>C</B>, because C is all
we talk.  Well, it could have been worse.  We could have written that
specification in <EM>French</EM>.</P>

<PRE>
0xABCD   = <B>hexadecimal</B> number ABCD, in C convention.
char     = <B>8 bit</B> signed integer,
u_char   = <B>8 bit</B> unsigned integer (BYTE),
short    = <B>16 bit</B> signed integer,
u_short  = <B>16 bit</B> unsigned integer (WORD),
long     = <B>32 bit</B> signed integer,
u_long   = <B>32 bit</B> unsigned integer (DWORD),
float    = <B>32 bit</B> single precision real (floating point).
</PRE>




<HR SIZE=3>
<!--FILE="qkspec_2.htm#content"-->

<H1><FONT COLOR="#007F00">2. <A NAME="CPAK0">The PACK files</A></FONT></H1>


<H2><FONT COLOR="#4F1F00">2.1 <A NAME="CPAKF">The PACK files
format</A></FONT></H2>

<P>The PACK format is used to emulate a Unix directory arborescence,
and to avoid putting some hundreds of files on the user's disk.  It is
not a compressed format, and it's very similar to the WAD format of
DOOM.</P>

<H3>2.1.1 The PACK Header</H3>

<P>The PACK file starts with a header, that indicates where to find
the directory, and the size of that directory.  The number of entries
can be deduced by dividing by <TT>sizeof(pakentry_t) = 0x40</TT>
<PRE>
typedef struct
{ u_char magic[4]= "PACK";     // Name of the new WAD format
  long diroffset;              // Position of WAD directory from start of file
  long dirsize;                // Number of entries * 0x40 (64 char)
} pakheader_t;
</PRE></P>

<H3>2.1.2 The PACK Directory</H3>

<P>The PACK directory is made of a list of consecutive entries, each with
the following format:
<PRE>
typedef struct
{ u_char filename[0x38];       // Name of the file, Unix style, with extension,
                               // 50 chars, padded with '\0'.
  long offset;                 // Position of the entry in PACK file
  long size;                   // Size of the entry in PACK file
} pakentry_t;
</PRE></P>

<P>At offset <TT>diroffset</TT> in the PACK file, you will find:
<PRE>
pakentry_t dir[dirsize/sizeof(pakentry_t)];   // Directory
</PRE></P>

<P>The directory is preferably placed at the end of the PACK file, but
it could actually be anywhere.  The entries could also be scattered all
around the PACK file, leaving large gaps.  If you write a PACK
hacking utility, you must take care not to introduce too many empty
space.  Also, you should never assume that the entries are stored in
the same order as in the directory (they could be in reverse order, for
example).  If you want to add some data after the last entry, make sure
that you are really at the end of the file.</P>

<P>Since PACK files are a bit like WAD, it is possible to use the same
tricks that were used by tools such as DeuSF and NWT to modify the
PACK file reversibly.  It is hoped, however, that Quake is flexible
enough so that this trick is not needed.</P>

<H3>2.1.3 Determining the type of PACK Entries</H3>

<P>Contrary to the WAD2 files, there is no tag giving the type of
each entry.  However, they can be safely recognized by the extension,
and it's the method used by Quake itself.</P>

<PRE><TABLE BORDER><TR><TD><TABLE>
<TR valign=top><TD><TT>.WAV</TT>  </TD><TD><A HREF="#PWAV">Sound</A> files (RIFF/WAVE)</TD></TR>
<TR valign=top><TD><TT>.BSP</TT>  </TD><TD><A HREF="#CBSPF">levels</A> (map and textures)</TD></TR>
<TR valign=top><TD><TT>.MDL</TT>  </TD><TD><A HREF="#CMDLF">3D models</A> (Alias)</TD></TR>
<TR valign=top><TD><TT>.SPR</TT>  </TD><TD><A HREF="#CSPRF">Sprite</A> models</TD></TR>
<TR valign=top><TD><TT>.DAT</TT>  </TD><TD><A HREF="#PDAT">Pseudo-code</A></TD></TR>
<TR valign=top><TD><TT>.RC</TT>   </TD><TD><A HREF="#PRES">Resources</A></TD></TR>
<TR valign=top><TD><TT>.CFG</TT>  </TD><TD><A HREF="#PCFG">Config Files</A></TD></TR>
<TR valign=top><TD><TT>.LMP</TT>  </TD><TD><A HREF="#PLMP">Lump files</A></TD></TR>
<TR valign=top><TD><TT>.LMP</TT>  </TD><TD><A HREF="#PBIN">End screen</A></TD></TR>
<TR valign=top><TD><TT>.WAD</TT>  </TD><TD><A HREF="#CWADF">WAD2</A> file</TD></TR>
</TABLE></TD></TR></TABLE></PRE>


<H2><FONT COLOR="#4F1F00">2.2 <A NAME="PRES">The resources files</A>
(<TT>.RC</TT>)</FONT></H2>

<P>Those files are ordinary Text, in Unix format (<TT>LF</TT> only, no
<TT>CR</TT>), so they won't display correctly under DOS if you are
using an old editor.  They contain only settings and definitions.</P>

<H2><FONT COLOR="#4F1F00">2.3 <A NAME="PWAV">The sound files</A>
(<TT>.WAV</TT>)</FONT></H2>

<P>The sound files are ordinary 16-bit RIFF WAVE files (the format
commonly used under Microsoft Windows, and now supported by many
utilities under different operating systems).</P>

<H2><FONT COLOR="#4F1F00">2.4 <A NAME="PDAT">The code lump</A>
(<TT>.DAT</TT>)</FONT></H2>

<P>The .DAT file contains some semi-compiled machine independent
P-code, instead of the Quake programming language <TT>.QC</TT>
files.</P>

<P>This file contains the behavior associated to each of the entities.
For instance, this file contains the frame table that defines how and
when each frame of the <A HREF="#CMDLF">Alias Models</A> must be
displayed.</P>

<P>This file also contains the light styles used to animate the <A
HREF="#BL7">Faces</A> of the BSP models.  Those light styles can be
found as strings, among the other character strings.</P>

<P>Here is a very partial description of that data lump. The only
interesting part is the list of text strings, because it gives the
names of possible spawning sequences for the <A
HREF="#BL0">Entities</A>.</P>
<PRE>
typedef struct
{ long offset;
  long size;
} codentry_t;

typedef struct
{ long  version;               // 3
  long  program;               // offset to start of P-CODE
  codentry_t  table12;         // table of 1 long and 4 short (frames?)
  codentry_t  table12;         // table of 3 long
  codentry_t  table12;         // table of 3 long
  codentry_t  table64;         // Table of 16 long
  codentry_t  strings;         // Character strings, separated by '\0'
  codentry_t  numeric;         // Constants and variable
} codehead_t;
</PRE>

<P>Do not attempt to decompile the QC code: most probably, this
language is still totally unstable, so any efforts to hack
would be a waste.  And id Software will probably provide
examples of source code, not only compiled stuff.</P>



<H2><FONT COLOR="#4F1F00">2.5 <A NAME="PLMP">The lump file</A>
(<TT>.LMP</TT>)</FONT></H2>
       
<P> There are three kinds of lumps: Palette, colormap, pictures.</P>


<H4>PALETTE</H4> 

<P>This is the game the color palette:
<PRE> 
struct { u_char Red, u_char Green, u_char Blue} Palette[256];
</PRE></P>

<H4>COLORMAP</H4> 

<P>This is the precalculated color map, made of 32 tables.
each table contains 256 indexes to the actual colors in the colormap.
<PRE>                                     
u_char ColorIndex[32][256];
</PRE>                                  
</P>

<P>Phen light level is <TT>light</TT> and the color is <TT>color</TT>, 
the games uses the color index:<BR>
<TT>c = ColorIndex[ ((light>>3)&0x1F)][color]</TT>.
</P>
                                             

<H4>Pictures</H4>

<P>These are simple flat pictures, with indication of width and height, that
are used for menus, status bar and the like.
<PRE> 
typedef struct
{ long width;
  long height;
  u_char Color[width*height];                                       
} picture_t;
</PRE></P>


<H2><FONT COLOR="#4F1F00">2.6 <A NAME="PBIN">The end screen</A>
(<TT>.BIN</TT>)</FONT></H2>
 
<P>A classical DOS text screen, 80x25 with color tags. Same as
the end screen in DOOM.</P>                                                                


<H2><FONT COLOR="#4F1F00">2.7 <A NAME="PCFG">The config file</A>
(<TT>.CFG</TT>)</FONT></H2>
  
<P>A simple text file, that contains the default configuration of keys.</P>

<HR SIZE=3>
<!--FILE="qkspec_3.htm#content"-->

<H1><FONT COLOR="#007F00">3. <A NAME="CBSP0">Level Map Models</A></FONT></H1>



<H2><FONT COLOR="#4F1F00">3.1 <A NAME="CBSPG">Description of .BSP Files</A></FONT></H2>

<H3>3.1.1 General description of level BSP Maps</H3>

<P>The BSP maps are meant to be generated automatically. They are described
here only for the purpose of helpin you write a BSP generation tool.
If you are only interested in building Quake editors, please read the 
description of <A HREF="#CMAPG">Level Maps</A> instead.</P>

<P>The level BSP maps are stored in files with extension <TT>.BSP</TT> (for
Binary Space Partition Tree).  Those files need not necessarily contain
level maps, they can also contain the definition of any entity that is
not supposed to be modified during game play.</P>

<P>Since a BSP based model requires the calculation of a BSP tree, and
this calculation is tedious, these models are not used to store
definitions of monsters, players, or anything that can change shape
during game play.  But you could use them for a model of a big rock,
because that rock isn't gonna be modified...</P>

<P>Moreover, there are no frames associated to a BSP based model,
contrary to what happens for Alias models: it's just one single big
frame.  So you cannot animate them.</P>

<H3>3.1.2 Description of the contents of .BSP files</H3>

<P>The .BSP files contain all the information that is needed to
display a level correctly, for the obvious reason that those files are
meant to be distributed individually, or associated in multi-level
maps without causing trouble.  In DOOM, you had to take care that all
the needed textures were available.  Now, the textures are in the level
itself.</P>

<P>One disadvantage of that format is that, contrary to DOOM, you
cannot have a single set of textures for all your levels, or re-use
textures in another level.  Now guess why Quake will come on
CD-ROM.</P>


<P>Here are the contents of levels:
<OL>
<LI> A list of entities that are present in the level.
<LI> A description of the level map, in term of faces, edges, vertices,
    and textures on the faces. Actually, there might be more faces
         than really needed, because of the BSP tree that splits them.
<LI> Some <B>enormous</B> amount of data to accelerate the rendering
   of levels, and which must be calculated off-line: a set of planes,
        models, BSP nodes, clip nodes, BSP leaves,
        visibility lists, and edge lists, face lists.
</OL>
</P>

<P>The format of level is pretty complicated, don't be disappointed if
you don't understand everything on first try.  Maybe you can imagine
how hard it has been to hack it out of the BSP map.</P>



<HR>

<H2><FONT COLOR="#4F1F00">3.2 <A NAME="CBSPF">The Format of BSP files</A></FONT></H2>

<P>Beware: the description below is valid only for the version <TT>0x1C</TT>
of the BSP file format, used in Quake Shareware version, 22 June 96.
Previous version of Quake used different formats. Future versions might 
differ again.</P>

<P>A BSP file starts with some sort of directory, of fixed size.  As a
matter of fact, the entries in a BSP file are always at the same place
in the directory.</P>

<P>Here is the description of one directory entry:
<PRE>
typedef struct                 // A Directory entry
{ long  offset;                // Offset to entry, in bytes, from start of file
  long  size;                  // Size of entry in file, in bytes
} dentry_t;
</PRE>
Here is the BSP header itself, made of a version tag, and 15 entries:
<PRE>
typedef struct                 // The BSP file header
{ long  version;               // Model version, must be <TT>0x17</TT> (23).
  dentry_t entities;           // List of <A HREF="#BL0">Entities</A>.
  dentry_t planes;             // Map <A HREF="#BL1">Planes</A>.
                               // numplanes = size/sizeof(plane_t)
  dentry_t miptex;             // Wall <A HREF="#BL2">Textures</A>.
  dentry_t vertices;           // Map <A HREF="#BL3">Vertices</A>.
                               // numvertices = size/sizeof(vertex_t)
  dentry_t visilist;           // Leaves <A HREF="#BL4">Visibility</A> lists.
  dentry_t nodes;              // <A HREF="#BL5">BSP Nodes</A>.
                               // numnodes = size/sizeof(node_t)
  dentry_t texinfo;            // <A HREF="#BL6">Texture Info</A> for faces.
                               // numtexinfo = size/sizeof(texinfo_t)
  dentry_t faces;              // <A HREF="#BL7">Faces</A> of each surface.
                               // numfaces = size/sizeof(face_t)
  dentry_t lightmaps;          // Wall <A HREF="#BL8">Light Maps</A>.
  dentry_t clipnodes;          // <A HREF="#BL9">clip nodes</A>, for Models.
                               // numclips = size/sizeof(clipnode_t)
  dentry_t leaves;             // <A HREF="#BLA">BSP Leaves</A>.
                               // numlaves = size/sizeof(leaf_t)
  dentry_t lface;              // List of <A HREF="#BLB">Faces</A>.
  dentry_t edges;              // <A HREF="#BLC">Edges</A> of faces.
                               // numedges = Size/sizeof(edge_t)
  dentry_t ledges;             // List of <A HREF="#BLD">Edges</A>.
  dentry_t models;             // List of <A HREF="#BLE">Models</A>.
                               // nummodels = Size/sizeof(model_t)
} dheader_t;
</PRE></P>

<P>All the offsets are counted from the start of the BSP files.  The
size can be 0, if the entry is not present.  It must not be
negative.</P>

<H3><A NAME="BLM">Basic data types</A></H3>

<P>Before we start with the level entry structure, you will need to
understand the following data types:
<PRE>
typedef float scalar_t;        // Scalar value,

typedef struct                 // Vector or Position
{ scalar_t x;                  // horizontal
  scalar_t y;                  // horizontal
  scalar_t z;                  // vertical
} vec3_t;

typedef struct                 // Bounding Box, Float values
{ vec3_t   min;                // minimum values of X,Y,Z
  vec3_t   max;                // maximum values of X,Y,Z
} boundbox_t;

typedef struct                 // Bounding Box, Short values
{ short   min;                 // minimum values of X,Y,Z
  short   max;                 // maximum values of X,Y,Z
} bboxshort_t;
</PRE></P>

<P><TT>scalar_t</TT> is a scalar value, that is used to represent X,Y,Z
coordinates, or distances.  It is a 32bit, single precision floating
point number, and it can be expected that in later version it will be
replaced by some fixed point number, as is typical in DOS games
(because the floating point unit of Intels just amazingly sucks).</P>

<P><TT>vec3_t</TT> is a 3D vector, that is used to represent either 3D
position in space, or vectors normal to planes.  Usually, 3D positions
in space will be integer values, though they are coded in floating
point.  Maybe a hint that the final engine will work only with integer
of fixed point values, like DOOM did.</P>

<P><TT>boundbox_t</TT> is a set of two vec3_t, that represents a
bounding box in 3D space.  The first vec3_t stores the minimum values,
the second one stores the maximum values.  These bounding boxes, though
less elegant than a center point and a distance, allow for greater
processing speed.</P>


<P><TT>bboxshort_t</TT> is a set of six short integer, that represent 
a condensed form of boundbox_t, the ordinary bounding box.</P>


<HR>


<H2><FONT COLOR="#4F1F00">3.3 <A NAME="CBSPL">Level layout definition</A></FONT></H2>

<P>The basic level entries are those that define the geometrical
structure of the level; i.e. those are the only ones a level editor
should ever bother about.</P>

<P>Actually, this is not totally true, because those entries are
intricately related to the BSP tree format, so an intermediate format
shall be used, before calculating the <A HREF="#CBSPN">BSP tree</A>
and the <A HREF="#CBSPC">pre-calculated</A> entries.</P>


<H3>3.3.1 <A NAME="BLE">The Definitions of Models</A></H3>

<P><I>The name Model refers here to either a big zone, the level, or
smaller independent parts inside that zone, like the grid bars on
level TEST1, that open with a push on the switch.</I></P>

<P>The level map is divided in one or more Models, which are
independent areas, roughly bounded by two sets of <A HREF="#BL9">Clip Nodes</A>,
and organised internally around a <A HREF="#BL5">BSP Tree</A>, that
contains the <A HREF="#BLA">BSP Leaves</A>, which are the actual areas
where entities can be found (like the sectors in DOOM).</P>

<P><PRE>
typedef struct
{ boundbox_t bound;            // The bounding box of the Model
  vec3_t origin;               // origin of model, usually (0,0,0)
  long node_id0;               // index of first <A HREF="#BL5">BSP node</A>
  long node_id1;               // index of the first <A HREF="#BL9">Clip node</A>
  long node_id2;               // index of the second <A HREF="#BL9">Clip node</A>
  long node_id3;               // usually zero
  long numleafs;               // number of <A HREF="#BLA">BSP leaves</A>
  long face_id;                // index of <A HREF="#BL7">Faces</A>
  long face_num;               // number of <A HREF="#BL7">Faces</A>
} model_t;
</PRE></P>

<H4>About the Models</H4>

<P>The first model is the whole level itself.
The other models, smaller, represent door, switches, bars, that might
move around the level. </P>

<P>A typical BSP model is only made of one single model, and only the
level maps may eventually need more than one model.<BR>

<H4>About the different fields</H4>

<P>The <TT>numleafs</TT> field is the number of leaves in the BSP tree.
It is used to determine how much room each  <A HREF="#BL4">visilists</A> 
requires when decompressed (better not put a wrong number there).</P>

<P>The <TT>node_id</TT> field is an index to the first node of the
BSP tree that splits the model. 
</P>

<P>The <TT>bnode_id</TT> and <TT>bnode_id2</TT> field is an index to the 
first node of two BSP tree that are used for early collision detection.
There used to be only one of these trees. The purpose of the second
tree is unknown (maybe it's not for collision detection after all).
</P>

<P>The <TT>face_id</TT> and <TT>face_num</TT> fields refer to
all the consecutive faces in the <A HREF="#BL7">face list</A>
that belong to a given model.</P>



<H4>Unknown fields</H4>

<P>The purpose of the four <TT>zero</TT> fields is unknown.
Apparently, it's not a good idea to use another value than 0
there.</P>



<H3>3.3.2 <A NAME="BL3">List of Vertices</A></H3>

<P>The vertices definitions are used for <A HREF="#BLC">Edges</A>,
which are part of <A HREF="#BL7">faces</A>.</P>

<P>The order of vertices in the list is irrelevant.
<PRE>
typedef struct
{ float X;                    // X,Y,Z coordinates of the vertex
  float Y;                    // usually some integer value
  float Z;                    // but coded in floating point
} vertex_t;
</PRE></P>

<P>The vertices are only used for texture mapping.</P>

<P>There must be only one given vertex definition, for any point in 3D
space.</P>


<H3>3.3.3 <A NAME="BLC">The Edges</A></H3>

<P>This structure stores a list of pairs of indexes of vertices, each
pair defining an edge of a face.  That edge will generally be used
by more than one face (two or three is typical).</P>

<P>Edges are referenced in <A HREF="#BLD">List of edges</A>, that
represent the actual list of edges contained in each 
<A HREF="#BL7">face</A>. The edges are not directly referenced
in faces, otherwise the face structure could not have
a fixed size.</P>


<P><PRE>
typedef struct
{ u_short vertex0;             // index of the start <A HREF="#BL3">vertex</A>
                               //  must be in [0,numvertices[
  u_short vertex1;             // index of the end <A HREF="#BL3">vertex</A>
                               //  must be in [0,numvertices[
} edge_t;
</PRE></P>

<P>Note that the first edge in the list is never used: as a matter of
fact, the <A HREF="#BLD">List of Edges</A> uses positive or negative
numbers to indicate the edge sense, so number zero would be unsuitable.</P>



<H3>3.3.4 <A NAME="BL6">The Texture Informations</A></H3>

<P>The texture informations define how the textures are rendred on the
faces (i.e. the Wall, Floors, Ceilings, Sky, and Water areas).</P>

<P>Since those surfaces can be of complex shape, they are split in simple
convex <A HREF="#BL7">Faces</A>. But then, all those faces have a reference
to the same texture information.</P>

<P><PRE>
typedef struct
{ vec3_t   vectorS;            // S vector, horizontal in texture space)
  scalar_t distS;              // horizontal offset in texture space
  vec3_t   vectorT;            // T vector, vertical in texture space
  scalar_t distT;              // vertical offset in texture space
  u_long   texture_id;         // Index of <A HREF="#BL2">Mip Texture</A>
                               //           must be in [0,numtex[
  u_long   animated;           // 0 for ordinary textures, 1 for water 
} surface_t;
</PRE></P>


<H4>Texture orientation</H4>

<P>The orientation of the texture, on the face, is defined
by two vectors <TT>S</TT> and <TT>T</TT>) and two offsets along these 
vectors, <TT>distS</TT> and <TT>distT</TT>.<BR>
See the explanation of <A HREF="#BL7">Texture Mapping</A> below.</P>

<P>The </TT>animated</TT> field is just a boolean that is set to 1 when
the texture is to be used with a swirling animated texture, like water,
slime or lava. If it is not set to 1 with those textures, the game
crashes, complaining that surface extent is invalid.</P> 

<H4>Mips mapping</H4>

<P>The textures are rendered by using Mip Mapping: depending on the
distance from the face to the player, a different texture is used
for texture mapping, so as to reduce aliasing.</P>

<P>Since the Mip Mapping uses distance as a trigger, the bounding box
of all face vertices (i.e. the face extent) must be <EM>smaller
than 256</EM>, for any coordinate.  Otherwise it would not be possible
to select a Mip Mapping valid for all the texture.</P>

<P>Once the right texture is chosen, the face is rendered as an
ordinary texture-mapped convex face.</P>

<H4>Texture names</H4>

<P>The Mip texture are referenced by <TT>texture_id</TT>, so that
more than 256 textures can be used in a level. But it is expected that
the more texture you use, the slower the game will be, so do not
use more than 64 without very good reasons.</P>

<P>Depending on the <A HREF="#CBSPI">name of the texture</A>, a 
face will look like a sky, or a wall or floor (that can eventually be 
animated).</P>




<H3>3.3.5 <A NAME="BL7">The Face</A></H3>

<P>The face are convex polygons that cover the original surfaces
(convex polygons are more convenient for 3D rendering, especially
in hardware).</P>

<PRE>
typedef struct  
{ u_short plane_id;            // The <A HREF="#BL1">plane</A> in which the face lies
                               //           must be in [0,numplanes[ 
  u_short side;                // 0 if in front of the plane, 1 if behind the plane
  long ledge_id;               // first edge in the <A HREF="#BLD">List of edges</A>
                               //           must be in [0,numledges[
  u_short ledge_num;           // number of edges in the <A HREF="#BLD">List of edges</A>
  u_short texinfo_id;          // index of the <A HREF="#BL6">Texture info</A> the face is part of
                               //           must be in [0,numtexinfos[ 
  u_char typelight;            // type of lighting, for the face
  u_char baselight;            // from 0xFF (dark) to 0 (bright)
  u_char light[2];             // two additional light models  
  long lightmap;               // Pointer inside the general light map, or -1
                               // this define the start of the face light map
} face_t;
</PRE>

<P>The faces that lie in the same plane must be stored
consecutively, because they will be referenced as a list in the
definition of <A HREF="#BLE">models</A>.</P>

<H4>Light level of the faces</H4>

<P>The <TT>lightmap</TT> field is an offset into the <A
HREF="#BL8">Light Maps</A>. If there is no light map, this pointer is
-1.</P>

<P>The <TT>baselight</TT> field gives the base light level for the
face, that is the minimum light level for the light map, or the
constant light level in the absence of light map.  Curiously, value
<TT>0xFF</TT> codes for minimum light, and value <TT>0</TT> codes for
maximum light.</P>

<P>The <TT>typelight</TT> field indicates the kind of lighting that
should be applied to the face:
<UL>
<LI> value <TT>0</TT> is the normal value, to be used with a light
  map.
<LI> value <TT>0xFF</TT> is to be used when there is no light map.
<LI> value <TT>1</TT> produces a fast pulsating light
<LI> value <TT>2</TT> produces a slow pulsating light
<LI> value <TT>3</TT> to <TT>10</TT> produce various other
  lighting effects, as defined in <A HREF="#PDAT">The code lump</A>.
</UL>
Note that if you use values <TT>1</TT> to <TT>8</TT>, you may wish to
set <TT>baselight</TT> to <EM>0</EM>.</P>



<H4>Texture mapping</H4>

<P>(Warning: texture mapping is totally different from early versions
of the BSP model. Forget about those early versions.)</P>

<P>To paint a face with a given texture, it is required that a position
<TT>(s,t)</TT> in texture space be associated to each vertex in 3D space.
</P>

<P>But that would make a lot of data, because a given vertex is often used
by more than one face, and each one require a special <TT>(s,t)</TT>
coordinate. So it has been prefered to store only the S and T vectors,
and to calculate the <TT>(s,t)</TT> coordinates on the fly, probably
when loading the level.</P>

<P>For a given face, the (s,t) coordinates are calculated from the 
<A HREF="#BL3">Vertex</A> coordinates and the <A HREF="#BL6">Texture</A> 
definitions by a simple dot product with the S and T vectors:
<PRE>
s = dotproduct(Vertex,<A HREF="#BL6">vectorS</A>) + <A HREF="#BL6">distS</A>;    
t = dotproduct(Vertex,<A HREF="#BL6">vectorT</A>) + <A HREF="#BL6">distT</A>;
</PRE>
</P>

<P>In theory, <TT>vectorS</TT> and <TT>vectorT</TT> should be orthogonal
vectors, and always lie in the face plane (or rather, the face plane),
so as to avoid any distortion when mapping the texture onto the face.</P>

<P>Actually, those two vectors are often chosen among the coordinate axis
themselves (or their opposite), so that textures in adjacent wall remain
naturally aligned, despite the possibly different orientation of the
walls. There is distortion of course, but it's limited.</P>

<P>Also, though the skies are ordinary wall textures, they are drawn in a 
very special way, that make them look like skies.  That is probably the 
same trick as in DOOM: it doesn't take the player position into account 
when texture mapping, only the orientation of view, so that the sky
appears to be far away.</P>


<H4>Unknown field</H4>

<P>There is one short integer that has not been identified, and
experiment showed that its value seems to be ignored by the engine.
However, it is safer to put value <TT>0xFFFF</TT> there, because this
is the default value used in almost every face.</P>


<H3>3.3.6 <A NAME="BL2">The Mip Textures</A></H3>

<P>The Mip textures definitions are used only in
<A HREF="#BL6">Texture info</A>, and are referenced by index, not by
name.</P>


<P>The Mip Texture definition is a structured file, that contains a list of
individual Mip Textures, each one accessed via an offset.
<PRE>
typedef struct                 // Mip texture list header
{ long numtex;                 // Number of textures in Mip Texture list
  long offset[numtex];         // Offset to each of the individual texture
} mipheader_t;                 //  from the beginning of mipheader_t
</PRE></P>

<P>Each individual texture is also a structured entry, that indicates
the characteristics of the textures, and a pointer to scaled down
picture data.
<PRE>
typedef struct                 // Mip Texture
{ char   name[16];             // Name of the texture.
  u_long width;                // width of picture, must be a multiple of 8
  u_long height;               // height of picture, must be a multiple of 8
  u_long offset1;              // offset to u_char Pix[width   * height]
  u_long offset2;              // offset to u_char Pix[width/2 * height/2]
  u_long offset4;              // offset to u_char Pix[width/4 * height/4]
  u_long offset8;              // offset to u_char Pix[width/8 * height/8]
} miptex_t;
</PRE></P>

<P>The Mip texture header is generally followed by <TT>(width *
height) * (85 / 64)</TT> bytes, that represent the color indexes of
the textures pixels, at different scales.  Do not rely on that size
however, rather consider the offsets described below.</P>

<P>The pixels are accessed by offsets, with <TT>offset1</TT>
(resp. <TT>2</TT>, <TT>3</TT>, <TT>4</TT>) pointing to the beginning
of the color indexes of the picture scaled by 1 (resp. 1/2, 1/4, 1/8).
These offsets are relative to the beginning of <TT>miptex_t</TT>.</P>

<P>The <A HREF="#CBSPI">name of the texture</A> is rather irrelevant,
except that:
<UL>
<LI> if it begins by <TT>*</TT> it will be animated like lava or water.
<LI> if it begins by <TT>+</TT> then it will be animated with frames,
     and the second letter of the name will be the frame number.
     Those numbers begin at 0, and go up to 9 at the maximum.
<LI> if if begins with <TT>sky</TT> if will double scroll like a sky.<BR>
     Beware that sky textures are made of two distinct parts.
</UL>
</P>

<P>An individual Mip texture occupies 33% more space than a simple
flat texture would.  This is the cost of anti-aliasing.</P>


<HR>

<H2><FONT COLOR="#4F1F00">3.4 <A NAME="CBSPN">Bsp tree definition</A></FONT></H2>

<P>These are the entries that are related to the BSP tree that is used for rendering
the level.</P>

<H3>3.4.1 <A NAME="BL5">The BSP tree Nodes</A></H3>

<P>The BSP tree nodes are used to partition one model (from the <A
HREF="#BLE">List of models</A>) into a set of independent convex
<A HREF="#BLA">BSP tree Leaves</A>.</P>

<P>All the BSP tree nodes are stored in that same BSP tree node
structure, Though there is in fact one BSP tree per model.  But of
course no index should point to nodes that are part of another BSP
tree.</P>

<P><PRE>
typedef struct
{ long    plane_id;            // The <A HREF="#BL1">plane</A> that splits the node
                               //           must be in [0,numplanes[
  u_short front;               // If bit15==0, index of Front child node
                               // If bit15==1, <B>~front</B> = index of <A HREF="#BLA">child leaf</A>
  u_short back;                // If bit15==0, id of Back child node
                               // If bit15==1, <B>~back</B> =  id of <A HREF="#BLA">child leaf</A>
  bboxshort_t box;             // Bounding box of node and all childs
  u_short face_id;             // Index of first <A HREF="#BL7">Polygons</A> in the node
  u_short face_num;            // Number of faces in the node
} node_t;
</PRE></P>

<H4>Organisation of the BSP tree</H4>

<P>The BSP tree nodes are part of a BSP tree, valid only inside a given model.</P>

<P>The <TT>front</TT> (resp. <TT>back</TT>) value is the equivalent of the
right (resp. left) of node, in DOOM.  Actually, even in DOOM it was the
front (resp. back) of a linedef, if it had been extended
vertically.</P>

<P>If the bit 15 is not set, as detected by <TT>(value &amp;
0x8000) == 0</TT>, then the number is the index to the front
(resp. back) child node.</P>

<P>If the bit 15 is set, then the child is in fact a BSP tree leaf,
and the index of this leaf is obtained by inverting all the bits of
<TT>front</TT> (resp. <TT>back</TT>).</P>

<P>In particular, the value -1 translates into leaf index 0. But
actually it means that there is no leaf. <A HREF="#BLA">Leaf 0</A>
is a dummy leaf, contains no faces, and has a special type (-2)
that means the BSP tree rendering must stop.</P>

<H4>The role of BSP tree nodes</H4>

<P>The nodes are the Quake equivalent of the DOOM nodes and also of
the DOOM blockmaps.  They are parts of a 3D BSP tree, not a 2D BSP
tree like in DOOM.</P>

<P>The nodes are used for level display, placements of entities and
second-level collision detections.</P>

<P>The front child node (and all the nodes below it) is entirely
contained in the half-space that is in front of the split plane.</P>

<P>The back child node (and all the nodes below it) is entirely
contained in the half-space that is in the back of the split plane.
(The 'front' and 'back' of a split planes are defined by the plane
equation giving a positive or negative result for any given
vertex.)</P>

<H4>The Bounding Boxes of nodes</H4>

<P>The Bounding box of the node is presented in a packed format,
bboxshort_t, that only contains short integer instead of floats.</P>

<P>That bounding box slightly exagerates the actual size of the node 
and all it's childs. Each bounding box boundary seems to be rounded to
the next multiple of 16, so that the bounding box is at least 32
units larger than it should be.</P>

<P>That means that the level coordinates must all remain roughly 
between -32700 and +32700.</P>

<H3>3.4.2 <A NAME="BLA">The BSP Tree Leaves</A></H3>

<P>The BSP tree leaves are children of <A HREF="#BL5">BSP tree
Nodes</A> and indicate which <A HREF="#BL7">faces</A> are contained
inside a BSP tree leaf.</P>

<P><PRE>
typedef struct
{ long type;                   // Special type of leaf
  long vislist;                // Beginning of <A HREF="#BL4">visibility lists</A>
                               //     must be -1 or in [0,numvislist[
  bboxshort_t bound;           // Bounding box of the leaf
  u_short lface_id;            // First item of the <A HREF="#BLB">list of faces</A>
                               //     must be in [0,numlfaces[
  u_short lface_num;           // Number of faces in the leaf  
  u_char sndwater;             // level of the four ambient sounds:
  u_char sndsky;               //   0    is no sound
  u_char sndslime;             //   0xFF is maximum volume
  u_char sndlava;              //
} dleaf_t;
</PRE></P>

<P>The first leaf (index 0) is always totally solid, so that in the 
<A HREF="#BL5">BSP tree nodes</A>, a value of zero points to a solid
leaf (i.e. a leaf that need not be rendered).</P>

<P>The BSP tree leaf contains a reference to a set of consecutive
entries in the <A HREF="#BLB">list of faces</A>.</P>

<P>The bounding box must contain all the faces in the leaf.</P>

<P>The leaf contains an index to the <A HREF="#BL4">Visibility
Lists</A> that describe which other leaves are visible from that
leaf. If this index is -1, then all the other leaves are visible.</P>

<P>The tree leaves are the Quake equivalent of the sectors in DOOM.
You can imagine them as rooms, or part of rooms, where the monsters,
players and object will be placed.</P>

<P>Actually the tree leaves are the equivalent of the Sub Sectors:
each sector in DOOM is decomposed by the BSP into smaller and simpler
convex sub sectors, that contain only part of the sector lines.</P>

<P>Technically, each tree leaf, made of some faces and bound by the
BSP node split lines, appears in 3D space as a convex polytope.</P>

<H4>Leaf types</H4>

<P>The <TT>type</TT> field describes what happens when the player
is into that precise leaf. Here are the known values (negative):
<UL>
<LI> <B>-1</B>: ordinary leaf
<LI> <B>-2</B>: the leaf is entirely inside a solid (nothing is displayed).
<LI> <B>-3</B>: Water, the vision is troubled.
<LI> <B>-4</B>: Slime, green acid that hurts the player.
<LI> <B>-5</B>: Lava, vision turns red and the player is badly hurt.
<LI> <B>-6</B>: Behaves like water, but is used for sky.
<LI> All types below -6 seem to be water (maybe they are not
  implemented yet)
</UL>
Note that this field is only taken into account when the player is in
the leaf, so if you're in a leaf full of water you'll see the world
blurred, but players outside will see you perfectly.  </P>



<H3>3.4.3 <A NAME="BLB">The List of Faces</A></H3>

<P>This structure stores a list of indexes of faces, so that a list
of faces can be conveniently associated to each <A HREF="#BLA">BSP
tree leaf</A>.</P>

<P><PRE>
u_short lface[numlface];   // each u_short is the index of a <A HREF="#BL7">Face</A>
</PRE></P>

<P>The list of faces is only used by the <A HREF="#BLA">BSP tree
leaf</A>.  This intermediary structure was made necessary because the
<A HREF="#BL7">faces</A> are already referenced by <A
HREF="#BL5">Nodes</A>, so a simple reference by first face and
number of faces was not possible.</P>




<H3>3.4.4 <A NAME="BLD">The List of Edges</A></H3>

<P>This structure stores indexes of edges, possibly inverted, so that
<A HREF="#BL7">faces</A> can be reconstituted.</P>

<P><PRE>
short lstedge[numlstedge];
</PRE></P>

<P>All the edges in a <A HREF="#BL7">face</A> are stored
consecutively, with the correct orientation so that all the <A
HREF="#BL3">vertices</A> in the face are walked
<B>clockwise</B>.</P>

<P>But since the edges are used for more than one face, there is a
trick to ensure that the edge of a given face is always referenced
with the correct orientation:
<UL>
<LI> if <TT>lstedge[e]</TT> is positive, then <TT>lstedge[e]</TT> is
  an index to an <A HREF="#BLC">Edge</A>, and that edge is walked in the
  normal sense, from vertex0 to vertex1.
<LI> if <TT>lstedge[e]</TT> is negative, then <TT>-lstedge[e]</TT> is
  an index to an <A HREF="#BLC">Edge</A>, and that edge is walked in the
  inverse sense, from vertex1 to vertex0.
</UL></P>

<P>The fact that all edges are walked in a <B>clockwise</B> order is
<B>critical</B> for the face rendering process (rasterisation).</P>

<P>The faces are made of just one closed set of edges, or
contour. Those edges seem to be always stored in the right order.</P>





<H3>3.4.5 <A NAME="BL4">Visibility Lists</A></H3>

<P><I>(Thanks to David Etherton for determining the precise formula)</I></P>

<P>The visibility lists are used by <A HREF="#BLA">BSP Leaves</A>, to
determine which other leaves are visible from a given BSP Leaf.</P>

<P>The Visibility list can be of size 0, in that case it will not be
used.  The game will crawl if there is no visibility list in a
level.</P>

<P><PRE>
u_char vislist[numvislist];    // RLE encoded bit array
</PRE></P>


<P>Basically, the visibility list is an array of bits. There is one
such array of bits for each <A HREF="#BLA">BSP Leaf</A>.  They are all
stored in the vislist array, and each leaf has an index to the first
byte of it's own array</P>

<P>The bit number N, if set to 1, tells that when laying in the tree
leaf, one can see the leaf number N.</P>

<P>The only complication is that this bit array in run-length encoded:
when a set of bytes in the array are all zero, they are coded by zero
followed by the number of bytes is the set (always more than 1).<P>

<P>Normally, the size of the bit array associated to a leaf should be
<TT>(<A HREF="#BLE">numleafs</A>+7)/8</TT>, but in fact due to the run
lenght encoding, it's usually much less.</P>

<P>When the player is in a leaf, the visibility list is used to tag
all the leaves that can possibly be visible, and then only those
leaves are rendered.</P>

<P>Here is an example of decoding of visibility lists:
<CODE><PRE>
// Suppose Leaf is the leaf the player is in.
v = Leaf.vislist;
for (L = 1; L &lt; numleaves; v++)
  {
    if (visisz[v] == 0)           // value 0, leaves invisible
      {
        L += 8 * visisz[v + 1]    // skip some leaves
        v++;
      }
    else                          // tag 8 leaves, if needed
      {
        for (bit = 0x80; bit &gt; 0; bit = bit / 2, L++)
          {
            if (visisz[v] &amp; bit)
              TagLeafAsVisible(L);
          }
      }
  }
</PRE></CODE></P>

<P>There is no necessity to unpack the visibility list in memory,
because the code to read them is fast enough.</P>

<P>If you put a few badly placed zero bits in the visibility lists,
some of the leaves will turn into totally grey areas, and that's
rather funny.  If you put <B>all bits to zero</B> for a given <A
HREF="#BLA">leaf</A>, then every player in that sector will become
temporarily <B>blind</B>: he will get a fully grey screen.  I wonder
what use you can make of this in level design, though.  If only it had
been black...</P>

<P>The visibility list structure is the Quake equivalent of the REJECT
map of DOOM, except that now it's also <B>used for level
rendering</B>.  It eliminates leaves that can't be seen, whereas in
DOOM it was just use to speed up monster line of sight
calculations.</P>



<HR>

<H2><FONT COLOR="#4F1F00">3.5 <A NAME="CBSPC">Pre-calculated geometric
entries</A></FONT></H2>

<P>Those entries can all be automatically calculated from the <A
HREF="#CBSPL">Level layout definition</A>, and are not related to the
<A HREF="#CBSPN">Bsp tree definition</A>.</P>

<P>Do not confuse the <A HREF=="#BL9">Clip Nodes</A> with the BSP
tree nodes, they are not used for the rendering of the level.</P>

<H3>3.5.1 <A NAME="BL1">List of Planes</A></H3>

<P>The plane definitions are used for <A HREF="#BL7">faces</A>, <A
HREF="#BL5">BSP Nodes</A>, <A HREF="#BL9">Clip Nodes</A>.</P>

<P>The order of planes in list is irrelevant.
<PRE>
typedef struct
{ vec3_t normal;               // Vector orthogonal to plane (Nx,Ny,Nz)
                               // with Nx2+Ny2+Nz2 = 1
  scalar_t dist;               // Offset to plane, along the normal vector.
                               // Distance from (0,0,0) to the plane
  long    type;                // Type of plane, depending on normal vector.
} plane_t;
</PRE></P>
     
<P>Plane <tt>type</tt>s:
<UL> 
<LI> 0:  Axial plane, in X
<LI> 1:  Axial plane, in Y
<LI> 2:  Axial plane, in Z
<LI> 3:  Non axial plane, roughly toward X
<LI> 4:  Non axial plane, roughly toward Y
<LI> 5:  Non axial plane, roughly toward Z
</UL>
</P>

<P>The planes are used as split planes in the BSP tree nodes, and as
reference plane in the faces.</P>

<P>They are the Quake equivalent of the DOOM Linedefs and
Segments.</P>

<P>The planes are defined by a normal vector and a distance.  This
normal vector must be of norm 1.</P>

<P>The plane equations are used for distance calculation and to
determine if a given vertex (of a face, or an entity) is on the
front side or the back side of the plane.</P>

<P>Some of the planes, especially the first ones in the list, are not
associated to any face, but rather to BSP nodes split planes.  So
they show <TT>numsurf = 0</TT>.</P>

<P>There must be only one given plane definition, for any plane in 3D
space.  That's because the calculations of the translation and
rotation of plane normal vector are cached, so if you put redundant
planes definitions you'll contribute to slowing down the engine.
Definitely not an option.</P>



<H3>3.5.2 <A NAME="BL9">The Clip Nodes</A></H3>

<P>This structure is used to give a rough and somewhat exaggerated
boundary to a given <A HREF="#BLE">model</A>.  It does not separate
models from each others, and is not used at all in the rendering of the
levels</P>

<P>Actually, the clip nodes are only used as a first and primitive
collision checking method. </P>

<P>The clip nodes are much simpler than the <A HREF="#BL5">BSP
nodes</A>, so it makes collision detection faster, most of the time.
In the same idea, DOOM defined a BLOCKMAP for faster collision
detection.</P>

<P><PRE>
typedef struct
{ u_long planenum;             // The <A HREF="#BL1">plane</A> which splits the node
  short front;                 // If positive, id of Front child node
                               // If -2, the Front part is inside the model
                               // If -1, the Front part is outside the model
  short back;                  // If positive, id of Back child node
                               // If -2, the Back part is inside the model
                               // If -1, the Back part is outside the model
} clipnode_t;
</PRE></P>

<P>The engine starts from the top bound node as defined in the <A
HREF="#BLE">Model</A>.
<UL>

<LI>If the value of <TT>front</TT> (resp. <TT>back</TT>) is positive,
  then it's the index of a child clip node.
<LI>If value <TT>-1</TT> is met, then the front (resp. back) half
  space is outside of the model, and collision is impossible.
<LI> If the value <TT>-2</TT> is met, then the front (resp. back) half
  space is inside the model, and the <A HREF="#BL5">BSP nodes</A> must be
  checked.
</UL>
</P>

<P>There is no bounding box defined for those nodes, because the
bounding box is that of the <A HREF="#BLE">model</A> bounding
boxes.</P>

<P>If you modify a clip node, for instance by changing the plane
definitions or by putting -1 values for each child, then the model
becomes totally pass-through.  That's a very funny special effect.</P>

<P>The Clip Nodes do not tightly bound a model, so you should
<EM>never</EM> use planes from the model as clip node split
planes. Actually, the clip node planes should be distant from the
model by at least <EM>16</EM> in X,Y, and <EM>24</EM> in Z.</P>

<P>Also take care that the Clip Node planes should be oriented toward
the <EM>exterior</EM> of the model, not the interior.  If you change
the orientation, then the player can go through the model as if it did
now exist... even falling through the floor.</P>




<H3>3.5.3 <A NAME="BL8">The Light Maps</A></H3>

<P>The light maps are special arrays that indicate the brightness of
some points in the <A HREF="#BL2">Mip Texture</A> pictures.</P>

<P>Different light maps can be associated to each <A
HREF="#BL7">face</A>, so that two faces with similar textures
can still look different, depending on the light level.</P>

<P>The light maps are simply:
<PRE>
u_char lightmap[numlightmap];  // value <B>0</B>:dark <B>255</B>:bright
</PRE></P>

<H4>Light levels</H4>

<P>The u_char value that the lightmap gives at any point is directly a
light level value, from 0 to 255.  If you put zero, it will be utter
darkness, and if you put 255 if will be totally bright.</P>

<P>The formula for calculating light level is something like:
<PRE>
light(X,Y,Z) = lightmap(X,Y,Z) * lightstyle(typelight, time) - baselight
</PRE>
where, as a rough explanation:
<UL>
<LI> <A HREF="#BL7"><TT>baselight</TT></A> is the base light level of
  each face (the flat shading of the surface).
<LI> <TT>lightmap(X,Y,Z)</TT> results from the translation of the
  lightmap into 3D space (see below).
<LI> <A HREF="#PDAT"><TT>lightstyle</TT></A> is a table of available
  light styles, available in the code lump. The light style used depends
  on the <A HREF="#BL6">typelight</A> of the corresponding face.
<LI> The exact lightstyle multiplier changes over time, so that it
  looks like the face's light is pulsating.
</UL>
</P>

<P>Note that the textures's color and light are translated into a
final color by using a pre-calculated color palette.  Direct RGB
calculations would be too costly and not very suitable for 256 color
displays.  This is the same trick as used when gouraud shading the
Alias models.</P>



<H4>Translation of lightmaps into 3D space</H4>

<P>Well the exact formula seems rather hard to determine
experimentally, so don't expect this explanation to be accurate.</P>

<P>The size and layout of a lightmap, on texture space, is not related
to the <A HREF="#BL2>texture</A> but only to the <A
HREF="#BL7">face</A> extent, in 3D space. You can change the
texture without having to recalculate light maps.</P>

<P>Each light maps seem to be stored as a simple
<PRE>
u_char light[width*height];
</PRE>
where <TT>width</TT> and <TT>height</TT> are determined by the extents
of the faces's bounding box, i.e. the bounding box of all the <A
HREF="#BL3">vertices</A> contained in that face (or, rather, all
the <A HREF="#BLC">Edges</A>).</P>

<P>Since such a bounding box is essentially 3D, and the lightmap is
only 2D, one coordinate has to be discarded. The coordinate to remove
depends on the orientation of the face's plane, as given by the <A
HREF="#BL1">Plane Type</A>.</P>

<P>This mapping from 3D to 2D, by discarding one coordinate, is
exactly the same as the one used for <A HREF="#BL6">Texture
Mapping</A> the faces.  You can probably consider the lightmaps as
``alpha-channel textures'' which modify the intensity of the real
textures on which they are applied.</P>

<P>Note that the extents of the bounding box (i.e. the difference
between maximum and minimum values) must be divided by 16 to give the
<TT>width</TT> and <TT>height</TT>, because a lightmap value is only
calculated every 16 steps, for every coordinate.

<P>Calculating only every 16 steps make the radiosity calculation 256
times less tedious, and ensures that the lightmap will look nice and
smooth on the face (because bilinear interpolation is used between
known lightmap values).</P>


<H4>Unknown Fields</H4>

<P>I'm aware that the above explanation is rather obfuscated, and may
not cover all cases.  It's savagely hacked out of some experimental
results and some considerations on the convenience of
calculations.</P>

<P>Note also that the lightmap are oriented in regard to the 3D
coordinates, and do not seem to care about the face orientation.
So if you modify a lightmap, chances are that your modifications will
happen is some unexpected place (like, at the bottom instead of at the
top...).</P>

<P>Last, in case you wonder where the <TT>lightstyle</TT> table is
defined, the answer is: no idea. </P>







<H2><FONT COLOR="#4F1F00">3.6 <A NAME="CBSPE">Definition of
entities</A></FONT></H2>


<P><I>(Thanks to John Wakelin who wrote most of this section)</I></P>

<P>The entities define the monsters, things, but also the positions in
space where something must happen.  So they are the Quake equivalent
of both the THINGS and the LINEDEF types from DOOM.</P>

<P>The entities are defined in the <TT>.BSP</TT> file in a series of
simple text blocks as shown below.</P>

<P>The entity definitions are made up of a series of specific details
that define what each is, where it starts, when it appears etc.  Each
specific is followed by a modifier that arguments it.  All definitions
have the <TT>classname</TT> specific that identifies that entity.  The
<TT>classname</TT> specifics relate intimately with the <A
HREF="#PDAT">code lump</A> and are the names of functions written in
Quake C.</P>

<H3>3.6.1 <A NAME="BL0">Format of entities definitions</A></H3>

<P>I have chosen the terms ``specific'' and ``arg'' for the two
different parts of each detail of the definition.  These terms may or
may not suit but, they will have to do until we learn what id calls
them.</P>

<P>Line feeds (ASCII <TT>0x0a</TT>) separate each definition and each
line in the definition.  Spaces (ASCII <TT>0x20</TT>) separate
specifics from args.  I tried changing them around and it does not
seem to matter what separates them as long as it is white space.</P>

<P>The specifics and args are contained within double quotes.  Each
definition is bounded by curly braces.</P>

<P>Like so:
<PRE>
  {
    &quot;<VAR>&lt;specific&gt;</VAR>&quot; &quot;<VAR>&lt;arg&gt;</VAR>&quot;
    &quot;<VAR>&lt;specific&gt;</VAR>&quot; &quot;<VAR>&lt;arg&gt;</VAR>&quot;
    ...
  }
</PRE></P>

<H3>3.6.2 Possible specifics</H3>

<P>
<PRE><TABLE><TR><TD><TABLE BORDER>
<TR VALIGN=TOP><TH ALIGN=LEFT>specifics   </TH><TH ALIGN=LEFT>args        </TH><TH ALIGN=LEFT>Description</TH></TR>

<TR VALIGN=TOP><TD><TT>classname   </TT></TD><TD><VAR>&lt;name&gt;</VAR>      </TD><TD>Type of entity to be defined (mandatory)</TD></TR>
<TR VALIGN=TOP><TD><TT>origin      </TT></TD><TD><VAR># # #</VAR>       </TD><TD>coordinates of where it starts in space</TD></TR>
<TR VALIGN=TOP><TD><TT>angle       </TT></TD><TD><VAR>#</VAR>           </TD><TD>direction it faces or moves (sometimes in degrees)</TD></TR>
<TR VALIGN=TOP><TD><TT>light       </TT></TD><TD><VAR>#</VAR>           </TD><TD>used with the <TT>light</TT> classname (how bright?)</TD></TR>

<TR VALIGN=TOP><TD><TT>target      </TT></TD><TD><VAR>&lt;t#&gt;</VAR>        </TD><TD>Matches a <TT>targetname</TT> & would appear to work</TD></TR>
<TR VALIGN=TOP><TD><TT>targetname  </TT></TD><TD><VAR>&lt;t#&gt;</VAR>        </TD><TD>like a linedef tag</TD></TR>

<TR VALIGN=TOP><TD><TT>wad         </TT></TD><TD><VAR>&lt;filename&gt;</VAR>  </TD><TD>??? - The world</TD></TR>
<TR VALIGN=TOP><TD><TT>spawnflags  </TT></TD><TD><VAR>#</VAR>           </TD><TD>Used to flag the definition of an object that is to
                        be different than the default behavior or type for a
                        classname.  See <TT>item_health</TT> for a good example of this</TD></TR>
<TR VALIGN=TOP><TD><TT>model       </TT></TD><TD><TT>*</TT><VAR>#</VAR>          </TD><TD>Tag to a moving shape/model (see <A HREF="#ENT1">Models</A>)</TD></TR>
</TABLE></TD></TR></TABLE></PRE></P>


<P>The following specifics are found only with the <A HREF="#ENT1">models</A>.
<PRE><TABLE><TR><TD><TABLE BORDER>
<TR VALIGN=TOP><TH ALIGN=LEFT>specifics   </TH><TH ALIGN=LEFT>args        </TH><TH ALIGN=LEFT>Description</TH></TR>

<TR VALIGN=TOP><TD><TT>speed       </TT></TD><TD><VAR>#</VAR>           </TD><TD>How fast the model is moved</TD></TR>
<TR VALIGN=TOP><TD><TT>wait        </TT></TD><TD><VAR>#</VAR>           </TD><TD>How long a pause between completion of movement and
                        return to the original position (in seconds I think)</TD></TR>
<TR VALIGN=TOP><TD><TT>lip         </TT></TD><TD><VAR>#</VAR>           </TD><TD>Seems to be a means of adjusting the starting position of
                        model</TD></TR>
<TR VALIGN=TOP><TD><TT>style       </TT></TD><TD><VAR>#</VAR>           </TD><TD>I am guessing that it is like the spawnflag arg in that
                        it may determine a <EM>different than default</EM> type.</TD></TR>
<TR VALIGN=TOP><TD><TT>dmg         </TT></TD><TD><VAR>#</VAR>           </TD><TD>How much damage the model causes when it shuts on you?</TD></TR>
</TABLE></TD></TR></TABLE></PRE></P>


<H3>3.6.3 Classnames</H3>

<P>The following classnames are the name of a function in the
<A HREF="#PDAT">Code Lump</A>.<P>

<P>Note these are only the names that are known to work currently,
but later versions of Quake will probably use different names.</P>

<P>
<PRE><TABLE><TR><TD><TABLE BORDER>
<TR VALIGN=TOP><TH ALIGN=LEFT>Classnames                 </TH><TH ALIGN=LEFT>Associated
                           specifics    </TH><TH ALIGN=LEFT>Description</TH</TR>

<TR VALIGN=TOP><TD ROWSPAN=2><TT>worldspawn                  </TT></TD><TD><TT>wad          </TT></TD><TD>??? Pointer to a .wad file</TD></TR>
                            <TR VALIGN=TOP><TD><TT>angle        </TT></TD><TD>-</TD></TR>

<TR VALIGN=TOP><TD ROWSPAN=2><TT>light                       </TT></TD><TD><TT>origin       </TT></TD><TD>Light source</TD></TR>
                            <TR VALIGN=TOP><TD><TT>light        </TT></TD><TD>Brightness -sometimes no light level is
                                                     specified (default?)</TD></TR>

<TR VALIGN=TOP><TD ROWSPAN=2><TT>info_player_start           </TT></TD><TD><TT>origin       </TT></TD><TD>Player starting coordinates</TD></TR>
                            <TR VALIGN=TOP><TD><TT>angle        </TT></TD><TD>-</TD></TR>

<TR VALIGN=TOP><TD ROWSPAN=2><TT>info_player_deathmatch      </TT></TD><TD><TT>origin       </TT></TD><TD>Deathmatch start coordinates</TD></TR>
                            <TR VALIGN=TOP><TD><TT>angle        </TT></TD><TD>-</TD></TR>
</TABLE></TD></TR></TABLE></PRE></P>

<P>Weapons - take the <TT>origin</TT> additional specific (and
sometimes <TT>angle</TT> but I don't see why)
<PRE><TABLE><TR><TD><TABLE BORDER>
<TR VALIGN=TOP><TD><TT>weapon_supershotgun         </TT></TD><TD>Double barrel</TD></TR>
<TR VALIGN=TOP><TD><TT>weapon_nailgun              </TT></TD><TD>Nailgun</TD></TR>
<TR VALIGN=TOP><TD><TT>weapon_supernailgun         </TT></TD><TD>Chain Nailgun</TD></TR>
<TR VALIGN=TOP><TD><TT>weapon_grenadelauncher      </TT></TD><TD>Grenade Launcher</TD></TR>
<TR VALIGN=TOP><TD><TT>weapon_rocketlauncher       </TT></TD><TD>Rocket Launcher</TD></TR>
<TR VALIGN=TOP><TD><TT>weapon_lightning            </TT></TD><TD>Lightning Gun (?)</TD></TR>
<TR VALIGN=TOP><TD><TT>weapon_superlightning       </TT></TD><TD>Chain Lightning Gun (?)</TD></TR>
</TABLE></TD></TR></TABLE></PRE></P>

<P>These monsters appear to take the <TT>origin</TT> and
<TT>angle</TT> specifics, but they might also take other specifics as well.
<PRE><TABLE><TR><TD><TABLE BORDER>
<TR VALIGN=TOP><TD><TT>monster_knight              </TT></TD><TD>Slashes at you with sword</TD></TR>
<TR VALIGN=TOP><TD><TT>monster_demon1              </TT></TD><TD>Jumps on you... then server crashes (out of area???)</TD></TR>
<TR VALIGN=TOP><TD><TT>monster_wizard              </TT></TD><TD>Shoots ``caco'' lightning balls at you ... deadly aim</TD></TR>
<TR VALIGN=TOP><TD><TT>monster_shambler            </TT></TD><TD>terrifying 10 foot tall beast with 3 clawed hands</TD></TR>
<TR VALIGN=TOP><TD><TT>monster_ogre                </TT></TD><TD>Chainsaw *and* nailgun</TD></TR>
<TR VALIGN=TOP><TD><TT>monster_army                </TT></TD><TD>looks like an untexture-mapped player</TD></TR>
<TR VALIGN=TOP><TD><TT>monster_tarbaby             </TT></TD><TD>Blobbish thing that jumps up at you when close</TD></TR>
<TR VALIGN=TOP><TD><TT>monster_fish                </TT></TD><TD>Swims after you ... should prob be in water</TD></TR>
<TR VALIGN=TOP><TD><TT>monster_serpent             </TT></TD><TD>Looks like an untexture mapped stingray (crashes)</TD></TR>
<TR VALIGN=TOP><TD><TT>monster_dragon              </TT></TD><TD>Nice looking Wayvern ... (crashes)</TD></TR>
<TR VALIGN=TOP><TD><TT>monster_vomit               </TT></TD><TD>Untextured blob ... scary and fast</TD></TR>
<TR VALIGN=TOP><TD><TT>monster_zombie              </TT></TD><TD>Untextured humaniod ... (crashes)</TD></TR>
</TABLE></TD></TR></TABLE></PRE></P>


<P>Items - Take the <TT>origin</TT> and <TT>spawnflags</TT> additional
specifics
<PRE><TABLE><TR><TD><TABLE BORDER>
<TR VALIGN=TOP><TD><TT>item_health                 </TT></TD><TD>25%  with spawnflag 1(default)<BR>
                            100% with spawnflag 2<BR>
                            13%  with spawnflag 3 (huh?)</TD></TR>

<TR VALIGN=TOP><TD><TT>item_armor1                 </TT></TD><TD>100% Armor  (blue)</TD></TR>
<TR VALIGN=TOP><TD><TT>item_armor2                 </TT></TD><TD>150%        (yellow)</TD></TR>
<TR VALIGN=TOP><TD><TT>item_armorInv               </TT></TD><TD>200%        (red)  - why didn't they use
                                                 spawnflags here?</TD></TR>

<TR VALIGN=TOP><TD><TT>item_shells                 </TT></TD><TD>Shotgun shells  (ammo for shotguns)</TD></TR>
<TR VALIGN=TOP><TD><TT>item_spikes                 </TT></TD><TD>Nine inch Nails (ammo for nailguns)</TD></TR>
<TR VALIGN=TOP><TD><TT>item_rockets                </TT></TD><TD>Rockets (ammo for grenade and rockt launchers)</TD></TR>
<TR VALIGN=TOP><TD><TT>item_cells                  </TT></TD><TD>(ammo for lightning weapons presumably)</TD></TR>

<TR VALIGN=TOP><TD><TT>item_key                    </TT></TD><TD>I assume it is a key but the game crashes
                            hard if it is hacked in</TD></TR>
<TR VALIGN=TOP><TD><TT>misc_barrel                 </TT></TD><TD>exploding barrel filled with lava</TD></TR>
<TR VALIGN=TOP><TD><TT>misc_explobox               </TT></TD><TD>exploding tall gray box</TD></TR>
<TR VALIGN=TOP><TD><TT>misc_explobox2              </TT></TD><TD>exploding short square box</TD></TR>
</TABLE></TD></TR></TABLE></PRE></P>


<P>These entities are always associated with models via targetnames.
<PRE><TABLE><TR><TD><TABLE BORDER>
<TR VALIGN=TOP><TD ROWSPAN=3><TT>info_teleport_destination   </TT></TD><TD><TT>origin       </TT></TD><TD>Teleport landing coordinates</TD></TR>
                            <TR VALIGN=TOP><TD><TT>angle        </TT></TD><TD>-</TD></TR>

                            <TR VALIGN=TOP><TD><TT>targetname   </TT></TD><TD>Same as trigger <TT>target</TT></TD></TR>

<TR VALIGN=TOP><TD ROWSPAN=3><TT>path_corner                 </TT></TD><TD><TT>origin       </TT></TD><TD>-</TD></TR>
                            <TR VALIGN=TOP><TD><TT>target       </TT></TD><TD>Where the train came from</TD></TR>
                            <TR VALIGN=TOP><TD><TT>targetname   </TT></TD><TD>Where to send it next<BR>

                                         These are used to define the
                                         path of a <TT>func_train</TT> such as
                                         the one above the main room in
                                         test2.</TD></TR>
</TABLE></TD></TR></TABLE></PRE></P>


<P><A NAME="ENT1">Models</A> - These classnames are used with the
model-type of entities

<PRE><TABLE><TR><TD><TABLE BORDER>
<TR VALIGN=TOP><TD><TT>func_door            </TT></TD><TD>door</TD></TR>
<TR VALIGN=TOP><TD><TT>func_door_secret     </TT></TD><TD>secret door</TD></TR>
<TR VALIGN=TOP><TD><TT>func_button          </TT></TD><TD>button</TD></TR>
<TR VALIGN=TOP><TD><TT>func_plat            </TT></TD><TD>Lifts</TD></TR>
<TR VALIGN=TOP><TD><TT>func_train           </TT></TD><TD>Sliding platforms</TD></TR>
<TR VALIGN=TOP><TD><TT>func_dm_only         </TT></TD><TD>Teleporters that only show up in deathmatch (may work
                       with other things but, no examples here)</TD></TR>
<TR VALIGN=TOP><TD><TT>trigger_teleport     </TT></TD><TD>teleporter entrance (walk-over)</TD></TR>
<TR VALIGN=TOP><TD><TT>trigger_multiple     </TT></TD><TD>Multiple actions that are activated by a walk over
                       rather than button type of switch.</TD></TR>
<TR VALIGN=TOP><TD><TT>func_illusionary     </TT></TD><TD>illusion: visible, but cannot be touched.</TD></TR>
</TABLE></TD></TR></TABLE></PRE></P>

<P>Note: The term <EM>model</EM> specifies an entity that controls the
actions of a <A HREF="#BLE">model</A> and its parameters.  Do not
confuse it with ordinary entity <A HREF="#CMDL0">models</A>.</P>

<P>The model numbers (<TT>*</TT><VAR>x</VAR>) comes from the order in
which the models are stored in the <A HREF="#BLE">models structure</A>.</P>

<P>The first model (<TT>*0</TT>) is a bounding box that defines the
extents of the whole world.  The rest (starting at <TT>*1</TT>) make
up the models.</P>

<P>The models are defined by a bounding box of the <TT>max</TT> and
<TT>min(x,y,z)</TT>.  Therefore they are always parrallel to the
horizontal planes.  This would seem to exclude any ramp-like
structures that move.</P>

<P>The specific classname, eg. <TT>func_button</TT>, tells Quake what
type of action to set up for this model. The rest of the specifics in
the model definition are arguments to the function refered by the
classname and define things like: what direction to move, how long to
wait between multiple actions, what tag to use to associate the action
with another model, how much damage it will inflict if it closes on
you, etc.</P>

<P>For more information, take a look in <A HREF="#APPA">appendix A</A>,
that contains a list of known models.</P>




<HR>

<H2><FONT COLOR="#4F1F00">3.7 <A NAME="CBSPI">Additional Informations</A></FONT></H2>


<H3>3.7.1 Texture names</H3>

<P><I>(Thanks to Stephen Crowley for experimenting with the names)</I></P>

<P>The names of textures can contain up to 16 characters.</P>

<P>The animation of the texture is entirely determined by it's name:
there are three special names, that make different animations. All the
other names mean that the texture is not animated.</P>

<P>Here are the animated textures:
<UL>
<LI> <B>sky</B>: the texture will behave like a sky, with two levels
        of scrolling made of two parts of the textures.
<LI> <B>*lava</B>: the texture slowly swirls, like the lava.
<LI> <B>*water</B>: the texture lsowly swirls, apparently like lava. 
</UL>
Currently, no other combination works.
</P>


<P>When displaying an animated texture, the lightmap and light levels
are not taken into account. Those textures are always rendered at full
brightness, probably because the face cache would be saturated if
every animation frame had to fit into it.</P>

<P>Note that sky textures have an extent that make them too big to
display as an ordinary wall texture, and that if you turn an ordinary
texture into a sky texture, it will look fairly weird.</P>

<P>Also, for some strange reason, bit <TT>4</TT> of the <A
HREF="#BL7">face flags</A> is set when the texture is supposed to
be animated. If you replace an animated texture by an ordinary texture,
and forget to set this bit to zero, then there will be an error like:
<TT>SurfExtent>256</TT>.</P>



<H3>3.7.2 Texture Anti-aliasing</H3>


<P>This is an attempted explanation for the curious structure of the
Mip Texture.</P>

<P>The sampling theorem states that when you sample any signal (sound,
picture, anything) the highest frequency contained in this signal must
be at most one half of the sampling frequency.  If there is any
frequency above that, the sampling process will map it into a lower
frequency, thus creating a terrible mess into the sampled signal.
This mess is called Aliasing.</P>

<P>When you try to display a picture on a smaller space, you increase
all the frequencies contained in that picture, and thus risk Aliasing.
That's basically what happened in DOOM at long distance.</P>

<P>Now, all you need is only to low-pass filter the picture, with a
cut frequency equal to half the sampling frequency.  Easy!  But...
There is no DSP on the video memory, so those calculations would take
too much time.  It's much easier to pre-calculate 4 scaled down
pictures, that can be used across the most common range of scales:<BR>
infinity-1, 1-1/2, 1/2-1/4, 1/4-1/8.<BR>
Below 1/8, there will be some aliasing...</P>





<HR SIZE=3>
<!--FILE="qkspec_4.htm#content"-->

<H1><FONT COLOR="#007F00">4. <A NAME="CMDL0">The Entity Alias
Models</A></FONT></H1>

<P><I>(Thanks to Brian Martin who clarified most of this section)</I></P>

<P>Alias models can be used for entities, like players, objects, or
monsters.  Some entities can use sprite models (that are similar in
appearance to those of DOOM, though the structure is totally
different) or even maybe models similar to those of the levels.</P>

<P>Importing models from 3DS or the likes is now quite easy.  You'll
just have to work out a few things on your own (like calculation of
the vertex normals, matching them with the vertex normal table,
finding the bounding area of the object, and scaling the vertices to
8-bit values).</P>


<H2><FONT COLOR="#4F1F00">4.1 <A NAME="CMDLP">Presentation of Alias Models</A></FONT></H2>


<P>You need not bother too much about the way Alias Models are
rendered, just keep in mind that the more simple the model, the faster
the game will be.</P>

<P>Here is an attempt at describing what the different parts of the
model represent.  This description is a bit outdated, though.</P>

<P>First imagine a wireframe model of the entity, made of triangles.
This gives the general shape of the entity.  For instance, imagine you
have the general shape of a cow, made of triangles in 3D space.</P>

<P>The 3D vertices define the position of triangles, and contrary
to level models, there is no need for elaborate stuff like nodes,
planes, faces.  Only triangles and vertices.</P>

<P>Now, there is something missing: the skin.  A cow without skin
looks pretty ugly.</P>

<P>Imagine that you have a flat carpet made of the skin of an unlucky
cow.  All you need to do is put some parts of this carpet at the
relevant place on the wireframe model of the cow, and you'll get a
fairly realistic (though a bit polygonal) cow.  Actually, you will
need two carpets: one for the upper part and one for the lower
part.</P>

<P>For each triangle in the wireframe model of the cow, there will be
a corresponding triangle cut from the skin picture.  Or, in other
words, for each 3D vertex of a triangle, there will be a corresponding
2D vertex positioned on the skin picture.</P>

<P>It is not necessary that the triangle in 3D space and the triangle
on the skin have exactly the same shape (in fact, it is not possible
for all triangles) but they should have shapes roughly similar, to
limit distortion and aliasing.</P>

<P>By the way: there is no Mip mapping on the Alias models, so they
don't look very good in distance, which is not too bad since they are
constantly supposed to be moving or changing.  If you want then to
look fine, do them with BSP models.  But then they won't move.</P>


<H2><FONT COLOR="#4F1F00">4.2 <A NAME="CMDLA">Animating Alias models</A></FONT></H2>

<P>The Alias Model animation is based on frames (in DOOM, sprites were
also animated by frames).  So the deformations are defined once and
for all, and there is no skeletal model or any similar physical model
involved in the deformations... well, at least not in real time.</P>

<P>Once the general shape of the model (for instance, a cow) is
defined, and the skin is mapped correctly on that shape, animation is
pretty straightforward: just move the triangles around and it will
seem to move.</P>

<P>To move the triangle, you need only modify the position of the 3D
vertices that are part of it.  For instance, to move the leg of the
cow, you will move the vertices that define the endpoints of the legs.
You will also move the other vertices a bit, so that the movement
looks less mechanical.</P>

<P>Chances are that creating a fine looking animation is gonna be a
very tough job, a bit like with the DOOM sprites.  I would bet that
the quality of the animation will be the most critical point.</P>

<P>Note that the animation consists <TT>only</TT> in changing vertex
positions (and that's why there is one set of vertices for each
animation frame).</P>

<P>The skin of the cow is not modified, neither are the definition of
the triangles.  If you want blood stains to appear on the skin, you'll
have to hide the original triangle, by reducing it or by putting
another triangle in front.</P>

<P>As remarked by Bernd Kreimeier, this method is similar to the
trick squids use when they want to change color: their skin is
made os small areas, of two different colors, and they can reduce
or enlage them at will.</P>

<P>Along the same idea, if you want parts of the models, like head,
weapons and the like, to go flying away when they are cut, then they
must be defined using parts of the skin that are separate from the
parts used for the body.</P>

<P>Or you can use separate models, like the player gibs, but then the
original part must be reduced to a very small size.</P>


<H2><FONT COLOR="#4F1F00">4.3 <A NAME="CMDLF">Alias Model
<TT>.MDL</TT> file format</A></FONT></H2>

<P>The <TT>.MDL</TT> files are collection of lumps, but contrary to
<TT>.BSP</TT> files there are no pointers to access the lumps
directly, and it is suspected that there will be, in future versions
of the models.</P>

<P>Once you have the file header, you can find all the other parts,
just by calculating their position in the file.</P>

<P>A Model file contains:
<OL>
<LI> A <A href="#MD1">skin texture</A>, that describes the color of the
   skin and clothes of the creature, or whatever it can be wearing.
<LI> A list of <A href="#MD2">skin vertices</A>, that are just the
   position of vertices on the skin texture.
<LI> A list of <A href="#MD3">triangles</A>, the describe the general
   shape of the model.
<LI> A list of <A href="#MD4">animation frames</A>.<BR>
   Each frame holds a list of the 3D vertices and the index of the
   precalculated vertex normal.
</OL></P>

<H3>4.3.0 <A NAME="MD0">Alias Model Header</A></H3>

<P>Here is the format of the <TT>.MDL</TT> file header:
<PRE>
typedef struct
{ long id;                     // 0x4F504449 = "IDPO" for IDPOLYGON
  long version;                // Version = 6
  vec3_t scale;                // Model scale factors.
  vec3_t origin;               // Model origin.
  scalar_t radius;             // Model bounding radius.
  vec3_t offsets;              // Eye position (useless?)
  long numskins ;              // the number of <A href="#MDS">skin textures</A>
  long skinwidth;              // Width of <A href="#MDS">skin texture</A>
                               //           must be multiple of 8
  long skinheight;             // Height of <A href="#MDS">skin texture</A>
                               //           must be multiple of 8
  long numverts;               // Number of <A href="#MD2">vertices</A>
  long numtris;                // Number of <A href="#MD3">triangles</A> surfaces
  long numframes;              // Number of <A href="#MD4">frames</A>
  long synctype;               // 0= synchron, 1= random
  long flags;                  // 0 (see Alias models)
  scalar_t size;               // average size of triangles
} mdl_t;
</PRE></P>

<P>The size of this header is <TT>0x54</TT> bytes (84).</P>

<H3>4.3.1 <A NAME="MD1">Alias Model Skins</A></H3>

<P>The model skins are flat pictures that represent the texture that
should be applied on the model. There can be more than one skin,
though usually there is only one.</P>
                 
<H4>The structure of model skins</H4>

<P> The structure of the skin is similar to the structure of 
<A HREF="#CSPRF">Sprites</A> textures.</P>

<P>You will find the first skin just after the model header, at offset 
<TT>baseskin = 0x54</TT>. There are <A HREF="#MD0">numskins</A> skins to read.</P>

<P>Each of these model skins is either a single picture (<B>type</B>=0) or a group 
of pictures (</B>type</B>!=0).</P>

<P>If the skin is made of a single picture, the structure is:
<PRE>
typedef struct
{ long   group;                // value = 0
  u_char skin[skinwidth*skinheight]; // the skin picture
} skin_t;
</PRE></P>

<P>If the skin is made of a group of pictures, the structure is:
<PRE>
typedef struct
{ long group;                  // value = 1
  long nb;                     // number of pictures in group
  float time[nb];              // time values, for each picture
  u_char skin[nb][skinwidth*skinheight]; // the pictures 
} skingroup_t;                                                 
</PRE></P>

<h4>The skin pictures</H4>

<P>The skin pictures are a table of </b>u_char</b>, which represent an
index in a color table. It is suspected that index 0xFF is not a color,
but an indication of transparency.</P>
                  
<P>The width of skins must be a multiple of 4, to ensure long word alignement.</P>

<P>Those pictures are usually made of at least two pieces: one is used
for the front of the model, the other for the back of the model.</P>

<P>Actually, there may be as many pieces as there are independent
parts in the model. For instance, for the player, there are two pieces
that defines the body, and two others that define the gun.</P>

<P>Note that the back skin of a given model part must be on the
<TT>same height</TT>, but translated <TT>width/2</TT>, relatively to
the front skin part.  The back skin part must also be inverted
along the vertical axis.</P>

<P>This design is used to allow the correct rendering of a seamless
skin texture, using <A HREF="#MD2">Skin Vertices</A> with <TT>onseam
== 0x20</TT>, on the skin border.</P>


<H3>4.3.2 <A NAME="MD2">Alias Model Skin Vertices</A></H3>

<P>A <TT>.MDL</TT> file is made of a list of vertices.  To each of
these vertices corresponds a 3D position, a normal, and a position on
the skin picture, for texture mapping.</P>

<P>The list of skin vertices indicates only the position on texture
picture, not the 3D position.  That's because for a given vertex, the
position on skin is constant, while the position in 3D space varies
with the animation.</P>

<P>The list of skin vertices is made of these structures:
<PRE>
typedef struct
{ long onseam;                 // 0 or 0x20
  long s;                      // position, horizontally
                               //  in range [0,skinwidth[
  long t;                      // position, vertically
                               //  in range [0,skinheight[
} stvert_t;
</PRE></P>

<P><TT>s</TT> and <TT>t</TT> are (X,Y) position on the skin picture.</P>

<P><TT>onseam</TT> is a flag, and if non zero it means that the
vertex is on the boundary between the skin part that is applied on the
front of the model, and the skin part that is applied on the back of
the models (i.e. on the edge).</P>

<P>If a vertex is <TT>onseam</TT>, but is part of a triangle that
is on the back side of the model (<TT>facesfront</TT> is 0), then
<TT><A href="#MD0">skinwidth</A>/2</TT> must be added to <TT>s</TT>
so as to find the actual value of <TT>s</TT>.</P>


<P>The skin vertices are stored in a list, that is stored at offset
offset <TT>baseverts = <A href="#MD1">baseskin</A> + skinsizes</TT>:                                 
<PRE>
stvert_t vertices[numverts];
</PRE></P>

<P><TT>skinsizes</TT> is the sum of the size of all skin pictures.
<UL>
<LI>If they are all simple skins, then <TT>skinsize = (4 + 
<A href="#MD0">skinwidth</A> * <A href="#MD0">skinheight</A>) * <A
href="#MD0">numskins</A></TT>.<BR> 
<LI>If there is a mix of simple skin and group skin, you have to
decode it to find out where the vertex begin.
</UL>


<H3>4.3.3 <A NAME="MD3">Alias Model Triangles</A></H3>

<P>An Alias Model is made of a set of triangle facets, with vertices
at the boundaries. Triangles should all be valid triangles, not 
degenerates (like points or lines).</P>

<P>Only <A HREF="#MD2">vertices</A> index are stored in triangles.
the normal vector of the surface is reconstituted from the vertex
position.</P>

<P>Here is the structure of triangles:
<PRE>
typedef struct
{ long facesfront;             // boolean
  long vertices[3];            // Index of 3 triangle vertices
                               // in range [0,numverts[
} itriangle_t;
</PRE></P>

<P>Note that the index of a given vertex is the same in the <A
HREF="#MD2">skin vertex</A> table and in the <A HREF="#MD4">frame</A>
table.</P>

<P>At offset <TT>basetri = <A href="#MD2">baseverts</A> + <A
href="#MD0">numverts</A> * sizeof(stvert_t)</TT> in the <TT>.MDL</TT>
file, you will find:
<PRE>
itriangle_t triangles[numtris];
</PRE></P>

<P>The boolean <TT>facesfront</TT> indicates if the triangle is part
of the front or the back skin.  <TT>1</TT> means that it is on the
front skin, <TT>0</TT> means that it is on the back skin.</P>
<P>When the triangle is on the back skin, then any skin vertex that
is on the skin seam (as indicated by <TT>onseam=1</TT>) must have
it's <TT>s</TT> coordinate increased by 
<TT><A href="#MD0">skinwidth</A>/2</TT>.</P>

<P>As a matter of fact, on the skin picture, the back skin is always
situtated at the same level as the front skin, but moved by 
<TT>skinwidth/2</TT> to the right (check this, with any model).</P>

<P>The following code might make this easier to understand:
<PRE>
  for(j=0; j &lt; numtris; j++)
  {
    for(i=0; i &lt; 3 ; i++)
    { 
      vertex = triangles[j].vertices[i]
      s = vertices[vertex].s;
      t = vertices[vertex].t;
      if( (vertices[vertex].onseam) && (!triangle[j].facesfront))
      { 
        s += skinwidth / 2;
      }
      /* use s and t as the coordinates of the vertex*/
    }
  }
</PRE>
</P>


<H3>4.3.4 <A NAME="MD4">Alias Model Frames</A></H3>

<P>An Alias Model contains a set of animation frames, which can be
used in relation with the behavior of the modeled entity, so as to
display it in various postures (walking, attacking, spreading its guts
all over the place...).</P> 

<P>This frame structure is rather complex to figure out, because:
<UL>
<LI> Frames can come standalone or in groups
<LI> vertex posistion, in frames, are packed to save space.
<LI> vertex normals are indicated by an index in a table.
</UL>
</P>
     
<H4>The frame vertices</H4>

<P>Each frame vertex is defined by a 3D position and a normal for each
of the <A href="#MD2">vertices</A> in the model. </P>

<P><PRE>
typedef struct
{ u_char packedposition[3];    // X,Y,Z coordinate, packed on 0-255
  u_char lightnormalindex;     // index of the vertex normal
} trivertx_t;
</PRE></P>
<P>To get the real X coordinate, from the packed coordinates, multiply
the X coordinate by the X scaling factor, and add the X origin.  Both
the scaling factor and the origin can be found in the <A
HREF="#MD0">Model Header</A>.</P>

<P>The formula for calculating positions is:
<PRE>
vec3_t position[i] = ( scale[i] *  packedposition[i] ) + origin[i]
</PRE>
Where <TT>scale</TT>, and <TT>origin</TT> can be found as vectors in
the <A href="#MD0">Model Header</A>.</P>

<H4>The vertex normals</H4>

<P>The <TT>lightnormalindex</TT> field is an index to the actual vertex
normal vector. This vector is the average of the normal vectors of all 
the faces that contain this vertex.<P>

<P> This information is necessary to calculate the Gouraud shading of
the faces, but actually a crude estimation of the actual vertex normal
is sufficient. That's why, to save space and to reduce the number of
computations needed, it has been chosen to approximate each vertex
normal.</P>

<P>The ordinary values of <TT>lightnormalindex</TT> are comprised
between 0 and 161, and directly map into the index of one of the 162
precalculated normal vectors that can be found in <A
HREF="#APPB">Appendix B</A>.</P>

<P>Value 255 is sometimes used in models, but this is a bug. Only values
0 through 161 should be used.</P>
       

<H4>The simple frames</H4>

<P>The simple frames can come standalone or in groups (see below). They always
have the same structure:
<PRE>
typedef struct
{ trivertx_t min;              // minimum values of X,Y,Z
  trivertx_t max;              // maximum values of X,Y,Z
  char name[16];               // name of frame
  trivertx_t frame[numverts];  // array of vertices
} simpleframe_t;
</PRE>

<P>The size of each simple frame is <TT>sizeframe = 0x18 + numverts *
trivertx_t;</TT>.</P>

<P>The number of vertices is <TT><A href="#MD0">numverts</A></TT>, and
to each of the vertex declared here corresponds a <A HREF="#MD2">Skin
Vertex</A> with the same index.</P>

<P>The frame header contains two vertex definitions, <TT>min</TT> and
<TT>max</TT>, that define a bounding box around the whole frame: all
the other vertices must be inside that bounding box.</P>

<P>However, that bounding box is only used for collision detection, so
if you make it smaller than it should be the model will still display
fine, but you can get very close to it before hitting it.</P>

<P>To get the floating point values corresponding to <TT>min</TT> and
<TT>max</TT>, treat them as if they were ordinary vertex
positions.</P>

<H4>The frames</H4>

<P>These are the actual animation frames, made of a single frame, or a group
of single frames, with timing indication.</P>

<P>The beginning of the frames can be found in the <TT>.MDL</TT> file,
at offset <TT>baseframes = <A href="#MD3">basetri</A> + <A
href="#MD0">numtris</A> * sizeof(itriangle_t);</TT>.</P>

<P>Each frame must be read separately, since they may not have a constant size.
</P>                                                     

<P>If the frame is made of one simple frame:
<PRE>                                      
struct               
{ long type;             // Value = 0
  simpleframe_t frame;         // a single frame definition
}
</PRE></P>

<P>If the frame is made of a group of simple frames:
<PRE> 
struct
{ long type;                   // Value != 0
  trivertx_t min;              // min position in all simple frames
  trivertx_t max;              // max position in all simple frames
  float time[nb]               // time for each of the single frames
  simpleframe_t frames[nb];    // a group of simple frames
}
</PRE>                                                       



<H4>Unknown fields</H4>

<P>The first filed of the header is always zero, and there's no
explanation for it. It cannot be a time stamp, since frame animations
is in fact coded in the <A HREF="#PDAT">Code lump</A>.</P>

<P>The <TT>lightnormalindex</TT> of <TT>min</TT> and <TT>max</TT> have
irrelevant values, and are apparently not used.  They only pad the
structure to 4 bytes.</P>




<HR SIZE=3>
<!--FILE="qkspec_5.htm#content"-->

<H1><FONT COLOR="#007F00">5. <A NAME="CSPR0">The Sprite models</A>
</FONT></H1>

<P><I>(Thanks to Rapha&euml;l Quinet who wrote most of this
section)</I></P>


<H2><FONT COLOR="#4F1F00"><A NAME="CSPRG">General description of
Sprites</A></FONT></H2>

<P>The sprites are used in Quake to represent objects that could not
be rendered properly using polygons (because of a shape with too many
small details) or that were not worth the trouble of using polygons
(they render faster than Alias models or BSP based models).</P>

<P>The sprites are essentially designed for stuff like explosions,
fire, magical effect, or the like.  They can also be used for simple
objects that have a vertical axis of rotation, like torches or
barrels.</P>

<P>The format of the sprites is rather simple.  Basically, this is a
list of 2D pictures (flat bitmaps) organized in lumps.</P>

<P>Some frames are grouped in animation sequences, that start with the
first picture in the animation and automatically proceed to the next,
at the time values indicated in the beginning of the sequence.</P>


<H2><FONT COLOR="#4F1F00">5.2 <A NAME="CSPRF">The Format of <TT>.SPR</TT> files</A></FONT></H2>

<P>The sprite files (<TT>.SPR</TT>) begin with a header, which is
immediately followed by the list of frames.  There are no pointers to
the individual pictures, which means that the engine probably reads
and parses the whole file once and for all, because the only way to
access a given picture is to read all previous frames and know their
width and height.</P>

<H3>5.2.1 Sprite file header</H3>

<P>Here is the format of the <TT>.SPR</TT> file header:
<PRE>
typedef struct
{ char name[4];                // "IDSP"
  long ver1;                   // Version = 1
  long type;                   // See below
  float radius;                // Bounding Radius
  long maxwidth;               // Width of the largest frame
  long maxheight;              // Height of the largest frame
  long nframes;                // Number of frames
  float beamlength;            // 
  long synchtype;              // 0=synchron 1=random
} spr_t;
</PRE></P>

<P>The size of this header is <TT>0x24</TT> bytes.</P>

<P>Type of sprites:
<UL> 
<LI> <b>Type 0</b>: vp parallel upright
<LI> <b>Type 1</b>: facing upright
<LI> <b>Type 2</b>: vp parallel
<LI> <b>Type 3</b>: oriented
<LI> <b>Type 4</b>: vp parallel oriented
</UL>
</P>

<H3>5.2.2 Sprite frames</H3>

<P>There are two types of frames.  Most of them contain a single
picture, but some of them (in <TT>s_torch.spr</TT> and
<TT>shots.spr</TT>) contain multiple pictures associated with floating
point values.</P>

<P>The first kind of frames are marked with a leading (long) zero,
followed by the picture data:
<PRE>
  long group;                 // Always 0 for single-picture frames
  picture pic;                 // Picture data, see below
</PRE></P>

<P>The second kind of frames are marked with a leading <TT>0x1</TT> or
<TT>0x10000000</TT>, followed by the number of pictures, a list of
floating point values, and a list of pictures:
<PRE>
  long group;                  // not zero (0x1 or 0x10000000)
  long npics;                  // Number of pictures
  float times[npics];          // 0.0, 0.2, 0.3, ...
  picture pic[npics];          // Pictures
</PRE></P>

<P>The <TT>times</TT> are offsets that describe when the corresponding
picture shall be displayed, relative to an animation frame that
repeats regularly.  <TT>0.0</TT> means start of the animation frame,
and <TT>1.0</TT> is the end.  So if you have <TT>npics</TT> pictures,
and want a regular sequence of pictures, you will start from
<TT>0.0</TT> and regularly increase the dates by <TT>1/npics</TT>.</P>

<P>By the way... the above is just a wild guess.  But what the heck can
it be, if it's not time stamps?</P>

<H3>5.2.3 Pictures</H3>

<P>The format of each individual picture is given below.  It contains
the X and Y offsets, the width and height of the picture, followed by
the list of pixels.  The reference to the Quake palette is implicit
and the value <TT>0xFF</TT> denotes a transparent pixel.
<PRE>
typedef struct
{ long ofsx;                   // horizontal offset, in 3D space
  long ofsy;                   // vertical offset, in 3D space
  long width;                  // width of the picture
  long height;                 // height of the picture
  char Pixels[width*height];   // array of pixels (flat bitmap)
} picture;
</PRE></P>




<HR SIZE=3>
<!--FILE="qkspec_6.htm#content"-->

<H1><FONT COLOR="#007F00">6. <A NAME="CWAD0">The WAD2
files</A></FONT></H1>

<P>The WAD2 format is only used for the graphic <TT>.WAD</TT>, that
stores general information like the palette and the status bar
items.</P>

<P>It is believed that this format was the original distribution file
intended for Quake, but since then id Software probably realised they
needed a file format that allowed a more direct mapping of their
development directories, so they chose the PACK format instead.</P>


<H2><FONT COLOR="#4F1F00">6.1 <A NAME="CWADF">The format of WAD2
files</A></FONT></H2>

<P>The structure of the WAD2 files is almost exactly the same as that
of DOOM's PWAD and IWAD files.  Only the size of the directory entries
is a bit different.</P>


<H3>6.1.1 The WAD2 file header</H3>

<P><PRE>
typedef struct
{ u_char magic[4];             // "WAD2", Name of the new WAD format
  long numentries;             // Number of entries
  long diroffset;              // Position of WAD directory in file
} wadhead_t;
</PRE></P>

<H3>6.1.2 The WAD directory</H3>

<P>The entries in the WAD2 directory are a bit bigger than in PWAD and
IWAD:
<PRE>
typedef struct
{ long offset;                 // Position of the entry in WAD
  long dsize;                  // Size of the entry in WAD file
  long size;                   // Size of the entry in memory
  char type;                   // type of entry
  char cmprs;                  // Compression. 0 if none.
  short dummy;                 // Not used
  char name[16];               // 1 to 16 characters, '\0'-padded
} wadentry_t;
</PRE></P>

<P>At offset <TT>diroffset</TT> in file, you will find the WAD
directory itself:
<PRE>
wadentry_t dir[numentries];        // like in DOOM
</PRE></P>

<P>This directory then contains pointers to all the entries in the
WAD2 file, and like with PACK file there can be large amounts of
unused data, if one is not careful enough when building WAD2
files.</P>

<H3>6.1.3 Determining the type of directory entries</H3>

<P>The field <TT>type</TT> in the directory identifies the entry.
It's a single byte, which give 256 possibilities.  Only 3 are
currently used.</P>

<PRE><TABLE BORDER><TR><TD><TABLE>
<TR VALIGN=TOP><TD><TT>0x40</TT>=  </TD><TD>'@'=  </TD><TD>Color Palette</TD></TR>
<TR VALIGN=TOP><TD><TT>0x42</TT>=  </TD><TD>'B'=  </TD><TD>Pictures for status bar</TD></TR>
<TR VALIGN=TOP><TD><TT>0x44</TT>=  </TD><TD>'D'=  </TD><TD>Used to be Mip Texture</TD></TR>
<TR VALIGN=TOP><TD><TT>0x45</TT>=  </TD><TD>'E'=  </TD><TD>Console picture (flat)</TD></TR>
</TABLE></TD></TR></TABLE></PRE>


<H2><FONT COLOR="#4F1F00">6.2 <A NAME="CWADS">Format of status bar
pictures</A></FONT></H2>

<P>The pictures will probably used for everything concerning the
status bar (animations, numbers, ...).  They are not used for sprites,
countrary to DOOM.</P>

<P>These files are just like DOOM flats, but with a header to indicate
width and height.
<PRE>
typedef struct
{ long width;                  // Picture width
  long height;                 // Picture height
  u_char Pixels[height][width]
} pichead_t;
</PRE></P>


<H2><FONT COLOR="#4F1F00">6.3 <A NAME="CWADC">Format of console
lumps</A></FONT></H2>

<P>The console lumps are just flat pictures, similar to DOOM flats,
without any formatting, and using one byte per pixel.  The color
palette is that of the PALETTE lump.</P>

<P>The console background:
<PRE>
char  Screen [200][320];       //This means it's a 320x200 array
</PRE>
The console characters:
<PRE>
char  CChars [128][128];       //This means it's a 128x128 array
</PRE></P>

<H2><FONT COLOR="#4F1F00">6.4 <A NAME="CWADP">Format of
Palettes</A></FONT></H2>

<P>All the pictures, textures, sprites and Alias model skins use color
indexes in a 256-color table, and it can be expected that only a
limited set of color palettes will be used.  Maybe just one.  At
least, it's pretty sure that there is only one color palette for all
the textures.</P>

<P>This format is Exactly the same as in DOOM:
<PRE>
struct RGB {char R; char G; char B;} Palette[256];
</PRE>
Internally, the color palette is translated into a much bigger
structure, that takes into account the light level, just like in DOOM.
This structure depends on the number of colors available on the
display, so it might be calculated by the engine at startup.</P>



<HR SIZE=3>
<!--FILE="qkspec_7.htm#content"-->
<H1><FONT COLOR="#007F00">7. <A NAME="CMAP0">The Level Map files</A></FONT></H1>

<H2><FONT COLOR="#4F1F00">7.1 <A NAME="CMAPG">Description of Map Files</A></FONT></H2>

<H3>7.1.1 General description of the Map format</H3>

<P>The Map format describes a single level of Quake, in a very robust and
very simple manner. This format is meant to be used by Quake editors, though
you can edit it by hand (provided you've got special 3D hardware in your brain).</P>

<P>The Map cannot directly be used by Quake: Once complete, it must be transformed into
a <A HREF="#CBSPG">BSP Level Map</A>. This transformation is known to require a lot
of processing power, a lot of memory, and a lot of time. <BR>
Those tools calculate the <A HREF="##CBSPN">BSP tree</A>, the set of 
<A HREF="#CBSPC">visibility lists</A>, the shadows on each textures,
and put the textures into the level BSP file.</P>

<P> This is rather complicated, but the advantage is that there
is no possibility to create invalid level layout, by mistake.</P>

<HR>




<HR SIZE=3>
<!--FILE="qkspec_a.htm#content"-->

<H1><FONT COLOR="#007F00"><A NAME="APPA">Appendix A.</A> Model
Examples</FONT></H1>

<P>These examples of the <A HREF="#ENT1">model types</A> may help to
explain their use a little better.  They were extracted from the three
levels included in QTEST1.</P>

<H2><FONT COLOR="#4F1F00">A.1 Map TEST1</FONT></H2>

<TABLE><TR><TH>Models</TH><TH>Model Bounding box Co-ordinates</TH></TR>
<TR VALIGN=TOP><TD><PRE>
{
  &quot;model&quot; &quot;*1&quot;
  &quot;angle&quot; &quot;-2&quot;
  &quot;classname&quot; &quot;func_door&quot;
  &quot;targetname&quot; &quot;t2&quot;
}
</PRE></TD><TD><PRE>
min: x = 412, y = 1352, z = -144
max: x = 428, y = 1368, z =  -24

</PRE></TD></TR>
<TR VALIGN=TOP><TD><PRE>
{
  &quot;model&quot; &quot;*2&quot;
  &quot;angle&quot; &quot;-2&quot;
  &quot;classname&quot; &quot;func_door&quot;
  &quot;targetname&quot; &quot;t2&quot;
}
</PRE></TD><TD><PRE>
min: x = 448, y = 1352, z = -144
max: x = 464, y = 1368, z =  -24

</PRE></TD></TR>
<TR VALIGN=TOP><TD><PRE>
{
  &quot;model&quot; &quot;*5&quot;
  &quot;classname&quot; &quot;func_button&quot;
  &quot;target&quot; &quot;t2&quot;
}
</PRE></TD><TD><PRE>
min: x = 500, y = 1240, z = -104
max: x = 512, y = 1256, z =  -88

</PRE></TD></TR>
</TABLE>

<P>These are the columns that block the path to the
teleport. <TT>*1</TT> is the left column (looking from outside the
room by the button) and <TT>*2</TT> is the one one the right.
<TT>*5</TT> is the button that lowers the two columns.</P>

<P>Note the targetname <TT>t2</TT> for both columns and the same one
for the button (model <TT>*5</TT>) This is what ties the button to the
lowering of the columns.</P>

<P>The angle specific here describes the direction to move the column.
Changing it to <TT>&quot;0&quot;</TT> moves the column to the right
instead of down (looking at it from by the button).  The angle is in
degrees for objects moving parallel to the normal line of sight but
for movements perpendicular to this ``horizontal plane'',
<TT>&quot;-1&quot;</TT> and <TT>&quot;-2&quot;</TT> are used for up
and down respectively.</P>

<P>Note: When the angle of model <TT>*1</TT> was changed to
<TT>&quot;-1&quot;</TT>, it moved up instead of down...  After jumping
through the teleporter the column could be seen protruding though the
floor upstairs.  This is important in that it showed that the model
was in fact a 3D object that is simply being moved in the manner
defined and not just some textures being manipulated in such a way as
to make them appear to be solid.</P>

<TABLE><TR><TH>Models</TH><TH>Model Bounding box Co-ordinates</TH></TR>
<TR VALIGN=TOP><TD><PRE>
{
  &quot;model&quot; &quot;*3&quot;
  &quot;target&quot; &quot;t1&quot;
  &quot;classname&quot; &quot;trigger_teleport&quot;
}
</PRE></TD><TD><PRE>
min: x = 244, y = 1576, z = -136
max: x = 284, y = 1624, z =  -40

</PRE></TD></TR>
<TR VALIGN=TOP><TD><PRE>
{
  &quot;targetname&quot; &quot;t1&quot;
  &quot;angle&quot; &quot;90&quot;
  &quot;origin&quot; &quot;448 1028 16&quot;                   
  &quot;classname&quot; &quot;info_teleport_destination&quot;
  &quot;light&quot; &quot;250&quot;
}
</PRE></TD><TD>
(Not a model, just a target)
</TD></TR>
</TABLE>


<P>Model <TT>*3</TT> is the teleporter.  The <TT>target</TT> specific
points it to the <TT>info_teleporter_destination</TT> entity with the
same tag (<TT>t1</TT>).</P>


<TABLE><TR><TH>Model</TH><TH>Model Bounding box Co-ordinates</TH></TR>
<TR VALIGN=TOP><TD><PRE>
{
  &quot;model&quot; &quot;*4&quot;
  &quot;classname&quot; &quot;func_door_secret&quot;
  &quot;angle&quot; &quot;180&quot;
}
</PRE></TD><TD><PRE>
min: x = 448, y = 668, z =   8
max: x = 512, y = 684, z =  88

</PRE></TD></TR>
</TABLE>

<P>This is the ``secret'' door that leads out onto the ledge with the
100% health.  Again the angle just tells the function which way to
move it.</P>

<TABLE><TR><TH>Model</TH><TH>Model Bounding box Co-ordinates</TH></TR>
<TR VALIGN=TOP><TD><PRE>
{
  &quot;model&quot; &quot;*6&quot;
  &quot;classname&quot; &quot;func_door&quot;
  &quot;angle&quot; &quot;180&quot;
  &quot;spawnflags&quot; &quot;1&quot;
  &quot;targetname&quot; &quot;t3&quot;
  &quot;speed&quot; &quot;175&quot;
  &quot;wait&quot; &quot;8&quot;
}
</PRE></TD><TD><PRE>
min: x = -304, y = 1360, z = -16
max: x =  -64, y = 1472, z =  -4

</PRE></TD></TR>
<TR VALIGN=TOP><TD><PRE>
{
  &quot;model&quot; &quot;*7&quot;
  &quot;classname&quot; &quot;func_button&quot;
  &quot;target&quot; &quot;t3&quot;
  &quot;angle&quot; &quot;-2&quot;
  &quot;lip&quot; &quot;4&quot;
  &quot;wait&quot; &quot;10&quot;
}
</PRE></TD><TD><PRE>
min: x = -400, y = 1564 z =  -4
max: x = -344, y = 1616 z =   4

</PRE></TD></TR>
</TABLE>

<P>These are the bridge to the 150% armor and the button on the floor
that causes it to extend.  Note the lip arg in model <TT>*7</TT>, this
defines the starting position in some way related to the surface that
the model is being moved into or out of.</P>

<P>It is also notable that the buttons are activated by touch (walking
over this one is as good as bumping model <TT>*5</TT>.  Presumably you
could put a button on the ceiling and have the player jump up into
it.</P>


<H2><FONT COLOR="#4F1F00">A.2 Map TEST2</FONT></H2>

<P>There are a <B>lot</B> of models/models in test2 (lots of moving
stuff) and it is here that we start to see some of the real
possibilities inherent in the engine.</P>

<TABLE><TR><TH>Model</TH><TH>Model Bounding box Co-ordinates</TH></TR>
<TR VALIGN=TOP><TD><PRE>
{
  &quot;model&quot; &quot;*7&quot;
  &quot;speed&quot; &quot;200&quot;
  &quot;classname&quot; &quot;func_door&quot;  
  &quot;angle&quot; &quot;0&quot;
  &quot;targetname&quot; &quot;t3&quot;
  &quot;spawnflags&quot; &quot;4&quot;
  &quot;dmg&quot; &quot;1000&quot;
}
</PRE></TD><TD><PRE>
min: x = 1112, y = -1024, z =   0
max: x = 1240, y =  -832, z = 112

</PRE></TD></TR>
<TR VALIGN=TOP><TD><PRE>
{
  &quot;model&quot; &quot;*9&quot;
  &quot;speed&quot; &quot;200&quot;
  &quot;dmg&quot; &quot;1000&quot;
  &quot;targetname&quot; &quot;t3&quot;
  &quot;angle&quot; &quot;180&quot;
  &quot;spawnflags&quot; &quot;4&quot;
  &quot;classname&quot; &quot;func_door&quot;
}
</PRE></TD><TD><PRE>
min: x = 2120, y = -1024, z =   0
max: x = 2248, y =  -832, z = 112

</PRE></TD></TR>
</TABLE>

<P>These are the walls that make up the two crushing traps on either
side of the starting room that allow you to kill anyone who goes for
the yellow armor in the cages.</P>

<P>Here is the first use of the <TT>dmg</TT> arg that defines how
badly it hurts you if it closes on you.  There are some doors that
will hurt you slightly (3-5%) if they catch you as they are closing.
There might be a default <TT>dmg</TT> value for certain types of doors
but, clearly, setting this at 1000 as it is here, will kill you in one
hit.</P>

<TABLE><TR><TH>Model</TH><TH>Model Bounding box Co-ordinates</TH></TR>
<TR VALIGN=TOP><TD><PRE>
{
  &quot;model&quot; &quot;*11&quot;
  &quot;target&quot; &quot;t4&quot;
  &quot;classname&quot; &quot;func_train&quot;  
}
</PRE></TD><TD><PRE>
min: x = 1792, y = -1064, z = 304
max: x = 1888, y =  -984, z = 320
</PRE></TD></TR>
<TR VALIGN=TOP><TD><PRE>
{
  &quot;target&quot; &quot;t5&quot;
  &quot;targetname&quot; &quot;t4&quot;
  &quot;origin&quot; &quot;1792 -1064 304&quot;
  &quot;classname&quot; &quot;path_corner&quot;
}
</PRE></TD><TD>
(Not a model, just a target)
</TD></TR>
<TR VALIGN=TOP><TD><PRE>
{
  &quot;target&quot; &quot;t4&quot;
  &quot;targetname&quot; &quot;t5&quot;
  &quot;classname&quot; &quot;path_corner&quot;
  &quot;origin&quot; &quot;1472 -1064 304&quot;
}
</PRE></TD><TD>
(Not a model, just a target)
</TD></TR>
</TABLE>

<P>This is that sliding platform that goes back and forth above the
starting room and carries you to the grenade-launcher and back
again.</P>

<P>The model is the ferry itself and I have included it's two
path_corners that define the extents of its route.  The thing to note
here is how the targets are set up pointing to each other's
<TT>targetname</TT> to keep the platform moving to and fro.  I imagine
that if you were to set up a series of these corners, that just kept
pointing to the next one in line, that you could have one of these
things follow a long complex path through the level.</P>

<TABLE><TR><TH>Model</TH><TH>Model Bounding box Co-ordinates</TH></TR>
<TR VALIGN=TOP><TD><PRE>
{
  &quot;model&quot; &quot;*1&quot;
  &quot;classname&quot; &quot;func_door&quot;
  &quot;angle&quot; &quot;180&quot;
  &quot;targetname&quot; &quot;t1&quot;
}
</PRE></TD><TD><PRE>
min: x = 1392, y = -1272, z = -16
max: x = 1696, y =  -840, z =  -4

</PRE></TD></TR>
<TR VALIGN=TOP><TD><PRE>
{
  &quot;model&quot; &quot;*2&quot;
  &quot;classname&quot; &quot;func_door&quot;
  &quot;angle&quot; &quot;0&quot;
}
</PRE></TD><TD><PRE>
min: x = 1696, y = -1272, z = -16
max: x = 2000, y =  -840, z = -4

</PRE></TD></TR>
<TR VALIGN=TOP><TD><PRE>
{
  &quot;model&quot; &quot;*3&quot;
  &quot;classname&quot; &quot;func_button&quot;
  &quot;angle&quot; &quot;90&quot;
  &quot;target&quot; &quot;t1&quot;
}
</PRE></TD><TD><PRE>
min: x = 1288, y = -832, z = 16
max: x = 1336, y = -816, z = 56

</PRE></TD></TR>
<TR VALIGN=TOP><TD><PRE>
{
  &quot;model&quot; &quot;*4&quot;
  &quot;spawnflags&quot; &quot;4&quot;
  &quot;targetname&quot; &quot;t1&quot;
  &quot;classname&quot; &quot;func_door&quot;
  &quot;angle&quot; &quot;270&quot;
  &quot;wait&quot; &quot;4&quot;
}
</PRE></TD><TD><PRE>
min: x = 1632, y = -1408, z = -16
max: x = 1760, y = -1288, z =  -4

</PRE></TD></TR>
<TR VALIGN=TOP><TD><PRE>
{
  &quot;model&quot; &quot;*5&quot;
  &quot;classname&quot; &quot;func_door&quot;
  &quot;spawnflags&quot; &quot;4&quot;
  &quot;angle&quot; &quot;90&quot;
  &quot;targetname&quot; &quot;t1&quot;
  &quot;lip&quot; &quot;0&quot;
  &quot;wait&quot; &quot;4&quot;
}
</PRE></TD><TD><PRE>
min: x = 1632, y = -824, z = -16
max: x = 1760, y = -688, z =  -4

</PRE></TD></TR>
<TR VALIGN=TOP><TD><PRE>
{
  &quot;model&quot; &quot;*8&quot;
  &quot;target&quot; &quot;t1&quot;
  &quot;angle&quot; &quot;90&quot;
  &quot;classname&quot; &quot;func_button&quot;
}
</PRE></TD><TD><PRE>
min: x = 2024, y = -832, z = 16
max: x = 2072, y = -816, z = 56

</PRE></TD></TR>
</TABLE>

<P>Models <TT>*1</TT> and <TT>*3</TT> somehow define the targetname
for model <TT>*2</TT>.</P>

<P>These are all the definitions that handle the two buttons in the
yellow armor cages and the four floor surfaces that they cause to
open.  Notice that there are only five target/targetname specifics
(<TT>t1</TT>) in the group.</P>

<P>Every once in a while, when calling two models into action, one of
the targetnames will be missing.  It turns out that you can wrap at
least one targetname-less model in between two models that are
targeted at one another.  Quake, apparently, will assume that you mean
to apply the action to the middle one as well.</P>

<TABLE><TR><TH>Model</TH><TH>Model Bounding box Co-ordinates</TH></TR>
<TR VALIGN=TOP><TD><PRE>
{
  &quot;model&quot; &quot;*25&quot;
  &quot;targetname&quot; &quot;t15&quot;
  &quot;angle&quot; &quot;180&quot;
  &quot;classname&quot; &quot;func_door&quot;
}
</PRE></TD><TD><PRE>
min: x = 2336, y = -568, z = 32
max: x = 2400, y = -552, z = 96

</PRE></TD></TR>
<TR VALIGN=TOP><TD><PRE>
{
  &quot;model&quot; &quot;*26&quot;
  &quot;classname&quot; &quot;func_door&quot;
}
</PRE></TD><TD><PRE>
min: x = 2400, y = -568, z = 32
max: x = 2464, y = -552, z = 96

</PRE></TD></TR>
<TR VALIGN=TOP><TD><PRE>
{
  &quot;model&quot; &quot;*27&quot;
  &quot;target&quot; &quot;t15&quot;
  &quot;classname&quot; &quot;trigger_multiple&quot;
}
</PRE></TD><TD><PRE>
min: x = 2336, y = -616, z = 56
max: x = 2464, y = -560, z = 64

</PRE></TD></TR>
</TABLE>


<P>Here is another example of the dropped targetname whilst wrapping,
using the <TT>trigger_multiple</TT> classname.  This is the small
double doors that let you out of the secret room with the red armor.
Model <TT>*27</TT> is walk-over activated (as are all triggers) and
opens the doors when you approach them.</P>

<TABLE><TR><TH>Model</TH><TH>Model Bounding box Co-ordinates</TH></TR>
<TR VALIGN=TOP><TD><PRE>
{
  &quot;model&quot; &quot;*31&quot;
  &quot;classname&quot; &quot;func_plat&quot;  
}
</PRE></TD><TD><PRE>
min: x = 1248, y = -704, z = 160
max: x = 1392, y = -576, z = 320
</PRE></TD></TR>
</TABLE>

<P><TT>func_plats</TT> are the elevator/lifts that automatically rise
as you step on them.  If they have the <TT>angle</TT> arg included it
would seem to be an indicator of the direction from which it is
activated.</P>



<H2><FONT COLOR="#4F1F00">A.3 Map TEST3</FONT></H2>

<TABLE><TR><TH>Model</TH><TH>Model Bounding box Co-ordinates</TH></TR>
<TR VALIGN=TOP><TD><PRE>
{
  &quot;model&quot; &quot;*5&quot;
  &quot;classname&quot; &quot;func_dm_only&quot;  
}
</PRE></TD><TD><PRE>
min: x = 1184, y = -960, z = -48
max: x = 1200, y = -848, z =  48

</PRE></TD></TR>
<TR VALIGN=TOP><TD><PRE>
{
  &quot;model&quot; &quot;*6&quot;
  &quot;classname&quot; &quot;func_dm_only&quot;
}
</PRE></TD><TD><PRE>
min: x = -576, y = -496, z = -40
max: x = -560, y = -400, z =  64
</PRE></TD></TR>
</TABLE>

<P>Map three is the only one that has these ... these models are
obviously the two teleporters that are only available during
deathmatch.</P>


<HR SIZE=3>
<!--FILE="qkspec_b.htm#content"-->

<H1><FONT COLOR="#007F00"><A NAME="APPB">Appendix B.</A> Table of
normal vectors</FONT></H1>

<P>This table is used in the <A HREF="#CMDL0">Entity models</A> to code
the <A HREF="#MD4">normal vector</A> of each vertex, in each frame
(the <TT>lightnormalindex</TT> value).</P>

<P>Since it doesn't seem to be derived from a regular polygon, there is
no known formula to calculate it, so we can only list here all the values.</P>

<P>Take care to normalise all those vectors to <TT>1</TT>, before using them.</P>

<P>To select the right vector from the list, just take the one whose
dot product with the actual normal vector of the vertex gives the
greater positive result. It's not too important that it differs a
bit from the actual normal vector of the vertex, Gouraud shading
tollerates a fair bit of imprecision.</P>


<P>Note: <I>since this table is defined in the QBSP source,
you had better get it from there (in file anorms.h). 
The table below was hacked out before QBSP was released.</I></P>



<PRE>
vector_t normals[162]=
{{-0.5257,0.0000,0.8507},{-0.4429,0.2389,0.8642},{-0.2952,0.0000,0.9554},
 {-0.3090,0.5000,0.8090},{-0.1625,0.2629,0.9511},{0.0000,0.0000,1.0000},
 {0.0000,0.8507,0.5257},{-0.1476,0.7166,0.6817},{0.1476,0.7166,0.6817},
 {0.0000,0.5257,0.8507},{0.3090,0.5000,0.8090},{0.5257,0.0000,0.8507},
 {0.2952,0.0000,0.9554},{0.4429,0.2389,0.8642},{0.1625,0.2629,0.9511},
 {-0.6817,0.1476,0.7166},{-0.8090,0.3090,0.5000},{-0.5878,0.4253,0.6882},
 {-0.8507,0.5257,0.0000},{-0.8642,0.4429,0.2389},{-0.7166,0.6817,0.1476},
 {-0.6882,0.5878,0.4253},{-0.5000,0.8090,0.3090},{-0.2389,0.8642,0.4429},
 {-0.4253,0.6882,0.5878},{-0.7166,0.6817,-0.1476},{-0.5000,0.8090,-0.3090},
 {-0.5257,0.8507,0.0000},{0.0000,0.8507,-0.5257},{-0.2389,0.8642,-0.4429},
 {0.0000,0.9554,-0.2952},{-0.2629,0.9511,-0.1625},{0.0000,1.0000,0.0000},
 {0.0000,0.9554,0.2952},{-0.2629,0.9511,0.1625},{0.2389,0.8642,0.4429},
 {0.2629,0.9511,0.1625},{0.5000,0.8090,0.3090},{0.2389,0.8642,-0.4429},
 {0.2629,0.9511,-0.1625},{0.5000,0.8090,-0.3090},{0.8507,0.5257,0.0000},
 {0.7166,0.6817,0.1476},{0.7166,0.6817,-0.1476},{0.5257,0.8507,0.0000},
 {0.4253,0.6882,0.5878},{0.8642,0.4429,0.2389},{0.6882,0.5878,0.4253},
 {0.8090,0.3090,0.5000},{0.6817,0.1476,0.7166},{0.5878,0.4253,0.6882},
 {0.9554,0.2952,0.0000},{1.0000,0.0000,0.0000},{0.9511,0.1625,0.2629},
 {0.8507,-0.5257,0.0000},{0.9554,-0.2952,0.0000},{0.8642,-0.4429,0.2389},
 {0.9511,-0.1625,0.2629},{0.8090,-0.3090,0.5000},{0.6817,-0.1476,0.7166},
 {0.8507,0.0000,0.5257},{0.8642,0.4429,-0.2389},{0.8090,0.3090,-0.5000},
 {0.9511,0.1625,-0.2629},{0.5257,0.0000,-0.8507},{0.6817,0.1476,-0.7166},
 {0.6817,-0.1476,-0.7166},{0.8507,0.0000,-0.5257},{0.8090,-0.3090,-0.5000},
 {0.8642,-0.4429,-0.2389},{0.9511,-0.1625,-0.2629},{0.1476,0.7166,-0.6817},
 {0.3090,0.5000,-0.8090},{0.4253,0.6882,-0.5878},{0.4429,0.2389,-0.8642},
 {0.5878,0.4253,-0.6882},{0.6882,0.5878,-0.4253},{-0.1476,0.7166,-0.6817},
 {-0.3090,0.5000,-0.8090},{0.0000,0.5257,-0.8507},{-0.5257,0.0000,-0.8507},
 {-0.4429,0.2389,-0.8642},{-0.2952,0.0000,-0.9554},{-0.1625,0.2629,-0.9511},
 {0.0000,0.0000,-1.0000},{0.2952,0.0000,-0.9554},{0.1625,0.2629,-0.9511},
 {-0.4429,-0.2389,-0.8642},{-0.3090,-0.5000,-0.8090},{-0.1625,-0.2629,-0.9511},
 {0.0000,-0.8507,-0.5257},{-0.1476,-0.7166,-0.6817},{0.1476,-0.7166,-0.6817},
 {0.0000,-0.5257,-0.8507},{0.3090,-0.5000,-0.8090},{0.4429,-0.2389,-0.8642},
 {0.1625,-0.2629,-0.9511},{0.2389,-0.8642,-0.4429},{0.5000,-0.8090,-0.3090},
 {0.4253,-0.6882,-0.5878},{0.7166,-0.6817,-0.1476},{0.6882,-0.5878,-0.4253},
 {0.5878,-0.4253,-0.6882},{0.0000,-0.9554,-0.2952},{0.0000,-1.0000,0.0000},
 {0.2629,-0.9511,-0.1625},{0.0000,-0.8507,0.5257},{0.0000,-0.9554,0.2952},
 {0.2389,-0.8642,0.4429},{0.2629,-0.9511,0.1625},{0.5000,-0.8090,0.3090},
 {0.7166,-0.6817,0.1476},{0.5257,-0.8507,0.0000},{-0.2389,-0.8642,-0.4429},
 {-0.5000,-0.8090,-0.3090},{-0.2629,-0.9511,-0.1625},{-0.8507,-0.5257,0.0000},
 {-0.7166,-0.6817,-0.1476},{-0.7166,-0.6817,0.1476},{-0.5257,-0.8507,0.0000},
 {-0.5000,-0.8090,0.3090},{-0.2389,-0.8642,0.4429},{-0.2629,-0.9511,0.1625},
 {-0.8642,-0.4429,0.2389},{-0.8090,-0.3090,0.5000},{-0.6882,-0.5878,0.4253},
 {-0.6817,-0.1476,0.7166},{-0.4429,-0.2389,0.8642},{-0.5878,-0.4253,0.6882},
 {-0.3090,-0.5000,0.8090},{-0.1476,-0.7166,0.6817},{-0.4253,-0.6882,0.5878},
 {-0.1625,-0.2629,0.9511},{0.4429,-0.2389,0.8642},{0.1625,-0.2629,0.9511},
 {0.3090,-0.5000,0.8090},{0.1476,-0.7166,0.6817},{0.0000,-0.5257,0.8507},
 {0.4253,-0.6882,0.5878},{0.5878,-0.4253,0.6882},{0.6882,-0.5878,0.4253},
 {-0.9554,0.2952,0.0000},{-0.9511,0.1625,0.2629},{-1.0000,0.0000,0.0000},
 {-0.8507,0.0000,0.5257},{-0.9554,-0.2952,0.0000},{-0.9511,-0.1625,0.2629},
 {-0.8642,0.4429,-0.2389},{-0.9511,0.1625,-0.2629},{-0.8090,0.3090,-0.5000},
 {-0.8642,-0.4429,-0.2389},{-0.9511,-0.1625,-0.2629},{-0.8090,-0.3090,-0.5000},
 {-0.6817,0.1476,-0.7166},{-0.6817,-0.1476,-0.7166},{-0.8507,0.0000,-0.5257},
 {-0.6882,0.5878,-0.4253},{-0.5878,0.4253,-0.6882},{-0.4253,0.6882,-0.5878},
 {-0.4253,-0.6882,-0.5878},{-0.5878,-0.4253,-0.6882},{-0.6882,-0.5878,-0.4253}
};
</PRE>
<!--FILE=""-->
<!--"""#--></BODY></HTML>
