<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from openal.texi on 1 December 2000 -->

<TITLE>Untitled Document</TITLE>
</HEAD>
<BODY>
<H1>Untitled Document</H1>
<P>
<P><HR><P>


<H1><A NAME="SEC1" HREF="openal_toc.html#TOC1">Introduction</A></H1>

<P>
The idea behind OpenAL is a 3d positional spatialized sound library analogous
to OpenGL: instead of micromanaging each aspect of sound playback and effect,
the application writer may limit themselves to placing the sounds in the 
scene and letting the native OpenAL implementation determine the correct
amount of pitch alteration, gain attenuation, phase shift, etc, required to
render the sounds correctly.


<P>
That's the goal, anyway.  


<P>
Here are some of the most Frequently Asked Questions, and their answers.



<UL>
</UL>

<P>
Configure openal with <SAMP>`configure --enable-esd'</SAMP>.  make, then install.
Then, place the following in your <SAMP>`~/.openalrc'</SAMP> file:



<PRE>

	(define devices '(esd))

</PRE>

<P>
Dollars-to-donuts your driver doesn't implemented the select call
properly.  You can see messages from <CODE>native_blitbuffer</CODE> complaining
about select timeouts when this is a problem.


<P>
If you suffer from an unimplemented select call in your driver, put the
following in your <SAMP>`~/.openalrc'</SAMP> file:



<PRE>

	(define native-use-select #f)

</PRE>

<P>
This will tell <CODE>OpenAL</CODE> that it shouldn't rely on select for
information about when to write to a file descriptor.


<P>
Use <CODE>alAttenuationScale_LOKI</CODE>.  For more info, please see
See section <A HREF="openal.html#SEC12">How to extend Loki's OpenAL</A>.




<H1><A NAME="SEC2" HREF="openal_toc.html#TOC2">Goals</A></H1>


<UL>
<LI>3d audio

<LI>World Domination

<LI>Fame

<LI>Fortune

</UL>



<H1><A NAME="SEC3" HREF="openal_toc.html#TOC3">The OpenAL API</A></H1>
<P>
<A NAME="IDX1"></A>


<P>
This is the OpenAL API.  Sort of.



<UL>
OpenAL Sections:

<LI><A HREF="openal.html#SEC4">types</A>: Integral types
<LI><A HREF="openal.html#SEC5">al</A>: High level stuff
<LI><A HREF="openal.html#SEC6">alc</A>: Context management
<LI><A HREF="openal.html#SEC7">alut</A>: Utility functions, etc
<LI><A HREF="openal.html#SEC8">alkludge</A>: Kludgey, Deprecated stuff
</UL>

<P>
al calls, either implicitly or explicitly, act upon opaque objects
of the kind <CODE>Buffers</CODE>, <CODE>Sources</CODE>, <CODE>Contexts</CODE>, or
<CODE>Listeners</CODE>.  Of these types, the generation and deletion of
<CODE>Buffers</CODE>, <CODE>Sources</CODE>, and <CODE>Contexts</CODE> are explicit
and must be handled by the application.


<P>
To give a brief overview:


<DL COMPACT>

<DT><CODE>Buffers</CODE>
<DD>
<A NAME="IDX2"></A>

<CODE>Buffers</CODE> contain PCM audio data, and the parameters associated with
the data (length, frequency, sample width etc).  <CODE>Buffers</CODE> cannot
be played, a <CODE>Source</CODE> must be associated with them, and the <CODE>Source</CODE>
is then played.

<CODE>Buffers</CODE> are created with a call to <CODE>alGenBuffers</CODE>, which creates
a set of buffer ids and binds them to buffers.  The buffer id is the only
mechanism by which an application may refer to a buffer.  After its 
useful lifetime is over, buffer ids should be deleted via the call
<CODE>alDeleteBuffers</CODE>.

<DT><CODE>Sources</CODE>
<DD>
<A NAME="IDX3"></A>

<CODE>Sources</CODE> are independent objects, which, when played, make sound.
<CODE>Sources</CODE> need to be associated with a <CODE>Buffer</CODE> before they
can be played.

<CODE>Sources</CODE> are created with a call to <CODE>alGenSources</CODE>, which creates
a set of source ids and binds them to sources.  The source id is the only
mechanism by which an application may refer to a source.  After its 
useful lifetime is over, source ids should be deleted via the call
<CODE>alDeleteSources</CODE>.

<DT><CODE>Contexts</CODE>
<DD>
<A NAME="IDX4"></A>

A <CODE>Context</CODE> abstracts the audio device from the rest of the library
(and the application).  You generally only need one.  Calling most al
functions before creating a context via <CODE>alcCreateContext</CODE> will result
in either an error or a segfault.

When you're about to quit, call <CODE>alcDestroyContext</CODE> to destroy the
context and don't make any other al calls.

</DL>



<H2><A NAME="SEC4" HREF="openal_toc.html#TOC4">OpenAL types</A></H2>

<DL COMPACT>

<DT><CODE>ALboolean</CODE>
<DD>
OpenAL bool type.

<DT><CODE>ALbyte</CODE>
<DD>
OpenAL 8bit signed byte.

<DT><CODE>ALubyte</CODE>
<DD>
OpenAL 8bit unsigned byte.

<DT><CODE>ALshort</CODE>
<DD>
OpenAL 16bit signed short integer type.

<DT><CODE>ALushort</CODE>
<DD>
OpenAL 16bit unsigned short integer type.

<DT><CODE>ALuint</CODE>
<DD>
OpenAL 32bit unsigned integer type.

<DT><CODE>ALint</CODE>
<DD>
OpenAL 32bit signed integer type.

<DT><CODE>ALfloat</CODE>
<DD>
OpenAL 32bit floating point type.

<DT><CODE>ALdouble</CODE>
<DD>
OpenAL 64bit double point type.

<DT><CODE>ALsizei</CODE>
<DD>
OpenAL 32bit type.

</DL>



<H2><A NAME="SEC5" HREF="openal_toc.html#TOC5">OpenAL main functions</A></H2>

<P>
Here are the al functions, grouped according to object they
affect.


<DL COMPACT>

<DT><CODE>Listener functions</CODE>
<DD>
Listener is the sample position for a given context.  The multi-channel
(usually stereo) output stream generated by the mixer is parametrized
by this Listener object: its position and velocity relative to Sources,
within occluder and reflector geometry.

<DL COMPACT>

<DT><CODE>void alListenerf( ALenum pname, ALfloat param )</CODE>
<DD>
Listener Gain:  default 1.0f.

<DT><CODE>void alListener3f( ALenum pname, ALfloat param1, ALfloat param2, ALfloat param3 )</CODE>
<DD>
Listener Position.
Listener Velocity.

<DT><CODE>void alListenerfv( ALenum pname, ALfloat *param )</CODE>
<DD>
Listener Position:        ALfloat[3]
Listener Velocity:        ALfloat[3]
Listener Orientation:     ALfloat[6]  (forward and up vector).

<DT><CODE>void alGetListeneri( ALenum pname,  ALint *value )</CODE>
<DD>
Retrieve listener integer parameter.

<DT><CODE>void alGetListenerf( ALenum pname,  ALfloat *values )</CODE>
<DD>
Retrieve listener float parameter.

<DT><CODE>void alGetListenerfv( ALenum pname, ALfloat *values )</CODE>
<DD>
Retrieve listener float vector parameter.

</DL>

<DT><CODE>Source functions</CODE>
<DD>
<A NAME="IDX5"></A>

Source objects are by default localized. Sources
take the PCM data provided in the specified Buffer,
apply Source-specific modifications, and then
submit them to be mixed according to spatial 
arrangement etc.

<DL COMPACT>

<DT><CODE>void alGenSources( ALsizei n, ALuint* sources )</CODE>
<DD>
<A NAME="IDX6"></A>

Create Source objects.

<DT><CODE>void alDeleteSources( ALsizei n, ALuint* sources )</CODE>
<DD>
<A NAME="IDX7"></A>
Delete Source objects.

<DT><CODE>ALboolean alIsSource( ALuint sid )</CODE>
<DD>
<A NAME="IDX8"></A>
Verify a handle is a valid Source.

<DT><CODE>void alSourcei( ALuint sid, ALenum param, ALint value )</CODE>
<DD>
<A NAME="IDX9"></A>
Set an integer parameter for a Source object.

<DT><CODE>void alSourcef( ALuint sid, ALenum param, ALfloat value )</CODE>
<DD>
<A NAME="IDX10"></A>
Set an integer parameter for a Source object.

<DT><CODE>void alSource3f( ALuint sid, ALenum param, ALfloat v1, ALfloat v2, ALfloat v3)</CODE>
<DD>
<A NAME="IDX11"></A>
				
Set an 3 float parameter for a Source object.

<DT><CODE>void alSourcefv( ALuint sid, ALenum param, ALfloat* values )</CODE>
<DD>
<A NAME="IDX12"></A>
Set a float vector parameter for a Source object.

<DT><CODE>void alGetSourcei( ALuint sid,  ALenum pname, ALint* value )</CODE>
<DD>
<A NAME="IDX13"></A>
Get an integer parameter for a Source object.

<DT><CODE>void alGetSourcef( ALuint sid,  ALenum pname, ALfloat* value )</CODE>
<DD>
<A NAME="IDX14"></A>
Get a float parameter for a Source object.

<DT><CODE>void alGetSourcefv( ALuint sid, ALenum pname, ALfloat* values )</CODE>
<DD>
<A NAME="IDX15"></A>
Get a float vector parameter for a Source object.

<DT><CODE>void alSourcePlayv( ALuint ns, ALuint *ids )</CODE>
<DD>
<A NAME="IDX16"></A>
Play a set of ns sources.

<DT><CODE>void alSourceStopv( ALuint ns, ALuint *ids )</CODE>
<DD>
<A NAME="IDX17"></A>
Stop a set of ns sources.

<DT><CODE>void alSourcePlay( ALuint sid )</CODE>
<DD>
<A NAME="IDX18"></A>
Activate a source, start replay.

<DT><CODE>void alSourcePause( ALuint sid )</CODE>
<DD>
<A NAME="IDX19"></A>
Pause a source.

<DT><CODE>void alSourceStop( ALuint sid )</CODE>
<DD>
<A NAME="IDX20"></A>
Stop a source, and reset its internal state to pre-Play.  To remove a
Source completely, it has to be deleted following Stop, or before Play.

</DL>

<DT><CODE>Buffers</CODE>
<DD>
Buffer objects are storage space for sample data.  Buffers are referred
to by Sources. There can be more than one Source using the same Buffer
data. If Buffers have to be duplicated on a per-Source basis, the driver
has to take care of allocation, copying, and deallocation as well as
propagating buffer data changes.

<DL COMPACT>

<DT><CODE>void alGenBuffers( ALsizei n, ALuint *samples )</CODE>
<DD>
<A NAME="IDX21"></A>
Buffer object generation.

<DT><CODE>void alDeleteBuffers( ALsizei n, ALuint *samples )</CODE>
<DD>
<A NAME="IDX22"></A>
Buffer object destruction.

<DT><CODE>ALboolean alIsBuffer( ALuint buffer )</CODE>
<DD>
<A NAME="IDX23"></A>
Buffer object query.

<DT><CODE>void alBufferData( ALuint buffer, ALenum format, ALvoid *data, ALsizei size, ALsizei freq )</CODE>
<DD>
<A NAME="IDX24"></A>
Specify the data to be filled into a buffer.

<DT><CODE>ALsizei alBufferAppendData( ALuint buffer, ALenum format, ALvoid *data, ALsizei size, ALsizei freq )</CODE>
<DD>
<A NAME="IDX25"></A>
                            
Specify data to be filled into a looping buffer.  This takes the current
position at the time of the call, and returns the number of samples
written.

<DT><CODE>void alGetBufferi( ALuint buffer, ALenum param, ALint *value )</CODE>
<DD>
<A NAME="IDX26"></A>
Query Buffer integer attribute.

<DT><CODE>void alGetBufferf( ALuint buffer, ALenum param, ALfloat* value )</CODE>
<DD>
<A NAME="IDX27"></A>
Query Buffer float attribute.

</DL>

<DT><CODE>Extension Support</CODE>
<DD>
Extension support.

<DL COMPACT>

<DT><CODE>ALboolean alIsExtensionPresent( const ALubyte* fname )</CODE>
<DD>
<A NAME="IDX28"></A>

Obtain the address of a function (usually an extension)
with the name fname. All addresses are context-independent. 

<DT><CODE>void *alGetProcAddress( const ALubyte* fname )</CODE>
<DD>
<A NAME="IDX29"></A>

Obtain the address of a function (usually an extension) with the name
fname. All addresses are context-independent.

<DT><CODE>ALenum alGetEnumValue( const ALubyte* ename )</CODE>
<DD>
<A NAME="IDX30"></A>

Obtain the integer value of an enumeration (usually an extension) with
the name ename.

</DL>

<DT><CODE>Misc</CODE>
<DD>
Misc functions that don't act directly upon an object and don't fit
well anywhere else.

OpenAL Maintenance Functions
State Management and Query.

<DL COMPACT>

<DT><CODE>void alEnable( ALenum capability )</CODE>
<DD>
<A NAME="IDX31"></A>

Renderer State management.

<DT><CODE>void alDisable( ALenum capability )</CODE>
<DD>
<A NAME="IDX32"></A>

Renderer State management.

<DT><CODE>ALboolean alIsEnabled( ALenum capability )</CODE>
<DD>
<A NAME="IDX33"></A>

Is capability enabled?

<DT><CODE>void alHint( ALenum target, ALenum mode )</CODE>
<DD>
<A NAME="IDX34"></A>
Application preferences for driver performance choices.

<DT><CODE>ALboolean alGetBoolean( ALenum param )</CODE>
<DD>
<A NAME="IDX35"></A>
State retrieval.

<DT><CODE>ALint alGetInteger( ALenum param )</CODE>
<DD>
<A NAME="IDX36"></A>
State retrieval.

<DT><CODE>ALfloat alGetFloat( ALenum param )</CODE>
<DD>
<A NAME="IDX37"></A>
State retrieval.

<DT><CODE>ALdouble alGetDouble( ALenum param )</CODE>
<DD>
<A NAME="IDX38"></A>
State retrieval.

<DT><CODE>void alGetBooleanv( ALenum param, ALboolean* data )</CODE>
<DD>
<A NAME="IDX39"></A>
State retrieval.

<DT><CODE>void alGetIntegerv( ALenum param, ALint* data )</CODE>
<DD>
<A NAME="IDX40"></A>
State retrieval.

<DT><CODE>void alGetFloatv( ALenum param, ALfloat* data )</CODE>
<DD>
<A NAME="IDX41"></A>
State retrieval.

<DT><CODE>void alGetDoublev( ALenum param, ALdouble* data )</CODE>
<DD>
<A NAME="IDX42"></A>

State retrieval.

<DT><CODE>const ALubyte *alGetString( ALenum param )</CODE>
<DD>
<A NAME="IDX43"></A>
Get string representation of param.

</DL>

</DL>



<H2><A NAME="SEC6" HREF="openal_toc.html#TOC6">OpenAL context management functions</A></H2>

<P>
You can't do anything really good in OpenAL without creating
at least one context.


<DL COMPACT>

<DT><CODE>void *alcCreateContext( ALint* attrlist )</CODE>
<DD>
<A NAME="IDX44"></A>

Create a context, returning a unique identifier for the context,
or NULL on error.  If this is the first context created, it
becomes the default context.

<CODE>attrlist</CODE> is usually <CODE>NULL</CODE>, but you can pass it an integer array
terminated by <CODE>ALC_INVALID</CODE> in alc enum / integer pairs:


<PRE>
	int attrlist[] = { ALC_SYNC, AL_TRUE,
			   ALC_SOURCES, 100,
			   ALC_FREQUENCY, 44100,
			   ALC_INVALID };

	void *context = alcCreateContext(attrlist);
</PRE>

<DT><CODE>ALCenum alcMakeContextCurrent( ALvoid *alcHandle )</CODE>
<DD>
<A NAME="IDX45"></A>

There is no current context, as we can mix several active contexts. But
al* calls only affect the current context.

<DT><CODE>void *alcUpdateContext( ALvoid *alcHandle )</CODE>
<DD>
For synchronous operation (where the context specified by alcHandle 
was created using the <CODE>ALC_SYNC</CODE> context creation flag), this
commits all the changes needed and writes the result to the audio
backend.  In asynchronous operation, this is a NOP.

<DT><CODE>ALCenum alcDestroyContext( ALvoid *alcHandle )</CODE>
<DD>
<A NAME="IDX46"></A>

Destroy the context associated with <CODE>alcHandle</CODE>, freeing all
associated memory.

<DT><CODE>ALCenum alcGetError( ALvoid );</CODE>
<DD>
<A NAME="IDX47"></A>

Get the last <CODE>alc</CODE> error set.

<DT><CODE>const ALubyte *alcGetErrorString(ALenum param);</CODE>
<DD>
<A NAME="IDX48"></A>
Get the string representation of the last <CODE>alc</CODE> error set.

</DL>



<H2><A NAME="SEC7" HREF="openal_toc.html#TOC7">OpenAL utility functions</A></H2>

<P>
Description of OpenAL utility functions goes here.




<H2><A NAME="SEC8" HREF="openal_toc.html#TOC8">OpenAL kludgey functions</A></H2>

<P>
<CODE>alkludge.h</CODE> is a repository for stuff that need to either be
discarded, rewritten, or thought out.  You should not rely on 
functions in <CODE>alkludge.h</CODE>, although it is unlikely that functions
will be removed from it without some form of equivalent functionality
being introduced in the regular library.


<P>
<A NAME="IDX49"></A>
<A NAME="IDX50"></A>
<A NAME="IDX51"></A>
<A NAME="IDX52"></A>
<A NAME="IDX53"></A>
<A NAME="IDX54"></A>
<A NAME="IDX55"></A>
<A NAME="IDX56"></A>
<A NAME="IDX57"></A>
<A NAME="IDX58"></A>
<A NAME="IDX59"></A>


<P>
There are two types of errors in OpenAL: <CODE>alc</CODE> errors and <CODE>al</CODE> 
errors.  <CODE>al</CODE> errors are context specific and one deep.  Only the
first occurring error will be recorded, subsequent errors will not be
recorded.  Errors may be retrieved via the <CODE>alGetError</CODE> call, after
which the error in the current context will be set to
<CODE>AL_NO_ERROR</CODE>, and subsequent errors will again alter the context's 
error state.


<P>
<CODE>alc</CODE> errors are not context specific, and may be retrieved via the 
<CODE>alcGetError</CODE> call.  After a call to <CODE>alcGetError</CODE>, the
context-global error variable is set to <CODE>ALC_NO_ERROR</CODE>.




<H1><A NAME="SEC9" HREF="openal_toc.html#TOC9">Loki's high-quality implementation of the OpenAL API</A></H1>

<P>
While we may be a bit biased, we are partial to the Loki OpenAL
implementation.  Loki's implementation is currently an all-software
library with support for multiple filters, configuration, and extension
support via plugins.



<UL>

<LI><A HREF="openal.html#SEC10">Filters</A>: What effects are available?
<LI><A HREF="openal.html#SEC11">Configuration</A>: How can I configure the library?
<LI><A HREF="openal.html#SEC12">Extensions</A>: How can I use extensions?

</UL>

<P>
<A NAME="IDX60"></A>


<P>
If you retrieve the library via cvs, be sure to run the autogen.sh
script provided.  It will build configure and config.h.in.


<P>
After that, run configure with the options you want.  Run 
configure --help for available options.




<H1><A NAME="SEC10" HREF="openal_toc.html#TOC10">Loki Openal Filters</A></H1>



<H1><A NAME="SEC11" HREF="openal_toc.html#TOC11">The openal configuration file</A></H1>
<P>
<A NAME="IDX61"></A>
<A NAME="IDX62"></A>
<A NAME="IDX63"></A>


<P>
Users can give openal hints as to optimal defaults for various
parameters via the openal configuration file.  The openal configuration
file should be placed in either <CODE>/etc</CODE> or in one's home
directory, being named <CODE>openalrc</CODE> in the first location or
<CODE>.openalrc</CODE> in the second location.


<P>
The configuration language is meant to be lisp-like.  This does not mean
that it supports lisp constructs, only that it looks something like
lisp.  This hideous language is referred to within the openal sources as
<CODE>ALRC</CODE> (for openAL Resource Configuration language).



<UL>
</UL>

<P>
<A NAME="IDX64"></A>
<CODE>ALRC</CODE> supports a very small number of primitives required to give
the user a very small amount of control over OpenAL.  Generally, the
user can specific default values for things like listener position,
source parameters, etc.


<P>
Primitives are responsible for evaluation their own arguments, unlike
expressions or functions.  Therefore, an argument passed to a primitive
may never be evaluated.


<P>
The primitives are:


<DL COMPACT>

<DT><CODE>and</CODE>
<DD>
<A NAME="IDX65"></A>


<PRE>
(and predicate-1 predicate-2 ... )
</PRE>

Performs a logical <CODE>and</CODE> on parameters, using short circuit
evaluation.  Evaluates to true if none of the parameters 
evaluate to false.

<DT><CODE>or</CODE>
<DD>
<A NAME="IDX66"></A>


<PRE>
(or predicate-1 predicate-2 ... )
</PRE>

Performs a logical <CODE>or</CODE> on parameters, stopping at the first true
evaluation.  Evaluates to true if any of the parameters evaluate to
true.

<DT><CODE>define</CODE>
<DD>
<A NAME="IDX67"></A>


<PRE>
(define identifier value)
</PRE>

<CODE>define</CODE> evaluates <CODE>value</CODE>, and if <CODE>identifier</CODE> is not
already in the symbol table, creates a new symbol named
<CODE>identifier</CODE> with the evaluated <CODE>value</CODE>.  If <CODE>identifier</CODE>
is already defined, define sets it to the the evaluated <CODE>value</CODE>.

<DT><CODE>load-extension</CODE>
<DD>
<A NAME="IDX68"></A>


<PRE>
(load-extension "/absolute/pathname/plugin.so")
</PRE>

<CODE>load-extension</CODE> informs openal of the presence of a plugin which
conforms to the extension format described in @xref{Making your own}.

</DL>

<P>
By setting certain <CODE>variables</CODE>, a user can change the behavior of
OpenAL without resorting to wholesale recompilations.  Loki's OpenAL
implementation respects on certain variables and checks for them.
Usually, the values are used to set default values (such as the default
gain for a source (usually 1.0).



<UL>
</UL>

<P>
<A NAME="IDX69"></A>


<P>
There are some, but I haven't listed them here.


<P>
<A NAME="IDX70"></A>


<DL COMPACT>

<DT><CODE>devices</CODE>
<DD>
<CODE>devices</CODE> is a list of tokens (either strings or unquoted symbols)
that OpenAL checks for in order to determine the sequence and types of
devices that should be used to render audio to.

The list of available devices at the time of this writing is:
<TABLE BORDER>

<TR><TD>native </TD><TD> Standard OSS (/dev/dsp) backend on linux.</TD>

</TR>
<TR><TD>sdl </TD><TD> Simple DirectMedia Layer backend.</TD>

</TR>
<TR><TD>arts </TD><TD> aRTs backend</TD>

</TR>
<TR><TD>esd </TD><TD> esound daemon backend.</TD>

</TR>
<TR><TD>alsa </TD><TD> ALSA backend.</TD>

</TR>
<TR><TD>waveout </TD><TD> WAVE file output.</TD>

</TR></TABLE>

...please note that this does not mean that the backends work without
fail, but that support either is included or is planned.

A typical invocation look like:


<PRE>
(define devices '(sdl native))
</PRE>

...which indicates to OpenAL that it should try to render audio to the
SDL backend (if available), and failing that to try the native audio
method for the platform in question, which usually means using the OSS
drivers and <CODE>/dev/dsp</CODE>.  If each device specified in <CODE>devices</CODE> 
fails, then the default behavior (<CODE>native</CODE>) is tried.  If that 
fails, OpenAL will return a <CODE>NULL</CODE> context.

</DL>

<P>
<A NAME="IDX71"></A>


<P>
Symbol values have associated type information.  Users should be 
acquainted with the following types in ALRC:



<UL>

<LI>ALRC_INVALID

This is the type of a value that is either false or for some reason
invalid.  No evaluation or assignment should be attempted with this
type.

<LI>ALRC_LIST

This type contains other types.  If not quoted, it is evaluated as
an expression with the first item specifying the function name, which
is probably not what you want.


<PRE>
'(0.0 0.0 0.0)          ; list which is not an expression
(define blah 'blah) 	; list which is an expression
</PRE>

<LI>ALRC_SYMBOL

Things which, when evaluated, are not themselves.

<LI>ALRC_INTEGER

Integer numbers.

<LI>ALRC_FLOAT

Floating point numbers.

<LI>ALRC_STRING

A series of characters enclosed by '"'.

</UL>



<H1><A NAME="SEC12" HREF="openal_toc.html#TOC12">How to extend Loki's OpenAL</A></H1>
<P>
<A NAME="IDX72"></A>
<A NAME="IDX73"></A>
<A NAME="IDX74"></A>


<P>
Loki's OpenAL implementation include some functions which are specific
to the implementation.  These functions all have the suffix <CODE>_LOKI</CODE> 
to distinguish them.


<P>
In order to use these extensions, the application will need to query
their existence via <CODE>IsExtensionPresent</CODE>, and then use
<CODE>GetProcAddress</CODE> to resolve the address of the extension.  The
result of <CODE>GetProcAddress</CODE> will need to be cast to the appropriate
function type.



<UL>
</UL>

<DL COMPACT>

Some of the Loki specific functionality is expressed in terms of
Loki specific enumerate tokens passed to otherwise standard 
calls.

<DT><CODE>AL_BYTE_LOKI</CODE>
<DD>
<A NAME="IDX75"></A>

<CODE>AL_BYTE_LOKI</CODE> is used as a getter to <CODE>alGetSourcei</CODE>, and
reports a source's position, in bytes, into the buffer, or -1 in the
case of a non playing source.  There are no guarentees about the
internal representation of data so the value returned using this
token may not correspond with the equivilant offset in the user
supplied data.

<DT><CODE>AL_SOURCE_LOOPING_LOKI</CODE>
<DD>
<A NAME="IDX76"></A>

<CODE>AL_SOURCE_LOOPING_LOKI</CODE> is used as a setter/getter to
<CODE>al{Get}Sourcei</CODE>, and sets/gets the infinite loop flag on a source.

</DL>

<P>
<A NAME="IDX77"></A>


<P>
Here's a list of extensions which are built into the Loki OpenAL
implementation.  The prefix is included in this section for clarify.


<DL COMPACT>

<DT><CODE>void alAttenuationScale_LOKI(ALfloat param)</CODE>
<DD>
<A NAME="IDX78"></A>
<A NAME="IDX79"></A>
<A NAME="IDX80"></A>
<A NAME="IDX81"></A>

<CODE>alAttenuationScale_LOKI</CODE> scales the units of the simulation.
Without a call to this function, it is very likely that your application 
will not sound correct.

The default scaling factor in Loki's OpenAL is such that a listener
placed at the origin will hear sounds attenuated until that point that
the sounds are <CODE>ALMAXDISTANCE</CODE> units away.  <CODE>ALMAXDISTANCE</CODE> is 
an arbitrary constant defined when including <CODE>AL/alkludge.h</CODE>.

It is almost assured that the default scaling factor will be incorrect
for most applications.  That is why this call is so important.  Usage
will generally follow:


<PRE>
        /* create context, load data, and define some value radius
         * to be the radius of your world simulation.
         */

        setScale = (void (*)(ALfloat ))
                        alGetProcAddress("alAttenuationScale_LOKI");
        if(setScale != NULL) {
                setScale(radius / ALMAXDISTANCE);
        }

</PRE>

It is highly recommended you explicitly use this function, and do not
assume that the default units will be useful to you.

<DT><CODE>ALfloat alcGetAudioChannel_LOKI(ALuint channel)</CODE>
<DD>
<A NAME="IDX82"></A>

<CODE>alcGetAudioChannel_LOKI</CODE> takes in a channel enumeration from the
set <CODE>AL_CHAN_MAIN_LOKI</CODE>, <CODE>AL_CHAN_PCM_LOKI</CODE>, and
<CODE>AL_CHAN_CD_LOKI</CODE>, and returns a normalized ALfloat, corresponding
to the volume associated with the channel on whatever backend the
library is using.

<DT><CODE>void alcSetAudioChannel_LOKI(ALuint channel, ALfloat volume)</CODE>
<DD>
<A NAME="IDX83"></A>

<CODE>alcSetAudioChannel_LOKI</CODE> takes a channel specification from the
set <CODE>AL_CHAN_MAIN_LOKI</CODE>, <CODE>AL_CHAN_PCM_LOKI</CODE>, and
<CODE>AL_CHAN_CD_LOKI</CODE> and a normalized volume, and sets the hardware
channel associated with the channel argument to the volume (the volume
mapped to the settings appropriate for the backend, that is).

<DT><CODE>void alMute_LOKI(ALvoid)</CODE>
<DD>
<A NAME="IDX84"></A>

<CODE>alMute_LOKI</CODE> returns nothing and takes no argument.  After a call
to <CODE>alMute_LOKI</CODE>, the implementation ceased all audio output, while
still updating state (so sources still play, you just can't hear them).
The audio setting is preserved so that a subsequent call to
<CODE>alUnMute_LOKI</CODE> will restore the volume to its value prior to the
<CODE>alMute_LOKI</CODE> call.

This isn't really useful, as you can do the same with by just querying
and setting the listener gain.

<DT><CODE>void alUnMute_LOKI(ALvoid)</CODE>
<DD>
<A NAME="IDX85"></A>

<CODE>alUnMute_LOKI</CODE> performs the inverse operation of
<CODE>alMute_LOKI</CODE>.  alUnMute_LOKI restores the volume of the simulation 
to that which is was before calling <CODE>alMute_LOKI</CODE>.

<DT><CODE>void alReverbScale_LOKI(ALuint sid, ALfloat param)</CODE>
<DD>
<A NAME="IDX86"></A>

<CODE>alReverbScale_LOKI</CODE> allows you to set a normalized value param,
which represents the gain that is used when reverberating.  Don't use
it.  It will be removed as soon as the IASIG extension is completed.

<DT><CODE>void alReverbDelay_LOKI(ALuint sid, ALfloat param)</CODE>
<DD>
<A NAME="IDX87"></A>

<CODE>alReverbScale_LOKI</CODE> allows you to set the delay associated with a
reverberating source.  Don't use this.  It will be removed as soon as
the IASIG extension is completed.

<DT><CODE>ALboolean alBufferPitchHack_LOKI(ALuint bid, ALfloat pitch)</CODE>
<DD>
<A NAME="IDX88"></A>
Don't use this.  You don't want it.

<DT><CODE>ALboolean alutBufferAndConvertData_LOKI(ALuint bid, void *data,</CODE>
<DD>
 				   ALboolean should_use, ALuint size)
<A NAME="IDX89"></A>

<CODE>alutBufferAndConvertData_LOKI</CODE> is like <CODE>alBufferData</CODE>, but it 
infers the format / frequency information from the data itself.  This is 
useful for when the application is handed a chunk of data that it would
like to use for a buffer, but cannot readily determine the type of
data.

<CODE>alutBufferAndConvertData_LOKI</CODE> accepts data in the form of entire
sound files, in their native format.  It does not accept raw PCM data.
The <CODE>should_use</CODE> argument is used to inform OpenAL that the data in 
question should be used, as opposed to OpenAL making a copy.  I don't
suggest you even set it to AL_TRUE.

<CODE>alutBufferAndConvertData_LOKI</CODE> returns <CODE>AL_TRUE</CODE> when the
conversion and <CODE>alBufferData</CODE> was successful, <CODE>AL_FALSE</CODE>
otherwise.  Unless you specify the <CODE>should_use</CODE> flag, in which case 
<CODE>alutBufferAndConvertData_LOKI</CODE> will return <CODE>AL_FALSE</CODE> in the
additional case that it could not use the original data (ie, in-place
conversion would be impossible without overflow).

<DT><CODE>void alBombOnError_LOKI(void)</CODE>
<DD>
<A NAME="IDX90"></A>
<A NAME="IDX91"></A>

<CODE>alBombOnError_LOKI</CODE>, when called, will cause the implementation to 
abort on error, instead of just setting the per-context error and
continuing.  This is useful only for debugging.  alc errors are not
handled.

<DT><CODE>void alBufferSyncData_LOKI( ALuint bid, ALenum format, ALvoid *data,</CODE>
<DD>
                                  ALsizei size, ALsizei freq );
<A NAME="IDX92"></A>

<CODE>alBufferSyncData_LOKI</CODE> is like <CODE>alBufferData</CODE>, but will
use the passed data instead of creating a copy.  Not recommended for
general use.

<DT><CODE>void alBufferi_LOKI( ALuint bid, ALenum param, ALint value )</CODE>
<DD>
<A NAME="IDX93"></A>

<CODE>alBufferi_LOKI</CODE> can be used to set a buffer's attributes.  Not
recommended unless you know what you're doing.  Usually, you can use
this to enable a "multichannel" buffer.

<DT><CODE>void alBufferDataWithCallback_LOKI( ALuint bid, ALint (*callback)(ALuint sid, ALuint bid, ALshort *data, ALenum format, ALuint samples))</CODE>
<DD>
<A NAME="IDX94"></A>

<CODE>alBufferDataWithCallback_LOKI</CODE> can be used to specify that the buffer
<CODE>bid</CODE> should, instead of using a static chunk of data specified by
<CODE>alBufferData</CODE>, call the callback <CODE>callback</CODE> to fill a chunk of
data as needed.

The parameters for <CODE>callback</CODE> are as such:


<PRE>
	<CODE>ALuint sid</CODE>
	The source id that this request is associated with.  Since many 
	sources may share the same buffer, this sid allows the application
	to keep track of offsets and other state associated with each
	source instance.

	<CODE>ALuint bid</CODE>
	The buffer id that the callback is associated with.

	<CODE>ALshort *data</CODE>
	The memory area that the callback should populate

	<CODE>ALenum format</CODE>
	The format the the output data should be in.

	<CODE>ALuint samples</CODE>
	The number of <STRONG>samples</STRONG> required.

</PRE>

</DL>

<P>
<A NAME="IDX95"></A>
<A NAME="IDX96"></A>


<P>
It is possible to extend the functionality of Loki's implementation of
OpenAL via plugins (combined with some configuration mojo).


<P>
"Plugins" are actually just shared libraries which contain, as an
available symbol, a table which contains function name/address pairs.
Code necessary for library initialization and exit should be placed in
_init, _fini as described in dlopen(3).


<P>
The table containing the function name/address pairs should correspond
to the following format:



<PRE>
struct {
        ALubyte *name;
        void *addr;
} alExtension_03282000 [] = {
    { "alutLoadGIF", (void *) alutLoadGIF },
    { NULL, NULL }
};
</PRE>

<P>
Right now, the end <CODE>{ NULL, NULL }</CODE> pair is needed, and the table
needs to be named <CODE>alExtension_03282000</CODE>.  This format is likely to
change in the future, in order to avoid a badly written plugin from
crashing each application linked against openal.


<P>
In order to take advantage of the extension, openal will have to be
informed of its location via the configuration file See section <A HREF="openal.html#SEC11">The openal configuration file</A>.


<P>
To avoid potential compatibility problems with initialization code, Loki's
OpenAL implementation checks for the presence of the functions
<CODE>alExtInit_03282000</CODE> and <CODE>alExtFini_03282000</CODE>.  These functions
are executed at dlopen and dlclose time, respectively.



<UL>
<LI><A HREF="openal.html#SEC13">Includes and typedefs</A>
<LI><A HREF="openal.html#SEC14">Basics</A>
<LI><A HREF="openal.html#SEC15">Getting symbol information</A>
<LI><A HREF="openal.html#SEC16">Adding Filters</A>
</UL>



<H2><A NAME="SEC13" HREF="openal_toc.html#TOC13">Includes and typedefs</A></H2>



<H2><A NAME="SEC14" HREF="openal_toc.html#TOC14">Basics</A></H2>



<H2><A NAME="SEC15" HREF="openal_toc.html#TOC15">Getting Symbol Information</A></H2>



<H2><A NAME="SEC16" HREF="openal_toc.html#TOC16">Adding Filters</A></H2>



<H1><A NAME="SEC17" HREF="openal_toc.html#TOC17">OpenAL examples</A></H1>

<P>
Here are some examples.



<UL>
<LI><A HREF="openal.html#SEC18">Trivial</A>: A trivial example
<LI><A HREF="openal.html#SEC19">Error Handling</A>: Some basic error handling
<LI><A HREF="openal.html#SEC20">Context Management</A>: Context management
<LI><A HREF="openal.html#SEC21">Panning</A>: An example of left/right panning
<LI><A HREF="openal.html#SEC22">Positional</A>: Positional attenuation example
<LI><A HREF="openal.html#SEC23">Doppler</A>: How to use velocity
<LI><A HREF="openal.html#SEC25">Streaming</A>: How to use streaming sound
<LI><A HREF="openal.html#SEC24">Reverb</A>: How to use reverb
</UL>



<H2><A NAME="SEC18" HREF="openal_toc.html#TOC18">Trivial Example</A></H2>


<PRE>

#include &#60;AL/al.h&#62;
#include &#60;AL/alc.h&#62;
#include &#60;AL/alkludge.h&#62;
#include &#60;AL/alut.h&#62;

#include &#60;time.h&#62;
#include &#60;stdio.h&#62;
#include &#60;stdlib.h&#62;
#include &#60;sys/time.h&#62;
#include &#60;sys/types.h&#62;
#include &#60;unistd.h&#62;

#define DATABUFFERSIZE (10 * (512 * 3) * 1024)

static void iterate(void);
static void init(void);
static void cleanup(void);

static ALuint moving_source = 0;

static time_t start;
static void *data = (void *) 0xDEADBEEF;

static void *context_id;

static void iterate( void ) {
        /* sleep for a bit */
        micro_sleep(500000);
}

static void init( void ) {
        FILE *fh;
        ALfloat zeroes[] = { 0.0f, 0.0f,  0.0f };
        ALfloat back[]   = { 0.0f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f };
        ALfloat front[]  = { 0.0f, 0.0f,  1.0f, 0.0f, 1.0f, 0.0f };
        ALuint stereo;
        ALsizei size;
        ALsizei bits;
        ALsizei freq;
        ALsizei format;
        int filelen;

        data = malloc(DATABUFFERSIZE);

        alListenerfv(AL_POSITION, zeroes );
        alListenerfv(AL_ORIENTATION, front );

        alGenBuffers( 1, &#38;stereo);

        fh = fopen("sample.wav", "rb");
        if(fh == NULL) {
                fprintf(stderr, "Couldn't open sample.wav\n");
                exit(1);
        }

        filelen = fread(data, 1, DATABUFFERSIZE, fh);
        fclose(fh);

        talutBufferAndConvertData(stereo, data, AL_TRUE, filelen);

        alGenSources(1, &#38;moving_source);

        alSource3f( moving_source, AL_POSITION, 0.0, 0.0, 4.0 );
        alSourcefv( moving_source, AL_VELOCITY, zeroes );
        alSourcei(  moving_source, AL_BUFFER, stereo );
        alSourcei(  moving_source, AL_SOURCE_LOOPING, AL_FALSE);

        /* Scale world to 0.7 * ALMAXDISTANCE */
        talAttenuationScale(0.7);

        return;
}

static void cleanup(void) {
        free(data);
        alcDestroyContext(context_id);
}

int main( int argc, char* argv[] ) {
        int attrlist[] = { ALC_FREQUENCY, 22050,
                           ALC_INVALID };
        time_t shouldend;
        ALint state = AL_INITIAL;

        /* Initialize ALUT. */
        context_id = alcCreateContext(attrlist);
        if(context_id == NULL) {
                return 1;
        }

        /*
         * Setup LOKI extensions
         */
        fixup_function_pointers();

        init( );

        alSourcePlay( moving_source );
        do {
                iterate();

                shouldend = time(NULL);
                if((shouldend - start) &#62; 10) {
                        /* After 10 seconds, we end */
                        alSourceStop(moving_source);
                }

                alSourcei(moving_source, AL_SOURCE_STATE, &#38;state);
        } while(state == AL_ACTIVE);

        cleanup();

        return 0;
}

</PRE>



<H2><A NAME="SEC19" HREF="openal_toc.html#TOC19">Error Handling</A></H2>

<P>
Error Handling goes here.




<H2><A NAME="SEC20" HREF="openal_toc.html#TOC20">Context Management</A></H2>

<P>
Context Management goes here.




<H2><A NAME="SEC21" HREF="openal_toc.html#TOC21">Panning</A></H2>

<P>
Panning example goes here.




<H2><A NAME="SEC22" HREF="openal_toc.html#TOC22">Positional</A></H2>

<P>
Positional example goes here.




<H2><A NAME="SEC23" HREF="openal_toc.html#TOC23">Doppler</A></H2>

<P>
Doppler example goes here.




<H2><A NAME="SEC24" HREF="openal_toc.html#TOC24">Reverb</A></H2>


<PRE>
#include &#60;AL/al.h&#62;
#include &#60;AL/alc.h&#62;
#include &#60;AL/alkludge.h&#62;
#include &#60;AL/alut.h&#62;

#include &#60;time.h&#62;
#include &#60;stdio.h&#62;
#include &#60;unistd.h&#62;

static void init( void );

static ALuint reverb_sid = 0;

static void *wave = NULL;

static void init( void ) {
	ALfloat zeroes[] = { 0.0f, 0.0f,  0.0f };
	ALfloat back[]   = { 0.0f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f };
	ALfloat front[]  = { 0.0f, 0.0f,  1.0f, 0.0f, 1.0f, 0.0f };
	ALuint boom;
	ALsizei size;
	ALsizei bits;
	ALsizei freq;
	ALsizei format;

	alListenerfv(AL_POSITION, zeroes );
	alListenerfv(AL_VELOCITY, zeroes );
	alListenerfv(AL_ORIENTATION, front );

        alGenBuffers( 1, &#38;boom );

	alutLoadWAV( "l2.wav", &#38;wave, &#38;format, &#38;size, &#38;bits, &#38;freq);

	alBufferData( boom, format, wave, size, freq );
	free(wave); /* openal makes a local copy of wave data */

	alGenSources( 1, &#38;reverb_sid);

	alSource3f(reverb_sid, AL_POSITION, 2.0, 0.0, 4.0);
	alSourcefv(reverb_sid, AL_VELOCITY, zeroes);
	alSourcefv(reverb_sid, AL_ORIENTATION, back);
	alSourcei (reverb_sid, AL_BUFFER, boom);

	alReverbScale(reverb_sid, 0.6);
	alReverbDelay(reverb_sid, 0.3);

	alAttenuationScale(0.3);
}

int main(int argc, char *argv[]) {
	alutInit( &#38;argc, argv );

	init( );

	alSourcePlay(reverb_sid);
	sleep(10);

	alutExit();

	return 0;
}

</PRE>



<H2><A NAME="SEC25" HREF="openal_toc.html#TOC25">Streaming</A></H2>
<P>
<A NAME="IDX97"></A>
<A NAME="IDX98"></A>
<A NAME="IDX99"></A>
<A NAME="IDX100"></A>
<A NAME="IDX101"></A>


<P>
Support for streaming sounds rises from the API specification
surrounding <CODE>alBufferAppendData</CODE>.  Streaming sources are understood
to be sources whose <CODE>AL_BUFFER</CODE> parameter is a streaming buffer.  A 
streaming buffer is a buffer created by a call to
<CODE>alGenStreamingBuffer</CODE>, and can only be fed data using
<CODE>alBufferAppendData</CODE>.  


<P>
Streaming sources have restrictions associated with them, and for the
time being require special creation procedures.  Further specifications
may remove some of these restrictions, but until further notice streaming 
sources will always be synchronized, and some of the filters may not
apply to them.



<PRE>
insert code example
</PRE>


<UL>
</UL>

<P>
Foo!




<H1><A NAME="SEC26" HREF="openal_toc.html#TOC26">Function Index</A></H1>

<P>
Jump to:
<A HREF="#findex_a">a</A>
<P>
<H2><A NAME="findex_a">a</A></H2>
<DIR>
<LI><A HREF="openal.html#IDX78">alAttenuationScale_LOKI</A>
<LI><A HREF="openal.html#IDX90">alBombOnError_LOKI</A>
<LI><A HREF="openal.html#IDX25">alBufferAppendData</A>, <A HREF="openal.html#IDX100">alBufferAppendData</A>
<LI><A HREF="openal.html#IDX24">alBufferData</A>
<LI><A HREF="openal.html#IDX94">alBufferDataWithCallback</A>
<LI><A HREF="openal.html#IDX93">alBufferi_LOKI</A>
<LI><A HREF="openal.html#IDX88">alBufferPitchHack_LOKI</A>
<LI><A HREF="openal.html#IDX92">alBufferSyncData_LOKI</A>
<LI><A HREF="openal.html#IDX44">alcCreateContext</A>
<LI><A HREF="openal.html#IDX46">alcDestroyContext</A>
<LI><A HREF="openal.html#IDX82">alcGetAudioChannel</A>
<LI><A HREF="openal.html#IDX47">alcGetError</A>
<LI><A HREF="openal.html#IDX48">alcGetErrorString</A>
<LI><A HREF="openal.html#IDX45">alcMakeContextCurrent</A>
<LI><A HREF="openal.html#IDX83">alcSetAudioChannel</A>
<LI><A HREF="openal.html#IDX22">alDeleteBuffers</A>
<LI><A HREF="openal.html#IDX7">alDeleteSources</A>
<LI><A HREF="openal.html#IDX32">alDisable</A>
<LI><A HREF="openal.html#IDX31">alEnable</A>
<LI><A HREF="openal.html#IDX21">alGenBuffers</A>
<LI><A HREF="openal.html#IDX6">alGenSources</A>
<LI><A HREF="openal.html#IDX101">alGenStreamingBuffer</A>
<LI><A HREF="openal.html#IDX35">alGetBoolean</A>
<LI><A HREF="openal.html#IDX39">alGetBooleanv</A>
<LI><A HREF="openal.html#IDX27">alGetBufferf</A>
<LI><A HREF="openal.html#IDX26">alGetBufferi</A>
<LI><A HREF="openal.html#IDX38">alGetDouble</A>
<LI><A HREF="openal.html#IDX42">alGetDoublev</A>
<LI><A HREF="openal.html#IDX30">alGetEnumValue</A>
<LI><A HREF="openal.html#IDX59">alGetError</A>
<LI><A HREF="openal.html#IDX37">alGetFloat</A>
<LI><A HREF="openal.html#IDX41">alGetFloatv</A>
<LI><A HREF="openal.html#IDX36">alGetInteger</A>
<LI><A HREF="openal.html#IDX40">alGetIntegerv</A>
<LI><A HREF="openal.html#IDX29">alGetProcAddress</A>, <A HREF="openal.html#IDX74">alGetProcAddress</A>
<LI><A HREF="openal.html#IDX14">alGetSourcef</A>
<LI><A HREF="openal.html#IDX15">alGetSourcefv</A>
<LI><A HREF="openal.html#IDX13">alGetSourcei</A>
<LI><A HREF="openal.html#IDX43">alGetString</A>
<LI><A HREF="openal.html#IDX34">alHint</A>
<LI><A HREF="openal.html#IDX23">alIsBuffer</A>
<LI><A HREF="openal.html#IDX33">alIsEnabled</A>
<LI><A HREF="openal.html#IDX28">alIsExtensionPresent</A>, <A HREF="openal.html#IDX73">alIsExtensionPresent</A>
<LI><A HREF="openal.html#IDX8">alIsSource</A>
<LI><A HREF="openal.html#IDX84">alMute_LOKI</A>
<LI><A HREF="openal.html#IDX87">alReverbDelay_LOKI</A>
<LI><A HREF="openal.html#IDX86">alReverbScale_LOKI</A>
<LI><A HREF="openal.html#IDX11">alSource3f</A>
<LI><A HREF="openal.html#IDX10">alSourcef</A>
<LI><A HREF="openal.html#IDX12">alSourcefv</A>
<LI><A HREF="openal.html#IDX9">alSourcei</A>
<LI><A HREF="openal.html#IDX19">alSourcePause</A>
<LI><A HREF="openal.html#IDX18">alSourcePlay</A>
<LI><A HREF="openal.html#IDX16">alSourcePlayv</A>
<LI><A HREF="openal.html#IDX20">alSourceStop</A>
<LI><A HREF="openal.html#IDX17">alSourceStopv</A>
<LI><A HREF="openal.html#IDX85">alUnMute_LOKI</A>
<LI><A HREF="openal.html#IDX89">alutBufferAndConvertData_LOKI</A>
</DIR>




<H1><A NAME="SEC27" HREF="openal_toc.html#TOC27">Variable Index</A></H1>
<P>
     
Jump to:
<A HREF="#vindex_a">a</A>
<P>
<H2><A NAME="vindex_a">a</A></H2>
<DIR>
<LI><A HREF="openal.html#IDX75">AL_BYTE_LOKI</A>
<LI><A HREF="openal.html#IDX76">AL_SOURCE_LOOPING_LOKI</A>
<LI><A HREF="openal.html#IDX81">ALMAXDISTANCE</A>
</DIR>




<H1><A NAME="SEC28" HREF="openal_toc.html#TOC28">Concept Index</A></H1>
<P>
     
Jump to:
<A HREF="#cindex__">_</A>
-
<A HREF="#cindex_a">a</A>
-
<A HREF="#cindex_b">b</A>
-
<A HREF="#cindex_c">c</A>
-
<A HREF="#cindex_d">d</A>
-
<A HREF="#cindex_e">e</A>
-
<A HREF="#cindex_i">i</A>
-
<A HREF="#cindex_l">l</A>
-
<A HREF="#cindex_o">o</A>
-
<A HREF="#cindex_p">p</A>
-
<A HREF="#cindex_s">s</A>
-
<A HREF="#cindex_u">u</A>
-
<A HREF="#cindex_w">w</A>
<P>
<H2><A NAME="cindex__">_</A></H2>
<DIR>
<LI><A HREF="openal.html#IDX77">_LOKI</A>
</DIR>
<H2><A NAME="cindex_a">a</A></H2>
<DIR>
<LI><A HREF="openal.html#IDX61">ALRC</A>
<LI><A HREF="openal.html#IDX65">and</A>
<LI><A HREF="openal.html#IDX1">API</A>
</DIR>
<H2><A NAME="cindex_b">b</A></H2>
<DIR>
<LI><A HREF="openal.html#IDX2">Buffers</A>
</DIR>
<H2><A NAME="cindex_c">c</A></H2>
<DIR>
<LI><A HREF="openal.html#IDX63">config file</A>
<LI><A HREF="openal.html#IDX62">configuration file</A>
<LI><A HREF="openal.html#IDX70">Context variables</A>
<LI><A HREF="openal.html#IDX4">Contexts</A>
</DIR>
<H2><A NAME="cindex_d">d</A></H2>
<DIR>
<LI><A HREF="openal.html#IDX67">define</A>
</DIR>
<H2><A NAME="cindex_e">e</A></H2>
<DIR>
<LI><A HREF="openal.html#IDX91">error</A>
<LI><A HREF="openal.html#IDX49">Errors</A>
<LI><A HREF="openal.html#IDX96">extensions</A>
<LI><A HREF="openal.html#IDX72">Extensions</A>
</DIR>
<H2><A NAME="cindex_i">i</A></H2>
<DIR>
<LI><A HREF="openal.html#IDX60">Installation</A>
</DIR>
<H2><A NAME="cindex_l">l</A></H2>
<DIR>
<LI><A HREF="openal.html#IDX71">Listener variables</A>
<LI><A HREF="openal.html#IDX68">load-extension</A>
</DIR>
<H2><A NAME="cindex_o">o</A></H2>
<DIR>
<LI><A HREF="openal.html#IDX66">or</A>
</DIR>
<H2><A NAME="cindex_p">p</A></H2>
<DIR>
<LI><A HREF="openal.html#IDX95">plugins</A>
<LI><A HREF="openal.html#IDX64">primitive</A>
</DIR>
<H2><A NAME="cindex_s">s</A></H2>
<DIR>
<LI><A HREF="openal.html#IDX69">Source variables</A>
<LI><A HREF="openal.html#IDX3">Sources</A>, <A HREF="openal.html#IDX5">Sources</A>
<LI><A HREF="openal.html#IDX97">Streaming</A>
<LI><A HREF="openal.html#IDX98">Streaming buffer</A>
<LI><A HREF="openal.html#IDX99">Streaming source</A>
</DIR>
<H2><A NAME="cindex_u">u</A></H2>
<DIR>
<LI><A HREF="openal.html#IDX79">units</A>
</DIR>
<H2><A NAME="cindex_w">w</A></H2>
<DIR>
<LI><A HREF="openal.html#IDX80">world units</A>
</DIR>


<P><HR><P>
This document was generated on 1 December 2000 using
<A HREF="http://wwwinfo.cern.ch/dis/texi2html/">texi2html</A>&nbsp;1.56k.
</BODY>
</HTML>
