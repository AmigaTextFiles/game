@database Magic.guide
@AUTHOR Tak Tang
@(C) 1996 Tak Tang
@VER: Magic.Guide v1.0.1 (14.7.96)
@wordwrap
@node main "Magic"
@{jcenter}
-----------------------------------------------------------------------
@{b}Magic 1.0.1@{ub}

A preliminary magic system for AmigaMUD 1.0
Author: Tak Tang

Release date : 14th July 1996

PUBLIC DOMAIN

-----------------------------------------------------------------------

User Manual
@{jleft}
	@{"  Introduction  " link "Introduction"}       What is Magic?
	@{"  Features      " link "Features"}       What makes Magic so special?
	@{"  Requirements  " link "Requirements"}       Will it run on my system?

	@{"  Installation  " link "Installation"}       How do I plug this in?

	Essential information
	    @{"  First steps   " link "Steps"}       Where to start learning
	    @{"  New commands  " link "Commands"}       Using the magic system
	    @{"  Spell listing " link "Spells"}       Spells in this release
	    @{"  Items         " link "Items"}       Things you might find

	Programmers information
	    @{"  Overview      " link "OverView"}       Spell effects and models
	    @{"  Grimoires     " link "PGrimoires"}       A library of knowledge
	    @{"  Scrolls       " link "PScrolls"}       A nugget of power
	    @{"  Potions       " link "PPotions"}       Another nugget

	@{"  Known bugs    " link "Bugs"}       Will it crash?
	@{"  Future        " link "Future"}       What the future will bring...

	@{"  Disclaimer    " link "Disclaimer"}       Use at own risk!
	@{"  Copyright     " link "Copyright"}       Legal stuff.

	@{"  Author        " link "Author"}       Where you can reach me.

@endnode

@NODE Introduction

@{b}Introduction@{ub}

    When I started playing with AmigaMUD, the most obvious thing missing was a magic system.  There were a _few_ magic items here and there, but not a real @{i}system@{ui} for magic @{i}spells@{ui}. 

    I decided to write my own.

    @{b}What this is:@{ub} This bunch of source code which defines a framework for a magic system.

    @{b}What this isnt:@{ub} A complete magic system, including a dozen magic using classes, hundreds of magic items and spells, a scenario, monsters.

@ENDNODE

@NODE Features

@{b}Features@{ub}

    ° Spells can optionally need to be memorized
    ° Spells can optionally use mana points to cast
    ° Scrolls - one use spells useable by mages
    ° Potions - one use spells useable by anyone
    ° Wands - multi charge items, useable by mages
    ° Grimoires - spell books, useable by mages
    ° Checkers to restrict who can learn and use spells, and hence
	° Divine magic, for SysAdmin and Wizards
	    ° Mortal magic, for normal players

@ENDNODE

@NODE Requirements

@{b}Requirements@{ub}

To make the best use of this, you need:

    ° An Amiga Computer ;-)
    ° A copy of Chris Gray's AmigaMUD v1.0, server, and standard scenario.  the other archives would probably be useful too.  You can get this from Aminet:games/role


@ENDNODE

@NODE Installation
@NEXT Usage.guide/main

@{b}Installation@{ub}

    First, make a backup copy of your scenario.  Assign ST: to where ever you have dearchived the files to.  Run the server, preferably on an offline test machine, log in as SysAdmin, and source the st:go-tt.m file.  This will cause everything to be sourced in the correct order.  If you wish to use it without the other stuff in the 'mystuff' directory, you can remove everything EXCEPT status.m and utility.m.  They MUST be sourced before magic.m.

@ENDNODE

@NODE Steps "First Steps"

@{b}First Steps@{ub}

When you have finished sourceing the files, SysAdmin will be the first,
and only mage in the game.  In SysAdmin's study will be three grimoires,
which contain divine magics, mortal magics, and mana magics.

The divine magics book (titled "powerful magic grimoire") contains spells
useable by wizards only.  Hence, they have no cost, no level, and are
extremely powerful.  Many of them are based on the spells in provided
with the standard AmigaMUD source distribution, in extra/spells.m.

The mortal magics book (titled "blue magic grimoire") contains spells
suitable for normal characters.  Note that I've not put much thought
into the spell level and spell costs yet, but they illustrate how
spells can have the same effect, but different power level.  There
are not very many spells yet.

The mana magics book (titled "red magic grimoire") contains spells
which are to do with magic.  Some of them are for wizards only.
You should take a look at "Grant Magery", the item creation spells
"Scroll", "Potion", and "Wand", and the "mem lock" spell.

You can get a list of spells memorized with "mlist", you can learn
spells from a grimoire with "mlearn <spell> from <grimoire>", and you
can see what spells are available with "read <grimoire>".  Cast spells
with "mcast <spell> (at | on | to) <target>".

@ENDNODE

@NODE COMMANDS "New commands"

@{b}New Commands@{ub}

    mlearn <spell> from <grimoire>
      -- copy a spell into memory from a book
    mlist
      -- see what spells you have memorized
    mcast <spell> [ at | to | on ] <target> [ <other args> ]
      -- cast a spell
    aim <wand> at <target> [ <other args> ]
      -- use a magic wand
    scribe
      -- copy a spell from a scroll into a grimoire
    read <scroll>
      -- see what spell is on a scroll
    read <scroll> [ at | on | to ]
      -- cast spell on a scroll at someone or something
    read <grimoire>
      -- see what spells are available in a grimoire
    drink <potion>
      -- use a potion, affecting SELF

@ENDNODE

@NODE SPELLS "Spells Anthology"

@{b}Spells Anthology@{ub}

  The spells are currently arranged into three grimoires.

"Powerful Magic Grimoire" (Divine magicks)

FIND +*
Usage : Find at <who>.
Effect: Show what <who> sees.

POOF +*
Usage : Poof to <who>.
Effect: Teleport caster to same location as <who>.

LOOK +*
Usage : Look at <who>.
Effect: Look at <who>, even if not nearby.

HEAL +*
Usage : Heal on <who>.
Effect: Heal <who> up to max hitpoints.

WHERE *
Usage : Where is [ all | clients | <name> ].
Effect: Shows location of agents

OBJECT CLONE *
Usage : Object Clone on <object>.
Effect: Creates a sibling of this object.  Not reliable, as some
    objects are more than empty children.

MIND SEND +*
Usage : Mind Send to <who> <stuff>.
Effect: Send <stuff> to <who> telepathically.

FORCE +*
Usage : Force on <who> <what>
Effect: Force <who> to do <what>.

TELEPORT +*
Usage : Teleport on <who> [here | <dir> | <roomname>].
Effect: Changes someone elses location.


"Blue Grimoire" (Mortal magicks)

MINOR HEAL
Usage : Minor Heal at <who>.
Effect: Heal <who> 1-6 hitpoints.

MAJOR HEAL
Usage : Major Heal at <who>.
Effect: Heal <who> 4-20 hitpoints.

TRUE HEAL
Usage : True Heal at <who>.
Effect: Heal <who> 100 hitpoints.

SET TIMER
Usage : Set Timer on <seconds>.
Effect: Set up an alarm to go off in <seconds>.

LESSER MIGHT
Usage : Might at <who>.
Effect: Enhances <who>'s strength by 1 for a minute.

LESSER MIGHT2
Usage : Might at <who>.
Effect: Enhances <who>'s strength by 1 for two minutes.

GREATER MIGHT
Usage : Might at <who>.
Effect: Enhances <who>'s strength by 2 for two minutes.

LESSER SPEED
Usage : Speed at <who>.
Effect: Enhances <who>'s speed by 1 for a minute.

LESSER SPEED2
Usage : Speed at <who>.
Effect: Enhances <who>'s speed by 1 for two minutes.

GREATER SPEED
Usage : Speed at <who>.
Effect: Enhances <who>'s speed by 2 for two minutes.

LESSER ENDURANCE
Usage : Endurance at <who>.
Effect: Enhances <who>'s hit points by 10 for a minute.

LESSER ENDURANCE2
Usage : Endurance at <who>.
Effect: Enhances <who>'s hit points by 10 for two minutes.

GREATER ENDURANCE
Usage : Endurance at <who>.
Effect: Enhances <who>'s hit points by 20 for two minutes.

LESSER LIGHT OBJECT
Usage : Light on <what>.
Effect: Causes <what> to emit light for a minute.

LESSER LIGHT OBJECT2
Usage : Light on <what>.
Effect: Causes <what> to emit light for two minutes.


"Red Grimoire" (Mana Currents)

CREATE SCROLL
Usage : Create Scroll on <spell>
Effect: Takes a spell in memory and creates a scroll from it.

CREATE POTION
Usage : Create Potion on <spell>.
Effect: Takes a spell in memory and creates a potion from it.

CREATE WAND
Usage : Create Wand on <spell>.
Effect: Takes a spell in memory and creates a wand from it, with
    10 charges.

GRANT MAGERY *
Usage : Grant Magery to <who>.
Effect: Initialises <who> for magic.

MEM LOCK *
Usage : Mem Lock on <spell>.
Effect: Locks or unlocks a spell in memory so it will not be forgotten
    when cast.

LESSER RESTORE MANA *
Usage : Lesser Restore Mana to <who>.
Effect: Restores 5 mana points to <who>.

GREATER RESTORE MANA *
Usage : Greater Restore Mana to <who>.
Effect: Restores 10 mana points to <who>.


+ same as one supplied with the standard scenario
* for Wizards and apprentices only

@ENDNODE

@NODE Items "Magic Items"

@{b}Items@{ub}

[ flesh this out a bit more ]

    Scrolls:
	To find out whats on a scroll, use "read <scroll>"
	To cast a spell from a scroll, use "read <scroll> at <target>"

    Wands:
	To find out a wand does, use "read <wand>"
	To use a wand, use "aim <wand> at <target>"

    Potions:
	To use, "drink <potion>"

    Grimoires:
	To see what spells are available, use "read <grimoire>"
	To learn a spell, use "mlearn <spell> from <grimoire>"

@ENDNODE

@NODE Overview "Programming Overview"

@{b}Programming Overview@{ub}

To achieve the flexibility I wanted, I realised that each spell must have
two parts - a generic spell effect, and a specific spell model.  In
OO terms, its a bit like an object class, and an object instance.
An effect is a mud procedure, which determines what the spell does.  But
rather than have one procedure for each individual spell, the exact
power level and level of effect is contained in a spell model, which
is just a thing.


Lets take an example - the heal spells.

There are three heal spells - minor heal, major heal, and true heal.
Each have the same spell effect, namely "se_heal".  When se_Heal
is called, it looks at the spell model, and extracts the p_sDice string,
which tells the model how many hit points to restore.


 : define tp_magic proc se_Heal(thing spell; string name)bool:
 :   thing who;
 :   int max,now,heal;
 :
 :   who := FindAgent(name);
 :   if who = nil then
 :     Print("There is no one here called '" + name + "'.\n");
 :   else
 :     max := who@p_pHitMax;
 :     now := who@p_pHitNow;
 :     if max = 0 then
 :       Print(name + " has no maximum hitpoints.\n");
 :     elif now = max then
 :       Print(name + " needs no healing.\n");
 :     else
 :       heal := parseDiceString(spell@p_sDice);
 :       if heal + now > max then
 :         heal := max - now;
 :       fi;
 :       who@p_pHitNow := now+heal;
 :       Print(name + " healed " + IntToString(heal)+ " hit points.\n");
 :       SPrint(who, FormatName(Me()@p_pName) + " has healed " +
 :          IntToString(heal)+ " hit points!\n");
 :     fi;
 :   fi;
 :   true
 : corp;
 :
 : define tp_magic smm_Heal CreateThing(sm_DefaultSpell).
 : smm_Heal@p_sEffect:=se_Heal.
 :
 : define tp_magic sm_MinorHeal CreateThing(smm_Heal).
 : sm_MinorHeal@p_sDesc:="minor heal at <who> - heal <who> 1-6 hp.".
 : sm_MinorHeal@p_sDice:="6+1".
 : sm_MinorHeal@p_sName:="heal;minor".
 : sm_MinorHeal@p_sCost:=2.
 : sm_MinorHeal@p_sLevel:=1.
 :
 : define tp_magic sm_MajorHeal CreateThing(smm_Heal).
 : sm_MajorHeal@p_sDesc:="major heal at <who> - heal <who> 4-20 hp.".
 : sm_MajorHeal@p_sDice:="5555+4".
 : sm_MajorHeal@p_sName:="heal;major".
 : sm_MajorHeal@p_sCost:=5.
 : sm_MajorHeal@p_sLevel:=2.
 :
 : define tp_magic sm_TrueHeal CreateThing(smm_Heal).
 : sm_TrueHeal@p_sDesc:="true heal at <who> - heal <who> 100 hp.".
 : sm_TrueHeal@p_sDice:="+100".
 : sm_TrueHeal@p_sName:="heal;true".
 : sm_TrueHeal@p_sCost:=10.
 : sm_TrueHeal@p_sLevel:=3.
 :


A spell model should never be "given out", only hand out children of
the models.  A "spell" is a child of a spell model.

Since spell models are only things, you can define your own properties as
necessary, to control the behaviour of the spells.  The file magic/base.m
contains the current list of properties.  Any spell must have at least
a name, and a spell effect, to function.  The other most frequently
used properties are description, cost and level.  Most will also have
either power (not listed above), or dice.


A spell effect takes a thing and a string as arguments, and returns bool.
The thing is a spell (child of spell model).  The string is whats left
of the input line after the "on","at", or "to" seperator words.  Usually
this will be a target, such as "Joe" or "apple".  In some cases, you will
have to break the string down further.  See "list-divine.m" for examples
of these, notably the "force" spell.

The return result should be true if the spell was cast successfully
(i.e. args were correct), and that the mana cost for casting the spell
should be deducted, and if necessary, removed from memory.  Return false
if the spell was not cast sucessfully, for example, if the named target
is not present (perhaps they made a typing error).


@ENDNODE

@NODE PGrimoires "Programming Grimoires"

@{b}Grimoires@{ub}

All you really need to know is how to make one.

If you want to have a "standard issue grimoire" containing a standard
set of spells, you will need to create a model grimoire object.

 : define tp_magic o_grimoire1 CreateThing(o_grimoire).
 : o_grimoire1@p_pLearnt:=CreateThingList().
 : o_grimoire1@p_oName:="grimoire,book,tome;blue,magic".
 : AddTail(o_grimoire1@p_pLearnt,CreateThing(sm_MinorHeal)).
 : AddTail(o_grimoire1@p_pLearnt,CreateThing(sm_TrueHeal)).
 : AddTail(o_grimoire1@p_pLearnt,CreateThing(sm_SetTimer)).
 : AddTail(o_grimoire1@p_pLearnt,CreateThing(sm_Might)).
 : AddTail(o_grimoire1@p_pLearnt,CreateThing(sm_Speed)).
 : AddTail(o_grimoire1@p_pLearnt,CreateThing(sm_Endurance)).
 : AddTail(o_grimoire1@p_pLearnt,CreateThing(sm_Light)).

You must create a child of "o_grimoire", which is the ancestor of all
grimoires.  It contains the read checkers and a few other bits.  You
must initialise the p_pLearnt property to a thing list.  This will
hold the list of spells in this grimoire.  You should customise the
name and description.  Finally, add spells to it simply by adding to
the list.

When you need to create a grimoire to give to someone (in a shop
perhaps...), use MakeGrimoire(model).  Make grimoire is a mud procedure
to create a child of "model", clone its spell list, and set it to
ts_public.  The list has to be cloned because mages will want to add
new spells to the grimoire as they discover them.  If the list was not
cloned, new spells will appear in ALL grimoires!

@ENDNODE

@NODE PScrolls "Programming Scrolls and wands"

@{b}Programming scrolls and wands@{ub}

These two items have two main differences.  A scroll is single use only,
and vanishes when used, where as a wand can have several charges.  Wands
will be rechargeable.  The second difference is that mages can copy
spells from a scroll into their personal grimoire.  This can be done
with the "scribe" command.

At game level, scrolls are created with the "Create Scroll" spell,
and wands are created by the "Create Wand" spell.  Both are listed
in "list-mana.m".

At wizard level, a scroll can be created with Spell0ToScroll(model),
and a wand with Spell0ToWand(model).  Both return the thing.

Otherwise, they are treated EXACTLY as spells.

Note :- wands and scrolls need further development.  In their current
form their ownly advantage is that you could have spells in scroll or
wand form that are too high level for you to learn and cast normally.
In future, it will be possible to create scrolls and wands which do not
draw mana from the user.

@ENDNODE

@NODE PPotions "Programming potions"

@{b}Programming Potions@{ub}

Potions differ from scrolls and wands in that they can be used by anyone,
not just mages.  They never draw mana from their users, and they never
take any arguments.  They always affect the drinker.  Not all spells
have a potion form.

A spell model which may be turned into a potion must have a "p_sPotionDesc",
which describes how the potion looks, and should have a "p_sNull", which
supplies the argument which the use would have typed if it were a normal
spell.  This so you could have a "polymorph self to spider" potion -
p_sNull "me spider", based on a polymorph spell.

Lets take a look at the Grant Magery spell

 :
 : define tp_magic sm_GrantMagery CreateThing(sm_DefaultWSpell).
 : sm_GrantMagery@p_sName:="magery;grant".
 : sm_GrantMagery@p_sEffect:=se_GrantMagery.
 : sm_GrantMagery@p_sDesc:="grant magery to <who>".
 : sm_GrantMagery@p_sNull:="me".
 : sm_GrantMagery@p_sPotionDesc:="This potion is mostly clear, "
 :     "except for the numerous colored bubbles that appear, "
 :     "and rise to the surface.\n".
 :

At game level, potions are created with the potion spell, listed in
list-mana.m.

At wizard level, potions are created with the Spell0ToPotion(model)
procedure, returning the potion.

@ENDNODE

@NODE Bugs

@{b}Bug@{ub} @{i}Informal@{ui}. an error or fault, as in a machine or system, esp. in a computer or computer program.

    Probably lots and lots of @{i}horrible@{ui} and @{i}nasty@{ui} bugs, but none known ones in this release.

@ENDNODE

@NODE Future

@{b}Future@{ub}

    ° Improve the docs!
    ° Finish writing learn checkers, cast checkers, and scribe
	checkers on rooms, people, spells and objects.
    ° Add better descriptions of potions and scrolls.
    ° Create other magic items (eg staff, wand etc...)
    ° More spells
    ° Put some thought into the spell levels and costs.
    ° Create a magic shop somewhere.
    ° Create a system for ENHANCING magic spells
    ° Keywords to define the general type of spell
	eg aggressive, divine, fire, elemental, protection
    ° Create monsters that are immune/susceptable to various
	attacks (e.g fire elemental not affected by fire magic, but
	seriously hurt by water/cold magic).
    ° Create a mages guild, and a few quests/adventures
    ° Multi use magic items, including staves and wands.
    ° Add smell descriptions for potions
    ° Add more messages to other people in the same room.
    ° Improve the language translator (get a non mage to
	try reading a scroll!).

    I'm sure theres lots, lots more.

@ENDNODE

@NODE Disclaimer

@{b}Disclaimer@{ub}

  No responsibility or liability will be accepted for any damage that may result from the (mis)use of this material.  All use is at your own risk.  This material is provided "as is" without any warranty implied or otherwise to the fitness or accuracy of this material and documentation.  The  documentation is believed to be correct but the author reserves the right to update the material and/or documentation without notice.

  Some names used in this text are trademarks or registered trademarks.  Their use of these names does not imply that they are free.

@ENDNODE

@NODE Copyright

@{b}Copyright@{ub}

  Copyright???  This is public domain.  Do whatever you want to with it.

  You may copy it, and distribute it in any shape or form.  You are positively @{i}encouraged@{ui} to canibalise this stuff and include it in your own games.


@ENDNODE

@NODE Author

@{B}Author@{UB}

  This was written by Tak Tang, who is a skint and starving student studying Computer Science at Southampton University.


  Please send bug reports, flames, song of praises etc...

		tst92@ecs.soton.ac.uk


@ENDNODE

@node misc

The 'mcast' command can also cast the old style spells provided with
the standard scenario (i.e. actions in a table), so you could
replace the 'cast' verb with the 'mcast' one.  Instructions in the
source code . . .  Incidentally, the old style spells have been
updated to my new style, and made useable by wizards only.  Now you
dont need to have a copy for EACH wizard - you can share the same
code.


To install
----------

    At first, the only mage is SysAdmin, who will have no spells
memorized.  The spells are available in a number of grimoires tucked
away in SysAdmins study.  You should get them and store them somewhere
safe (i.e. lock your study).

Creating spells
---------------

Each spell is a thing, which contains details such as level, power, mana
cost, and spell effect.  The spell effect is just an action.  This allows
the scenario to have a range of spells with the same effect, but different
levels of power.

[more]


Grimoires
---------

A "grimoire" is a book from which a mage can memorize spells.  The spells
in a grimoire's list are empty "things" which are the children of the spell
model.  Furthermore, the grimoires are hierarchical.  i.e. a grimoire will
contain its own spells, and any spells in its parent grimoire.  Why???
This is so that each mage's grimoire begins with a default set of spells
in it (perhaps none?).  They can then go on quests to discover new spells,
and transfer them into their own grimoires for later use.  Or perhaps they
can be taught by a mages guild, or encouraged to swap and trade spells.

Potions
-------

A potion is a spell in drink form.  The main advantage of them is that they
do not require mana, so can be used by non-mages.  They are also handy if
you are short of mana.  The main disadvantage is that they can only affect
the drinker, and hence not all magic spells have a potion form.

Common potions are : healing potions, restore mana potions

Scrolls
-------

A step up from potions, scrolls are spells written down on parchment.  They
can only be used by mages, as they require the mage to expend mana when
they are read.  Their main advantage over potions is that they can be
directed at someone or something.  You can also cast a spell from a scroll
which you might not be high enough level to learn yourself.  Spells are
usually transfered onto scroll so that mages can trade them with each
other.

Final word
----------

  The two files langTrans.m and checker.m are very new, and under
development.  Dont expect any of it to make sense, or to stay the same!



@endnode

