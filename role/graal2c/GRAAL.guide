@database 002e4fd0-0
@master olaf:graal.guide
@$VER: 1.0
@author "Per Thulin"
@(c) "1995"
@index HeddleyAutoIndex
@remark Created with Heddley v1.1 (c) Edd Dumbill 1994

@node "Main" ""
@next "GG_INTRO"

                            GRAAL ON-LINE REFERENCE  
                            =======================

                2.3 (c) Per Thulin / Performance Software 1998

                                @{"Read the News!!!" link "News" 0}

                                         
                    @{" A Very Short Introduction             " link "GG_INTRO" 0}       
                    @{" Machine Requirements                  " link "GG_Requirements" 0}
                    @{" About this Reference                  " link "GG_Reference" 0} 

                    @{" Player interface and shortcut keys    " link "GG_Interface" 0}

                    @{" The Structure of a GRAAL Game         " link "GG_STRUCTURE" 0}     
                    @{" Syntax Conventions                    " link "GG_Syntax" 0}
                    @{" Limitations, Ranges, Reserved Numbers " link "GG_Limits" 0}
                    @{" Special Characters in Text Strings    " link "GG_Vars" 0}
 
                    @{" Statements in the graal.main file     " link "GG_ST_MAIN" 0}
                    @{" Statements in the n.section files     " link "GG_ST_SECT" 0}
                    @{" Statements in the n.room files        " link "GG_ST_ROOM" 0}

                    @{" Conditions                            " link "GG_Conditions" 0}            
                    @{" Commands                              " link "GG_Commands" 0}
 
                    @{" Trouble-shooting                      " link "Troubleshooting" 0}
@endnode

@node "GG_INTRO" " A Very Short Introduction "
@next "GG_Requirements"
@prev "GG_INTRO"


@{fg shine}@{bg fill}A Very Short Introduction@{fg text}@{bg back}

What is GRAAL?

GRAAL is a computer language that lets you create graphic adventures in
a "classic" format. All the tools you need are included except an
art/animation package and music/sound sampler programs and equipment. 

GRAAL has come a long way since its first release, and you can now
customize most aspects of your adventure's look and feel. Starting with
version 2.1, you can even control multiple characters.

If you want  to see what the result may look like, just play the demo of
"Olaf Longhair Goes East", which  is included in the delivery package.
You should also look out for "The GRAAL Herald", a diskmag using GRAAL
itself to display the articles and run mini-demos showing stuff that
isn't included in the "Olaf" demo


@{i}NOTE:@{ui} The registered version of GRAAL contains some programming tools
essential  for the serious adventure creator, for example devices to
compress and encrypt your scripts to make it impossible to crack the
game by looking at the files.

However, the function of the freely distributable version is not
limited in any other way - you may create as large an adventure as you
wish using only the GRAAL program contained in the demo package, if you
have the stamina and perseverence to do so...!
@endnode

@node "GG_Requirements" " Machine Requirements                  "
@next "News"
@prev "GG_INTRO"


@{fg highlight}@{bg fill}MACHINE REQUIREMENTS@{fg text}@{bg back}


GRAAL should run on any machine with enough RAM:, although I haven't
tested it with anything below Workbench 2.05. The games are a bit
sluggish on standard A500's and the like. Isn't everything these days?

To develop GRAAL games, you need the following:

 * A hard disk
 * 2MB RAM


The following is very much recommended:

 * A machine with at least the speed of an A1200
 * Fast RAM
@endnode

@node "News" " News in version 2                     "
@next "GG_Reference"
@prev "GG_Requirements"


@{fg shine}@{bg fill} NEWS IN GRAAL 2.3@{fg text}@{bg back}


Here are the changes and additions to the GRAAL language in 2.3



@{"Major name change to image related commands!" link "imagesyntax" 0}


@{"RESUME KEEP" link "GG_RESUME" 0}     new parameter that allows you to keep changes to
                data made between a MARK and this RESUME.

@{"SPEECH_LAYOUT:" link "ST_SPEECHLAYOUT" 0}  graal.main statement that makes it possible to
                do all sorts of nice things with text displays.

@{"SETTEXT" link "Document_1" 0}         command that allows you to do the same nice things 
                in subsequent TEXT commands.

@{"HOTSP" link "GG_HOTSP" 0}           this command, as well as the hotspot parameter of all
                the ...IMGS: statements, has been given new x-axis 
                capabilities. Mostly because the new CARTOON speech 
                style needs it! 

@{"NAME" link "GG_NAME" 0}            now accepts optional object number as first parameter.

@{"IFNOTROOM" link "GG_IFNOTROOM" 0}       new condition that's fairly self-explanatory.

@{"PLAYMACRO" link "GG_PLAYMACRO" 0}       command to play pre-recorde macros from within
                a script

@{"SPEECHMODE" link "GG_SPEECHMODE" 0}      a command to switch between spoken text, displayed 
                text, or both.

@{"CHAR:" link "ST_CHAR" 0}           Two new parameters added. (The only mandatory script
                change in 2.3!)

@{"MUSIC" link "GG_MUSIC" 0}           command to switch music on and off (as with "M" key).

Check out http://www.GeoCities.com/TimesSquare/Lair/7400 - the GRAAL
homepage. Updated with this release!

Questions? Comments? Mail:

pethu@hotmail.com
@endnode

@node "GG_Reference" " About this Tutorial                   "
@next "GG_STRUCTURE"
@prev "News"


@{fg shine}@{bg fill}About this Reference@{fg text}@{bg back}


This guide is the definitive authority on all details of all GRAAL
statements, conditions, and commands. However, before you can write your
own games, you also need to know about the overall structure and idea
behind GRAAL, which are subjects we only touch upon in this file.

Therefore, I recommend all developers to read the GRAAL Manual prior to
emerging too deep into the art of GRAAL writing. The GRAAL Manual is
included in the GRAAL unregistered development package.
@endnode

@node "GG_STRUCTURE" " The Structure of a GRAAL Game "
@next "GG_Syntax"
@prev "GG_Reference"


@{fg shine}@{bg fill}GRAAL script structure@{fg text}@{bg back}

A GRAAL adventures is based on a number of script
files, related to each other in the following way:



                            +-------------+
                            | graal.main  |
                            +------+------+
                                   |
                +------------------+----------------+
                |                                   |
           +----+-----+                        +----+-----+
           |n.section |         . . .          |n.section | 
           +----+-----+                        +----+-----+
                |                                   |
       +--------+--------+                  +---------------+
       |        |        |                  |               |
   +---+---++---+---++---+---+          +---+---+       +---+---+
   |n.room ||n.room ||n.room |          |n.room |       |n.room |
   +-------++-------++-------+          +-------+       +-------+


There is always a @{"graal.main" link "GG_ST_MAIN" 0} file, describing the
main characteristics of the game and of the main character (which is the
one the player controls and commands).

The entire adventure is divided into locations or
"rooms" as they are called  in GRAAL. The specifics of each room is
defined in a @{"n.room" link "GG_ST_ROOM" 0} file

The rooms may be grouped into sections, as shown above. Each section has
a @{"n.section" link "GG_ST_SECT" 0} file.

The general idea is that if a player can issue a
certain command or do a  certain thing in just one specific room, the
GRAAL code to handle that action  should be placed in the corresponding
.room script file. If the action can  occur anywhere in the section ,
the code is placed in the .section file; and if the action is something
that can occur anywhere in the adventure, it is  taken  care of in the
graal.main file. 

Whenever the player inputs a command, first the current
room file is scanned  for appropriate action, then the section file,
and lastly the graal.main file.  This is why the graal.main file should
always contain general "safety nets" to  handle most of the totally
off-the-wall and generally stupid things a player  may try during the
game!

Apart from the three script file types above, there are two other
types with  specific purposes:

@{".scene" alink "1.scene/1.scene/main" 0} files, containing the commands making up an
animated,  non-interactive "cut-scene".

@{".ptrn" alink "1.ptrn/main" 0} files, containing animation patterns too big and complex to
fit into the code of a script file.
@endnode

@node "GG_Syntax" " Syntax Conventions "
@next "GG_Limits"
@prev "GG_STRUCTURE"


@{fg shine}@{bg fill} GRAAL Syntax @{fg text}@{bg back}



@{u}@{fg highlight}Script Syntax@{uu}@{fg text}

Scripts can normally contain @{b}empty lines@{ub}, @{b}comment lines@{ub}, and @{b}statement
lines@{ub}. (Exceptions are the @{b}.scene@{ub} files, which only contain commands,
and @{b}.ptrn@{ub} files, which only contain animation patterns.)

Comment lines always begin with the characters @{b}/*@{ub}.

Statement lines always begin with the statement followed by a colon and
one blank space. After that comes the parameters separated by
semicolons, but without spaces in between, like this:

@{b}STATEMENT: parameter;parameter;parameter;...;parameter@{ub}

In the following statements, each parameter is a condition or command:

  @{"ACTION" link "ST_ACTION" 0}     -  Actions taken for player input 
  @{"DACT" link "ST_DACT" 0}       -  Actions executed when entering a new room
  @{"LACT" link "ST_LACT" 0}       -  Actions taken when player chooses a dialogue line

Each condition and command then has its own "internal" syntax. Usually,
parameters within a command are separated by colons (,).

Some statements and command allow you to leave parameter positions
"blank" to retain a previous value or set a default value. "blank" does
not mean "empty": You MUST enter a blank space in the position! For
example, if you wish to leave the two middle parameters of the SHOW
command empty, this is the way to do it:

SHOW 2, , ,4

(This example tells GRAAL to use image number 4 to display object 2, but
let the image remain in its old place, since we left the x and y
parameters blank.)



@{u}@{fg highlight}Command and Statement Notation@{uu}@{fg text}

@{b}UPPERCASE@{ub}

Type as written. 


@{b}lowercase@{ub}

Replace with value of specified type.


@{b}list@{ub}

A list of values separated with | characters may be used. In conditions,
any value in the list will make the condition TRUE. In commands, one of
the alternatives in the list will be chosen at random each time the
command is encountered during gameplay.


@{b}option1|option2@{ub}

One of the options can be chosen.


@{b}[parameter,]@{ub}

This parameter is optional.



@{u}@{fg highlight}Referring to the Contents of the Input Sentence@{uu}@{fg text}

When the scripts are searched for commands to execute, what happens is
based entirely on how the current input sentence from the player looks.

IN this reference, the first object in the current command sentence
input by the player is referred to as @{b}OBJ1@{ub}, and the second - if any - as
@{b}OBJ2@{ub}. The "command" itself is referred to as the @{b}VERB@{ub}. 



@{u}@{fg highlight}Referring to Objects and Images@{uu}@{fg text}

An @{b}object number@{ub} can be an ordinary number (@{b}n@{ub}),  a room object number
(@{b}ROBJn@{ub}) or a section object number (@{b}SOBJn@{ub}).

An @{b}image number@{ub} can be an ordinary global image (@{b}n@{ub}), a  room image
(@{b}RIMGn@{ub}) or a section image (@{b}SIMGn@{ub}).
@endnode

@node "GG_Limits" " Limitations, Ranges, Reserved Numbers "
@next "GG_Vars"
@prev "GG_Syntax"


@{fg shine}@{bg fill} GRAAL Limits, Ranges & Reserved Numbers @{fg text}@{bg back}
   

These are basic technical limitations to GRAAL 2. 


@{i}SCREEN GRAPHICS@{ui}

@{b}SCENE AREA@{ub}: Background pictures must be lowres, 32 or 64 (EHB) colours,
and between 320 and 640 pixels wide. (IFF picture files used for clipart
must also be the same number of colours.)

@{b}COMMAND AND DIALOGUE AREAS@{ub}: Pictures used must be hires, and 640 pixels
wide. (No more than 16 colours.)


@{i}BOBS@{ui}


Allowed BOB numbers for general use: 1-59

BOB numbers assigned:

  60-63 - used for system graphics like the display of messages and 
          names of objects and exits in the scene area


@{i}ANIMATION@{ui}

Animation channels allowed for general use: 2-15

Channel 1 is normally used for the main character animation, although
when characters are defined by @{"CHAR:" link "ST_CHAR" 0} statements  any channel may be used
for this instead (and is defined by the animation channel set for the
object depicting the character).


@{i}STATEMENT AND COMMAND LIMITS@{ui}

                                           Default 
  Item                                      Limit  Alterable 
  ----------------------------------------- ------ -------------- 
  Max no of DACT lines in room file                 Y (graal.main) 
  Max no of concurrent dialogues               6    Y   -"-
  Max no of dialogue lines per dialogue       30    Y   -"-
  Max no of LACT statements per dialogue      90    Y   -"-
  Max no of ACTION lines in a room                  Y   -"-
  Max no of ACTION lines in a section               Y   -"-
  Number of flags for each object              6    N 
  Number of flags for each room               20    N 
  Maximum number of floors in a room          12    N
  Maximum number of paths in a room           12    N 
  Max.no of objects in each inventory         50    N
  Number of controllable characters            4    N
  Number of inventories                        4    N
  Number of string varibales                  12    N
  Max no of objects in current room           30    N
   (displayed simultaneously, not counting
   @{"BOBON" link "GG_BOBON" 0}, @{"STATIC:" link "ST_STATIC" 0}, @{"ANIM:" link "ST_ANIM" 0} graphics)
@endnode

@node "GG_Vars" " Variables in Text Strings "
@next "GG_Animation"
@prev "GG_Limits"


@{fg shine}@{bg fill}Special text characters@{fg text}@{bg back}


The following special character strings are replaced with variable
values etc. when used in SAY, THINK, RESP, and similar commands

  @{b}\ @{ub}       is replaced with a line break 

  @{b}#R#n#f#@{ub}  will be replaced by the value held in flag f for room n 

  @{b}#O#n#f#@{ub}  will be replaced by the value held in flag f for object n

  @{b}#VARn#@{ub}    will be replaced by the string held in string variable n
 
  @{b}#OBJ1@{ub}    will be replaced by the name of OBJ1 

  @{b}#OBJ2@{ub}    will be replaced by the name of OBJ2 
 
  @{b}#Won@{ub}     will be replaced by determination word n for object o
           (That is, o should be 1 for OBJ1, or 2 for OBJ2.)

  @{b}#TIME@{ub}    will be replaced by the current game time in the format
           specified in the @{"TIME_FORMAT" link "ST_TIMEFORMAT" 0} statement..

  @{b}#DATE@{ub}    will be treplaced by the current game date in the format 
           specified by the @{"DATE_FORMAT" link "ST_DATEFORMAT" 0} statement.

Example: OBJ1 is "apple", and word 1 for the object "apple" has been
defined as "an". The command


   SAY Just #W11 #OBJ1!

will then cause the character to  say 

   Just an apple!
@endnode

@node "GG_Commands" "GRAAL Commands"
@next "GG_WEEKDAY"
@prev "GG_Commands"


@{bg fill}GRAAL Commands:@{bg back}


These are all the commands that can be used in the @{"ACTION" link "ST_ACTION" 0}, @{"DACT" link "ST_DACT" 0}, and
@{"LACT" link "ST_LACT" 0} statements, as well as in cutscene files.

@{i}General program flow control@{ui}
 @{" W(ait)         " link "GG_WAIT" 0} Make a pause
 @{" EXIT           " link "GG_EXIT" 0} Stop searching for commands to execute
 @{" REDO           " link "GG_REDO" 0} Re-run current input sentence
 @{" CUTSCENE       " link "GG_CUTSCENE" 0} Execute a cutscene
 @{" COMAREA        " link "GG_COMAREA" 0} Hide or show the command area
 @{" MARK           " link "GG_MARK" 0} Mark current position 
 @{" RESUME         " link "GG_RESUME" 0} Resume marked position 
 @{" QUIT           " link "GG_Quit" 0} Quit GRAAL
 @{" SAVE           " link "GG_SAVE" 0} Save game at the last MARK 
 @{" LOAD           " link "GG_LOAD" 0} Load a saved game 
 @{" EXEC           " link "GG_EXEC" 0} Execute a cli command or program
 @{" TRACE          " link "GG_TRACE" 0} Start or stop single-step trace mode

@{i}Timed events@{ui}
 @{" DOAFTER        " link "GG_DOAFTER" 0} Set a timer
 @{" CANCEL         " link "GG_CANCEL" 0} Cancel a timer

@{i}Dialogue control@{ui}
 @{" DSET           " link "GG_DSET" 0} Start / change a dialogue
 @{" LINE           " link "GG_LINE" 0} Change dialogue line number
 @{" EDLG           " link "GG_EDLG" 0} End a dialogue

@{i}Sentence control@{ui}
 @{" OBJ1 / OBJ2    " link "GG_OBJ" 0} Change object number
 @{" VERB           " link "GG_VERB" 0} Change verb number

@{i}Room control@{ui}
 @{" GOTO           " link "GG_GOTO" 0} Go to a new room
 @{" SETRF          " link "GG_SETRF" 0} Set room flag value 
 @{" ADDRF          " link "GG_ADDRF" 0} Add to room flag value 
 @{" DECRF          " link "GG_DECRF" 0} Decrease room flag value
 @{" SHOWEXIT       " link "SHOWEXIT" 0} Show a hideen exit 
 @{" HIDEEXIT       " link "HIDEEXIT" 0} Hide an exit

@{i}"Speech"@{ui}
 @{" SAY            " link "GG_SAY" 0} Make character speak
 @{" THINK          " link "GG_THINK" 0} Make character think
 @{" RESP           " link "GG_RESP" 0} Make speaking partner respond

@{i}Object manipulation@{ui}
 @{" HANDLE         " link "GG_HANDLE" 0} Make character handle object 
 @{" PICK           " link "GG_PICK" 0} Make character pick up object
 @{" GET            " link "GG_GET" 0} Add object to inventory
 @{" PUT            " link "GG_REMOVE" 0} Remove object from inventory
 @{" INVENTORY      " link "GG_INVENTORY" 0} Change the inventory
 @{" NAME           " link "GG_NAME" 0} Alter the name of an object
 @{" ICON           " link "GG_ICON" 0} Alter the icon image for inventory
 @{" PREP           " link "GG_PREP" 0} Alter the preposition for an object
 @{" NEWOBJ         " link "GG_NEWOBJ" 0} Create or modify an object 
 @{" SETOF          " link "GG_SETOF" 0} Set object flag value 
 @{" ADDOF          " link "GG_ADDOF" 0} Add to object flag value 
 @{" DECOF          " link "GG_DECOF" 0} Decrease object flag value

@{i}Object display@{ui}
 @{" OMOVE          " link "GG_OMOVE" 0} Move and animate object
 @{" SHOW           " link "GG_SHOW" 0} Show object 
 @{" HIDE           " link "GG_HIDE" 0} Hide object
 @{" OBJONTOP       " link "GG_OBJONTOP" 0} Put object on top of other objects

@{i}Main character display@{ui}
 @{" CIMG           " link "GG_CIMG" 0} Change character image
 @{" CMOVE          " link "GG_CMOVE" 0} Move character
 @{" WALK_SPEED     " link "GG_WALK_SPEED" 0} Main character walking speed
 @{" MOBJ           " link "GG_MOBJ" 0} Move character next to object
 @{" MEXIT          " link "GG_MEXIT" 0} Move character to exit
 @{" CPOS           " link "GG_CPOS" 0} Change character position
 @{" CHAR           " link "GG_CHAR" 0} Hide / display character
 @{" SWITCH         " link "GG_SWITCH" 0} Switch controlled character
 @{" FOLLOW         " link "GG_FOLLOW" 0} Make another character follow 

@{i}Floor control@{ui}
 @{" FLOOR          " link "GG_FLOOR" 0} Define floor
 @{" NFLOOR         " link "GG_NFLOOR" 0} Set number of floors
 @{" SETFLOOR       " link "GG_SETFLOOR" 0} Change character's floor

@{i}String manipulation@{ui}
 @{" PROMPT         " link "GG_PROMPT" 0} Prompt player for string input
 @{" SETVAR         " link "GG_SETVAR" 0} Set a string variable

@{i}Audio control@{ui}
 @{" TRACK          " link "GG_TRACK" 0} Soundtracker module control
 @{" EFFECT         " link "GG_EFFECT" 0} Pre-load a sound effect
 @{" SOUND          " link "GG_SOUND" 0} Play a pre-loaded sound effect
 @{" SAMLOAD        " link "GG_SAMLOAD" 0} Load raw or IFF sample
 @{" SAM            " link "GG_SAMPLAY" 0} Sample control

@{i}Graphics control@{ui}
 @{" CLPART         " link "GG_CLPART" 0} Load a clipart picture file
 @{" IMGS           " link "GG_IMGS" 0} Grab images from clipart picture
 @{" HOTSP          " link "GG_HOTSP" 0} Alter the hotspot of an image
 @{" LIGHTS         " link "GG_LIGHTS" 0} Fade scene area in or out
 @{" COLOUR         " link "GG_COLOUR" 0} Change a single colour
 @{" FADE           " link "GG_FADE" 0} Fade one colour to another
 @{" CAMERA         " link "GG_CAMERA" 0} Pan the camera to any part of background
 @{" TITLE          " link "GG_TITLE" 0} Display / remove a title screen
 @{" TYPE           " link "GG_TYPE" 0} Type text on title screen
 @{" TEXT           " link "GG_TEXT" 0} Display text in scene area
 @{" BOBON          " link "GG_BOBON" 0} Show a BOB
 @{" BOBOFF         " link "GG_BOBOFF" 0} Remove a BOB
 @{" PIMG           " link "GG_PIMG" 0} Paste an image
 @{" COMGR          " link "GG_COMGR" 0} Paste an image in command area

@{i}Time and date manipulation@{ui}
 @{" SETDATE        " link "GG_SETDATE" 0} Set the date
 @{" SETTIME        " link "GG_SETTIME" 0} Set the time
 @{" ADDTIME        " link "ADDTIME" 0} Advance the time
 @{" SAVETIME       " link "GG_SAVETIME" 0} Save the current time and date
 @{" RESTORETIME    " link "GG_RESTORETIME" 0} Restore the saved time and date

@{i}Special Cutscene commands:@{ui}
 @{" NOBREAK        " link "GG_NOBREAK" 0} Disable [Esc] in cutscene
 @{" FINAL          " link "GG_FINAL" 0} Marks cutscene [Esc] resume point
@endnode

@node "GG_Conditions" "GRAAL Conditions"
@next "GG_IFOBJ"
@prev "GG_Conditions"


@{bg fill}GRAAL Conditions:@{bg back}

These are the conditions that can be used in the @{"ACTION" link "ST_ACTION" 0}, @{"DACT" link "ST_DACT" 0}, @{"LACT" link "ST_DACT" 0}, and
@{"LINE" link "ST_LINE" 0} statements.

 @{" IFOBJ / IFOBJ2     " link "GG_IFOBJ" 0} Test objects in the input sentence
 @{" IFOF / IFOF2       " link "GG_IFOF" 0} Test object flags
 @{" IFROOM             " link "GG_IFROOM" 0} Test current room
 @{" IFRF               " link "GG_IFRF" 0} Test room flags
 @{" IFCARR / IFNOTCARR " link "GG_IFCARR" 0} Test if object is in inventory
 @{" IFPICK             " link "GG_IFPICK" 0} Test if object can be picked up
 @{" IFTYPE             " link "GG_IFTYPE" 0} Test object types
 @{" IFSPOS             " link "GG_IFSPOS" 0} Test room starting position
 @{" IFCIMG             " link "GG_IFCIMG" 0} Test current character image
 @{" IFFLOOR            " link "IFFLOOR" 0} Test the current floor
 @{" IFDATE             " link "GG_IFDATE" 0} Test the date
 @{" IFTIME             " link "GG_IFTIME" 0} Test the time
 @{" IFWEEKDAY          " link "GG_WEEKDAY" 0} Test the day of the week
 @{" IFNOTSAVEDISK      " link "GG_IFNOTSAVEDISK" 0} Test if the saved games disk is present
 @{" IFEXISTS           " link "GG_IFEXISTS" 0} Test if a certain saved game exists
 @{" IFCHAR             " link "GG_IFCHAR" 0} Test the currently controlled character
 @{" IFHERE             " link "GG_IFHERE" 0} Test if an object is in the current room
 @{" IFVAR              " link "GG_IFVAR" 0} Test the contents of a string variable
@endnode

@node "GG_Animation" "animation sequences"
@next "GG_Interface"
@prev "GG_Vars"


@{fg shine}@{bg fill}Basics about GRAAL Animation@{fg text}@{bg back}

Most simple animation sequences used in GRAAL have the following
format:

 @{b} A n,(image,time)(image,time)(image,time)...(image,time)@{ub}

@{b}n@{ub} is a number deciding how many times the animation sequence is played -
in GRAAL, it is set to 0 in most cases, which means the animation will
go on "forever". Forever in this case means "until GRAAL decides to put
a stop to it".

@{b}image@{ub} is an image number.

@{b}time@{ub} is the time the image is displayed before the next one comes on
screen (in 50ths of a second on PAL machines).

Example: A 0,(RIMG1,12)(RIMG2,12)(RIMG3,12)(RIMG4,12) would play the
sequence of four room images over and over again. Note that the commas
are not GRAAL parameter separators in this case - they are all part of
the same sequence definition!
@endnode

@node "GG_Interface" " The GRAAL player interface"
@next "GG_Interface"
@prev "GG_Animation"


@{fg shine}@{bg fill}The GRAAL Player Interface@{fg text}@{bg back}


Although the graphics of the player interface can be changed very much
to your liking, all  GRAAL games play in pretty much the same way. It
presents the alternatives to the user in a very clear and precise way to
let them know exactly what objects can be manipulated and what options
are available at any time.

This is an attempt to explain the elements of GRAAL's intuitive control
method. which is really much harder than just doing it:) It also
contains some "style guide" tips...



@{fg shine}SENTENCE AND OBJECT DISPLAYS: @{fg text}


@{i}OBJECTS IN THE SCENE AREA: @{ui}

As soon as the mouse cursor moves over an object with a name consisting
of anything but an empty string, its name appears above the cursor.

If there is a default command associated with the object, and neither a
verb or other object has actually been clicked by the player, the
default command for the object beneath the mouse cursor is shown in the
sentence box. 

If a verb has been previously clicked, the name of the object also
appears in the sentence box. IF the verb / object combination requries a
second object to beclicked, the appropriate preposition is also
displayed in the sentence box.


@{i}OBJECTS IN THE INVENTORY:@{ui}

Pointing to an object in the inventory works the same way as pointing to
an object in the scene area, with the exception that its name does not
appear above the cursor - instead, it appears in the sentence box IF a
scene area object has not been selected already.


@{i}VERBS:@{ui}

If you move the mouse cursor over a verb in the command area, and no
verb has been clicked, the name of the verb appears in the sentence box.
Once more, IF an object is already there and the verb/object combination
requires a second object, the preposition will also be shown.


@{i}EXITS:@{ui}

If you move the mouse pointer over an exit, and the name of the exit is
anything but an empty string, its name apperas above the mouse cursor.
Note that object and exit cursor texts in most cases SHOULD be coloured
differently, so that players don't leave the room and waste a lot of
time by accident.

If you try to use an exit, the message "GO TO exit name" will be shown
in the sentence box. If the exit name is blank, no message at all is
shown.


@{fg shine}KEYBOARD KEYS@{fg text}


@{i}PLAYER KEYS@{ui}

These keys are avaliable regardless of whether the system is in
developer or runtime mode (although some of them may be disabled by
special statements in graal.main):

  @{b}S@{ub} and @{b}L@{ub}   both bring up the same save/load requester.
            (May be disabled by the DISABLE_SAVE: statement.)
  @{b}space@{ub}     puts the game in pause mode. Any key continues.
  @{b}F@{ub}         displays the amount of free memory (mainly for
            debugging purposes.)
  @{b}M@{ub}         toggles sound on and off.
  @{b}V@{ub}         displays the adventure name and version information.
  @{b}I@{ub}         increases the speed of sentence displays.
  @{b}D@{ub}         decreases the speed of sentence displays.
  @{b}Q@{ub}         quits the game. (May be disabled by the DISABLE_QUIT:
            statement, if you provide another way to QUIT.)
  @{b}Esc@{ub}       jumps to the end of a cutscene
  @{b}.@{ub}         ends a pause or sentence display

  @{b}left mouse button @{ub}   Select an object, exit, command or dialogue
                       alternative
  @{b}right mouse button@{ub}   Select default object action or end a pause 
                  

@{i}DEVELOPER KEYS@{ui}

  @{b}G@{ub}         brings up the monitor screen.
  @{b}R@{ub}         starts a macro recording. Pressing R again stops the
            macro recording and asks for a name for the new macro.
  @{b}P@{ub}         asks for a macro name, then starts playing it.
  @{b}ctrl+c@{ub}    aborts GRAAL. Use only in emergencies, as this does
            not clean up memory, leaves FONTS: assigned to RAM:FONTS,
            etc.
  @{b}leftA+m @{ub}  (A="Amiga") switches between GRAAL and Workbench. Note that
            programs running concurrently will be sluggish, and only
            the fonts in your GRAAL FONTS: drawer will be available.
            (That's why I have included the DPAINT font in the drawer,
            because I sometimes need to run that in parallell...)

All developer keys are diabled in an encrypted game (registered users
only), unless a DEBUG: statement in graal.main specifically asks for
them to be turned on.
@endnode

@node "GG_IFOBJ" " IFOBJ / IFOBJ2 "
@next "GG_IFPICK"
@prev "GG_Conditions"


@{fg shine}@{bg fill}IFOBJ Condition@{fg text}@{bg back} 

@{i}Test an object in the current sentence@{ui}


  @{b}IFOBJ obj|list@{ub}

This condition is TRUE if the object number of OBJ1 is equal to obj,  or
to any one of the objects in a list.


  @{b}IFOBJ2 object number | list@{ub}

Same thing, but checks OBJ2.
@endnode

@node "GG_IFPICK" " IFPICK "
@next "GG_IFOF"
@prev "GG_IFOBJ"


@{fg shine}@{bg fill}IFPICK Condition@{fg text}@{bg back} 

@{i}Test if an object can be picked up@{ui}


 @{b} IFPICK [obj]@{ub}                

This condition is TRUE if OBJ1 (default) or the specified object can be
picked up.


Example:

 @{b} IFPICK;MOBJ;HANDLE;PICK;HANDLE -1@{ub}

Move to object and pick it up only if it is defined as "pickable"!
@endnode

@node "GG_IFOF" " IFOF "
@next "GG_IFROOM"
@prev "GG_IFPICK"


@{fg shine}@{bg fill}IFOF Condition@{fg text}@{bg back} 

@{i}Test the value of an object flag@{ui}


  @{b}IFOF [obj,]flag<op>value|list@{ub}

This condition is TRUE if the flag  of OBJ1, or the specified object,
passes the test (see <op> below).

  @{b}IFOF2 flag<op>value|list@{ub}

This condition is TRUE if the flag of OBJ2 passes the test. This form is
mainly kept for backwards compatibility - specify the object number of
OBJ2 in the format above instead, if you have a choice.


@{b}<op>@{ub}

op an be any of the standard logical operators: =, >, <, <>, >=, <=


@{b}value@{ub}

The value can be a fixed integer number or a reference to another flag.
The format  for flag references is #R#roomnumber#flag# or
#O#objectnumber#flag.

NOTE: flag references can only be used when testing a single value. That
is, you cannot specify a list of flag references to test.


@{b}list@{ub}

If a list of values is specified, the condition is true if one of the
list values makes the condition true.

(There is no point in specifying a list if the operator is <> - c'mon,
think about it!!)

Examples:

 IFOF 2=3

is true if object flag 2 of OBJ1 is 3


 IFOF 4,2>3

is true if object flag 2 of object 4 is greater than 3


 IFOF 4,2=2|4|6|8

is true if object flag 2 of object 4 is 2,4,6, or 8.


 IFOF 7,4<>#R#3#1#

is true if object flag 4 of object 7 is not equal to room flag 1 of room
3.
@endnode

@node "GG_IFROOM" " IFROOM "
@next "GG_IFNOTROOM"
@prev "GG_IFOF"


@{fg shine}@{bg fill}IFROOM Condition@{fg text}@{bg back}

@{i}Test the current room@{ui}


  @{b}IFROOM room|list@{ub}

This condition is true if the current room matches the room number(s)
specified.
@endnode

@node "GG_IFNOTROOM" "IFNOTROOM"
@next "GG_IFRF"
@prev "GG_IFROOM"


@{fg shine}@{bg fill}IFNOTROOM Condition@{fg text}@{bg back}

@{i}The opposite of IFROOM@{ui}


 @{b}IFNOTROOM room|list@{ub}

Does the opposite of what @{"IFROOM" link "GG_IFROOM" 0} does.
@endnode

@node "GG_IFRF" " IFRF "
@next "GG_IFCARR"
@prev "GG_IFNOTROOM"


@{fg shine}@{bg fill}IFRF Condition@{fg text}@{bg back} 

@{i}Test the value of a room flag@{ui}


  @{b}IFRF [room,]flag<op>value|list@{ub}

The operator <op> can be any of the following logical operators:

=, <, >, <>, >=, <=

The IFRF condition works the same way as the @{"IFOF" link "GG_IFOF" 0} condition, so click
that to see a number of examples.
@endnode

@node "GG_IFCARR" " IFCARR / IFNOTCARR "
@next "GG_IFTYPE"
@prev "GG_IFRF"


@{fg shine}@{bg fill}IFCARR Condition@{fg text}@{bg back}

@{i}Test if object is in inventory@{ui}


  @{b}IFCARR [obj]@{ub}

This condition is TRUE if the specified object is in the inventory.  If
no object number is specified, OBJ1 is assumed.


  @{b}IFNOTCARR [obj]@{ub}

TRUE if the object is NOT in the inventory.
@endnode

@node "GG_IFTYPE" " IFTYPE "
@next "GG_IFSPOS"
@prev "GG_IFCARR"


@{fg shine}@{bg fill}IFTYPE Condition@{fg text}@{bg back}

@{i}Test if an object is of specified type(s)@{ui}


 @{b} IFTYPE type|list@{ub}

This condition is TRUE if the type character matches any of the
characters defined in the object type for OBJ1. For example, in standard
GRAAL notation, an object defined as DW is (D)ead and made of (W)ood.
IFTYPE D would be true, as would IFTYPE S|W (checking if the object is
of either stone or wood).

 @{b} IFTYPE2 type|list@{ub}

This condition checks OBJ2 according to the same rules as described for
OBJ1 above.
@endnode

@node "GG_IFSPOS" " IFSPOS             "
@next "GG_IFCIMG"
@prev "GG_IFTYPE"


@{fg shine}@{bg fill}IFSPOS Condition@{fg text}@{bg back}

@{i}Test which starting position was last used@{ui}


  @{b}IFSPOS spos|list@{ub}

This condition is TRUE, if the last GOTO command (or START_ROOM
statement) pointed to the specified starting position (= START_POS
statement). 

Its main use is setting the room up in different ways in DACT
statements, depending on which entrance was being used.
@endnode

@node "GG_IFCIMG" " IFCIMG             "
@next "GG_IFCHAR"
@prev "GG_IFSPOS"


@{fg shine}@{bg fill}IFCIMG Condition@{fg text}@{bg back}

@{i}Test the currently displayed character image@{ui}


 @{b} IFCIMG image|list@{ub}

This is TRUE if the image used to display the main character matches the
number given in the condition. It could, for example, be useful in
creating "stall anims" (see @{"DOAFTER" link "GG_DOAFTER" 0}) and other main character animations
that should look different depending on the main character's current
appearance.
@endnode

@node "GG_IFCHAR" "IFCHAR Condition"
@next "GG_IFHERE"
@prev "GG_IFCIMG"


@{fg shine}@{bg fill}IFCHAR Condition@{fg text}@{bg back}

@{i}Tests which character is currently controlled by the player (in multiple
character games)@{ui}


  @{b}IFCHAR number@{ub}

This condition is TRUE if the character currently under player control
matches the character number specified. Character numbers can be between
1 and 4. Character 1 is the initial, default character which must always
be defined.

See also: @{"CHAR:" link "ST_CHAR" 0} statement, @{"SWITCH" link "GG_SWITCH" 0} command
@endnode

@node "GG_IFHERE" "IFHERE Condition"
@next "IFFLOOR"
@prev "GG_IFCHAR"


@{fg shine}@{bg fill}IFHERE Condition@{fg text}@{bg back}

@{i}Tests if an object is in the room@{ui}


  @{b}IFHERE obj@{ub}

This condition is TRUE if the specified object is in the current room.

In most normal cases, you don't need for the presence of an object - the
only way it can show up as OBJ1 or OBJ2 in an input sentence from the
player is if it is available! However, this condition comes in handy
when the presence or absence of something movable influences the
gameplay  even though the object is not directly used in input
sentences.
@endnode

@node "IFFLOOR" " IFFLOOR            "
@next "GG_IFDATE"
@prev "GG_IFCHAR"


@{fg shine}@{bg fill}IFFLOOR Condition@{fg text}@{bg back}

@{i}Tests the current floor@{ui}


  @{b}IFFLOOR floor|list@{ub}


This condition is true if the main character is currently on any of the
specified floors.
@endnode

@node "GG_IFDATE" " IFDATE             "
@next "GG_IFTIME"
@prev "IFFLOOR"


@{fg shine}@{bg fill}IFDATE Condition@{fg text}@{bg back}

@{i}Test the game-date@{ui}


 @{b} IFDATE <op>date@{ub}

@{b}<op>@{ub}

is one of the logical operators >, <, or =

@{b}date@{ub}

must be in the format year*10000+month*100+date. For example, August 1,
1996 is specified as

19960801


The date can also be specified as a reference to a room or object flag
holding a date value (see SETOF and SETRF). The format is
#R#roomnumber#flag# or #O#objectnumber#flag#.


Examples:


IFDATE =19960801

is true if GRAAL's calendar is equal to August 1, 1996.


IFDATE <19960801

is true if GRAAL's calendar has not yet reached August 1, 1996


IFDATE >19960801

is true if the date has passed.


IFDATE <#R#4#1#

is true if the date is less than the value held in room flag 1 of room
4.
@endnode

@node "GG_IFTIME" " IFTIME             "
@next "GG_IFNOTSAVEDISK"
@prev "GG_IFDATE"


@{fg shine}@{bg fill}IFTIME Condition@{fg text}@{bg back}

@{i}Test the game-time@{ui}


  @{b}IFTIME <op>time@{ub}

@{b}<op>@{ub}

is one of the logical operators >, <, or =

@{b}time@{ub}

must be specified as hours*100+minutes (and always in 24-hour format,
regardless of what the TIME_FORMAT: statement says).

So, 2:30 pm (or 14:30 in 24-hour format) is specified as

1430


The time can also be sepcified as a reference to a room or object flag
holding a time value (see SETOF and SETRF). The format is
#R#roomnumber#flag# or #O#objectnumber#flag#.


Examples:


IFTIME =1130

is true if the game clock is 11:30


IFTIME <1130

is true if the clock is less than 11:30


IFTIME >1130

is true if the clock is past 11:30


IFTIME <#O#1#8#

is true if the time is less than the value held in object flag 8 of
object 1.
@endnode

@node "GG_IFNOTSAVEDISK" " IFNOTSAVEDISK      "
@next "GG_IFEXISTS"
@prev "GG_IFTIME"


@{fg shine}@{bg fill}IFNOTSAVEDISK Condition@{fg text}@{bg back}

@{i}Checks for a saved games disk@{ui}


  @{b}IFNOTSAVEDISK@{ub}

This is a little more than just a condition. If GRAAL comes across it
when a saved games disk is not available, it prompts the player to
insert it. The condition only becomes TRUE if the player cancels the
"insert saved games disk" procedure.

It is only intended to be used in your own save/load rooms. Say that you
have made room 50 your own save/load screen. From any room, you invoke
the save/load room in this way:

MARK;GOTO 50,1

(Note that the MARK is essential for any SAVE to work...)

In the very first DACT: line of your save room, you should place the
following:

DACT: IFNOTSAVEDISK;RESUME


This ensures that the rest of the room actions will only be accessible
if a saved games disk is available for coming SAVE and LOAD commands.


See also: The @{"SAVE" link "GG_SAVE" 0} command for more info on coding personal save/load
routines.
@endnode

@node "GG_IFEXISTS" " IFEXISTS           "
@next "GG_IFVAR"
@prev "GG_IFNOTSAVEDISK"


@{fg shine}@{bg fill}IFEXISTS Condition@{fg text}@{bg back}

@{i}Checks if a certain saved game file exists@{ui}


  @{b}IFEXISTS game_no@{ub}

This is TRUE if a saved game file corresponding to game_no exists, and
it is valid for the current version of the adventure and GRAAL driver.

See also: The @{"SAVE" link "ST_DISSAVE" 0} command for more info on coding your own save/load
routines.
@endnode

@node "GG_IFVAR" "IFVAR Condition"
@next "GG_IFVAR"
@prev "GG_IFEXISTS"


@{fg shine}@{bg fill}IFVAR Condition@{fg text}@{bg back}

@{i}Tests the contents of a string variable@{ui}


 @{b} IFVAR var<op>string|list@{ub}


<op> can be either "=" or "<>"

The test is TRUE if variable @{b}var@{ub} meets the condition.

Example:

IFVAR 8=Hello world

is true if variable 8 is equal to the string "Hello world".

IFVAR 3<>Anna|Bobby|Charlie

is true if the variable is neither "Anna", "Bobbie", nor "Charlie".

See the @{"PROMPT" link "GG_PROMPT" 0} and @{"SETVAR" link "GG_SETVAR" 0} commands
@endnode

@node "GG_WEEKDAY" " IFWEEKDAY          "
@next "GG_WAIT"
@prev "GG_Commands"


@{fg shine}@{bg fill}IFWEEKDAY Condition@{fg text}@{bg back}

@{i}Tests the day of the week@{ui}


 @{b} IFWEEKDAY day_number|list@{ub}

This condition is true if the weekday, according to the in-game
calender, is matched by the number(s) specified. 1=Monday, 2=Tuesday,
... 7=Sunday.

Are your shops open on Sunday?
@endnode

@node "GG_WAIT" " W(ait) "
@next "GG_EXIT"
@prev "GG_WEEKDAY"


@{fg shine}@{bg fill}W Command@{fg text}@{bg back}

@{i}Wait nn vertical blanks.@{ui}


 @{b} W frames@{ub}

This command creates a pause. The time is measured in frames or
"vertical blanks", which occur at the rate of 50 per second for PAL
systems and 60 per second for NTSC systems. On a PAL system,

 @{b} W 50@{ub}

would cause a one second pause.

The W command allows the player to end the pause before the specified
time by pressing the full stop ( . ) or escape key. 

(The escape key, when used in a cutscene, also causes a skip to the
FINAL section of the cutscene. )
@endnode

@node "GG_EXIT" " EXIT "
@next "GG_REDO"
@prev "GG_WAIT"


@{fg shine}@{bg fill}EXIT Command@{fg text}@{bg back}

@{i}Ends the execution of commands to handle the current input sentence from
the player.@{ui}

  @{b}EXIT@{ub}

is used when all actions for a user sentence has been performed, and you
do not wish to search further in the .room, .section, and graal.main
files for entries that match the sentence. It is used in ACTION: and
DACT: statements, and combined with EDLG to end dialogues.

See also: @{"EDLG" link "GG_EDLG" 0}, @{"REDO" link "GG_REDO" 0}
@endnode

@node "GG_REDO" " REDO "
@next "GG_SPEECHMODE"
@prev "GG_EXIT"


@{fg shine}@{bg fill}REDO Command@{fg text}@{bg back}

@{i}Re-run the scripts after having changed the player's input sentence.@{ui}

  @{b}REDO@{ub}

This command is used after having changed the current sentence contents
with the OBJ1, OBJ2 and VERB commands. The whole idea is that sometimes
you want exactly the same actions performed for different sentences, and
using REDO is easier and less space-consuming than copying all the
actions. For example, if you want the same actions taken for USE BOOK
and OPEN BOOK, you can replace the verb USE (3) with the verb OPEN (4)
and then start over with checking for appropriate actions. Example,
assuming the book is object 1:

  @{b}ACTION: 3;IFOBJ 1;VERB 4;REDO@{ub}

The checking will start over with the first ACTION: statement in the
same file, but now looking for actions for OPEN BOOK rather than USE
BOOK, which was what the player entered. (Not to worry, the player will
never see what is going  on!)
@endnode

@node "GG_SPEECHMODE" "SPEECHMODE"
@next "GG_MUSIC"
@prev "GG_REDO"


@{fg shine}@{bg fill}SPEECHMODE Command@{fg text}@{bg back}

@{i}sets spoken/text dialogue on/off@{ui}


 @{b}SPEECHMODE TEXT|AUDIO|BOTH@{ub}

Speechmode decides whether text displaying commands with @{"audio info" link "Audio Info" 0} in
connection to the text should

a) ignore the audio and display text the usual way (TEXT).

b) skip the text display and just output the audio (AUDIO).

c) output audio while displaying the text at the same time (BOTH).


This affects SAY, RESP, THINK and TEXT commands as well as LINE: texts.


The same function is available on the "A" keyboard key, which cycles
through the three alternatives.

How to give the @{"audio info" link "Audio Info" 0} is explained here.
@endnode

@node "GG_MUSIC" "MUSIC"
@next "GG_PLAYMACRO"
@prev "GG_SPEECHMODE"


@{fg shine}@{bg fill}MUSIC@{fg text}@{bg back}

@{i}switches music and sound effects on or off@{ui}


 @{b} MUSIC ON|OFF@{ub}

This command simply mimicks the function of the "M" keyboard key. See
also @{"SPEECHMODE" link "GG_SPEECHMODE" 0}.
@endnode

@node "GG_PLAYMACRO" "PLAYMACRO"
@next "GG_CUTSCENE"
@prev "GG_MUSIC"


@{fg shine}@{bg fill}PLAYMACRO Command@{fg text}@{bg back}

@{i}Plays a previously recorded macro from within a script@{ui}


@{b} PLAYMACRO file@{ub}


This simply plays a pre-recorded macro - mainly useful if you want to
put together non-playable demos. (Macros are usually recorded played
back via the GRAAL user interface (the "R" and "P" keyboard keys. See
the GRAAL manual for  details.)

Note - You don't have to specify the ".macro" file extension, it will be
added automatically by GRAAL.
@endnode

@node "GG_CUTSCENE" " CUTSCENE "
@next "GG_COMAREA"
@prev "GG_PLAYMACRO"


@{fg shine}@{bg fill}CUTSCENE Command@{fg text}@{bg back}

@{i}Loads and executes contents of a cutscene file@{ui}


  @{b}CUTSCENE cutscene_no,S|F|H|N|NF@{ub}

Rather straight forward, this one. You only have to remember that
cutscenes can only contain commands and not conditions, and also note
the effect the second parameter has on the cutscene indicator (in Olaf's
case, the movie camera icon) that is shown instead of the command
buttons while a cutscene is being played.

@{b}S@{ub}

Cutscene indicator will be shown as normal and taken away when this
cutscene has finished playing.

@{b}N@{ub}

The whole command area will disappear during the cutscene, and return
when the cutscene has finished playing.

@{b}F@{ub}

The cutscene indicator will appear as normal but remain on screen when
this cutscene finishes. This should be used if several cutscenes are
played in sequence, or when cutscenes are "nested" (=called from inside
other cutscenes).

@{b}NF@{ub}

The command area will disappear during the cutscene and remain hidden
until a cutscene command containing the "N" parameter restores it. (Does
the same for "N" as "F" does for "S", if you know what I mean...)

@{b}H@{ub}

The cutscene indicator will not be used at all. Use for short cutscenes
and cutscenes with the NOBREAK command, if appropriate.

See also: @{"NOBREAK" link "GG_NOBREAK" 0}
@endnode

@node "GG_COMAREA" "COMAREA command"
@next "GG_Quit"
@prev "GG_CUTSCENE"


@{fg shine}@{bg fill}COMAREA Command@{fg text}@{bg back}

@{i}Turns the command area off and on@{ui}


  @{b}COMAREA OFF|ON@{ub}

Use this command to turn the command area off and on. it works exactly
like calling a "blank" cutscene with the NF (OFF) or N (ON) parameter.



@{b}OFF@{ub}

The command area disappears. While it is hidden, any cutscenes executed
must use the "NF" parameter to keep it hidden. DSET and PROMPT may be
used while the command area is hidden.


@{b}ON@{ub}

Sooner or later, you MUST turn the command area back on using this.


@{i}Note:@{ui} Saving and loading of games should nomally only be done while the
command area is visible!
@endnode

@node "GG_Quit" " QUIT           "
@next "GG_EXEC"
@prev "GG_COMAREA"


@{fg shine}@{bg fill}QUIT Command@{fg text}@{bg back}

@{i}Cleans up and quits GRAAL@{ui}


 @{b} QUIT@{ub}

This command simply kills GRAAL. Use it after displaying an end-of-game
screen, for example. If you provide your own way to quit the game, you
probably also want to put the DISABLE_QUIT: statement in graal.main.
@endnode

@node "GG_EXEC" " EXEC        "
@next "GG_SAVE"
@prev "GG_Quit"


@{fg shine}@{bg fill}EXEC Command@{fg text}@{bg back}

@{i}Executes a cli command or program@{ui}


  @{b}EXEC FG|BG,command with parameters@{ub}


This command executes the cli command or program with any parameters
that are supplied. GRAAL execution is halted until the command has
finished.

If "FG" is specified, GRAAL is switched to the back of the display,
showing the workbench screen while executing the command. When execution
has finished, control is switched back to GRAAL which is once more put
into the foreground.

IF "BG" is specified, the GRAAL screen remains visible while the command
is executed invisibly in the background. (But GRAAL execution is still
halted until the command has finished.)

You can use this for anything you like, but it's mainly here to support
intro screens and animations that Amos and GRAAL can't handle.

Note: If executing a command in the foreground (with the FG parameter),
the Workbench screen is briefly visible before and after the command
does its stuff - this is, sadly, unavoidable.
@endnode

@node "GG_SAVE" " SAVE           "
@next "GG_LOAD"
@prev "GG_EXEC"


@{fg shine}@{bg fill}SAVE Command@{fg text}@{bg back}

@{i}Saved the game at the last position set with the MARK command@{ui}

@{b}
  SAVE game_no@{ub}

The command creates a saved game file on the saved game disk. You must
ensure the saved game disk is present with a @{"IFNOTSAVEDISK" link "GG_IFNOTSAVEDISK" 0} condition
before attempting this. Using these and related conditions and commands,
you can code your own save/load rooms to replace the cheesy built-in
GRAAL requesters.

The saved game file will be named game_noSAVE.GRAAL. For example,

SAVE 1

creates the file 1SAVE.GRAAL


See also: @{"LOAD" link "GG_LOAD" 0}, @{"MARK" link "GG_MARK" 0} and @{"RESUME" link "GG_RESUME" 0}  commands, @{"IFNOTSAVEDISK" link "GG_IFNOTSAVEDISK" 0} and @{"IFEXISTS" link "GG_IFEXISTS" 0}
conditions, @{"DISABLE_SAVE:" link "ST_DISSAVE" 0} statement.
@endnode

@node "GG_LOAD" " LOAD           "
@next "GG_DOAFTER"
@prev "GG_SAVE"


@{fg shine}@{bg fill}LOAD Command@{fg text}@{bg back}

@{i}Loads a saved game@{ui}


  @{b}LOAD game_no@{ub}

This load a previously saved game. Use this to construct your own
save/load routines.

See also: The @{"SAVE" link "GG_SAVE" 0} command for a more thorough discussion of the
subject.
@endnode

@node "GG_DOAFTER" " DOAFTER        "
@next "GG_CANCEL"
@prev "GG_LOAD"


@{fg shine}@{bg fill}DOAFTER Command@{fg text}@{bg back}

@{i}Sets a timer do execute events when a certain time period has elapsed@{ui}


  @{b}DOAFTER interval,obj,device@{ub}

GRAAL has three "timer devices" which can be used to make things happen
after a certain period of time or at (almost) regular intervals. Once
set up, they continue to operate until a @{"CANCEL" link "GG_CANCEL" 0} command defuses them.

Possible uses are machinery where a sequence of actions must be carried
out within a certain time limit, rooms where exits close if you take too
long, updating of time data, etc.


@{b}interval@{ub}

This is the timer interval in seconds. (Or, alas, in 5/6ths of seconds
if you are an NTSC user. That's standards for you!) If you specify an
interval like "10-50", this means the interval will be a random number
between 10 and 50. However, once the interval has been set, it remains
constant as long as the timer operates - unless it is changed by a new
DOAFTER command. Also, timer device "0" is a little different - see
below.


@{b}obj@{ub}

What happens when the interval has elapsed? GRAAL starts looking for
ACTION: statements for the special verb number -1, that's what. And
which of those will it use? That depends on the event object, which can
be any number. For example, if the event object is set to 3, GRAAL will
execute statements beginning with

ACTION: -1;IFOBJ 3;

If you only use the one timer and intend to always run through all the
timer action, you may choose not to test on the object number at all,
and any number will do nicely here. 

Control is returned to the player with an EXIT command, same as always.
Before the EXIT command, you may wish to put one of the following:

 * A new DOAFTER command for the same device, altering its function
   or the time interval
 * A CANCEL command, defusing the timer.


@{b}device@{ub}

This is the timer device, which is a simple number from 0 to 2. Each
device is its own little time bomb - however, device 0 works in a
slightly different way from the rest. 

Device 0 keeps track of how long it has been since the player's last
input to the game, rather than counting how long it's been since the
DOAFTER command was given. Each mouse click is counted as an action, and
thus resets the timer. This timer is also completely disabled during
dialogues.

This means that timer 0 can be used for things like  "stall anims" -
making the character urge you to do something if you take too long, for
example. (A classic example of this sort of timer is the one in that
good old text adventure, "the Hobbit": "You wait... time passes. And it
did.)

@{fg shine}Limitations to the timed events:@{fg text}

Because GRAAL only checks for elapsed timers when it waits for player
input in dialogue or command mode, the timing is very approximate. For
example, if a timer elapses while your hero is making a long speech, the
timed event will occur only after the speech stops and when return
normally should have returned directly to the player.

In other words, you will have to think about how you set the action in
scenes where timing events are critical. Preferably, there shouldn't be
long sequences without checks for player input occuring at the same
time.

Also note that execution of the timer commands in the ACTION: statements
does not multitask, and if two or three timers elapse at the same time,
the commands for each timer will be carried out in sequence, starting
with timer 0 and ending with timer 2, possibly putting the timing off
even further from what was  expected.

Finally, NEVER use timers for things which can be achieved with
repeating animation patterns - they are much more accurate in the timing
and put much less strain on the system!


See also: @{"CANCEL" link "GG_CANCEL" 0} command
@endnode

@node "GG_CANCEL" " CANCEL         "
@next "GG_TCURS"
@prev "GG_DOAFTER"


@{fg shine}@{bg fill}CANCEL Command@{fg text}@{bg back}

@{i}Cancels the function of a timer@{ui}


 @{b} CANCEL device@{ub}

This command stops a timer started with the @{"DOAFTER" link "GG_DOAFTER" 0} command.


@{b}device@{ub}

is the device number of the timer (1-3).


See also: @{"DOAFTER" link "GG_DOAFTER" 0} command
@endnode

@node "GG_TCURS" "TCURS command"
@next "GG_DSET"
@prev "GG_CANCEL"


@{fg shine}@{bg fill}TCURS Command@{fg text}@{bg back}

@{i}Decides whether the cursor is displayed during timer events or not@{ui}


  @{b}TCURS ON|OFF@{ub}

During the execution of timer events, the mouse pointer (cursor) is
normally switched of just like when commands input by the player is
being executed.

With TCURS ON, you can have the cursor remain on screen. (However, if
the timer events take long to execute, this may annoy the player because
normal player input is not possible, and there will be no indication of
this fact.)
@endnode

@node "GG_DSET" " DSET "
@next "GG_LINE"
@prev "GG_TCURS"


@{fg shine}@{bg fill}DSET Command@{fg text}@{bg back}

@{i}Handles dialogue alternatives@{ui}

  @{b}DSET dlg[,{dset_command}]   @{ub}      

Tells the dialogue dlg how to behave using a number of commands, such
as:
                        
  @{b}+n@{ub}       add line n to the available set of lines

  @{b}-n@{ub}       take away line n from the line set temporarily (can be
           restored by another + later on)

  @{b}Nn@{ub}       make line n never appear again in this game, even if 
           a DSET+ appears later on.

  @{b}Ss@{ub}       Save the current status (the set of alternatives the 
           player sees) before "branching" in the dialogue. s is a set
           of saved lines, and can be 1-3

  @{b}Rs@{ub}       Restore a previously saved dialogue status from set 1-3

  @{b}E@{ub}        Erase all currently displayed dialogue lines, equal to
           giving a "-" command for each line. (This is also done
           automatically by the S (Save) command.

If you are not already involved in the dialogue, DSET will put the
dialogue control area onto the screen instead of the normal control
area.

If no commands are specified, the dialogue is only refreshed. However,
even this may alter the set of alternatives the player actually sees -
because the availability of the alternatives also depend upon conditions
set in the LINE: statements themselves, and those conditions may be
changed between DSET commands.

Remember that although dialogues are specified in room and section
scripts, their numbers must be unique for the entire game.

Examples:

  @{b}DSET 4,+1,+3@{ub}

shows lines 1 and 3 of dialogue 4

  @{b}DSET 4,-1,N3,+4@{ub}

hides line 1 temporarily, line 3 forever, and adds line 4

  @{b}DSET 4,S1,+12,+13,+14@{ub}

saves the current dialogue status in set 1, clearing all old input
alternatives at the same time, and replaces them with lines 12, 13 and
14.

The special command "L" allows you to alter the dialogue status without
showing what you are doing in the dialogue control area. This is mainly
used to restore the dialogue to its proper status just before ending the
dialogue, so that the proper alternatives will be in place when the
player starts talking to the same dialogue partner the next time. For
example, before we leave dialogue 4 we know that we want to go back to
the way things looked before we saved the status in set 1:

 @{b} DSET 4,L,R1;EDLG;EXIT@{ub}

restores the previously saved dialogue status for dialogue 4 just before
the dialogue is ended, without the user being disturbed by flickering
alternatives in the dialogue control area. However, the next time the
player engages in this dialogue, the old alternatives will be back to
choose from.

See also: @{"EDLG" link "GG_EDLG" 0}
@endnode

@node "GG_LINE" " LINE "
@next "GG_EDLG"
@prev "GG_DSET"


@{fg shine}@{bg fill}LINE Command@{fg text}@{bg back}

@{i}Alter the line chosen in a dialogue@{ui}


 @{b} LINE line@{ub}

This command, in conjunction with th REDO command, lets you use the same
reactions (LACT: statements) for a number of different dialogue
alternatives - much easier than copying all commands into a number of
LACT:s.

Example: You wish the reactions to line 5 in a dialogue to be exactly
the same as those for line 3. Simply specify this:

@{b}LACT: 5;LINE 3;REDO@{ub}

The program now goes through the LACT:s again, now looking for those who
are connected to line 3 instead of line 5 which was actually chosen.

See also: @{"REDO" link "GG_REDO" 0}
@endnode

@node "GG_EDLG" " EDLG "
@next "GG_OBJ"
@prev "GG_LINE"


@{fg shine}@{bg fill}EDLG Command@{fg text}@{bg back}

@{i}Ends a dialogue session@{ui}


  @{b}EDLG@{ub}

This command ends the dialogue. The normal Control Area is put back on
screen instead of the Dialogue Control Area. The last set of dialogue
lines will be present as default if the dialogue is resumed later on.

Normally, you would not want to evaluate any more line action (LACT:)
statements after having decided to end the dialogue. Therefore, you
should normally put an EXIT command right behind the EDLG:

 @{b} EDLG;EXIT@{ub}

See also: @{"DSET" link "GG_DSET" 0}
@endnode

@node "GG_OBJ" " OBJ1 / OBJ2 "
@next "GG_VERB"
@prev "GG_EDLG"


@{fg shine}@{bg fill}OBJ1 / OBJ2 Command@{fg text}@{bg back}

@{i}Alters the object number for OBJ1 or OBJ2.@{ui}

  @{b}OBJ1 [obj]
  OBJ2 [obj]@{ub}

These commands are used in two main ways:

a) to temporarily put another object number in the place of OBJ1 or OBJ2
in order to manipulate an object using other commands. In this case, you
only need a simple OBJ1 or OBJ2 without any parameters  to change the
object number back to what it originally was when you are through
manipulating the object you specified with "obj". For example, imagine
you are about to open a can of gasoline in a room with a lit candle. The
gasolin  has object number 15 and is currently OBJ1, the object number
for the  candle is 20.

  @{b}...OBJ1 20;MOBJ;HANDLE;SHOW 20, , ,10;SAY I put the light out
first;HANDLE -1;OBJ1 15;...@{ub}

would be an easy way to switch from the gasolin, operate the candle, and
then switch back to working with the gasolin.

b) to alter the object handled and then use the @{"REDO" link "GG_REDO" 0} command to run
through all action statements again.


@{i}Note:@{ui} Exit numbers used to check which exit was clicked is actually a
special use of the OBJ1 variable. This must be remembered when coding
ACTION: statements for verb 0 (= exit click).

See also: @{"VERB" link "GG_VERB" 0}, @{"REDO" link "GG_REDO" 0}
@endnode

@node "GG_VERB" " VERB "
@next "GG_ROOM"
@prev "GG_OBJ"


@{fg shine}@{bg fill}VERB Command@{fg text}@{bg back}

@{i}Alters the current verb@{ui}

  @{b}VERB verb_no@{ub}

Use this to alter the verb in the current sentence. Mainly used before
the @{"REDO" link "GG_REDO" 0} command to make one action synonym to another. 

If no verb number is specified, the verb number before the last  VERB
command is restored (but why you should want to do that,  I don't know
at this stage.)

See also: OBJ1/OBJ2, REDO
@endnode

@node "GG_ROOM" " ROOM "
@next "GG_LINE"
@prev "GG_VERB"


@{fg shine}@{bg fill}ROOM Command@{fg text}@{bg back}

@{i}Alter the current room@{ui}

  @{b}ROOM <room number>@{ub}

A bit obsolete, this one. You can set flags for rooms other than the
current using a special form of the SETRF command, so this one may soon
be deleted. Don't use it.

Anyway, specifying ROOM without the parameter brings back the room
number that was in effect before the last ROOM <room number> was called,
just like OBJ1/OBJ2 can restore the previous object if used without the
parameter.
@endnode

@node "GG_LINE" " LINE "
@next "GG_EDLG"
@prev "GG_ROOM"


@{fg shine}@{bg fill}LINE Command@{fg text}@{bg back}

@{i}Alter the line chosen in a dialogue@{ui}


 @{b} LINE line@{ub}

This command, in conjunction with th REDO command, lets you use the same
reactions (LACT: statements) for a number of different dialogue
alternatives - much easier than copying all commands into a number of
LACT:s.

Example: You wish the reactions to line 5 in a dialogue to be exactly
the same as those for line 3. Simply specify this:

@{b}LACT: 5;LINE 3;REDO@{ub}

The program now goes through the LACT:s again, now looking for those who
are connected to line 3 instead of line 5 which was actually chosen.

See also: @{"REDO" link "GG_REDO" 0}
@endnode

@node "GG_EDLG" " EDLG "
@next "GG_OBJ"
@prev "GG_LINE"


@{fg shine}@{bg fill}EDLG Command@{fg text}@{bg back}

@{i}Ends a dialogue session@{ui}


  @{b}EDLG@{ub}

This command ends the dialogue. The normal Control Area is put back on
screen instead of the Dialogue Control Area. The last set of dialogue
lines will be present as default if the dialogue is resumed later on.

Normally, you would not want to evaluate any more line action (LACT:)
statements after having decided to end the dialogue. Therefore, you
should normally put an EXIT command right behind the EDLG:

 @{b} EDLG;EXIT@{ub}

See also: @{"DSET" link "GG_DSET" 0}
@endnode

@node "GG_OBJ" " OBJ1 / OBJ2 "
@next "GG_VERB"
@prev "GG_EDLG"


@{fg shine}@{bg fill}OBJ1 / OBJ2 Command@{fg text}@{bg back}

@{i}Alters the object number for OBJ1 or OBJ2.@{ui}

  @{b}OBJ1 [obj]
  OBJ2 [obj]@{ub}

These commands are used in two main ways:

a) to temporarily put another object number in the place of OBJ1 or OBJ2
in order to manipulate an object using other commands. In this case, you
only need a simple OBJ1 or OBJ2 without any parameters  to change the
object number back to what it originally was when you are through
manipulating the object you specified with "obj". For example, imagine
you are about to open a can of gasoline in a room with a lit candle. The
gasolin  has object number 15 and is currently OBJ1, the object number
for the  candle is 20.

  @{b}...OBJ1 20;MOBJ;HANDLE;SHOW 20, , ,10;SAY I put the light out
first;HANDLE -1;OBJ1 15;...@{ub}

would be an easy way to switch from the gasolin, operate the candle, and
then switch back to working with the gasolin.

b) to alter the object handled and then use the @{"REDO" link "GG_REDO" 0} command to run
through all action statements again.


@{i}Note:@{ui} Exit numbers used to check which exit was clicked is actually a
special use of the OBJ1 variable. This must be remembered when coding
ACTION: statements for verb 0 (= exit click).

See also: @{"VERB" link "GG_VERB" 0}, @{"REDO" link "GG_REDO" 0}
@endnode

@node "GG_VERB" " VERB "
@next "GG_MARK"
@prev "GG_OBJ"


@{fg shine}@{bg fill}VERB Command@{fg text}@{bg back}

@{i}Alters the current verb@{ui}

  @{b}VERB verb_no@{ub}

Use this to alter the verb in the current sentence. Mainly used before
the @{"REDO" link "GG_REDO" 0} command to make one action synonym to another. 

If no verb number is specified, the verb number before the last  VERB
command is restored (but why you should want to do that,  I don't know
at this stage.)

See also: @{"OBJ1/OBJ2" link "GG_OBJ" 0}, @{"REDO" link "GG_REDO" 0}
@endnode

@node "GG_MARK" " MARK "
@next "GG_RESUME"
@prev "GG_VERB"


@{fg shine}@{bg fill}MARK Command@{fg text}@{bg back}

@{i}Mark the current game position@{ui}

 @{b} MARK [number]@{ub}

This saves the current game state. 


@{b}number@{ub}

If number is specified, this command acts as a "save game" to RAM:
(which can take some time).

Any number of MARKs can be stored using unique identification numbers to
tell them apart. Just keep in mind that each MARK creates a file of
about 20K in RAM:, and that the command takes a few seconds to perform.
(Older machines can really struggle in comparison with 1200s or
accelerated ones, so do not use it excessively.)

If a number is not included, the position is saved to a string of
variables in memory, which is somewhat faster. However, only one
position can be saved this way.

The  position can be re-created later using  a RESUME command.

You can use this in a number of ways:

* Implement your own "save to RAM:" commands.

* Provide an "ooops!" function, allowing the player an easy way to get 
  back into a game where something just has gone terribly wrong...

* Cut away to cutscenes using other rooms and restore the game position
  afterwards, not having to care exactly what the scene looked like
when
  the jump to the cutscene occured.

* Use a MARK as the very first command in the game and provide a "try
  again" option from an end-of-game screen.

See also: @{"RESUME" link "GG_RESUME" 0} command
@endnode

@node "GG_RESUME" " RESUME "
@next "GG_SAY"
@prev "GG_MARK"


@{fg shine}@{bg fill}RESUME Command@{fg text}@{bg back}

@{i}Resume the action at the spot saved with the MARK command@{ui}

 @{b} RESUME [number|KEEP]@{ub}

@{b}number@{ub}

The optional number must correspond to the one of a previous MARK
command. See the MARK command for a detailed description of what is
going on. 

@{b}KEEP@{ub}

reloads the position marked by the MARK command (without parameters),
but preserves any changes made to object data, object flags, room flags,
string variables, and inventory data - that is, this  information is not
overwritten by the information saved with the MARK command. This is
useful in special rooms to which the player can jump from many different
points, where you need to perform some operations on game data and
return to the room from where you came: Notebooks, control panels  

As with normal "load game" operations, GRAAL searches for and executes
any ACTION: statements starting with the special verb number -2 before
lighting the scene and returning control to the player. This is to
enable you to perform any special actions that need to be taking, for
example restoring global images (which are not saved by a "save game" or
a MARK command).

See also: @{"MARK" link "GG_MARK" 0} command
@endnode

@node "GG_SAY" " SAY "
@next "GG_GOTO"
@prev "GG_RESUME"


@{fg shine}@{bg fill}SAY Command@{fg text}@{bg back}

@{i}Makes the main character speak a sentence (or two).@{ui}

  @{b}SAY sentence@{ub}

This command uses the animations in the TALK_MAP statements of the
graal.main file to animate the character during the length of the text
display. The text display may use some @{"special characters" link "GG_Vars" 0} to perform
line breaks, put in variable values, etc.

Note that the SAY command can only be used if the main character is on
screen, not if a @{"CHAR OFF" link "GG_CHAR" 0} or other command has hidden it!

The sentecne can contain audio info for talkies. See @{"audio info" link "Audio Info" 0}.


See also: @{"THINK" link "GG_THINK" 0}
@endnode

@node "GG_GOTO" " GOTO "
@next "GG_THINK"
@prev "GG_SAY"


@{fg shine}@{bg fill}GOTO Command@{fg text}@{bg back}

@{i}Move to another room@{ui}

 @{b} GOTO room|list,entrance|list@{ub}

This command automatically moves to a new room - it is not needed when
using exits in the normal way, but is handy in cutscenes and the like.
As usual, if a list of alternatives is specified, one is choosen at
random. Could be used in maze-like surroundings, perhaps?

See also: @{"MARK" link "GG_MARK" 0}, @{"RESUME" link "GG_RESUME" 0}
@endnode

@node "GG_THINK" " THINK "
@next "GG_RESP"
@prev "GG_GOTO"


@{fg shine}@{bg fill}THINK Command@{fg text}@{bg back}

@{i}Displays text above the main character@{ui}

  @{b}THINK sentence@{ub}

This command behaves just like @{"SAY" link "GG_SAY" 0}, except it doesn't automatically
animate the character. Good for "thinking" as well as using special
animation sequences shown using MOVE commands instead of the standard
TALK_MAP animations.

The sentence can contain audio info for talkies. See @{"audio info" link "Audio Info" 0}.

See also: @{"SAY" link "GG_SAY" 0}
@endnode

@node "GG_RESP" " RESP           "
@next "GG_HANDLE"
@prev "GG_THINK"


@{fg shine}@{bg fill}RESP Command@{fg text}@{bg back}

@{i}Make a dialogue partner respond@{ui}


  @{b}RESP R|S,partner,sentence@{ub}

@{b}R@{ub} means after the character has "spoken", it will be displayed using its
default image or animation again. @{b}S@{ub} means the image used just before the
RESP command was called will be used again.

@{b}partner@{ub} 

refers to the partner number assigned by the @{"DLG:" link "ST_DLG" 0} statement in the
graal.main file.

The sentence is constructed just like sentences used in, for example,
the @{"SAY" link "GG_SAY" 0} and @{"THINK" link "GG_THINK" 0} commands.

The sentence can contain audio info for talkies. See @{"audio info" link "Audio Info" 0}.

See also: @{"SAY" link "GG_SAY" 0} and @{"THINK" link "GG_THINK" 0} commands, @{"DLG" link "ST_DLG" 0} statement
@endnode

@node "GG_HANDLE" " HANDLE "
@next "GG_PICK"
@prev "GG_RESP"


@{fg shine}@{bg fill}HANDLE Command@{fg text}@{bg back}

@{i}Make the main character handle an object@{ui}

 @{b} HANDLE [obj|LOW|MID|HIGH|-1]@{ub}

@{b}HANDLE@{ub} on its own uses the HANDLE_MAP animations specified in the
graal.main file to make the main character "operate" OBJ1. 

@{b}HANDLE obj@{ub} makes the character operate the specified object.

@{b}HANDLE LOW|MID|HIGH@{ub} uses the "handle animation" - a general, convenient
way to stretch out a hand without having to resort to CIMG or OMOVE
0,... commands.

@{b}HANDLE -1@{ub} resets the main character to what he/she looked like just
before the previous HANDLE command took effect.
@endnode

@node "GG_PICK" " PICK "
@next "GG_GET"
@prev "GG_HANDLE"


@{fg shine}@{bg fill}PICK Command@{fg text}@{bg back}         

@{i}Pick up an object@{ui}

 @{b} PICK [obj]@{ub}

Adds the specified object (or OBJ1, if no object number is specified) to
the inventory and erases it from the scene area. This command is often
preceded by a MOBJ and a @{"HANDLE" link "GG_HANDLE" 0} command to show on screen what's going
on.

There is not a DROP command that automatically does the opposite. The
most comfortable way to dispose of objects is letting the main character
do so automatically when they have filled their purpose, using  the
@{"REMOVE" link "GG_REMOVE" 0} command.

See also: @{"GET" link "GG_GET" 0}, @{"REMOVE" link "GG_REMOVE" 0}
@endnode

@node "GG_GET" " GET "
@next "GG_REMOVE"
@prev "GG_PICK"


@{fg shine}@{bg fill}GET Command@{fg text}@{bg back}

@{i}Add an object to the inventory@{ui}

  @{b}GET obj,U|N@{ub}

The object is added to the inventory. Use "U" if the inventory display
should be updated (which is the normal procedure), "N" if the inventory
should be left unaffected, for example if GET is used during a dialogue,
or you make a number of consecutive GETs letting only the last one
update the display.

The difference between GET and @{"PICK" link "GG_PICK" 0} is that GET does not take any notice
of the object's previous whereabouts.

See also: @{"PICK" link "GG_PICK" 0}, @{"REMOVE" link "GG_REMOVE" 0}
@endnode

@node "GG_REMOVE" " REMOVE "
@next "GG_INVENTORY"
@prev "GG_GET"


@{fg shine}@{bg fill}PUT Command@{fg text}@{bg back}

@{i}Relocates an object@{ui}

 @{b} PUT obj|OBJ1,U|N,room|Iinventory@{ub}

Formerly known as the REMOVE command, this command can be used to put
any object in any room or inventory, except the current room and
inventory, at any time.

If it was previously in the current inventory, it will be removed. In
this case, and if the inventory is displayed, you should use the  "U"
parameter to update the inventory display. 

To put an object in the current room, use the @{"SHOW" link "GG_SHOW" 0}   command. 

To put an object in the current inventory, use the @{"GET" link "GG_GET" 0} command.

@{b}obj|OBJ1@{ub}

The number of the object to be relocated. If OBJ1 is specified, the
first object in the sentence is the one that is removed or relocated.


@{b}U|N@{ub}

If @{b}U@{ub} is specified, the inventory display is updated. 


@{b}room|Iinventory@{ub}

The object is placed in the specified room. If the room is specified as
0, the object "disappears" from the game!

I followed by an inventory number is only used when you have more than
one inventory in the game, and wish to place the object in an inventory
other than the one currently on screen. The default inventory is always
number one, but inventories can be swicthed with the @{"INVENTORY" link "GG_INVENTORY" 0} command.

 PUT 12,U,I2

would remove object 12 from the displayed inventory and put it in
inventory 2 instead. (It should thus become visible when you switch to
display  inventory 2.)


Note: 


See also: @{"GET" link "GG_GET" 0}, @{"PICK" link "GG_PICK" 0}
@endnode

@node "GG_INVENTORY" " INVENTORY      "
@next "GG_NAME"
@prev "GG_REMOVE"


@{fg shine}@{bg fill}INVENTORY Command@{fg text}@{bg back}

@{i}Changes the currently used inventory@{ui}


  @{b}INVENTORY number,U|N@{ub}

This command allows the use of multiple inventories in GRAAL - up to six
inventories can be used, and the default inventory is number 1.

@{b}number@{ub}

The new inventory number to use. All subsequent @{"GET" link "GG_GET" 0}, @{"REMOVE" link "GG_REMOVE" 0}, and @{"PICK" link "GG_PICK" 0}
commands will use this inventory.

@{b}U|N@{ub}

Specify U if the inventory display should be updated immediately to show
the new inventory. Use N only when the inventory display is currently
unavailable and another command will refresh it before control is
returned to the user next time.
@endnode

@node "GG_NAME" " NAME           "
@next "GG_ICON"
@prev "GG_INVENTORY"


@{fg shine}@{bg fill}NAME Command@{fg text}@{bg back}

@{i}Alter the name of an object@{ui}


  @{b}NAME [obj,]new_name[,word1,word2,word3]@{ub}

Very often in an adventure, an object is "transformed" - that is, one
object appears while another disappears at the same time. (For example,
a parcel is opened to reveal a book - the parcel is gone, the book
exists.) To save memory, it makes sense to use the old object number for
the new object also, since there is no risk of confusion - the two
objects never appear at the same time.

The command NAME alters the name of the current OBJ1 (see the @{"syntax" link "GG_Syntax" 0}
conventions). In addition, the determination words (see the @{"OBJECT" link "ST_OBJECT" 0}
statement) may be altered to suit the new object description. You can
also specify the object to be changed by putting the object number in
front of the new name.

See also: @{"OBJ1" link "GG_OBJ" 0} command, @{"OBJECT" link "ST_OBJECT" 0} statement.
@endnode

@node "GG_ICON" " ICON           "
@next "GG_PREP"
@prev "GG_NAME"


@{fg shine}@{bg fill}ICON Command@{fg text}@{bg back}

@{i}Alter the icon used for inventory display@{ui}


 @{b} ICON [obj,]image@{ub}

This command does a bit of what the NAME command does for a text
inventory, but you should probably use both the NAME and the ICON
command when changing properties for objects in an icon display - NAME
still determines the text shown when the object is referred to in the
game, although it doesn't appear in the inventory list...
@endnode

@node "GG_PREP" " PREP           "
@next "GG_NEWOBJ"
@prev "GG_ICON"
@{fg shine}@{bg fill}

PREP Command@{fg text}@{bg back}

@{i}Alter the preposition of OBJ1@{ui}


 @{b} PREP [preposition]@{ub}

By specifying a preposition for an object, the verb USE will assume this
object must be used in conjunction with something else, and therefore
awaits the input of a second object before checking for actions.

Specifying PREP without a preposition will do the opposite, allowing an
object to be used on its own again.
@endnode

@node "GG_NEWOBJ" " NEWOBJ         "
@next "GG_SETOF"
@prev "GG_PREP"


@{fg shine}@{bg fill}NEWOBJ Command@{fg text}@{bg back}

@{i}Creates or modifies an object@{ui}


 @{b} NEWOBJ: object_parameters@{ub}

This command acts exactly like the OBJECT: statement - only here, the
parameters are separated by commas instead of semi-colons, so you can
not place an animation sequence containing commas as the default object
image. Also note that this command resets all object flags to 0, and
shouldn't be used unless you experience some sort of emergency I haven't
been able to anticipate.

See also: @{"OBJECT" link "ST_OBJS" 0} statement
@endnode

@node "GG_SETOF" " SETOF "
@next "GG_ADDOF"
@prev "GG_NEWOBJ"


@{fg shine}@{bg fill}SETOF Command@{fg text}@{bg back}

@{i}Assigns a value to an object flag@{ui}

  @{b}SETOF [obj,]flag=value|list@{ub}

If no object number is specified, OBJ1 is assumed. The flag is set to
the value.

If the value is specified as #DATE, the value is the current in-game
date in the format year*10000+month*100+date, e.g. 19960801 for Augist
1, 1996

If the value is specified as #TIME, the value is the current in-game
time in the format hour*100+minutes, e.g. 2355 for 11:55 pm.

The value can also be a reference to a room or object flag. The format
is #R#roomnumber#flag# or #O#objectnumber#flag#

For example,

 SETOF 3,6=#R#3#4#

would set flag 6 for object 3 to the value held in room flag 4 of room
3.

If a list of values is specified, one of the values is chosen at random.
For example,

 SETOF 2=3|7|9

would set object flag 2 for object 1 to either 3, 7, or 9. A maximum of
12 values may be specified in a list.


See also: @{"ADDOF" link "GG_ADDOF" 0}, @{"DECOF" link "GG_DECOF" 0}, @{"IFOF" link "GG_IFOF" 0}
@endnode

@node "GG_ADDOF" " ADDOF "
@next "GG_DECOF"
@prev "GG_SETOF"


@{fg shine}@{bg fill}ADDOF Command@{fg text}@{bg back}

@{i}Adds to or subtracts from a flag value@{ui}

 @{b} ADDOF [obj,]flag[,value]
  ADDOF2 flag[,value]@{ub}

ADDOF affects a flag for an object. If no value is specified, 1 is
added. Negative values may be used, thus subtracting from the flag
value.

ADDOF2 affects OBJ2 - this form is kept mainly for backwards
compatibility, you can achieve exactly the same by specifying object 2's
object number in most cases...

DECOF is used for special "countdown" purposes.

The value can be a reference to a room or object flag. The format is
#R#roomnumber#flag# or #O#objectnumber#flag#.

For example,

 ADDOF 1,#O#4#2#

would add the value held in object flag 2 for object 4 to object flag 1
for OBJ1.

Another example:

 ADDOF2 4

would add 1 to object flag 4 of OBJ2.

See also: @{"SETOF" link "GG_SETOF" 0}, @{"DECOF" link "GG_DECOF" 0}, @{"IFOF" link "GG_IFOF" 0}
@endnode

@node "GG_DECOF" " DECOF "
@next "GG_SETRF"
@prev "GG_ADDOF"


@{fg shine}@{bg fill}DECOF Command@{fg text}@{bg back}

@{i}Counts down the flag value to zero@{ui}

 @{b} DECOF flag
  DECOF2 flag@{ub}

DECOF is used for OBJ1, DECOF2 for OBJ2. The flag value is decreased by
1 until it reaches zero, then it stays there.

See also: @{"SETOF" link "GG_SETOF" 0}, @{"ADDOF" link "GG_ADDOF" 0}, @{"IFOF" link "GG_IFOF" 0}
@endnode

@node "GG_SETRF" " SETRF "
@next "GG_ADDRF"
@prev "GG_DECOF"


@{fg shine}@{bg fill}SETRF Command@{fg text}@{bg back}

@{i}Assigns a value to a room flag@{ui}

  @{b}SETRF [room,]flag=value|list@{ub}

If no room number is specified, the current room is assumed. The flag is
set to the value.

If the value is specified as #DATE, the value will be the current
in-game date in the format year*10000+month*100+date, e.g. 19960801 for
August 1, 1996.

If the value is specified as #TIME, the value will be the current
in-game time in the format hours*100 + minutes, e.g. 2355 for 11:55 pm.

For example,

 SETRF 2,1=5

would set room flag 1 for room 2 to 5

The value can be a reference to a room or object flag. The format is
#R#roomnumber#flag# or #O#objectnumber#flag#

For example,

 SETRF 2=#R#2#1#

would set room flag 2 for the current room to the value of room flag 1
for room 2.

If a list of values is specified, one of the values is choosen at
random. For example,

 SETRF 2=3|7|9

would set room flag 2 to either 3, 7, or 9. A maximum of 12 values may
be specified in a list.

 SETRF 1,3=#TIME

would set room flag 3 for room 1 to the current game time.

 SETRF 0,1=#DATE

would set room flag 1 for room 0 to the current game date. Room 0 is a
"global" room never used as a normal room. Nevertheless, it exists
flag-wise, so its 20 flags can be used to hold "global game values".


See also: @{"ADDRF" link "GG_ADDRF" 0}, @{"DECRF" link "GG_DECRF" 0}, @{"IFRF" link "GG_IFRF" 0}
@endnode

@node "GG_ADDRF" " ADDRF "
@next "GG_PROMPT"
@prev "GG_SETRF"


@{fg shine}@{bg fill}ADDRF Command@{fg text}@{bg back}

@{i}Adds to or subtracts from a room flag value@{ui}

 @{b} ADDRF [room,]flag[,value]@{ub}

ADDRF affects a flag for the current room. The number is added to the
flag value. If the number is negative, a subtraction is performed.

The value may be a reference to a room or object flag. The format is
#R#roomnumber#flag# or #O#objectnumber#flag#.

For example,

 ADDRF 3,1,#O#5#2#

adds the value held in object flag 2 of object 5 to room flag 1 of room
3.


 ADDRF 2

would add 1 to room flag 2 of the current room


 ADDRF 2,3

would add 3 to room flag 2 of the current room


 ADDRF 5,2,3

would add 3 to room flag 2 of room 5 


See also: @{"SETRF" link "GG_SETRF" 0}, @{"DECRF" link "GG_DECRF" 0}, @{"IFRF" link "GG_IFRF" 0}
@endnode

@node "GG_PROMPT" "PROMPT Command"
@next "GG_SETVAR"
@prev "GG_ADDRF"


@{fg shine}@{bg fill}PROMPT Command@{fg text}@{bg back}

@{i}Prompts the user for input of a string variable@{ui}


  @{b}PROMPT var,text@{ub}

This command uses the dialogue area to display the prompt and
accompanying text. It can not be used while in dialogue mode.

@{b}var@{ub}

The string variable (1-12) where the player's input will be held. This
can then be displayed using a text @{"variable" link "GG_Vars" 0} or tested  with the @{"IFVAR" link "GG_IFVAR" 0}
condition.

@{b}text@{ub}

An explanatory text shown in the first line of the dialogue area

Example:

@{b}PROMPT 1,Please enter your name:@{ub}

Whatever the player types will be stored in string variable 1.
@endnode

@node "GG_SETVAR" "SETVAR Command"
@next "SHOWEXIT"
@prev "GG_PROMPT"


@{fg shine}@{bg fill}SETVAR Command@{fg text}@{bg back}

@{i}Sets a string variable@{ui}


  @{b}SETVAR var,string@{ub}

GRAAL has 12 string variables which can be set by the player (see
@{"PROMPT" link "GG_PROMPT" 0}) or with this command.

@{b}var@{ub}

Variable number (1-12)

@{b}string@{ub}

An arbitrary text string

Example:

@{b}SETVAR 1,Hello world!@{ub}

will store the text "Hello world!" in string variable 1.
@endnode

@node "SHOWEXIT" " SHOWEXIT       "
@next "HIDEEXIT"
@prev "GG_SETVAR"


@{fg shine}@{bg fill}SHOWEXIT Command@{fg text}@{bg back}

@{i}Shows a previously hidden exit@{ui}


 @{b} SHOWEXIT exit_no@{ub}

This restores a previously hidden exit on screen

See also: @{"HIDEEXIT" link "HIDEEXIT" 0} command
@endnode

@node "HIDEEXIT" " HIDEEXIT       "
@next "GG_DECRF"
@prev "SHOWEXIT"


@{fg shine}@{bg fill}HIDEEXIT Command@{fg text}@{bg back}

@{i}Hides an exit@{ui}


  @{b}HIDEEXIT exit_no@{ub}

When entering a room, all exit defined by EXIT: statements are always
visible and usable. This command hides the exit. It can be restored
later by the SHOWEXIT command.

See also: @{"SHOWEXIT" link "SHOWEXIT" 0} command
@endnode

@node "GG_DECRF" " DECRF "
@next "GG_CIMG"
@prev "HIDEEXIT"


@{fg shine}@{bg fill}DECRF Command@{fg text}@{bg back}

@{i}Counts down the room flag value to zero@{ui}

 @{b} DECRF flag@{ub}

DECRF decreases the value of the flag until it reaches zero, then it
stays there.

See also: @{"SETRF" link "GG_SETRF" 0}, @{"ADDRF" link "GG_ADDRF" 0}, @{"IFRF" link "GG_IFRF" 0}
@endnode

@node "GG_CIMG" " CIMG "
@next "GG_CMOVE"
@prev "GG_DECRF"


@{fg shine}@{bg fill}CIMG Command@{fg text}@{bg back}

@{i}Alter the image for the main character@{ui}


 @{b} CIMG image@{ub}

The main character changes to the specified image. The screen (hotspot)
position is not altered.

See also: @{"CPOS" link "GG_CPOS" 0}, @{"CMOVE" link "GG_CMOVE" 0}, @{"OMOVE" link "GG_OMOVE" 0}
@endnode

@node "GG_CMOVE" " CMOVE "
@next "GG_WALK_SPEED"
@prev "GG_CIMG"


@{fg shine}@{bg fill}CMOVE Command@{fg text}@{bg back}

@{i}Moves the character to a new screen position using the default @{"WALK_..." link "ST_WALK" 0}
animations.@{ui}

 @{b} CMOVE x,y,C|P@{ub}

@{b}x@{ub} and @{b}y@{ub} are the screen (hotspot) coordinates. Use @{b}P@{ub} to end the CMOVE
with an appropriate PAUSE_... image, @{b}C@{ub}" link "ST_PAUSE" 0} image, C to
end with a @{"STILL_..." link "ST_STILL" 0} image. C is mainly used when another CMOVE follows
immediately.

See also: @{"CIMG" link "GG_CIMG" 0}, @{"CPOS" link "GG_CPOS" 0}, @{"OMOVE" link "GG_OMOVE" 0}
@endnode

@node "GG_WALK_SPEED" "WALK_SPEED command"
@next "GG_MOBJ"
@prev "GG_CMOVE"


@{fg shine}@{bg fill}WALK_SPEED Command@{fg text}@{bg back}

@{i}Sets the pace of the main character animation@{ui}


 @{b} WALK_SPEED speed@{ub}

See the description of the @{"WALK_SPEED" link "ST_WALK_SPEED" 0} statement.
@endnode

@node "GG_MOBJ" " MOBJ "
@next "GG_MEXIT"
@prev "GG_WALK_SPEED"


@{fg shine}@{bg fill}MOBJ Command@{fg text}@{bg back}

@{i}Move the main character next to an object@{ui}


  @{b}MOBJ [obj]@{ub}

The main character is moved to the position indicated by the character
offset parameters of the OBJECT statement or command. If no object
number is given, OBJ1 is assumed.
@endnode

@node "GG_MEXIT" " MEXIT          "
@next "GG_CPOS"
@prev "GG_MOBJ"


@{fg shine}@{bg fill}MEXIT Command@{fg text}@{bg back}

@{i}Move character to exit@{ui}


 @{b} MEXIT@{ub}

This command can only be used in an ACTION: 0;... statement, and moves
the character to the exit point for the clicked exit, as specified in
the corresponding @{"EXIT:" link "ST_EXIT" 0} statement
@endnode

@node "GG_CPOS" " CPOS "
@next "GG_CHAR"
@prev "GG_MEXIT"


@{fg shine}@{bg fill}CPOS Command@{fg text}@{bg back}

@{i}Alter the character's screen position@{ui}

 
  @{b}CPOS x,y@{ub}

Immediately alters the main character's screen position to x,y (without
walking there like @{"CMOVE" link "GG_CMOVE" 0}.) The image is not altered: @{"CIMG" link "GG_CIMG" 0} may be used
for that.

See also: @{"CIMG" link "GG_CIMG" 0}, @{"CMOVE" link "GG_CMOVE" 0}, @{"OMOVE" link "GG_OMOVE" 0}
@endnode

@node "GG_CHAR" " CHAR "
@next "GG_SWITCH"
@prev "GG_CPOS"


@{fg shine}@{bg fill}CHAR Command@{fg text}@{bg back}

@{i}Turn main character display on or off@{ui}

 @{b} CHAR ON|OFF@{ub}

CHAR OFF means the main character is not on screen - use for cutscenes,
animated intros and the like. CHAR ON restores the main character to the
position before CHAR OFF.

See also: @{"CPOS" link "GG_CPOS" 0}, @{"CIMG" link "GG_CIMG" 0}
@endnode

@node "GG_SWITCH" "SWITCH"
@next "GG_FOLLOW"
@prev "GG_CHAR"


@{fg shine}@{bg fill}SWITCH Command@{fg text}@{bg back}

@{i}Switches control between alternate controllable characters@{ui}


  @{b}SWITCH character@{ub}

Using @{"CHAR:" link "ST_CHAR" 0} Statements in graal.main, up to four characters can be
defined that can be put under player control. This command switches
control between them.

Note that inventorys are not automatically connected to characters, so
an @{"INVENTORY" link "GG_INVENTORY" 0} command should normally be given immediately before the
SWITCH command.

@{i}Note:@{ui} You cannot use SWITCH while a @{"CHAR OFF" link "GG_CHAR" 0} is in effect.
@endnode

@node "GG_FOLLOW" "FOLLOW Command"
@next "GG_FLOOR"
@prev "GG_SWITCH"


@{fg shine}@{bg fill}FOLLOW Command@{fg text}@{bg back}

@{i}Makes an alternate controllable character follow the current character@{ui}


 @{b} FOLLOW character,startx,starty,followx,followy,delay
  FOLLOW OFF@{ub}


Any player action causing the controlled character to walk around, and
any @{"CMOVE" link "GG_CMOVE" 0} command, will cause the following character to follow.

This "automatic following" procedure will be in effect until the next
@{"SWITCH" link "GG_SWITCH" 0}, or FOLLOW OFF command. You may also alter the FOLLOW parameters
at any time by giving a new FOLLOW command.

@{b}character@{ub}

This is the number of the character that should follow the
player-controlled character around. 

@{b}startx,starty@{ub}

If the controlled character is transported to a new room, the following
character will also appear there. Its image will be offset from the
controlled character by the amounts specified here. @{b}startx@{ub} should always
be a positive number: It is the Left/Right/Middle position in the
@{"START_POS:" link "ST_START_POS" 0} statements that determines whether the following character
will be placed left or right of the controlled character. @{b}starty@{ub} should
probably be a  small, negative number most of the time - because further
up the picture is also further away in the scene, this will make the
following character appear further away than the controlled character.

@{b}followx,followy@{ub}

These are the offset amounts used when the CMOVE command or a player
mouse click causes the controlled character to move. Both numbers should
always be positive: In most cases, the following character will end up
followy pixels further up the picture than the controlled character. The
only exception is when the controlled character stops after "walking
away" and ends up with its back towards the player - then, the following
character stops followy pixels below the controlled character. This
gives the illusion of the following character still keeping behind the
controlled character.

@{b}delay@{ub}

This specifies the time before the following character starts to move. A
delay of 50 equals a one second wait.


@{i}Notes:@{ui} 

Unfortunately, there is no feasible way for me to make the controlled
and following character - or indeed, multiple characters in the same
room in any situation - keep out of each other's ways. This means the
characters will sometimes seem to walk through each other. You can
minimize the problem by selecting the possible movement paths carefully.
@endnode

@node "GG_FLOOR" " FLOOR          "
@next "GG_NFLOOR"
@prev "GG_FOLLOW"


@{fg shine}@{bg fill}FLOOR Command@{fg text}@{bg back}

@{i}(Re-)defines a floor@{ui}


  @{b}FLOOR number,x1,y1,x2,y2,floormap1/.../floormapn@{ub}

This command works exactly like the @{"FLOOR:" link "ST_FLOOR" 0} statement, and allows you to
re-arrange floors for a room any way you like. You can make previously
unreachable areas accessible, or quite the opposite.

You must make sure that all floormaps are valid - changing a single
floor may mean you have to use FLOOR commands for other floors to just
to change the floor maps. And if you alter the number of floors, you
must also use the @{"NFLOOR" link "GG_NFLOOR" 0} command to set the new number of floors.

See also: @{"NFLOOR" link "GG_NFLOOR" 0} and @{"SETFLOOR" link "GG_SETFLOOR" 0} commands, @{"FLOOR:" link "ST_FLOOR" 0} statement
@endnode

@node "GG_NFLOOR" " NFLOOR         "
@next "GG_SETFLOOR"
@prev "GG_FLOOR"


@{fg shine}@{bg fill}NFLOOR command@{fg text}@{bg back}

@{i}Changes the number of floors in a room@{ui}


  @{b}NFLOOR n_floors@{ub}

Only use this command when you have changes the floor structure, and
number of floors, in a room with the @{"FLOOR" link "GG_FLOOR" 0} command.

See also: @{"FLOOR" link "GG_FLOOR" 0} and @{"SETFLOOR" link "GG_SETFLOOR" 0} commands.
@endnode

@node "GG_SETFLOOR" " SETFLOOR       "
@next "GG_OMOVE"
@prev "GG_NFLOOR"


@{fg shine}@{bg fill}SETFLOOR command@{fg text}@{bg back}

@{i}Informs the system about the main character's whereabouts in the floor
system.@{ui}


 @{b} SETFLOOR [character,]floor@{ub}

Normally, GRAAL automatically keeps track of on which floor your
character is currently positioned. There are, however, a few commands
that may leave the system unaware about your hero's whereabouts. 

These are the @{"FLOOR" link "GG_FLOOR" 0},  @{"OMOVE" link "GG_OMOVE" 0}, and @{"FOLLOW" link "GG_FOLLOW" 0} commands.  If one of these
commands places your character on another floor previously, you should
specify the new floor number with this command. Otherwise, strange
things may happen when the character tries to move next.

@{b}character@{ub}

Only use this parameter in multiple-character games. If @{b}character@{ub} is not
specified, it is always the current floor for the character currently
under player control that is set.

See also: @{"FLOOR" link "GG_FLOOR" 0} and @{"OMOVE" link "GG_OMOVE" 0} commands, and the @{"FLOOR:" link "ST_FLOOR" 0} statement.
@endnode

@node "GG_OMOVE" " OMOVE "
@next "GG_SHOW"
@prev "GG_SETFLOOR"


@{fg shine}@{bg fill}OMOVE Command@{fg text}@{bg back}

@{i}Move an object (or the main character) according to specified animation
sequence

@{ui}
 @{b} OMOVE obj_no,x,y,speed,FLIP| ,WAIT| ,anim|ptrn@{ub}

The object's hot spot is moved to the x,y screen co-ordinates. During
the movement, the @{"animation sequence" link "GG_Animation" 0} specified in the last parameter is
used.


The x and y positions can be set relative to the main character's
current position using CX+offset and CY+offset. Example:

  @{b}OMOVE 2,CX+20,CY+0,1,FLIP, ,A
0,(SIMG1,12)(SIMG2,12)(SIMG3,12)(SIMG2,12)@{ub}

moves object 2 to a position 20 pixels to the right of the main
character, at the normal WALK_SPEED speed, using an animation consisting
of four different images.

If the speed adjustment factor is 1, the speed will be the speed set
with the WALK_SPEED parameter in the graal.main file. A @{b}lower@{ub} number
gives @{b}faster@{ub}" link "ST_WALK_SPEED" 0} parameter in the graal.main file.
A lower number gives faster movement, a @{b}higher@{ub} number gives @{b}slower@{ub}
movement.

If FLIP is specified, and movement is from left to right,  the images
are used as supplied, but if the movement is from right to left, all
images in the animation sequence are automatically flipped first.
Specifying any other value (such as a blank) means the images are always
used as specified.

If WAIT is specified, the entire animation sequence is carried out
before GRAAL continues with the next command. Otherwise, GRAAL will not
check if the animation has been concluded until the next OMOVE command
for the same object. If you put several OMOVE commands for the same
object next to each other, you should specify a blank space instead of
WAIT - this eliminates the brief pauses between OMOVE commands that will
otherwise occur. On the other hand, if the command following an OMOVE is
something like a SHOW command for the  same object, always specify WAIT
- otherwise the SHOW would be affecting the object before the animation
sequence had a chance to finish.
  OMOVE can be used to move and animate the main character using other
animations sequences than the default. Just specify object number 0 to
point to the main character.

If x and y are left blank, the object is animated using the animation
string at its curent position. Normally, the animation is automatically
stopped when the object reaches the x,y position, and the first image in
the animation sequence will the be used as the still image. When no new
x,y position is given, the animation goes on until another
image-manipulating command for the object  is encountered, for example
SHOW or CIMG. Example:

 @{b} OMOVE 0, , ,1,A 0,(11,24)(12,24)@{ub}

would animate the main character alternating between images 11 and 12
indefinitely. (Well, until the image for the main character is altered
using some other command, anyway.)

See also: @{"SHOW" link "GG_SHOW" 0}, @{"CMOVE" link "GG_CMOVE" 0}, @{"CPOS" link "GG_CPOS" 0}, @{"CIMG" link "GG_CIMG" 0}, @{"HIDE" link "GG_HIDE" 0}
@endnode

@node "GG_SHOW" " SHOW "
@next "GG_HIDE"
@prev "GG_OMOVE"


@{fg shine}@{bg fill}SHOW Command@{fg text}@{bg back}

@{i}Show an object@{ui}


 @{b} SHOW obj,x,y,image|anim|ptrn@{ub}

If the object number is 0, the commands manipulates the graphics of the
main character.

The image can be an image number, an animation string, or even a pattern
(PTRN) specification. If you specify DEF, the image from the OBJECT:,
ROOMOBJ: or SECTIONOBJ: statement defining the object will be used.

If x and y are left blank, the position of the object will not be
altered, only the image.

If image is left blank, the object is moved to the new co-ordinates
retaining the previous image.

Note: If the object was in the inventory before the SHOW, it is removed
and the inventory is updated.


Example:

 @{b} SHOW 3, , ,PTRN 1@{ub}

would show object 3 in its previous position using the animation
sequence stored in the 1.ptrn file. This only works if the object was
previously visible.

Another example:

  @{b}SHOW ROBJ1,30,70, @{ub}

would place room object 1 at the new co-ordinates 30,70.

A third example:

  SHOW 0, , , 

refreshes the graphics of the main character. This is useful if you have
loaded new global images, for instance.


See also: @{"HIDE" link "GG_HIDE" 0}, @{"OMOVE" link "GG_OMOVE" 0}, @{"CPOS" link "GG_CPOS" 0}, @{"CIMG" link "GG_CIMG" 0}, @{"CMOVE" link "GG_CMOVE" 0}
@endnode

@node "GG_HIDE" " HIDE "
@next "GG_OBJONTOP"
@prev "GG_SHOW"


@{fg shine}@{bg fill}HIDE Command@{fg text}@{bg back}

@{i}Hides an object@{ui}


 @{b} HIDE obj@{ub}

hides the specified object from view (that is, removes it from the
current room). This may often be used in room DACT statements, using
room flags to decide what objects are being shown and not in a
particular situation or phase of the game.


See also: @{"CHAR" link "GG_CHAR" 0}, @{"SHOW" link "GG_SHOW" 0}
@endnode

@node "GG_OBJONTOP" " OBJONTOP       "
@next "GG_TRACK"
@prev "GG_HIDE"


@{fg shine}@{bg fill}OBJONTOP Command@{fg text}@{bg back}

@{i}Puts the object on top of all other displayed objects@{ui}


 @{b} OBJONTOP obj@{ub}

Sometimes it happens that two objects partly occupy the same space on
screen - one object being displayed on top op the other.

However, the topmost object being displayed properly is not, in itself,
a guarantee that the mouse cursor will actually register it when you
move the cursor across it. If the underlying object is further up
GRAAL's internal list of objects shown in the room, it is that object's
name that will be shown, which is probably not what you want. And that
list was unavailable to you before GRAAL 2.

The simple remedy is this command. If, when testing your adventure, you
find an object which is unavailable in the manner described above,
simply give an OBJONTOP command for it once it's been placed in the room
- in a DACT: statement if it is a ROOMOBJect, or right after a SHOW
command, for example.
@endnode

@node "GG_TRACK" " TRACK "
@next "GG_EFFECT"
@prev "GG_OBJONTOP"


@{fg shine}@{bg fill}TRACK Command@{fg text}@{bg back}

@{i}Handles soundtracker music modules@{ui}


  @{b}TRACK file|list,tempo,FILTER|NOFILTER@{ub}


@{b}file|list@{ub}

If the file name is different than the last sound tracker file name
used, or no tracker file is currently in memory, the file is loaded and
the module starts playing. 


@{b}tempo@{ub}

If tempo is set to 0, vertical blank timing will be used just as in
previous versions of GRAAL.

If tempo is set to another value, it indicates the tempo in BPM (beats
per minute), which gives easier and more accurate timing in most cases.

(This parameter replaces the old LOOP parameter which never did work,
anyway.)


@{b}FILTER|NOFILTER@{ub}

Specify FILTER if you want the Amiga's low-pass audio filter to be on
while the module is playing (takes away some high frequencies and
hissing noises.)



  @{b}TRACK OFF@{ub}

Stop the module playing temporarily.

  @{b}TRACK ON@{ub}

Resume playing a stopped module.

  @{b}TRACK NO@{ub}

Stop playing and erase the module from memory (thus freeing memory
space).

  @{b}TRACK CHANNELS=channels@{ub}

This command determines which channels will play tracker music, and
which will be kept free for sound effects. Specify a list of channels:

 TRACK CHANNELS=123    will use channels 1-3 (or 0-2, depending on 
                       how you refer to them) for tracker music and 
                       keep channel 4 free for SAMPLAY etc.

 TRACK CHANNELS=13     will use channels 1 and 3 for tracker, and 
                       2 and 4 for samples.

 TRACK CHANNELS=1234   will use all channels for tracker music. This 
                       is the default, and it also means samples are 
                       also set to all four channels, thus interrupting

                       the tracker module if you try to use the sound
                       channels for both things simultaneously.

The channel allocation will remain in effect until another  TRACK
CHANNELS=... command is given.



See also: @{"SAMLOAD" link "GG_SAMLOAD" 0}, @{"SAMPLAY" link "GG_SAMPLAY" 0}
@endnode

@node "GG_EFFECT" "EFFECT:"
@next "GG_SOUND"
@prev "GG_TRACK"


@{fg shine}@{bg fill}EFFECT: Command@{fg text}@{bg back}

@{i}Pre-loads a frequently used sound effect@{ui}


 @{b} EFFECT number;file;frequency|DEFAULT@{ub}


@{b}number@{ub}

This is the effect number to be used in the @{"SOUND" link "GG_SOUND" 0} command when playing
the sound effect. A maximum of 2 simultaneous effects can be loaded with
EFFECT commands, so this number must be either 1 or 2.


@{b}file@{ub}

This is the file name of the file containing the IFF or raw sound sample
to be used for the effect.


@{b}frequency|DEFAULT@{ub}

Specifying a frequency means the SOUND command will use this frequency.
DEFAULT means the default frequency stored in the IFF sample will be
used. In the case of a raw sample, DEFAULT means the frequency will be
8363 Hz.
@endnode

@node "GG_SOUND" " SOUND          "
@next "GG_SAMLOAD"
@prev "GG_EFFECT"


@{fg shine}@{bg fill}SOUND Command@{fg text}@{bg back}

@{i}Plays a sound effect pre-loaded with the EFFECT: statement@{ui}


  @{b}SOUND effect_number@{ub}

Up to two sound effects can be loaded with @{"EFFECT" link "GG_EFFECT" 0}   commands for instant
access with this SOUND command.
@endnode

@node "GG_SAMLOAD" " SAMLOAD "
@next "GG_SAMPLAY"
@prev "GG_SOUND"


@{fg shine}@{bg fill}SAMLOAD Command@{fg text}@{bg back}

@{i}Loads a raw or IFF sample into memory@{ui}


 @{b} SAMLOAD file|list>@{ub}

This command loads a raw or IFF sample into memory for later use with
the SAM command.

See also: @{"SAM" link "GG_SAMPLAY" 0}
@endnode

@node "GG_SAMPLAY" " SAMPLAY "
@next "GG_CLPART"
@prev "GG_SAMLOAD"


@{fg shine}@{bg fill}SAM Command@{fg text}@{bg back}

@{i}Plays a previously loaded sample@{ui}

  @{b}SAM DEF|channel,DEF|frequency@{ub}

Play a sample loaded with a previous SAMLOAD command. Note that from
version 2.1, samples can't be looped. If you need a continuously looped
sample, you'll have to put it in a tracker module and use the TRACK
command.

@{b}DEF|channel@{ub}

@{b}DEF@{ub} will play the sample over the sound channels left over by the
@{"TRACK CHANNELS=" link "GG_TRACK" 0} command. That is, if TRACK CHANNELS=24 has been used,
samples will play on channels 1 and 3. If TRACK CHANNELS= has not been
used, the sample will play on all channels, temporarily  interrupting
any music that may be playing.

@{b}channel@{ub} will play the sample on a single channel as specified,
regardless of whether it has been designated a sample channel or not.

@{b}DEF|frequency@{ub}

@{b}DEF@{ub} will make the sample play with the default frequency. To raise or
lower the pitch, specify a @{b}frequency@{ub} instead.

 @{b}SAM OFF@{ub}

Stop playing a sample.

 @{b} SAM NO@{ub}

Stop playing a sample and erase it from memory (thus freeing memory
space).

See also: SAMLOAD
@endnode

@node "GG_CLPART" " CLPART "
@next "GG_IMGS"
@prev "GG_SAMPLAY"


@{fg shine}@{bg fill}CLPART Command@{fg text}@{bg back}

@{i}Load a clipart IFF file@{ui}


  @{b}CLPART file@{ub}

The specified picture file is loaded into memory, where it is used for
grabbing images with the IMGS command.

 @{b} CLPART OFF@{ub}

Get rid off a previously loaded clipart file when it is no longer
needed.

See also: @{"IMGS" link "GG_IMGS" 0}
@endnode

@node "GG_IMGS" " IMGS "
@next "GG_MAKE3D"
@prev "GG_CLPART"


@{fg shine}@{bg fill}IMGS Command@{fg text}@{bg back}

@{i}Loads images into the image bank@{ui}


  @{b}IMGS no,start_img,x1,y1,w,h,x-offset,hotspot@{ub}

The parameters for this command are exactly the same as for the @{"IMGS:" link "ST_IMGS" 0}
statement, except the parameters should be separated by commas (,)
instead of semi-colons (;). There is one slight difference in how you
specify the the starting image number (which is the second parameter).
This should be specified as n, SIMGn, or RIMGn, depending on the type of
images you intend to add / replace in the image bank.

This command must be preceeded by a CLPART command.

See also: @{"CLPART" link "GG_CLPART" 0}
@endnode

@node "GG_MAKE3D" "MAKE3D command"
@next "GG_HOTSP"
@prev "GG_IMGS"


@{fg shine}@{bg fill}MAKE3D Command@{fg text}@{bg back}

@{i}Re-creates the scaled images for a character@{ui}


 @{b} MAKE3D character@{ub}

Normally, the @{"3D:" link "ST_3D" 0} statement handles all scaling of character images
automatically.

However, if you use the @{"CLPART" link "GG_CLPART" 0} and @{"IMGS" link "GG_IMGS" 0} commands to replace the graphics
for a character, you have to issue a MAKE3D command afterwards to create
the scaled images for the new character images.
@endnode

@node "GG_HOTSP" " HOTSP          "
@next "GG_LIGHTS"
@prev "GG_MAKE3D"


@{fg shine}@{bg fill}HOTSP Command@{fg text}@{bg back}

@{i}Alters the hotspot of an image@{ui}


 @{b} HOTSP image,position@{ub}

This command is used when you need to make changes to the "3D order" in
which objects and images are displayed on the screen. The hotspot is the
"graphical reference point" from which all coordinates are calculated.


@{b}image@{ub}

This is the image number for which to set the hotspot.


@{b}position@{ub}

the position can take two formats: the "Y" format and the "X/Y"-format,
depending on whether you specify a single number or two numbers with a
slash in between.

Y-format

A hotspot position of 0 defines the default hotspot at the middle of the
bottom of the image. 

Any other value defines another hotspot in the y direction of the image,
and the x position remains as it were. 

The y direction is the important one, because it is the relative
position  of hotspots in the y direction that determines which image
goes in front  of another on the screen. The 


X/Y-format

the first number sets the x position, the second the y position.



See also: @{"IMGS" link "ST_IMGS" 0} statement
@endnode

@node "GG_LIGHTS" " LIGHTS "
@next "GG_COLOUR"
@prev "GG_HOTSP"


@{fg shine}@{bg fill}LIGHTS Command@{fg text}@{bg back}

@{i}Fade scene area out or in@{ui}


 @{b} LIGHTS ON|OFF@{ub}

ON makes the scene area visible. OFF fades the scene area to black.  A
LIGHTS ON must always be present in a DACT: statement for a room,
otherwise the screen will stay black and nobody will be able to do very
much!
@endnode

@node "GG_COLOUR" " COLOUR "
@next "GG_FADE"
@prev "GG_LIGHTS"


@{fg shine}@{bg fill}COLOUR Command@{fg text}@{bg back}

@{i}Change a colour@{ui}


  @{b}COLOUR [DLY,]colour,colour_value@{ub}

The colour is changed to the new value. If you want to manipulate
colours in DACT: statements before the @{"LIGHTS ON" link "GG_LIGHTS" 0} command has been
issued, begin the command with the DLY (delay) parameter. This will
cause the new colour to faded in together with the rest when the LIGHTS
ON take effect.

See also: @{"FADE" link "GG_FADE" 0}
@endnode

@node "GG_FADE" " FADE "
@next "GG_CAMERA"
@prev "GG_COLOUR"


@{fg shine}@{bg fill}FADE Command@{fg text}@{bg back}

@{i}Fade one colour to another@{ui}


 @{b} FADE colour,speed,colour_value,WAIT|NOWAIT|STACK@{ub}

Fades the specified colour to the new colour value with a certain speed.
Use the STACK parameter if several colours should be faded
simultaneously - GRAAL will wait until a FADE command with WAIT or
NOWAIT specified and then also fade all STACKed colours at the same
time.

WAIT causes the action to be suspended during the colour fade. NOWAIT
means action will continue while the colours are being faded.

See also: @{"COLOUR" link "GG_COLOUR" 0}
@endnode

@node "GG_CAMERA" " CAMERA         "
@next "GG_TITLE"
@prev "GG_FADE"


@{fg shine}@{bg fill}CAMERA Command@{fg text}@{bg back}

@{i}Pan the camera to any part of the background picture in scene area@{ui}


  @{b}CAMERA xpos_center@{ub}

@{b}xpos_center@{ub} is the horizontal position GRAAL tries to put in the center
of the scene area. Of course, the pan stops whenever one of the edges of
the background picture comes into view.

Use this command in cutscenes and the like, when you need to move the
camera away from or independently of the main character.
@endnode

@node "GG_TITLE" " TITLE "
@next "GG_TYPE"
@prev "GG_CAMERA"


@{fg shine}@{bg fill}TITLE Command@{fg text}@{bg back}

@{i}Show a title screen@{ui}


 @{b} TITLE file,effect|CUT|FADE@{ub}

The file is an ordinary iff picture file. The effect can be one of the
following:

@{b}effect@{ub}

A previous title picture is gradually dissolved into a new one using a
bit pattern that depends on the number given. Odd numbers, and prime
numbers in particular, are recommended. Some numbers don't work at all!

@{b}FADE@{ub}

The old picture is faded to black, then the new one is faded in.

@{b}CUT@{ub}

Pictures are just swapped without any special effects. HAM screens
should be handled this way.

See also: @{"TYPE" link "GG_TYPE" 0}
@endnode

@node "GG_TYPE" " TYPE "
@next "GG_SETTEXT"
@prev "GG_TITLE"


@{fg shine}@{bg fill}TYPE Command@{fg text}@{bg back}

@{i}Type text on a title screen.@{ui}


 @{b} TYPE font,colour,x,y,SHADOW|SHADOW2|BORDER|NONE,text@{ub}

This command is used to type text on title background screens. 

@{b}font@{ub} is 1 or 2, corresponding to the @{"TITLEFONT:" link "ST_XXXFONT" 0} statements in the
graal.main file.

@{b}colour@{ub} is the colour number

@{b}x,y@{ub} is the printing position. x=-1 means the text will be centered.

@{b}SHADOW@{ub}, @{b}SHADOW2@{ub} or @{b}BORDER,@{ub} surrounds the text with different kinds of
shading for greater legibility. If no effect is desired, use NONE.

See also: @{"TITLE" link "GG_TITLE" 0}
@endnode

@node "GG_SETTEXT" "SETTEXT"
@next "GG_TEXT"
@prev "GG_TYPE"


@{fg shine}@{bg fill}SETTEXT Command@{fg text}@{bg back}

@{i}Sets the display style for text@{ui}


 @{b}SETTEXT [SQUARE|ROUNDED|CARTOON,fill,bg,ink]@{ub}

This command sets the display style for all subsequent TEXT commands
until a new SETTEXT without parameters is given.


@{b}SQUARE|ROUNDED|CARTOON@{ub}

The shape of the text background. SQUARE is - well, square, ROUNDED has
slightly rounded corners, and CARTOON adds a cartoon-style speech bubble
arrow to the ROUNDED shape.


@{b}fill@{ub}

The type of fill behind the text. 

0 gives a solid fill, and also means the usual black outline round the
text will disappear.

2 paint every other pixel, levaing you with a "semi-transparent"
background.

1 and 3-15 gives a number of other patterns, which is prbably  less
useful


@{b}bg@{ub}

is the colour of the background fill


@{b}ink@{ub}

is the colour of the border surrounding the fill.


Se also the @{"SPEECH_LAYOUT:" link "ST_SPEECHLAYOUT" 0} statement, which gives a similar effect to
SAY, RESP and THINK command text.
@endnode

@node "GG_TEXT" " TEXT           "
@next "GG_BOBON"
@prev "GG_SETTEXT"


@{fg shine}@{bg fill}TEXT command@{fg text}@{bg back}

@{i}Display text in scene area@{ui}


  @{b}TEXT x,y,colour,text@{ub}

This command uses the same font and pause lengths as the @{"SAY" link "GG_SAY" 0}, @{"THINK" link "GG_THINK" 0}, and
@{"RESP" link "GG_RESP" 0} commands, but any text can be used and it is not connected to the
main character or a certain dialogue.


@{b}x,y@{ub}

The text is placed centered around these co-ordinates. 

If x is set to -1, the text is be centered vertically on screen, no
matter how the background is currently scrolled.


The text can contain audio info for talkies. See @{"audio info" link "Audio Info" 0}.


See also: @{"SAY" link "GG_SAY" 0}, @{"THINK" link "GG_THINK" 0}, and @{"RESP" link "GG_RESP" 0} commands
@endnode

@node "GG_BOBON" " BOBON "
@next "GG_BOBOFF"
@prev "GG_TEXT"


@{fg shine}@{bg fill}BOBON Command@{fg text}@{bg back}

@{i}Places a BOB that is not a GRAAL object on screen.@{ui}


 @{b} BOBON bob,x,y,image@{ub}

If you are putting a new image on the screen, first make sure  the BOB
number is not already in use for any object in the room.

If the BOB is already placed on screen, and x and y are left empty, only
the image is changed and not the position.

If the BOB is already placed on screen, and the image number is left
blank, only the BOB position changes.

See also: @{"BOBOFF" link "GG_BOBOFF" 0}
@endnode

@node "GG_BOBOFF" " BOBOFF "
@next "GG_PBOB"
@prev "GG_BOBON"


@{fg shine}@{bg fill}BOBOFF Command@{fg text}@{bg back}

@{i}Take away a BOB that is not an object from the screen@{ui}


  @{b}BOBOFF bob@{ub}

Used to take away BOBs from display that have been put there by the
BOBON command.

See also: @{"BOBON" link "GG_BOBON" 0}
@endnode

@node "GG_PBOB" " PIMG           "
@next "GG_COMGR"
@prev "GG_BOBOFF"


@{fg shine}@{bg fill}PIMG command@{fg text}@{bg back}

@{i}Pastes an image@{ui}


 @{b} PIMG ulx,uly,image@{ub}

The image is pasted into the picture without anyway of removing it
afterwards (unlike the BOBON / BOBOFF commands, which actually use a BOB
to display an image).

Note that the coordinates in this case are the upper left corner of the
image and not the hotspot position.
@endnode

@node "GG_COMGR" "COMGR command"
@next "GG_SETDATE"
@prev "GG_PBOB"


@{fg shine}@{bg fill}COMGR Command@{fg text}@{bg back}

@{i}Pastes an image onto the command or dialogue area@{ui}


 @{b} COMGR ulx,uly,image,S| @{ub}

This is exactly like a @{"PIMG" link "GG_PIMG" 0} command for the command or dialogue area,
depending on which happens to be on screen at the time.

@{b}ulx,uly@{ub}

Upper left corner of image

@{b}S@{ub}

If the last parameter is @{b}S@{ub}, the command areas current look will be saved
to memory. Otherwise, the pasted image is lost when switching back and
forth between dialogue and command modes.

Note: Saving the new version of the command area takes time!
@endnode

@node "GG_SETDATE" " SETDATE        "
@next "GG_SETTIME"
@prev "GG_COMGR"


@{fg shine}@{bg fill}SETDATE Command@{fg text}@{bg back}

@{i}Sets the (game) date@{ui}


  @{b}SETDATE year,month,date,weekday@{ub}

Note that we are talking about the "internal game time", not the system
real time clock...

If any of the weekday, date, or month parameters are left blank, they
retain their old values.

@{b}year@{ub}

Anything you wish, preferably 2 or 4 digits

@{b}month@{ub}

1-12, 1 being January...

@{b}date@{ub}

1-31. The GRAAL calendar can handle the normal lengths of the months,
but does not consider leap-years.

@{b}weekday@{ub}

1-7, 1 being Monday and 7 Sunday. The GRAAL calendar does not check the
historical accuracy of weekday versus date, though (see above).

See also: @{"SETTIME" link "GG_SETTIME" 0} and @{"ADDTIME" link "ADDTIME" 0} commands
@endnode

@node "GG_SETTIME" " SETTIME        "
@next "ADDTIME"
@prev "GG_SETDATE"


@{fg shine}@{bg fill}SETTIME command@{fg text}@{bg back}

@{i}Sets the time@{ui}


  @{b}SETTIME hours,minutes@{ub}

The time must be set in 24-hour format, regardless of whether it is
presented that way or not (see @{"TIME_FORMAT" link "ST_TIMEFORMAT" 0}).

Note that we talk about the "in-game clock", not the real-time system
clock here.

See also: @{"ADDTIME" link "ADDTIME" 0} command
@endnode

@node "ADDTIME" " ADDTIME        "
@next "GG_SAVETIME"
@prev "GG_SETTIME"


@{fg shine}@{bg fill}ADDTIME command@{fg text}@{bg back}

@{i}Advances the clock@{ui}


 @{b} ADDTIME hours,minutes@{ub}

Added time also alters the calendar if needed. Note that this command is
only meant to be used for adding minutes, hours or possibly a day or two
- when jumping further in time, use the @{"SETDATE" link "GG_SETDATE" 0} command.

If @{"TIME_LAYOUT" link "ST_TIMELAYOUT" 0} or @{"DATE_LAYOUT" link "ST_DATELAYOUT" 0} is active, the command also updates the
time and/or date displays.

See also: @{"SETTIME" link "GG_SETTIME" 0} command
@endnode

@node "GG_SAVETIME" " SAVETIME       "
@next "GG_RESTORETIME"
@prev "ADDTIME"


@{fg shine}@{bg fill}SAVETIME Command@{fg text}@{bg back}

@{i}Saves the current in-game time and date@{ui}


  @{b}SAVETIME@{ub}


This command is mainly here to make it a little easier to perform
operations on dates and times. Doing "maths" on dates and times manually
is not very fun, so this command lets you use the @{"ADDTIME" link "ADDTIME" 0} command
without loosing the current time and date forever: Using @{"RESTORETIME" link "GG_RESTORETIME" 0}
brings back the saved time and date.

Example: You wish to store the date and time twelve hours from "now" in
room flag 1 for room 1. This sequence of commands ought to do it.

SAVETIME;ADDTIME 12,0;SETRF 1,1=#TIME;RESTORETIME
@endnode

@node "GG_RESTORETIME" " RESTORETIME    "
@next "GG_NOBREAK"
@prev "GG_SAVETIME"


@{fg shine}@{bg fill}RESTORETIME Command@{fg text}@{bg back}

@{i}Restores a previously saved time and date@{ui}


  @{b}RESTORETIME@{ub}

Use this command to restore the date and time to that saved with
@{"SAVETIME" link "GG_SAVETIME" 0}.
@endnode

@node "GG_NOBREAK" " NOBREAK "
@next "GG_FINAL"
@prev "GG_RESTORETIME"


@{fg shine}@{bg fill}NOBREAK Cutscene Command@{fg text}@{bg back}

@{i}Disables [Esc] key in cutscenes@{ui}


 @{b} NOBREAK@{ub}

This can only appear as the very first statement in a cutscene, and
tells GRAAL that the [Esc] key cannot be used to skip this cutscene.
@endnode

@node "GG_FINAL" " FINAL"
@next "GG_TRACE"
@prev "GG_NOBREAK"


@{fg shine}@{bg fill}FINAL Cutscene Command@{fg text}@{bg back}

@{i}Indicates resume point in cutscene@{ui}


 @{b} FINAL@{ub}

This can only be use in a cutscene. All commands below FINAL will be
executed is the rest of the cutscene was skipped with the [Esc] key.
@endnode

@node "GG_TRACE" "TRACE Command"
@next "GG_TRACE"
@prev "GG_FINAL"


@{fg shine}@{bg fill}TRACE Command@{fg text}@{bg back}

@{i}Starts or stops the single-step trace mode@{ui}


  @{b}TRACE ON|OFF@{ub}

This is a development function, which can also be activated and
de-activated from the on-line monitor.

TRACE ON opens a trace console window at the top of the display, where
each condition and command that GRAAL is about to execute is shown in
green. Nothing will happen until you press a key - then the text
switches to red and the condition or command is executed in the normal
way. An empty console window means GRAAL is waiting for player input.
@endnode

@node "GG_ST_MAIN" " graal.main file "
@next "GG_ST_SECT"
@prev "Main"


@{fg shine}@{bg fill}graal.main Statements@{fg text}@{bg back} @{"=DEMO=>" alink "graal.main/main" 0}

When it comes to the order in which the statements should appear, look
to the graal.main file of the "Olaf" demo and the ones in The GRAAL
Herald diskmags for guidance. The most important thing is to make sure
all statements requiring graphics to be present have something to work
with - so the statements  specifying the graphics should come before
those actually using the graphics!

("Number" below: ONE means statement occurs only once. ANY means zero to
any number of times.)

 Statement          Number Description

 @{" NAME " link "ST_NAME" 0}             one    Name of the adventure
 @{" VERSION " link "ST_VERSON" 0}          one    Version number of the adventure
 @{" MAX_CACHE " link "ST_MAXCACHE" 0}        one    Maximum number of files in memory cache

 @{" DEBUG " link "ST_DEBUG" 0}            0-1    Switches on debug stuff in encrypted version

 @{" MAX_ROOM " link "ST_MAX_ROOM" 0}         one    Maximum room number used
 @{" MAX_SECTION " link "ST_MAX_SECTION" 0}      one    Maximum section number used
 @{" MAX_DLG " link "ST_MAXDLG" 0}          one    Maximum number of dialogues
 @{" N_DIALOGUES " link "ST_NDIALOGUES" 0}      0-1    Sets the limits for dialogues
 @{" MAX_DACT " link "ST_MAX_DACT" 0}         one    Maximum number of DACT statements per room
 @{" MAX_ACTION " link "ST_MAXACTION" 0}       one    Maximum number of ACTION statements per room

 @{" GLOBALOBJS " link "ST_OBJS" 0}       one    Number of global objects
 @{" SECTIONOBJS " link "ST_OBJS" 0}      one    Number of section objects
 @{" ROOMOBJS " link "ST_OBJS" 0}         one    Number of room objects

 @{" N_GLOBALIMGS " link "ST_NIMGS" 0}     one    Number of global images
 @{" N_SECTIONIMGS " link "ST_NIMGS" 0}    one    Number of section images
 @{" N_ROOMIMGS " link "ST_NIMGS" 0}       one    Number of room images
 
 @{" CLPART " link "ST_CLPART" 0}           any    Name of picture containing clipart graphics
 @{" IMGS " link "ST_IMGS" 0}             any    Grab global images from clipart picture

 @{" MODE_SWITCH " link "ST_MODESWITCH" 0}      0-1    Command/dialogue switching style
 @{" AREA_SIZES " link "ST_AREASIZES" 0}       0-1    Heights of scene and command areas
 @{" COMMAND_AREA " link "ST_AREAFILES" 0}     one    Name of picture with command area graphics
 @{" DLG_AREA " link "ST_AREAFILES" 0}         one    Name of picture with dialogue area graphics
 @{" RESOURCE " link "ST_RESOURCE" 0}         one    Name of interface resource bank

 @{" N_VERBS " link "ST_NVERBS" 0}          0-1    Number of verbs, default is 9
 @{" VERB_ZONE " link "ST_VERBZONE" 0}        any    position and size of each verb "button"
 @{" VERB_TEXT " link "ST_VERBTEXT" 0}        any    Message when pointing to a verb

 @{" ARROW_CURSOR " link "ST_ARROW_CURSOR" 0}     0-1    Image to use for arrow mouse pointer
 @{" CROSSHAIR_CURSOR " link "ST_ARROW_CURSOR" 0} 0-1    Image to use for crosshair mouse pointer
 @{" CURSOR_PALETTE " link "ST_CURSOR_PALETTE" 0}   0-1    Colours for mouse pointer

 @{" INV_LAYOUT " link "ST_INVLAYOUT" 0}       0-1    position and size of inventory list
 @{" INV_UP " link "ST_INVUP_ETC" 0}           0-1    properties of inventory scroll arrow 
 @{" INV_DOWN " link "ST_INVUP_ETC" 0}         0-1    properties of inventory scroll arrow 

 @{" CUTSCENE_LAYOUT " link "ST_CUTSCENELAYOUT" 0}  0-1    position and size of inventory list

 @{" DLG_LAYOUT " link "ST_DLGLAYOUT" 0}       0-1    position and size of dialogue lines
 @{" DLG_UP " link "ST_INVUP_ETC" 0}           0-1    properties of dialogue scroll arrow
 @{" DLG_DOWN " link "ST_INVUP_ETC" 0}         0-1    properties of dialogue scroll arrow

 @{" SENTENCE_LAYOUT " link "ST_SENTLAYOUT" 0}  0-1    position and size of sentence display

 @{" TIME_FORMAT " link "ST_TIMEFORMAT" 0}      0-1    format of time display
 @{" TIME_LAYOUT " link "ST_TIMELAYOUT" 0}      0-1    layout of time display
 @{" DATE_FORMAT " link "ST_DATEFORMAT" 0}      0-1    format of date display 
 @{" DATE_LAYOUT " link "ST_DATELAYOUT" 0}      0-1    layout of date display 
 @{" MONTH_TEXT " link "ST_MONTHTEXT" 0}       0-1    change names of all months
 @{" DAY_TEXT " link "ST_DAYTEXT" 0}         0-1    change names of all the days of the week

 @{" SYSTEM_TEXT " link "ST_SYSTEMTEXT" 0}      any    change system message texts

 @{" WALK_BUTTON " link "ST_WALKBUTTON" 0}      one    Left or right button used for walking?
 @{" DISABLE_QUIT " link "ST_DISQUIT" 0}     0-1    Disables the "q" quit key
 @{" DISABLE_SAVE " link "ST_DISSAVE" 0}     0-1    Disables the "s" and "l" save/load keys

 @{" EXIT_COL " link "ST_EXIT_COL" 0}         one    Text color of exit names
 @{" OBJ_COL " link "ST_OBJ_COL" 0}          one    Text color of object names

 @{" START_ROOM " link "ST_START_ROOM" 0}       one    Adventure starting position

 @{" MSGFONT " link "ST_XXXFONT" 0}          one    Scene area text font and size
 @{" COMFONT " link "ST_XXXFONT" 0}          one    Command and dialogue area text font and size
 @{" TITLEFONT1 " link "ST_XXXFONT" 0}       one    Titlepage text font and size (1)
 @{" TITLEFONT2 " link "ST_XXXFONT" 0}       one    Titlepage text font and size (2)

 @{" LINE_LENGTH " link "ST_linelength" 0}      one    Line length for SAY, RESP, etc.
 @{" NORMAL_WAIT " link "ST_NORMWAIT" 0}      0-1    Normal wait period for texts

 @{" CHAR " link "ST_CHAR" 0}             0-4    Specify data for alternate characters

 @{" CHARACTER_HEIGHT " link "ST_CHARSIZE" 0} 0-1    Estimated average height of main character
 @{" CHARACTER_WIDTH " link "ST_CHARSIZE" 0}  0-1    Estimated average width of main character

 @{" CHARACTER_COL " link "ST_CHARACTER_COL" 0}    0-1    Text color of main character "speech"
 @{" STILL_RIGHT " link "ST_STILL" 0}      one    Main character right profile image  
 @{" STILL_LEFT " link "ST_STILL" 0}       one    Main character left profile image
 @{" STILL_BACK " link "ST_STILL" 0}       one    Main character backside image
 @{" STILL_FRONT " link "ST_STILL" 0}      one    Main character front image
 @{" PAUSE_RIGHT " link "ST_PAUSE" 0}      one    Main character pause image having walked
right
 @{" PAUSE_LEFT " link "ST_PAUSE" 0}       one    Main character pause image having walked
left
 @{" PAUSE_BACK " link "ST_PAUSE" 0}       one    Main character pause image having walked
away
 @{" PAUSE_FRONT " link "ST_PAUSE" 0}      one    Main character pause image having walked
toward
 @{" WALK_RIGHT " link "ST_WALK" 0}       one    Main character animation for walking right
 @{" WALK_LEFT " link "ST_WALK" 0}        one    Main character animation for walking left
 @{" WALK_AWAY " link "ST_WALK" 0}        one    Main character animation for walking away
 @{" WALK_TOWARD " link "ST_WALK" 0}      one    Main character animation for walking toward
 @{" WALK_SPEED " link "ST_WALK_SPEED" 0}       0-1    Main character walking speed adjustment

 @{" TALK_MAP " link "ST_TALK_MAP" 0}         1-8    Speech animations mapped to pause/still
images
 @{" HANDLE_MAP " link "ST_HANDLE_MAP" 0}       1-8    Object manipulation animations mapped to -"-

 @{" OBJECT " link "ST_OBJECT" 0}           any    Definitions of global objects

 @{" DLG " link "ST_DLG" 0}              any    Definitions of dialogue partners *NEW*

 @{" ACTION " link "ST_ACTION" 0}           any    Actions taken for input relevant to entire
game

@endnode

@node "GG_ST_SECT" " .section files "
@next "GG_ST_ROOM"
@prev "GG_ST_MAIN"


@{fg shine}@{bg fill}n.section Statements@{fg text}@{bg back} @{"=DEMO=>" alink "1.section/main" 0}

Follow the statement order presented here in your .section files to
avoid any unnecessary trouble.

  Statement      Number Description

  @{" CLPART " link "ST_CLPART" 0}       any    Name of picture file containing clipart
  @{" SECTIONIMGS " link "ST_IMGS" 0}  any    Grab section images from clipart picture

  @{" SECTIONOBJ " link "ST_OBJECT" 0}   any    Define section objects

  @{" LINE " link "ST_LINE" 0}         any    Define dialogue lines main character can choose
                        from *NEW*

  @{" LACT " link "ST_LACT" 0}         any    Define responses to dialogue lines *NEW*

  @{" DACT " link "ST_DACT" 0}         any    Actions executed directly when the section file
                        is first used.

  @{" ACTION " link "ST_ACTION" 0}       any    Actions taken for player input relevant to
                        section
@endnode

@node "GG_ST_ROOM" " .room files "
@next "GG_ST_ROOM"
@prev "GG_ST_SECT"


@{fg shine}@{bg fill}n.room Statements@{fg text}@{bg back} @{"=DEMO=>" alink "1.room/main" 0}

Please follow the order indicated here in your .room files to avoid
unnecessary errors and trouble.


  Statement    Number Description

  @{" UPDATE " link "ST_UPDATE" 0}     one    Frame update rate *NEW*
  @{" SECTION " link "ST_SECTION" 0}    one    Section to which room belongs
  @{" BACKDROP " link "ST_BG_IFF" 0}   one    Name of background picture for room

  @{" START_POS " link "ST_START_POS" 0}  any    Starting positions for main character

  @{" FLOOR " link "ST_FLOOR" 0}      1-12   Areas where the main character can "put its feet"

  @{" PATH " link "ST_PATH" 0}       0-12   Path used for navigating between floors

  @{" EXIT " link "ST_EXIT" 0}       1-10   Exits

  @{" CLPART " link "GG_CLPART" 0}     any    Name of picture file containing clipart
  @{" ROOMIMGS " link "ST_IMGS" 0}   any    Grab room images from clipart picture

  @{" STATIC " link "ST_STATIC" 0}     any    Place static graphic elements on background
                      picture
  @{" ANIM " link "ST_ANIM" 0}       any    Place animated graphic elements on background
                      picture

  @{" ROOMOBJ " link "ST_OBJECT" 0}    any    Define room objects

  @{" DACT " link "ST_DACT" 0}       any    Actions to be taken directly upon entering the
                      room

  @{" LINE " link "ST_LINE" 0}       any    Define dialogue lines main character can choose
                      from
  @{" LACT " link "ST_LACT" 0}       any    Define responses to dialogue alternatives

  @{" ACTION " link "ST_ACTION" 0}     any    Actions to take for player input relevant to room
@endnode

@node "ST_NAME" "NAME"
@next "ST_VERSON"
@prev "ST_NAME"


@{fg shine}@{bg fill}NAME Statement (main)@{fg text}@{bg back}

@{i}Gives the adventure name@{ui}


  @{b}NAME: game_title@{ub}

It's always nice to know what you are playing, isn't it? This is shown
when the player presses "V" and also identifies saved game files.
@endnode

@node "ST_VERSON" "VERSION"
@next "ST_EXIT_COL"
@prev "ST_NAME"


@{fg shine}@{bg fill}VERSION Statement (main)@{fg text}@{bg back}

@{i}Gives the adventure version@{ui}


  @{b}VERSION: version_no@{ub}

This is used to make sure saved game files are compatible with the
current status of your adventure - always update this when you do
ANYTHING with the adventure that affects the number of rooms, objects,
sections, object definitions, or any flag usage! One of the most common
sources of problems when debugging is using old saved game files.
@endnode

@node "ST_MAXCACHE" "MAX_CACHE"
@next "ST_DEBUG"
@prev "ST_VERSON"


@{fg shine}@{bg fill}MAX_CACHE Statement (main)@{fg text}@{bg back}

@{i}Sets the maximum number of files in the memory cache@{ui}


 @{b} MAX_CACHE: no_of_files@{ub}

For normal use: Set to 0 when creating a game (especially if you are
using the on-line debugger to reload altered scripts).

Set to 100 once the game is ready to be played to eliminate disk swaps
and make use of any extra memory you may have.

When GRAAL detects that extra memory is available, it calculates how
many files it will be able to fit into RAM, thus reducing disk access
during gameplay. GRAAL calculates an average of 50K per file - if this
is totally wrong (and don't ask me how, you will probably never have to
bother), you may have to set this to a very low number or even to zero.

If you are creating a game and have MAX_CACHE set to anything but 0,
graal will sometimes read old scripts from memory when you really want
it to read the changes you just saved to disk. That is why you should
set this to 0 during development.
@endnode

@node "ST_DEBUG" " DEBUG "
@next "ST_ARROW_CURSOR"
@prev "ST_MAXCACHE"


@{fg shine}@{bg fill}DEBUG: Statement (main)@{fg text}@{bg back}

@{i}Switches on debugging tools & stuff in encrypted version of the game@{ui}


  @{b}DEBUG:@{ub}

Note: This is only of use to registered users.

Sometimes, you have to debug problems to do with the organisation of
files on the delivery diskettes, and you need to do it AFTER having used
the encrypt/compress option in GPRO. Just have this statement in
graal.main (BEFORE running it through GPRO, mind you!). This makes it
possible to call up the monitor, and it also leave s the "looking for
file ..." message in the diskette switching requester. Once everything
is OK, take away DEBUG: in the source graal.main, and make another set
of diskettes by running GPRO and GDC again...
@endnode

@node "ST_NTSCTIMING" "NTSC_TIMING: Statement"
@next "ST_ARROW_CURSOR"
@prev "ST_DEBUG"


@{fg shine}@{bg fill}NTSC_TIMING: Statement@{fg text}@{bg back}

@{i}Makes pauses equally long on NTSC and PAL systems@{ui}


  @{b}NTSC_TIMING: YES|NO@{ub}

While most European countries use the PAL standard for T.V. broadcasts,
U.S.A. and other countries use NTSC. NTSC has a lower resolution but a
higher refresh rate, making for a more stable picture. This means that
depending on the system used, timing operations that depend on waiting
for vertical blank periods (that is, the periods between drawing a
complete T.V. picture) will have different lengths depending on the
system. A pause for 1/50th of a second on a PAL system will be a 1/60th
second wait on  an NTSC system.

This command makes all pauses handled by the GRAAL pause function
equally long on NTSC and PAL systems. That is, if NTSC_TIMING: is set to
yes, the length of each pause will be multiplied by 1.2.

Among the affected commands are @{b}W@{ub}(ait), @{b}SAY@{ub}, @{b}THINK@{ub}, @{b}RESP@{ub} and @{b}TEXT@{ub}.

@{i}Note 1:@{ui} Animations are NOT affected by this statement: they will still
run faster under NTSC.

@{i}Note 2:@{ui} To make the playback speed of tracker modules equal in PAL and
NTSC, use the new tempo parameter of the @{"TRACK" link "GG_TRACK" 0} command.
@endnode

@node "ST_ARROW_CURSOR" " ARROW_CURSOR: "
@next "ST_CURSOR_PALETTE"
@prev "ST_DEBUG"


@{fg shine}@{bg fill}ARROW_CURSOR / CROSSHAIR_CURSOR Statements (main)@{fg text}@{bg back}

@{i}Changes the image of the mouse pointer@{ui}


 @{b} ARROW_CURSOR: image;hotspotx;hotspoty
  CROSSHAIR_CURSOR: image;hotspotx;hotspoty@{ub}


@{b}image@{ub}

a normal image number - you must grab the image to be used using a IMGS:
statement first.

Note that the images to be used as mouse pointer shapes must be drawn i
lowres, and in four colours (2 bitplanes) only. Also, the image must be
exactly 16 pixels wide. (Actually, the IMGS: statement should read 17
pixels, which will actually pick up 16 - one of life's little
mysteries.)


@{b}hotspotx;hotspoty@{ub}

This sets the "sensitive point" of the cursor image, counted in pixels
from the upper left corner of the image.


See also: @{"CURSOR_PALETTE" link "ST_CURSOR_PALETTE" 0} statement
@endnode

@node "ST_CURSOR_PALETTE" " CURSOR_PALETTE: "
@next "ST_INVLAYOUT"
@prev "ST_ARROW_CURSOR"


@{fg shine}@{bg fill}CURSOR_PALETTE Statement (main)@{fg text}@{bg back}

@{i}Sets the colours to use for the mouse pointer in the command area

@{ui}
  @{b}CURSOR_PALETTE: rgb;rgb;rgb@{ub}

The mouse pointer uses three colours, except for its first colour (0),
which is regarded as transparent.

The colours specified here are used in the command and dialogue area.
Each colour value is given as a a red, green, and blue component value
in hexadecimal.

FFF means white 000 means black 888 means grey 550 means dark yellow
(some red + some blue) 0FF means bright cyan (all green + all blue), and
so on...

In the scene area, colours 1, 2, and 3 of the cursor will be translated
into colours 17, 18, and 19 of the backdrop palette.
@endnode

@node "ST_INVLAYOUT" "INV_LAYOUT"
@next "ST_INVUP_ETC"
@prev "ST_CURSOR_PALETTE"


@{fg shine}@{bg fill}INV_LAYOUT Statement (main)@{fg text}@{bg back}

@{i}Controls the layout of the inventory list@{ui}


  @{b}INV_LAYOUT: x1;y1;x2;y2;rows;cols;TEXT|ICONS;
              VERTICAL|HORIZONTAL;ink/image_no;bg@{ub}

The first four parameters determines the size and position of the box
containing the inventory list. "rows" and "columns" determines how many
rows and columsn there are.


@{b}TEXT|ICONS@{ub}

determines whether text or icons will be used for the objects in the
inventory list


@{b}VERTICAL|HORIZONTAL@{ub}

determines whether the list scrolls vertically (top to bottom) or
horizontally (left to right).


@{b}ink/image_no@{ub}

If the inventory display is TEXT, this is the ink colour. 

If the display is ICONS, this is the image number to be used for an
"empty space" in the inventory display. For example, if all your
inventory icons have a border, this image should be a border with
nothing in it - it kind of helps fill out the display...

When a text inventory is specified, it is assumed there may be a border
(1 pixel high, 2 pixels wide) around each "cell" in the inventory
display: This means GRAAL does not erase the edges of the "cell".

@{b}bg@{ub}

specifies the colour to use for the background colour.


If no INV_LAYOUT statement is given, the following is assumed:

INV_LAYOUT: 284;19;634;60;3;2;TEXT;VERTICAL;7;8

which corresponds to the GRAAL built-in command area (the one used if
COMMAND_AREA: DEFAULT is specified).
@endnode

@node "ST_INVUP_ETC" " INV_UP "
@next "ST_DLGLAYOUT"
@prev "ST_INVLAYOUT"


@{fg shine}@{bg fill}INV_UP / INV_DOWN / DLG_UP / DLG_DOWN Statements (main)@{fg text}@{bg back}

@{i}Sets the properties of the arrows used to scroll the inventory and the
dialogue lines@{ui}


  @{b}INV_UP: x;y;image1;image2
  INV_DOWN: x;y;image1;image2
  DLG_UP: x;y;image1;image2
  DLG_DOWN: x;y;image1;image2@{ub}

@{b}x;y@{ub}

is the top left hand corner of the aroow of other symbol used to
indicate the list can be scrolled (up or down, depending on which
statement we're talking about)

@{b}image1@{ub}

is the image used when the function is available 

@{b}image2@{ub}

is the image used when the function is unavailable


The images must be global. The default statements are as follows:

 INV_UP: 265;18;12;10;3;5
 INV_DOWN: 265;48;12;10;4;5

 DLG_UP: 8;8;12;10;3;5
 DLG_DOWN: 8;38;12;10;4;5

As you see, by default the inventory and dialogue displays use the same
symbols (up and  down arrows), and all statements use the same image2.
This is possible because the "not available" symbol is just a piece of
background, erasing the unavailable arrow(s) completely.
@endnode

@node "ST_DLGLAYOUT" " DLG_LAYOUT "
@next "ST_CUTSCENELAYOUT"
@prev "ST_INVUP_ETC"


@{fg shine}@{bg fill}DLG_LAYOUT Statement (main)@{fg text}@{bg back}

@{i}Determines the layout of the dialogue area@{ui}


 @{b} DLG_LAYOUT: x1;y1;x2;y2;rows;ink;bg;inkhi@{ub}


@{b}x1;y1;x2;y2@{ub}

defines the "box" containing the dialogue lines.

@{b}rows@{ub}

determines the numer of lines shown at the same time. The height of the
box is divided into this many "cells"


ink;bg;inkhi

sets the text and background colours. inkhi is the highlighting colour
used when the mouse cursor passes over a sentence.


When handling the dialogue lines, GRAAL assumes there may be a border 1
pxel high and 2 pixels wide around each "cell" in the list, and
therefore does not erase the edges of the cell.
@endnode

@node "ST_CUTSCENELAYOUT" " CUTSCENE_LAYOUT "
@next "ST_SPEECHLAYOUT"
@prev "ST_DLGLAYOUT"


@{fg shine}@{bg fill}CUTSCENE_LAYOUT Statement (main)@{fg text}@{bg back}

@{i}Determines size, position and image for cutscene indicator@{ui}


 @{b} CUTSCENE_LAYOUT: x1;y1;x2;y2;bg;ulx;uly;image@{ub}

This is used by the @{"CUTSCENE" link "GG_CUTSCENE" 0} command ( with the "S" or "F" parameter )
to place the cutscene indicator on the command area.


@{b}x1;y1;x2;y2;bg@{ub}

defines the area in the command area which should be "blanked out"
before placing the indicator itself, an its colour. (A larger area
"eats" some memory, because the overlaid graphics have to be stored
elsewhere for  the duration...


@{b}bg@{ub}

is the background colour


@{b}ulx;uly@{ub}

is the top left corner of the indicator image: note that x1;y1;x2;y2 can
define a larger or different area to erase - the area does not have to
be exactly that which is covered by the actual cutscene indicator
image.

@{b}image@{ub}

is the image containing the actual indicator.


If this statement is not in the graal.main file, the following is used:

CUTSCENE: 5;18;255;62;8;122;24;6
@endnode

@node "ST_SPEECHLAYOUT" "SPEECH_LAYOUT"
@next "ST_SENTLAYOUT"
@prev "ST_CUTSCENELAYOUT"


@{fg shine}@{bg fill}SPEECH_LAYOUT: Statement@{fg text}@{bg back}

@{i}Decides the appearance of "spoken" text@{ui}


 @{b}SPEECH_LAYOUT: SQUARE|ROUNDED|CARTOON;fill;bg;ink@{ub}

SPEECH_LAYOUT determines how text displayed with the SAY, THINK, and
RESP commands will look on screen. Options range from semi-transparent
square plaques to black-on white cartoon bubbles. See the @{"SETTEXT" link "GG_SETTEXT" 0}
command for an explanation of the parameters.
@endnode

@node "ST_SENTLAYOUT" " SENTENCE_LAYOUT "
@next "ST_TIMEFORMAT"
@prev "ST_SPEECHLAYOUT"


@{fg shine}@{bg fill}SENTENCE_LAYOUT Statement (main)@{fg text}@{bg back}

@{i}Determines the size and position of the sentence display area@{ui}


 @{b} SENTENCE_LAYOUT: x1;y1;x2;y2;ink;inkhi;bg@{ub}


This statement sets the box where the constructed sentence is built and
displayed.


@{b}x1;y1;x2;y2@{ub}

are the corners of the area of the sentence box.

It is assumed a border is included in the area (1 pixel high, 2 pixels
wide), which means the edges of the specified area will not be erased by
GRAAL. The text will be centered at the top of the area.


@{b}ink;inkhi;bg@{ub}

sets the text, highlighted text, and background colours.
@endnode

@node "ST_TIMEFORMAT" " TIME_FORMAT "
@next "ST_TIMELAYOUT"
@prev "ST_SENTLAYOUT"


@{fg shine}@{bg fill}TIME_FORMAT Statement (main)@{fg text}@{bg back}

@{i}Determines how the time is shown@{ui}


   @{b}TIME_FORMAT: format_string;am_text;pm_text@{ub}

The time can be shown either permanently in the command area (using
@{"TIME_LAYOUT" link "ST_TIMELAYOUT" 0}), or in a text in the scene area (using the special variable
#TIME in a TEXT, SAY, THINK, or RESP command).

This statement determines how it is shown (excluding the ANALOGUE
display possible with TIME_LAYOUT - see that for more info.)


@{b}format-string@{ub}

This is a string of characters. The following special characters may
appear:

#12

the hours will be placed here in 12-hour format

#24

the hours will be placed here in 24-hour format

#MM

the minutes will be placed here

#AM

the am/pm text will be placed here


Examples:

TIME_FORMAT: #12:#MM #AM;am;pm

may give results such as "3:35 am" and "6:00 pm"

TIME_FORMAT: #24:#MM

may give results such as "1:30" or "15:37"
@endnode

@node "ST_TIMELAYOUT" " TIME_LAYOUT "
@next "ST_DATEFORMAT"
@prev "ST_TIMEFORMAT"
@{fg shine}@{bg fill}

TIME_LAYOUT Statement (main)@{fg text}@{bg back}

@{i}tells GRAAL to show the time in the command area@{ui}


  @{b}TIME_LAYOUT:
DIGITAL|ANALOGUE;x1;y1;x2;y2;ink;bg[[;ax1;ay1;ax2;ay2;ink;bg];font]@{ub}

If this statement is present in the graal.main script, the time will be
permanently shown in the command area. It will be automatically updated
when needed.


@{b}DIGITAL|ANALOGUE@{ub}

 "DIGITAL"  will show the time in figures and text using the format 
            specified in @{"TIME_FORMAT" link "ST_TIMEFORMAT" 0} 

 "ANALOGUE" will draw the hands of an analogue clock


@{b}x1;y1;x2;y2@{ub}

This is the area where either the text or the clock hands are drawn. If
ANALOGUE is chosen, the width of the rectangle should be double the
height to achieve a circular clock face on a hires command area.

In DIGITAL mode, the text will be centered at the top of the rectangle.

In ANALOGUE mode, the area is NOT erased when the hands are redrawn -
only the old positions of the hands are erased. This means you can draw
the rest of the clock face around the hands in the command area backdrop
picture - just make sure the hands do not pass over any of your
graphics.


@{b}ink;bg@{ub}

sets colour and background for the "digital text" or the clock face.


@{b}ax1;ay1;ax2;ay2@{ub}

This can only be used together with ANALOGUE and defines a second
rectangle in the command area where the "am/pm" texts are shown to
complement the information in the analogue clock. If you do not want to
display this information, just leave the last 7 parameters out. (That
is, the last "font" parameter is also left out, because you do not need
to specify a font for the display of the clock face...)


@{b}ink;bg@{ub}

sets the text and background colours for the "am/pm" text display for an
analogue clock (if this is included)..


@{b}font@{ub}

This is the font used for the "DIGITAL" time display, or the "am/pm"
display complementing the "ANALOGUE" clock. A number between 1 and 4 is
expected:

 1 is TITLEFONT1
 2 is TITLEFONT2
 3 is MSGFONT
 4 is COMFONT


Examples:

@{b}TIME_LAYOUT: DIGITAL;10;8;90;24;1;0;4@{ub}

This prints the time in text format with ink 1 and bg colour 0 in the
area 10;8;90;24. The font is font 4 (COMFONT).

@{b}TIME_LAYOUT: ANALOGUE;500;10;580;50;3;6@{ub}

This prints the hands of a clock in the area 500;10;580;50 with ink 3
and bg colour 6.

@{b}TIME_LAYOUT: ANALOGUE;500;10;580;50;3;6;500;56;580;70;1;0;3@{ub}

As above, but goes on to print the am/pm text in the area 500;56;580;70
with ink colour 1, bg colour 0, and font 3 (MSGFONT).
@endnode

@node "ST_DATEFORMAT" " DATE_FORMAT "
@next "ST_DATELAYOUT"
@prev "ST_TIMELAYOUT"


@{fg shine}@{bg fill}DATE_FORMAT Statement (main)@{fg text}@{bg back}

@{i}Sets the date display format@{ui}


  @{b}DATE_FORMAT: format_string@{ub}

The date can be displayed either permanently in the command area (using
the @{"DATE_LAYOUT" link "ST_DATELAYOUT" 0} statement) or in the sentence area using the special
variable #DATE in a SAY, THINK, TEXT or RESP statement.

This statement determines how the date will be presented.

@{b}format_string@{ub}

In this string, the following special characters will be replaced by
"date data"

#Y

is replaced with the year

#M

is replaced by the number of the month without a leading zero

#0M

is replaced by the number of the month with a leading zero

#N

is replaced by the name of the month (is seldom used in the same string
as "M", obviously)

#D

is replaced by the date without a leading zero

#0D 

is replaced by the date with a leading zero

#W

is replaced by the weekday


All other characters in the string is kept as is.

Examples:

DATE_FORMAT: #Y-#0M-#0D

may give "1996-08-01"

DATE_FORMAT: #M/#D/#Y

may give: "8/1/96" (two or four digits in the year simply depends on
what you set the year to - see SETDATE command)

DATE_FORMAT: #N #D, #Y

may give "August 1, 1996"

DATE_FORMAT: #W, #N #D

may give "Saturday, August 1"



Note that the names of months and weekdays can be changed using the
@{"MONTH_TEXT:" link "ST_MONTHTEXT" 0} and @{"DAY_TEXT:" link "ST_DAYTEXT" 0} statements.
@endnode

@node "ST_DATELAYOUT" " DATE_LAYOUT "
@next "ST_WALKBUTTON"
@prev "ST_DATEFORMAT"


@{fg shine}@{bg fill}DATE_LAYOUT Statement (main)@{fg text}@{bg back}

@{i}tells GRAAL to show the date in the command area@{ui}


 @{b} DATE_LAYOUT: x1;y1;x2;y2;ink;bg;font@{ub}

If this statement is present in the graal.main script, the date will be
permanently shown in the  command area. It will be automatically updated
when needed. The display format is decided by the @{"DATE_FORMAT" link "ST_DATEFORMAT" 0}
statement.


@{b}x1;y1;x2;y2@{ub}

This is the rectangle containing the date. The text will be centered at
the top of the rectangle.


@{b}ink;bg@{ub}

sets the text and background colours


@{b}font@{ub}

is a number between 1 and 4:

 1 is TITLEFONT1
 2 is TITLEFONT2
 3 is MSGFONT
 4 is COMFONT
@endnode

@node "ST_WALKBUTTON" " WALK_BUTTON "
@next "ST_DISQUIT"
@prev "ST_DATELAYOUT"


@{fg shine}@{bg fill}WALK_BUTTON Statement (main)@{fg text}@{bg back}

@{i}Sets the mouse button used for walking.@{ui}


 @{b} WALK_BUTTON: LEFT|RIGHT@{ub}

The setting determines if you can use the left or right mouse button to
command the main character to walk to any spot in the room (that is,
click anywhere that isn't an object or an exit).
@endnode

@node "ST_DISQUIT" " DISABLE_QUIT "
@next "ST_DISSAVE"
@prev "ST_WALKBUTTON"


@{fg shine}@{bg fill}DISABLE_QUIT Statement (main)@{fg text}@{bg back}

@{i}disables the standard "q" quit key and function.@{ui}


  @{b}DISABLE_QUIT:@{ub}

This statement has no parameters. When found in the graal.main file, it
disables the use of the "q" quit key to quit the game. You shouldn't do
this until you have implemented and tested your own quit function, which
probably uses a direct verb (see the @{"VERB_TEXT:" link "ST_ExitMessage" 0} statement) and  the @{"QUIT" link "GG_Quit" 0}
command.
@endnode

@node "ST_DISSAVE" " DISABLE_SAVE "
@next "ST_NVERBS"
@prev "ST_DISQUIT"


@{fg shine}@{bg fill}DISABLE_SAVE Statement (main)@{fg text}@{bg back}

@{i}Disables the "s" and "l" keyboard keys@{ui}


  @{b}DISABLE_SAVE:@{ub}

Use this if you have coded your own save/load routines and wish to
disable the built-in save/load requester - but not before you have
tested your own routines!

See also: The @{"SAVE" link "GG_SAVE" 0} command for info on coding your own save/load
routines.
@endnode

@node "ST_NVERBS" " N_VERBS "
@next "ST_VERBZONE"
@prev "ST_DISSAVE"


@{fg shine}@{bg fill}N_VERBS Statement (main)@{fg text}@{bg back}

@{i}Sets the number of commands (verbs) used in the player interface@{ui}


 @{b} N_VERBS: no_of_verbs@{ub}

The default number of verbs is 9, not counting verb 0 (go to), which is
always present but not shown to the player.

If you do use this statement, there must also be a @{"VERB_ZONE:" link "ST_VERBZONE" 0} statement
for each and every verb you plan to use - even if some of the verbs
match the default positions, GRAAL will not know where to place them
otherwise!
@endnode

@node "ST_VERBZONE" " VERB_ZONE "
@next "ST_VERBTEXT"
@prev "ST_NVERBS"


@{fg shine}@{bg fill}VERB_ZONE Statement (main)@{fg text}@{bg back}

@{i}Sets the position and size of a command (=verb) "button".@{ui}


 @{b} VERB_ZONE: verb number;x1;y1;x2;y2;image1;image2;quickkey@{ub}


If VERB_ZONE statements are to be used at all, or @{"N_VERBS" link "ST_NVERBS" 0} changed from
the default 9, one @{"VERB_ZONE:" link "ST_VERBZONE" 0} and one @{"VERB_TEXT:" link "ST_VERBTEXT" 0} statement must be
present for each verb you want to make available in the command area.


@{b}verb number@{ub}

is the number of the verb this zone belongs to


@{b}x1;y1;x2;y2@{ub}

defines a rectangle (top left and bottom right corner, as always when
specifying areas this way).



If you don't want to use graphics to highlight the verb zones, set both
the following parameters to 0.

@{b}image1@{ub}

This is an image that will overlay the VERB_ZONE area as soon as the
cursor moves over it.


@{b}image2@{ub}

This is an image that will overlay the VERB_ZONE area when the command
has been clicked.


The images used must be cut out to be exactly the same size as the
corresponding verb zone - an easy task if you use the <Area> button in
the GRAAL Editor.



@{b}quickkey@{ub}

A letter or number corresponding to a keyboard key (typed in uppercase).
When the player presses the key, GRAAL acts as if the command had been
clicked with the mouse. If you don't want a keyboard key ahortcut for
the command, leave this parameter empty.
@endnode

@node "ST_VERBTEXT" " VERB_TEXT "
@next "ST_MONTHTEXT"
@prev "ST_VERBZONE"


@{fg shine}@{bg fill}VERB_TEXT Statement (graal.main)@{fg text}@{bg back}

@{i}Contains the message shown when using a verb, and also whether a verb is
a direct verb or not.@{ui}


  @{b}VERB_TEXT: verb_no;[$]text@{ub}

This is the text that appears in the sentence area when you use a
command or an exit. Texts 0-9 and 999 have default values in English,
but all of them can be translated into any language using this
statement, and all of them (except a few) can also be changed to a
completely different verb.

If the text is prefixed with a dollar sign (@{b}$@{ub}), the verb is treated as a
@{b}direct verb@{ub}. A direct verb does not use objects - it is executed
immediately when the player clicks it. This can be useful for making
special functions available in the command area, such as speical forms
of QUIT, or a RESTART command - although the possibilities do no end
there.


These are the default values:

 0 - Go to            (Meaning can not be changed)
 1 - Give             (Meaning can not be changed)
 2 - Pick up
 3 - Use              (Meaning can not be changed)
 4 - Open
 5 - Talk to
 6 - Push
 7 - Close
 8 - Look at
 9 - Pull 
 

 999 - to  (This is the preposition text for command 1, "Give")

And here's why you cant change the meaning of 0,1, and 3:

0 - This is not a command shown in the command area, but rather what
    happens when you click an exit in the scene area - thus, it must
    always have the meaning "go to" (although you can translate THAT
    into any language using this statement!)

1 - This command is always suffixed with the preposition " to ".
    To alter the " to ", use VERB_TEXT: 999;newtext 

3 - This command makes use (no pun intended!) of the preposition
    defined for an object, which is what makes it possible to make
objects
    interact with each other (or not).

Of course, some of the other commands are also hard to think of a better
replacement for - how are you going to engage in conversations without a
"Talk to" command, for instance? Or perhaps you are not planning to -
that's also up to you!
@endnode

@node "ST_MONTHTEXT" " MONTH_TEXT "
@next "ST_DAYTEXT"
@prev "ST_VERBTEXT"
@{fg shine}@{bg fill}

MONTH_TEXT Statement (main)@{fg text}@{bg back}

@{i}sets the names of all the months@{ui}


 @{b} MONTH_TEXT: name1;name2; ... ;name12@{ub}

This is the name of the month that can be used when displaying a date.
The default names are "January","February", ... , "December"

See also: @{"DATE_FORMAT" link "ST_DATEFORMAT" 0} and @{"DATE_LAYOUT" link "ST_DATELAYOUT" 0} statements
@endnode

@node "ST_DAYTEXT" " DAY_TEXT "
@next "ST_SYSTEMTEXT"
@prev "ST_MONTHTEXT"


@{fg shine}@{bg fill}DAY_TEXT Statement (main)@{fg text}@{bg back}

@{i}sets the names of the days in the week@{ui}


 @{b} DAY_TEXT: name1;name2; ... ;name7@{ub}

These are the names that can be used when displaying a date. The default
names are "Monday","Tuesday", ... , "Sunday"

See also: @{"TIME_FORMAT" link "ST_TIMEFORMAT" 0} and @{"TIME_LAYOUT" link "ST_TIMELAYOUT" 0} statements
@endnode

@node "ST_SYSTEMTEXT" " SYSTEM_TEXT "
@next "ST_EXIT_COL"
@prev "ST_DAYTEXT"


@{fg shine}@{bg fill}SYSTEM_TEXT: Statement (main)@{fg text}@{bg back}

@{i}changes a system message text@{ui}


 @{b} SYSTEM_TEXT: message_no;text@{ub}

This is of use for translators to foreign languages only (like my own,
for instance).

Try to keep the text about the same length as the English original.
These are the default texts (the quotes must be included in the
statement):

  1  "Please insert disk "
  2  "Select a saved game slot"
  3  "Saved game description"
  4  "Load"
  5  "Save"
  6  "Back"
  7  "OK"
  8  "Cancel"
  9  "Change"
 10  "   There are no saved games on this disk."
 11  "Do you want to use this disk for saved games?"
 12  "****** GAME PAUSED ******\Press any key to continue"
 13  "You are playing"
 14  "running under "
 15  "Please insert save disk into DF0:"
 16  "Please write-enable the disk!"
 17  " Yes"
 18  "Music & Sounds off"
 19  "Music & Sounds on"
 20  "  Speech speed:"
 21  "Slow         Fast"
@endnode

@node "ST_EXIT_COL" "EXIT_COL"
@next "ST_OBJ_COL"
@prev "ST_SYSTEMTEXT"


@{fg shine}@{bg fill}EXIT_COL Statement (main)@{i}

@{fg text}@{bg back}Specifies color of exit names shown in scene area@{ui}


  @{b}EXIT_COL: ink@{ub}

@{b}ink@{ub} is the number of the colour.

Make this a fairly bright colour - the text will be surrounded by a
black outline.
@endnode

@node "ST_OBJ_COL" "OBJ_COL"
@next "ST_START_ROOM"
@prev "ST_EXIT_COL"


@{fg shine}@{bg fill}OBJ_COL Statement (main)@{fg text}@{bg back}

@{i}Specifies the colour of object names displayed in the scene area@{ui}


 @{b} OBJ_COL: ink@{ub}

@{b}ink@{ub} is the number of the colour.

Make this a fairly bright colour - it will be surrounded by a black
outline.
@endnode

@node "ST_START_ROOM" "START_ROOM"
@next "ST_MAX_ROOM"
@prev "ST_OBJ_COL"


@{fg shine}@{bg fill}START_ROOM Statement (main)@{fg text}@{bg back}

@{i}Specifies the starting position for the adventure@{ui}


  @{b}START_ROOM: room;entrance@{ub}

The action will commence in this room and at this entrance - also see
the .room @{"START_POS" link "ST_START_POS" 0} statement.
@endnode

@node "ST_MAX_ROOM" "MAX_ROOM"
@next "ST_MAX_SECTION"
@prev "ST_START_ROOM"


@{fg shine}@{bg fill}MAX_ROOM Statement (main)@{fg text}@{bg back}

@{i}Highest room number used in this adventure@{ui}


  @{b} MAX_ROOM: n_rooms@{ub}

All rooms in an adventure are numbered from 1 and upwards - try not to
leave "holes" in the room sequence, since each room number, used or not,
takes up valuable memory space! If the adventure is split up onto
several disks, there is no way for GRAAL to automatically know how many
rooms there actually is, so this statement must be updated continually
as more rooms are added to the game.

Tip: If you  delete a sequence of rooms in the middle of the game,
re-use those vacant room numbers if you add more rooms later on - rather
than increasing the highest room number.
@endnode

@node "ST_MAX_SECTION" "MAX_SECTION"
@next "ST_MAX_DACT"
@prev "ST_MAX_ROOM"


@{fg shine}@{bg fill}MAX_SECTION Statement (main)@{fg text}@{bg back}

@{i}The highest section number used in the adventure@{ui}


 @{b} MAX_SECTION: n_sections@{ub}

Like MAX_ROOM, this must be manually updated with the highest section
number used so far during development. Always start with section 1 and
continue upwards without leaving "holes" in the numbering sequence if
you can avoid it.
@endnode

@node "ST_MAX_DACT" "MAX_DACT"
@next "ST_MAXDLG"
@prev "ST_MAX_SECTION"


@{fg shine}@{bg fill}MAX_DACT Statement (main)@{fg text}@{bg back}

@{i}Sets the maximum number of DACT statements that can be used in a room
file@{ui}


 @{b} MAX_DACT: n_DACTs@{ub}

This is the maximum number of DACT statements used in any room script.
Set to 50 or so initially.
@endnode

@node "ST_MAXDLG" "MAX_DLG:"
@next "ST_NDIALOGUES"
@prev "ST_MAX_DACT"


@{fg shine}@{bg fill}MAX_DLG Statement (main)@{fg text}@{bg back}

@{i}Sets the highest dialogue number that can be used in the game.@{ui}


  @{b}MAX_DLG: dlg_no@{ub}

There has been a radical change in dialogue set-up since the 2.0 beta
version:

Before, the DLG: statement containing the highest dialogue number set
the space needed for dialogue data. This was possible (but not very well
thought out) because each dialogue required its own @{"DLG:" link "ST_DLG" 0}  statement in
the graal.main script.

From 2.0 and onwards, DLG: statements merely define "speaking partners"
- that is, the partners referred to in RESP commands.

Thus, the MAX_DLG: statement is now needed to set the highest number of
any dialogue  used in the game. If it is not present in the graal.main
script, space for 30 dialogues is reserved by default.

What does this mean for pre-2.0 scripts? Well, if you have more than 30
dialogues, you must add a MAX_DLG: statement. If you have 30 dialogues
or less, you don't have to do anything! There is still no law against
having one partner defined for each dialogue, it's just that with the
new possibilities of using dialogues for other things than
person-to-person conversations, it's a bit unnecessary at times.

See also: @{"DLG:" link "ST_DLG" 0} and @{"N_DIALOGUES:" link "ST_NDIALOGUES" 0} statements.
@endnode

@node "ST_NDIALOGUES" " N_DIALOGUES "
@next "ST_XXXFONT"
@prev "ST_MAXDLG"


@{fg shine}@{bg fill}N_DIALOGUES Statement (main)@{fg text}@{bg back}

@{i}Sets the limits for dialogues@{ui}


  @{b}N_DIALOGUES number;lines;actions@{ub}


@{b}number@{ub}

is the number of simultaneously available dialogues - that is, the
maximum number referred to at any time by the current section and the
current room scripts. For example, if a section script defines 2
dialogues and a room script for that section contains 5 dialogues,
@{b}number@{ub} would have to be set to 7, since all these dialogues must be
handled by GRAAL simultaneously.

@{b}lines@{ub}

is the maximum number of LINE: statements used in a dialogue

@{b}actions@{ub}

is the maximum number of LACT: statements used in a dialogue

A recent addition to the setup of space for dialogues is the  @{"MAX_DLG:" link "ST_MAXDLG" 0}
statement, which sets the total number of dialogues for the entire game.
@endnode

@node "ST_XXXFONT" "MSGFONT"
@next "ST_linelength"
@prev "ST_NDIALOGUES"


@{fg shine}@{bg fill}MSGFONT COMFONT TITLEFONT1 TITLEFONT2 Statements (main)@{fg text}@{bg back}

@{i}Defines fonts and sizes for various uses@{ui}


 @{b} MSGFONT: fontname;fontsize
  COMFONT: fontname;fontsize
  TITLEFONT1: fontname;fontsize
  TITLEFONT2: fontname;fontsize@{ub}

The fonts (in the proper sizes) must be available in a FONTS: drawer in
your development directory. Furthermore, FIXFONTS must have been used on
the drawer for all the fonts to be OK.

@{b}MSGFONT@{ub} is the font used for all text displayed in the scene area.

@{b}COMFONT@{ub} is the font used for the input sentence display and dialogue
lines.

@{b}TITLEFONT1@{ub} and @{b}TITLEFONT2@{ub} are primarily used with the @{"TYPE" link "GG_TYPE" 0}  command to
print text on title screens.
@endnode

@node "ST_linelength" " LINE_LENGTH "
@next "ST_NORMWAIT"
@prev "ST_XXXFONT"


@{fg shine}@{bg fill}LINE_LENGTH Statement (main)@{fg text}@{bg back}

@{i}Determines the line length of displayed sentences (SAY, RESP, and other
commands.)@{ui}


 @{b} LINE_LENGTH: line_length@{ub}

GRAAL does automatic line breaks in long sentences - this is the length
it aims for for each line in SAY, RESP, and other similar commands.

GRAAL will only break lines in between words, and does not hyphenate.

You may control line breaks manually in any sentence - just insert
backslash ( \ ) characters where you want line breaks to appear. This
will override the setting of the LINE_LENGTH: statement.
@endnode

@node "ST_NORMWAIT" " NORMAL_WAIT "
@next "ST_MODESWITCH"
@prev "ST_linelength"


@{fg shine}@{bg fill}NORMAL_WAIT Statement (main)@{fg text}@{bg back}

@{i}Sets the default display time for text and sentences in scene area@{ui}


 @{b} NORMAL_WAIT: time@{ub}

This value is used in a formula calculating for how long a text or
spoken sentence should be displayed in the scene area. The formular also
incorporates the overall text length and the number of lines it is
broken into. Also, character sentences are shown for a slightly shorter
period of time than other characters speech, because the contents of a
"SAY" sentence uttered by the main character is often known wholly or
partly by the player beforehand.

The bigger the number, the longer the pause. Default is 100. If this is
not enough, try other nice, round numbers like 200 or 400..
@endnode

@node "ST_MODESWITCH" " MODE_SWITCH "
@next "ST_AREASIZES"
@prev "ST_NORMWAIT"


@{fg shine}@{bg fill}MODE_SWITCH Statement (main)@{fg text}@{bg back}

@{i}Decides how a switch between command and dialogue mode is performed.@{ui}


 @{b} MODE_SWITCH: ROLL|INSTANT@{ub}

@{b}ROLL@{ub}

The command area rolls off the bottom of the screen, and the dialogue
area rolls in from where the command area disappeared. (And vice
versa.)

This is the default, and what GRAAL 1 used.


@{b}INSTANT@{ub}

The command area disappears instantly, and the dialogue area is created
"on the spot" to replace it. (And vice versa.)


("Instantly" does not mean "instantly" on slower machines - the screens
are compressed in memory and takes a few moments to decompress when
used.)
@endnode

@node "ST_AREASIZES" " SPLIT_LINE "
@next "ST_AREAFILES"
@prev "ST_MODESWITCH"


@{fg shine}@{bg fill}AREA_SIZES: Statement (main)@{fg text}@{bg back}

@{i}Sets the height of the scene area and the command area.@{ui}


 @{b} AREA_SIZES: scenearea;comarea@{ub}

This statement allows you to vary the size of the screen set aside to
the scene area and the command/dialogue area. The numbers are expressed
in pixels; default is 120 for the scene area and  80 for the command
area.

NOTE: If you want NTSC machine users to be able to run your adventures,
you should make sure the sum of the values is not higher than 200.
"Pal-only" adventures should not use a sum bigger then 256.
@endnode

@node "ST_AREAFILES" "COMMAND_AREA"
@next "ST_RESOURCE"
@prev "ST_AREASIZES"


@{fg shine}@{bg fill}COMMAND_AREA / DLG_AREA Statements (main)@{fg text}@{bg back}

@{i}Graphic files containing the graphics for the command area and dialogue
area@{ui}


 @{b} COMMAND_AREA: file|DEFAULT;BUFFERED|NORMAL
  DLG_AREA: file|DEFAULT@{ub}

These files contain the graphics for the command area and its
replacement during dialogues, the dialogue control area. 


@{b}file|DEFAULT@{ub}

If DEFAULT is specified as filename, a new file will not be loaded - the
default graphics present in GRAALs memory will be used instead, which
speeds up the loading time.


@{b}BUFFERED|NORMAL@{ub}

When you alter the graphics in the command area, it may flicker a
little. If you specify the BUFFERED parameter, the flicker will be
eliminated. However, screen updates will be slower, and it takes more
memory. 


Make sure the height of your images match the values set in the
@{"AREA_SIZES:" link "ST_AREASIZES" 0} statement.
@endnode

@node "ST_RESOURCE" "RESOURCE"
@next "ST_OBJS"
@prev "ST_AREAFILES"


@{fg shine}@{bg fill}RESOURCE Statement (main)@{fg text}@{bg back}

@{i}Name of interface resource bank@{ui}


  @{b}RESOURCE filename@{ub}

This must be an Amos Pro resource bank especially designed for GRAAL. It
controls the graphic appearance of the disk swapping, save/load and quit
dialogue boxes, among other things. Experienced Amos Pro users can also
easily use the Amos resource editor to make their own banks, but this
will not be explained here.

Registered users get several different ready-made resource banks with
different  looks: High-tech, Stone-age, Medeival... 

Consider customizing the quit, save and load routines - see the @{"SAVE" link "GG_SAVE" 0} and
@{"QUIT" link "GG_Quit" 0} commands for more information. The only requesters you cannot hide
from the player are the ones connected to disk swapping when playing
from diskettes.
@endnode

@node "ST_OBJS" "GLOBALOBJS"
@next "ST_NIMGS"
@prev "ST_RESOURCE"


@{fg shine}@{bg fill}GLOBALOBJS / SECTIONOBJS / ROOMOBJS Statements (main)@{fg text}@{bg back}

@{i}Sets the number of objects that can be used in the game@{ui}


  @{b}GLOBALOBJS: n_objects
  SECTIONOBJS: n_SOBJs
  ROOMOBJS: n_ROBJs@{ub}

These statements decide how many objects of each time GRAAL will make
room for. You can alter any of the values any time during the
development, so there is no need for accurate estimates right away.

Objects are all the objects that have a name within the adventure and
thus can be manipulated by the user.

It would be an unnecesary waste of memory to have the data for all
objects in memory all the time, which is why they are divided into three
categories:

@{b}GLOBAL OBJECTS@{ub} are indeed available all the time. Everything that can be
carried in the inventory over more than one section of the game, and all
characters that Olaf can have conversations with must be in this
category. Numbering of global objects start with 1 and proceeds
upwards.

@{b}SECTION OBJECTS@{ub} can only exist within one particular section of the
game. Note that if a player leaves the section and re-enters it at a
later date, all information in object flags and the like has been lost -
all object will be re-initialised with the status and position defined
in the OBJECT: stetements in the .section file. Therefore, use this with
caution! To refer to a section object, use SOBJn, where n is the number
of the section object.

@{b}ROOM OBJECTS@{ub} are restricted to the current room only, and should
preferrably be  objects which can not be "seriously" manipulated by the
user - usually, they are only there to add a bit of atmosphere and to
act as red herrings. The torch in the bar in Olaf 1 is a perfect example
of such an object. To refer to a room object, use ROBJn, where n is the
number of the room object. Like section objects, the flags for room
objects are reset each time the player leaves and re-enters the room, so
if anything concerning room objects needs to be saved, it must be stored
in room flags instead.
@endnode

@node "ST_NIMGS" "N_GLOBALIMGS"
@next "ST_CLPART"
@prev "ST_OBJS"


@{fg shine}@{bg fill}N_GLOBALIMGS / N_SECTIONIMGS / N_ROOMIMGS Statements (main)@{fg text}@{bg back}

@{i}Sets the number of image bank slots available for each image category@{ui}


  @{b}N_GLOBALIMGS: n_imgs
  N_SECTIONIMGS: n_SIMGs
  N_ROOMIMGS: n_RIMGs@{ub}

Images are referred to and treated according to which of the three above
categories they belong:

GLOBAL IMAGES are images that are always in memory for instant access
anywhere in the game - for instance, the images used for the animation
of the main character. Global images are grabbed by the IMGS: statement
in the graal.main file and referred to by their true number. 

SECTION IMAGES are grabbed with the SECTIONIMGS: statement in a .section
file and remain in memory as long as the player stays in the section.
They are referred to using SIMGn, where n is the number of the section
image.

ROOM IMAGES are grabbed with the ROOMIMGS: statement in a .room file and
remain in memory as long as the player stays in the room. They are
referred to using RIMGn, where n is the number of the room image.

The numbers set in these statements may be altered at any time during
development, so don't panic.

Note: If you need some "dynamic" image replacing, any kind of image may
also be grabbed/replaced by the @{"IMGS" link "GG_IMGS" 0} command, which has the same
parameter as these statements.
@endnode

@node "ST_CLPART" "CLPART"
@next "ST_IMGS"
@prev "ST_NIMGS"


@{fg shine}@{bg fill}CLPART Statement (main, section, room)@{fg text}@{bg back}

@{i}Loads an IFF picture file containing clipart into memory@{ui}


  @{b}CLPART: file@{ub}

GRAAL doesn't mess around with complicated picture storage formats - all
graphics used in the game are "grabbed" from ordinary IFF files. This
statement selects the IFF file to be using for subsequent "grabbing"
with the IMGS:, SECTIONIMGS: and ROOMIMGS: statements.
@endnode

@node "ST_IMGS" "IMGS"
@next "ST_CHAR"
@prev "ST_CLPART"


@{fg shine}@{bg fill}IMGS Statement (main)@{fg text}@{bg back}

@{fg shine}@{bg fill}SECTIONIMGS Statement (section)@{fg text}@{bg back}

@{fg shine}@{bg fill}ROOMIMGS Statement (room)@{fg text}@{bg back}

@{i}Grabs images into the images bank@{ui}


  @{b}IMGS: number;start_img;x1;y1;w;h;x-offset;hotspot
  SECTIONIMGS: number;start_img;x1;y1;w;h;x-offset;hotspot
  ROOMIMGS: number;start_img;x1;y1;w;h;x-offset;hotspot@{ub}

This command can grab a single image or a row of images, provided they
are aligned horisontally and equally sized and spaced. All three
versions of the command have the same syntax. The only difference is the
images category they grab. Images are later referred to by their proper
image number, section images by SIMGn and  room images by RIMGn.

@{b}number@{ub}

The number of images to grab with this statement.

@{b}start_img@{ub}

The first image to grab will get this number. If more than one image is
grabbed, the number will be assigned in increasing sequence. E.g., 

  IMGS: 4;11;... would grab the global images 11, 12, 13 and 14. 

  ROOMIMGS: 1;5;... would grab ROBJ5.

  SECTIONIMGS: 3;2;... would grab SIMG3 and SIMG4.

@{b}x1;y1@{ub}

Imagine the clipart being cut out of the picture (previously loaded with
the CLPART: statement) by placing a rectangular frame over the picture
and cutting along the edges, x1;y1 is the co-ordinate in the upper left
corner of the frame...

@{b}w;h@{ub}

...and this is the width and the height of the frame. Everything that is
cut out and is of colour 0 will be transparent when the image is used.

@{b}x-offset@{ub}

If more than one image is grabbed with the statement, this number tells
how many pixels to the right the "frame" should be moved before cutting
out the next image.

@{b}hotspot@{ub}

The hotspot decides which point of an image is actually placed at the
co-ordinates of a command using the image. For example, 

  BOBON 10,30,70,SIMG3

is a GRAAL command placing image SIMG3 at the co-ordinates 30,70. Great,
but which point of the image is actually placed at 30,70? That is
decided by the hotspot. 

There are two possible formats to the hotspot parameter, the
single-number "Y" format, and the "X/Y" format where you specify two
numbers with a slash in between

Y format

0 sets the hotspot to GRAAL's default hotspot setting, which is in the
middle at the bottom of the frame. This is where a character grabbed as
an image usually should have its feet. (See the GRAAL manual for further
discussion of hot spots and graphics.)

Any other single number sets the Y hotspot relative to the top edge of
the frame. Negative values means the hotspot goes above the actual
graphics, and you can allso specify values so big that the hotspot point
goes below the actual image. This can help you sort graphics on screen
in the correct order, but note that it can be confusing at times when
using the editor to place graphics correctly - the may start off off
screen when you try to place them!

X/Y format

the first number sets the x position, the second the y position. This is
escpecially convenient if you use non-symmetric characters and CARTOON
style text displays: The arrow of the cartoon bubble always "chases" the
x hotspot, so specifying the x hotspot can help you get the arrow where
you want it!

See also the @{"HOTSP" link "GG_HOTSP" 0} command, which does the same in a slightly different
way.
@endnode

@node "ST_CHAR" " CHAR "
@next "ST_SELECTCHAR"
@prev "ST_IMGS"


@{fg shine}@{bg fill}CHAR: Statement (main)@{fg text}@{bg back}

@{i}Defines alternate characters@{ui}


 @{b} CHAR: number;obj;stimg;eimg;floor;ink;height;text_offset;width;
       walkspeed;im_height;im_width@{ub}


This statement is used to define the characters in games that allows the
player to switch control between multiple characters.

Whenever the character switching or 3d scaling features are to be used,
a CHAR: statement for character number 1 MUST be present, because
character 1 is always the character which defines the graphics routines
for all character animation, and it is always the character GRAAL puts
under player control at the start of the game.


@{b}number@{ub}

A number between 1 and 4, thus allowing up to 4 controllable characters
in the game.


@{b}obj@{ub}

Each controllable character must be connected with an object (even
character 1). The starting room of the object becomes the starting room
of the character, because all characters are just normal objects as long
as control isn't switched to them.

All character objects must

 * be global objects
 * be VIS (visible)
 * be NPICK (non-pickable). 
 * have a unique BOB number not used for anything else in the 
   sections of the game where the character may appear
 * have a unique animation channel (3-15) not used for anything
   else in the sections of the game where the character can appear

Obviously, it's nice if the object number matches the character number,
but this is not at all necessary.


@{b}stimg;eimg@{ub}

This defines a range of images used by this character for its default
graphics.

All controllable characters must use the same animation strings as the
default character, and the images must be stored in the image bank with
the same relationships between each other. 

For example, imagine all graphics for the default character that are
used in STILL_...:, WALK_...:, HANDLE_MAP: and TALK_MAP: statements
occupy global images 11-50 (40 images):

  CHAR: 1;3;11;50;...

(Character 1 is object 3, and uses images 11-50 for default graphics.
50-11+1 = 40 images.)

There must be an identical set of images for character 2, the alternate
character, only stored in a different area iof the image bank, of
course:

  CHAR: 2;5;51;90;...

(Character 2 is object 5, and uses images 51-90 for default graphics.
90-51+1 = also 40 images!)

Now, image 51 should show character 2 in the same pose as image 11 shows
character 1, image 12 should show an identical pose to image 52, and so
on.

NOTE: The images for character 1 must always have lower numbers than the
images for any other character(s).


@{b}floor@{ub}

Most data about each character is fetched from the object definition.
However, there is nothing about the initial floor number in the object
definition, so this must be specified here. (Compare to the @{"START_POS:" link "ST_START_POS" 0}
statement in .room scripts, which also must give the initial floor
number...)


@{b}ink@{ub}

Specifies the colour of the character's text display for SAY and THINK
commands


@{b}height;text_offset;width@{ub}

These parameters correspond to the @{"CHAR_HEIGHT:" link "ST_CHARSIZE" 0} and @{"CHAR_WIDTH:" link "ST_CHARSIZE" 0}
statements.


@{b}walk_speed@{ub}

This parameter corresponds to the @{"WALK_SPEED:" link "ST_WALK_SPEED" 0} statement.


im_height;im_width

What? Didn't we just do this? No, these width and height parameters
state the true size of the character images, not the character WITHIN
the images.  So these values should match the height and width of the
images  cut out for tha character  by ...IMGS: statements or IMGS
commands. (Introduced in 2.3.)



MEMORY-SAVING TIP:

If you have various alternate characters that don't appear in the same
sections of the game, you can preserve valuable memory by letting them
use the same image numbers - then load the correct set of images for the
current "buddy" character with CLPART and IMGS commands in the section
files!
@endnode

@node "ST_SELECTCHAR" "SELECT_CHAR: statement"
@next "ST_CHARSIZE"
@prev "ST_CHAR"


@{fg shine}@{bg fill}SELECT_CHAR: Statement@{fg text}@{bg back}

@{i}Decides whether controlled character is registered by the cursor.@{ui}


  @{b}SELECT_CHAR: YES|NO@{ub}

This statement is only relevant if you use @{"CHAR:" link "ST_CHAR" 0} statements.

If it is set to NO, the character under the players control will not be
regarded as an object by the cursor. This allows you to move the
character more precisely because you can clikc inside the character
image to move it.

Default is YES, which means the currently controlled character can be
handled just like any other object when constructing sentences.
@endnode

@node "ST_CHARSIZE" "CHARACTER_HEIGHT"
@next "ST_CHARACTER_BOB"
@prev "ST_SELECTCHAR"


@{fg shine}@{bg fill}CHARACTER_HEIGHT / CHARACTER_WIDTH Statements (main)@{fg text}@{bg back}

@{i}Gives the average size of the main character@{ui}

@{b}
  CHARACTER_HEIGHT: pixels[,text_offset]
  CHARACTER_WIDTH: pixels@{ub}

This states how big you main character normally is, and is used to
calculate how the main character may move on the screen. 

When the player clicks a point in the scene area, GRAAL normally takes
the character height into account and tries to place the centre of the
character at that point. If you wish the feet to be placed at the
clicked point instead, you must specify the character height as 0
pixels. However, this also affects the position where the text in SAY
and THINK commands is placed. To compensate, you must give a number in
the text_offset parameter.

CHARACTER_HEIGHT: 50

The character is about 50 pixels high. Text will be placed immediately
above its head, when ordered to move GRAAL will place the centre of the
character image at the clicked point (if possible).

CHARACTER_HEIGHT: 0;50

The characters feet wil end up at the clicked position (or as close as
possible), and the text will be displayed at the same height above the
character as in the first example.

CHARACTER_HEIGHT: 50;10

This works like the first example, but we want some extra space between
the character's head and the messages.
@endnode

@node "ST_CHARACTER_BOB" "CHARACTER_BOB"
@next "ST_CHARACTER_COL"
@prev "ST_CHARSIZE"


@{fg shine}@{bg fill}CHARACTER_BOB Statement (main)@{fg text}@{bg back}

@{i}Sets the BOB number used for the main character@{ui}


  @{b}CHARACTER_BOB: number@{ub}

Do not alter this! (But some time in the future there may be a good
reason to be able to customise it.)
@endnode

@node "ST_CHARACTER_COL" "CHARACTER_COL"
@next "ST_PAUSE"
@prev "ST_CHARACTER_BOB"


@{fg shine}@{bg fill}CHARACTER_COL Statement (main)@{fg text}@{bg back}

@{i}Sets the colour to use for main character "speech"@{ui}


  @{b}CHARACTER_COL: ink@{ub}

Make this a fairly bright colour, since it will be surrounded by a black
outline.  It should also a colour that is the same for all graphics in
the adventure, because it does not look good if the main characters
speech keeps shifting its colour from dialogue to dialogue.
@endnode

@node "ST_PAUSE" "PAUSE_RIGHT"
@next "ST_STILL"
@prev "ST_CHARACTER_COL"


@{fg shine}@{bg fill}PAUSE_RIGHT / PAUSE_LEFT / PAUSE_BACK / PAUSE_FRONT Statements (main)@{fg text}@{bg back}

@{i}Sets the images used when the character pauses in one of the four main
directions@{ui}


 @{b} PAUSE_RIGHT: image
  PAUSE_LEFT: image
  PAUSE_BACK: image
  PAUSE_FRONT: image@{ub}

These images are used when the main character pauses waiting for player
input. You may choose to use exactly the same images as for the
corresponding STILL_ statements.
@endnode

@node "ST_STILL" "STILL_RIGHT"
@next "ST_WALK"
@prev "ST_PAUSE"


@{fg shine}@{bg fill}STILL_RIGHT / STILL_LEFT / STILL_BACK / STILL_FRONT Statements (main)@{fg text}@{bg back}

@{i}Sets the still images used for the main character and the four main
directions.@{ui}

@{b}
  STILL_RIGHT: image
  STILL_LEFT: image
  STILL_BACK: image
  STILL_FRONT: image@{ub}

These images will be used in automatic main character movement.
@endnode

@node "ST_WALK" "WALK_RIGHT"
@next "ST_WALK_SPEED"
@prev "ST_STILL"


@{fg shine}@{bg fill}WALK_RIGHT / WALK_LEFT / WALK_AWAY / WALK_TOWARD Statements (main)@{fg text}@{bg back}

@{i}Defines the animation sequence used for movement in the four
directions.@{ui}


 @{b} WALK_RIGHT: anim
  WALK_LEFT: anim
  WALK_AWAY: anim
  WALK_TOWARD: anim@{ub}

These four @{"animation sequences" link "GG_Animation" 0} are used by GRAAL for all automatic
movement of the main character.
@endnode

@node "ST_WALK_SPEED" "WALK_SPEED"
@next "ST_TALK_MAP"
@prev "ST_WALK"


@{fg shine}@{bg fill}WALK_SPEED Statement (main)@{fg text}@{bg back}

@{i}Adjust walking speed@{ui}


  @{b}WALK_SPEED: character_speed@{ub}

This statement adjusts the speed of the automatic main character
movement so that the speed matches the WALK_xxxxx animation squences -
the objective is to make it look like the character actually uses his
feet to walk, rather than glide around on a slippery surface. Simply
experiment with the value until the movement (especially sideways) looks
good!
@endnode

@node "ST_TALK_MAP" "TALK_MAP"
@next "ST_HANDLE_MAP"
@prev "ST_WALK_SPEED"


@{fg shine}@{bg fill}TALK_MAP Statement (main)@{fg text}@{bg back}

@{i}Defines animation sequences used for automatic main character speech@{ui}"
link "GG_Animation" 0} used for automatic main character speech


  @{b}TALK_MAP: still_image;anim@{ub}

When a @{"SAY" link "GG_SAY" 0} command is given, GRAAL checks which image is currently used
for the main character. (This should normally be one of the @{"STILL_..." link "ST_STILL" 0} or
@{"PAUSE_..." link "ST_PAUSE" 0} images.) The image is checked against the TALK_MAP statements
(there may be up to 8 of them) and the one where the previous image
matches the main character's current image is used for the animation of
the speech.
@endnode

@node "ST_HANDLE_MAP" "HANDLE_MAP"
@next "ST_OBJECT"
@prev "ST_TALK_MAP"


@{fg shine}@{bg fill}HANDLE_MAP Statement (main)@{fg text}@{bg back}

@{i}Defines the animation sequences used when main character manipulates
objects@{ui}" link "GG_Animation" 0} used when main character manipulates
objects


 @{b} HANDLE_MAP: still_iimage;anim_lo;anim_mid;anim_hi@{ub}

When a HANDLE command is encountered, GRAAL checks which image is
currently being used for the main character, and the "handle position"
for the object being manipulated. The proper animation sequence foom the
HANDLE_MAP statement matching the current main character image is then
used. Note that the animation sequences only show the main character
reaching out for something, and that the last image in each sequence
should be specified as lasting for only one frame.
@endnode

@node "ST_OBJECT" "OBJECT"
@next "ST_DLG"
@prev "ST_HANDLE_MAP"


@{fg shine}@{bg fill}OBJECT Statement (main)@{fg text}@{bg back}

@{fg shine}@{bg fill}SECTIONOBJ Statement (section)@{fg text}@{bg back}

@{fg shine}@{bg fill}ROOMOBJ Statement (room)@{fg text}@{bg back}

@{i}Defines an object@{ui}


  @{b}OBJECT: obj;name;room;VIS|NVIS;bob;image;x;y;cx;cy;cimage;prep;
          PICK|NPICK;anim_ch;verb;icon;LOW|MID|HIGH;types;w1;w2;w3

  SECTIONOBJ: ...ditto...

  ROOMOBJ: ...ditto...@{ub} same syntax for all three...

Note that all parameters should be on the same line in the GRAAL file -
a bit difficult to show in ordinary guide format here, though. Anyway,
you really should use GRAALs own object editor to be able to edit the
parameters in a more user-friendly format. (See the editor documentation
for this one.)

Yes, this is the most complex statement there is, but let's run through
it one parameter at a time:


@{b}obj@{ub}

For global objects specified by the OBJECT statement, the object is
later referred to by this very number.

Objects defined by SECTIONOBJ will be referred to as SOBJn, where n is
the number.

Objects defined by ROOMOBJ will be referred to as ROBJn, where n is the
number.


@{b}name@{ub}

The object name shown when the cursor hits the object, and in the
inventory. A backslash in the name will cause a line break in that
position when it is displayed in the scene area. The @{"NAME" link "GG_NAME" 0} command can
alter this at any time.


@{b}room@{ub}

The room number where the object is initially positioned. 0 is used for
objects that are "nowhere". To specify an inventory, specify "I"+ the
inventory number - for example @{b}I1@{ub} means inventory 1 (the default
inventory).


@{b}VIS|NVIS@{ub}

VIS if the object is visible, NVIS if it is hidden. @{"SHOW" link "GG_SHOW" 0} and @{"HIDE" link "GG_HIDE" 0}
commands can alter this as you wish later on.


@{b}bob@{ub}

the bob number to use for this object. two objects (including characters
and static and animated objects) cannot use the same bob number at the
same time.


@{b}image@{ub}

image number, animation string or pattern definition initially used for
the object.


@{b}x;y@{ub}

The object's position on the screen.


@{b}cx;cy@{ub}

The main character's position relative to the object when manipulating
it, looking at it, or plain walking up to it (with the @{"MOBJ" link "GG_MOBJ" 0} command).

If cx is a normal number, the offset is the character's hotspot relative
to the object's hotspot. If cx is prefixed with a W (for example, "W9")
the offset is the closest edge of the character relative to the object's
hotspot. The edge of the character is calculated using the
@{"CHARACTER_WIDTH:" link "ST_CHARSIZE" 0} statement (or the corresponding parameter in a @{"CHAR:" link "ST_CHAR" 0}
statement, if you have multiple controllable character's in the game.)

This means different controllable characters will end up at the same
distance  from the object when using @{"MOBJ" link "GG_MOBJ" 0}. It is primarily when the MOBJ
ends with the  character facing the object with a side view.


@{b}cimage@{ub}

The image used for the main character after having walked up to the
object.


@{b}prep@{ub}

A preposition that indicates that the object can not be used on its own,
but must be combined with a second object. 

More technically put, verb 3 (default USE) will look at this and if it
is not a blank, will wait for a second object to be clicked, combining
the two objects with this preposition.


@{b}PICK|NPICK@{ub}

PICK means the object can be picked up and added to the inventory.
(NPICK for churches, planet systems and other things hard to carry
around.)


@{b}anim_ch@{ub}

The animation channel used for the object. (Only if the object is
animated, of course.) Make sure two animated objects in the same room
don't try to use the same channel!


@{b}verb@{ub}

This is the command verb directly executed if the player points to an
object in the scene area and clicks the right mouse button


@{b}icon@{ub}

If the inventory is displayed as icons, this is the image number used
for the inventory display. Can be a global, room or section image -
naturally, the image must be available at all times when there is a
chance of the oject being in the inventory!


@{b}LOW|MID|HIGH@{ub}

Decides whether the object is manipulated using the LOW, MID or HIGH
animation (@{"HANDLE" link "GG_HANDLE" 0} command).


@{b}types@{ub}

A character string, where each character specifies some property for the
object. The following are suggested, but using @{"IFTYPE" link "GG_IFTYPE" 0}, you can use this
feature for almost anything you like!

  M = Male character
  F = Female character
  A = Animal
  G = Group
  V = Alive
  D = Dead
  C = Container
  W = Wood
  T = Metal
  S = Stone
  L = Liquid
  E = Food     ...  and so on  ...


@{b}w1;w2;w3@{ub}

When you construct sentences referring to an object, sometimes you would
like to use the proper article or other word connected to the object.
These parameters give you a chance to specify such words, which can the
be put into your @{"sentences" link "GG_Vars" 0}. These can also be altered with the @{"NAME" link "GG_NAME" 0}
command during the game.
@endnode

@node "ST_DLG" "DLG"
@next "ST_ACTION"
@prev "ST_OBJECT"


@{fg shine}@{bg fill}DLG Statement (main)@{fg text}@{bg back}

@{i}Defines the dialogue partners.@{ui}


 @{b} DLG: partner;object;speech colour;speech offset;speech animation
sequence@{ub}

For each dialogue partner referred to by a RESP command,a DLG statement
must be present. (This is a slight change from the rules for this
statement in pre-2.0 versions. See @{"MAX_DLG:" link "ST_MAXDLG" 0}  for more info.)

@{b}dlg@{ub}

Dialogue partner number. Must be unique for each DLG: statement. Should
start from 1 and proceed upwards. This is the number used  in the @{"RESP" link "GG_RESP" 0}
command.

@{b}obj@{ub}

The dialogue "partner" is defined by this object. A partner can be a
global, section, or room object.

@{b}ink@{ub}

The colour used for the partner's speech.

@{b}y_offset@{ub}

This number determines where the partner's speech is printed. lower
numbers=higher above the partner's head.

@{b}anim@{ub}

The speech animation sequence used with the @{"RESP" link "GG_RESP" 0}  command.

See also: @{"RESP" link "GG_RESP" 0} command.
@endnode

@node "ST_ACTION" "ACTION"
@next "ST_DACT"
@prev "ST_DLG"


@{fg shine}@{bg fill}ACTION Statement (main, section, room)@{fg text}@{bg back}

@{i}Contains conditions and commands checked when player inputs a sentence.@{ui}


 @{b} ACTION: verb_no;{cond|comm}@{ub}

@{b}verb_no@{ub}

is the command verb number in the input sentence being checked

@{b}{cond|comm}@{ub}

is any number of conditions and/or commands, separated by ";"
characters.


When the player inputs a sentence, the ACTION: statements are checked
for the currently used script files, in this order:

 room file, top to bottom 
 section file, top to bottom 
 graal.main file, top to bottom

When an ACTION statement with the proper verb number is found, its
parameters - the conditions and commands - are checked and executed from
left to right. As soon as a condition is FALSE, the rest of that ACTION
statement is skipped, and GRAAL looks at the next one. (There is a
special verb number, -1, for "timer events" - see the @{"DOAFTER" link "GG_DOAFTER" 0} command.)

The search for further ACTION statements is stopped as soon as a valid
@{"EXIT" link "GG_EXIT" 0} command has been found. If a @{"REDO" link "GG_REDO" 0} statement is encountered, the
process is restarted from the first ACTION statement in the file
currently being processed.
@endnode

@node "ST_DACT" "DACT"
@next "ST_MAXACTION"
@prev "ST_ACTION"


@{fg shine}@{bg fill}DACT Statement (section, room)@{fg text}@{bg back}

@{i}Immediate actions upon entering section / room@{ui}


  @{b}DACT: {cond|comm}@{ub}


@{b}{cond|comm}@{ub}

is any number of conditions and/or commands, separated by ";"
characters.


@{i}DACT:s in room scripts@{ui}

Immediately after a room script has been loaded, all DACT statements in
the script are scanned for commands that should be executed before
control is returned to the player. As soon as an EXIT command is found,
any remaining DACT:s in the script are ignored. 


@{i}DACT:s in section scripts@{ui}

DACT:s in sections are executed immediately before the room DACT:s for
every room belonging to that section. Note that an EXIT command in a
section DACT only skips the rest of the section DACT:s - then the
execution of the room DACT:s begins.

The structure and function of DACT statements are the same as for
@{"ACTION:" link "ST_ACTION" 0} statements, except there is no verb number as first parameter
here.
@endnode

@node "ST_MAXACTION" "MAX_ACTION: statement"
@next "ST_UPDATE"
@prev "ST_DACT"


@{fg shine}@{bg fill}MAX_ACTION: Statement@{fg text}@{bg back}

@{i}Sets the maximum number of ACTION: statements in room and section
scripts@{ui}


 @{b} MAX_ACTION: actions@{ub}

Nothing much more to say, really. Mandatory from release 2.2. Try a
value of between 100 and 200 to begin with.
@endnode

@node "ST_UPDATE" "UPDATE"
@next "ST_SECTION"
@prev "ST_MAXACTION"


@{fg shine}@{bg fill}UPDATE Statement (room)@{fg text}@{bg back}

@{i}Set screen update rate@{ui}


 @{b} UPDATE: scroll_frames[;normal_frames]@{ub}

When there is a lot of graphics being updated simultaneously, the
animation(s) may become jerky. This is because all elements can't be
updated within 1/50th of a second - the time gap available before GRAAL
normally refreshes the screen. The problem is most noticeable during
background scrolls, because of the  added amount of graphics moving
about.

To make the animations smoother, we sometimes need to slow down the
updating rate and update the screen perhaps every 2/50ths or 3/50ths,
allowing GRAAL more time to do its graphics work. The UPDATE: statement
allows you to set specific rates for each room, optimising the
performance, and also to provide different values depending on whether
the background is currently scrolling or not.

Default values are 6 for background scrolling and 1 for "normal"
displays.
@endnode

@node "ST_SECTION" "SECTION"
@next "ST_3D"
@prev "ST_UPDATE"


@{fg shine}@{bg fill}SECTION Statement (room)@{fg text}@{bg back}

@{i}Defines to which section this room belongs@{ui}


 @{b} SECTION: section_no|SAME@{ub}

When you enter a new room and the section number is not the same as the
one for the previous room, the approprita section file (n.section) is
loaded and its contents executed.

Use SECTION: SAME in rooms which are jumped to from different sections,
for example load/save rooms or "current score" screens. This makes the
room use the previous section number, which prevents messing up the
section data...
@endnode

@node "ST_3D" "3D: statement"
@next "ST_BG_IFF"
@prev "ST_SECTION"


@{fg shine}@{bg fill}3D: Statement (room)@{fg text}@{bg back}

@{i}Sets the scaling points when scaling characters@{ui}


 @{b} 3D: max;mid;min;adjspeed@{ub}

3D: enables automatic scaling of controllable characters. max, mid, and
min refer to vertical (y) coordinates in the scene area (backdrop
picture).

@{b}max@{ub}

below this line, the characters will be shown in their original size.
Above it, they are shown at 5/6 of the original size.

@{b}mid@{ub}

Above this line, the characters are shown at 2/3 of the original size.

@{b}min@{ub}

Above this line, the characters are shown at 1/2 of the original size.

@{b}adjspeed@{ub}

This value allows you to adjust the speed factor, so that the smaller
the character becomes, the slower it moves. A value of 0 means no change
to the speed will be made. A value of 0.4 means the speed of the
smallest character size will be half of that in the original character
size (if the original walking speed was 1.2, as in the demo adventure).
Experiment to find a value giving walking speeds that seem "natural" in
the scene.


By placing some of the lines completely above or below the visible part
of the scene area, you can force GRAAL to use only some of the character
sizes in a particular room.

3D: relies on the data in the @{"CHAR:" link "ST_CHAR" 0} statements to find the images that
must be scaled. This means that even in single-character games, you have
to define a global object for the character, and also create a CHAR:
statement for it

Character scaling affects the following commands:

@{"CPOS" link "GG_CPOS" 0}, @{"CIMG" link "GG_CIMG" 0}, @{"CMOVE" link "GG_CMOVE" 0}, @{"MOBJ" link "GG_MOBJ" 0}, @{"HANDLE" link "GG_HANDLE" 0}, @{"SAY" link "GG_SAY" 0}


This means in a "scaled" room, you should not animate characters using
OMOVE or SHOW. IF two or more scalable characters are in the same room,
and they should interact with each other, you should do this using the
@{"SWITCH" link "GG_SWITCH" 0} command followed by CMOVE etc. for the respective characters.
@endnode

@node "ST_BG_IFF" "BG_IFF"
@next "ST_START_POS"
@prev "ST_3D"


@{fg shine}@{bg fill}BACKDROP Statement (room)@{fg text}@{bg back}

@{i}Name of background graphics file@{ui}


 @{b} BACKDROP: file@{ub}

This statement loads the background graphics for the room. The backdrop
should be 120 pixels high, and at least 320 pixels wide.

( Until release 2.2, this statement was called BG_IFF: )
@endnode

@node "ST_START_POS" "START_POS"
@next "ST_FLOOR"
@prev "ST_BG_IFF"


@{fg shine}@{bg fill}START_POS Statement (room)@{fg text}@{bg back}

@{i}Sets possible starting positions@{ui}


  @{b}START_POS: startpos_no;image;x;y;L|R|M;floor_no@{ub}

@{b}startpos_no@{ub}

Number of this entrance to the room, should range from 1 and upwards.

@{b}image@{ub}

The image used for the main character when placed in the starting
position.

@{b}x;y@{ub}

Position of the main character

@{b}L|R|M@{ub}

Decides whether the Left, Right, or Middle of the backdrop is initially
shown.

@{b}floor_no@{ub}

A floor containing the x;y point. If this is not properly set, the main
character may do a strange walkabout the first time he is commanded to
move somewhere else...
@endnode

@node "ST_FLOOR" "FLOOR"
@next "ST_PATH"
@prev "ST_START_POS"


@{fg shine}@{bg fill}FLOOR Statement (room)@{fg text}@{bg back}

@{i}Defines the "path" where the main character can walk and how they are
connected@{ui}


  @{b}FLOOR: floor_no;x1;y1;x2;y2;floormap{[/floormap]}@{ub}

Each floor defines a rectangular area where the main character can
"place its feet". Up to 12 such rectangles can be defined in a room, and
they should be connected in such a way that no floor becomes an "island"
without sharing any space with any other floor. In fact, floors shoull
overlap as much as possible in order for the character to be able to
move about. 

OVERLAPPING OF FLOORS

There are some vital rules for floor overlapping. Two floors may have
one or two intersection points, but not four. In the following diagrams,
X marks the intersection points:

        +------+                      +--------+ +--------+
        |  1   |                      |   1    |               |    1 |
        |      |                      |        |               | |
        +------X----------+     +-----X--------X--+   +--------X----+ |
        |      |          |     |     |        |  |   |        |    | |
        |      |    2     |     |  2  |        |  |   |   2 +----X---+
        |      |          |     |     |        |  |   |             |
        +------+----------+     +-----+--------+--+   +-------------+

are all OK, but the following is ILLEGAL:

              +------+
              |  1   |
         +----X------X-----+
         | 2  |      |     |
         +----X------X-----+
              |      |
              +------+

WALKING AROUND

The floormap parameters decide which floors the main character uses to
move from one spot to another.

For each floor defined, there must be as many floormaps defined as there
are floors in the room. Each floormap has the following format:

 @{b} finishfloor-nextfloor@{ub}

and answers the question: "If my final destination is @{b}finishfloor@{ub}, which
floor should I go to from where I currently am?" 

Example: For floor 2, there is a floormap

  @{b}3-4@{ub}

This floormap says that to go to floor 3 from floor 2, you should go via
floor 4.

Through logic follows that for each floor defined, there is always a
floormap for that floor pointing to itself. For example, one of the
floormaps for floor one is always 

  @{b}1-1@{ub}

because, if you want to get to floor 1, and you already are there, you
should not go anywhere else to get there. That's logic!

If there is more than one floormap, they are separated by a slash ( /
).


PATHS

From GRAAL 2, there is a way of navigating between floors that do not
require the floors to overlap: A path can be defined between them using
the @{"PATH:" link "ST_PATH" 0} statement. Paths can also twist and turn a number of times,
which may come in handy in its own right.

To use a path in a floormap, prefix the (path) number with a "P". Click
PATH: above for a more complete description.



EXAMPLE


  FLOOR: 1;10;40;210;60;1-1/2-2/3-2/4-P1

This is floor 1, which extends from 10;40 to 210;60. To go to floor 1
(itself), you go on to floor 1 (as discussed above). To go to floor 2,
you go directly on to floor 2. To go to floor 3, you go via floor 2. To
go to floor 4, you go via path 1, which thus must have one of its end
points within floor 1.
@endnode

@node "ST_PATH" " PATH "
@next "ST_EXIT"
@prev "ST_FLOOR"


@{fg shine}@{bg fill}PATH Statement (room)@{fg text}@{bg back}

@{i}defines a path to walk between two floors@{ui}


 @{b} PATH: path_no;floor1;floor2;px1;py1;px2;py2[{more_points}]@{ub}

@{b}floor1@{ub}

The number of the floor containing the first co-ordinate of the path.

@{b}floor2@{ub}

The number of the floor containing the last co-ordinate of the path.

@{b}px1;py1;px2;py2;...@{ub}

Co-ordinates specifying points along the path.
 

This is an alternative way to move between two floors. If two floors do
not overlap, a path can be defined between them:


                                    +--------------+
                                    |              |
                                    | D            |
                                    |/             |
                        Path 1      /              |
                     B-------------C               |
                    /               |              |
      Floor 1      /                +--------------+
         +--------/---+                        Floor 2
         |       /    |
         |      A     |
         |            |
         +------------+

As shown in the diagram, a path can alter direction a number of times.
This path has a starting point (A), two "knees" (B and C), and an ending
point (D).  Up to six point may be defined. Two is the natural minimum.

Example:

PATH: 1;2;4;120;40;160;30;230;60

Path 1 goes between floors 2 and 4. The starting point is 120;40 (within
floor 2), it turns at 160;30 and ends at 230;60 (within floor 4).

These are the rules:

 * A path must start inside one floor and end inside another.

 * A when a path should be used, it is specified in a floormap
   (se the @{"FLOOR:" link "ST_FLOOR" 0} statement) prefixed by a "P". For example,
   the floormap

    3-P2

   means "if the destination floor is 3, now use path 2"

 * Paths cannot be changed by commands, and if the floor settings
   are changed by the @{"SETFLOOR" link "GG_SETFLOOR" 0} command, the starting and ending points
   of all paths must still remain within the original floors. (Just
   a longwinded way to say "avoid using paths in rooms where you
   use SETFLOOR a lot...)

 * When the player clicks a position on the screen, GRAAL tries to 
   calculate the closest point to which the character can walk. This
   does NOT include points along the paths, but only the nearest
   point within a floor. For example, is the player clicks point B in 
   the diagram above, the character will actually only move to the
   point in floor 1 directly below and closest to it. If the player 
   clicks point C, GRAAL thinks "Aha, you want to go to floor 2, and 
   moves the character to the paths ending point (D), then to the point

   within that floor that is closest to point C.
@endnode

@node "ST_EXIT" "EXIT"
@next "ST_STATIC"
@prev "ST_PATH"


@{fg shine}@{bg fill}EXIT Statement (room)@{fg text}@{bg back}

@{i}Defines an exit from the room@{ui}


 @{b} EXIT: exit_no;x1;y1;x2;y2;x;y;description@{ub}

Up to 12 exits may be defined in each room.

@{b}exit_no@{ub}

is from 1 to 12 and must be unique within the room.

@{b}x1;y1;x2;y2@{ub}

Defines an area which the player can click to exit. x1;y1 = upper left
corner, x2;y2 = lower right corner.

@{b}x;y@{ub}

The co-ordinate the main character will walk to when exiting.

@{b}description@{ub}

Name of exit displayed in the scene area when the cursor moves over it.


When the exit is clicked, GRAAL will execute any ACTION statements that
begin

ACTION: 0;IFOBJ exit_no;...

This should usually be followed by @{"MEXIT" link "GG_MEXIT" 0} and @{"GOTO" link "GG_GOTO" 0} commands, if all you
want to do is a straightforward, uncomplicated switch to the next room.
However, you may do anything you like in these ACTION statements that
you can do when taking care of "normal" player input. Just remember, the
@{"VERB" link "GG_Syntax" 0} is 0, and @{"OBJ1" link "GG_Syntax" 0} is the exit number.
@endnode

@node "ST_STATIC" "STATIC"
@next "ST_ANIM"
@prev "ST_EXIT"


@{fg shine}@{bg fill}STATIC Statement (room)@{fg text}@{bg back}

@{i}Display a static image that is not an object@{ui}


 @{b} STATIC: bob;image;x;y@{ub}

This statement is particularly useful to insert foreground objects into
a scene, which you never want to manipulate in any way.

As always, make sure the bob number used isn't used for any other image
displayed in this room.

See also: @{"ANIM" link "ST_ANIM" 0}
@endnode

@node "ST_ANIM" "ANIM"
@next "ST_LINE"
@prev "ST_STATIC"


@{fg shine}@{bg fill}ANIM Statement (room)@{fg text}@{bg back}

@{i}Display an animated image that is not an object@{ui}


  @{b}ANIM: bob;image;anim_ch;@{"anim" link "GG_Animation" 0}|ptrn;x;y

@{ub}This statement is particularly useful for animated foreground images
that you do not wish to manipulate in any way in the game.

See also: @{"STATIC" link "ST_ANIM" 0}
@endnode

@node "ST_LINE" "LINE"
@next "ST_LACT"
@prev "ST_ANIM"


@{fg shine}@{bg fill}LINE Statement (section, room)@{fg text}@{bg back}

@{i}Define a dialogue alternative@{ui}


  @{b}LINE: dlg;line_no;sentence1;sentence2; |{cond}@{ub}

Each LINE statement defines a sentence to be shown in the dialogue
control area during a dialogue. It is the @{"DSET" link "GG_DSET" 0} command that decides
which alternatives actually appears at a certain time.

See the bottom of this text for special notes on use in .section files.

@{b}dlg@{ub}

Dialogue number (defined by the DSET statement in graal.main).

@{b}line_no@{ub}

A number from 1-30, must be unique within the dialogue

@{b}sentence1@{ub}

The sentence the main character will "speak" the first time this line is
used. If the first character of the sentence is a dollar sign ( $ ), the
main character will NOT speak the sentence. This means you can use the
dialogues for player multiple choice input, or having dialogues going on
when the main character is not shown on screen.

@{b}sentence2@{ub}

The sentence the main character will "speak" if the line has been used
before. This enables you to rephrase alternatives in a way that is more
natural than having to repeat the first-time line. For example, in the
sentence is

  Who are you?

and you would like to repeat that further on, the alternative should be
something like

  Who did you say you are?

because repeating the first version would seem rather stupid.

Sentences can contain audio info for talkies. See @{"audio info" link "Audio Info" 0}.

@{b} |{cond}@{ub}

Special conditions deciding whether the sentence is available to the
player or not. Put a blank space if no special conditions exist.

There are two factors deciding whether a line appears in the dialogue
control area or not. The first one is that a DSET command must have
given it permission to appear. The second one is that all conditions
specified here must be fulfilled.


@{i}About section dialogues@{ui}

As of GRAAL 2, dialogues may be common to an entire section of the
game.

Needless to say, this takes some care in the planning stage: Just keep
in mind that everywhere the dialogue can be invoked, the objects,
characters and room flags needed to carry out all possible LACT:s are in
place. For example, it is wise to make specific references to room flags
(IFRF room,flag=value) rather than test for "current room", because the
room may change from call to call.

At any time, the number of active dialogues loaded from the .room and
.section scripts must not exceed the number of dialogues set in the
@{"N_DIALOGUES:" link "ST_NDIALOGUES" 0} statement (default=6). For example, if there are two
dialogues in use by the section, no room belonging to that section must
load more than N_DIALOGUES-2 dialogues.
@endnode

@node "ST_LACT" "LACT"
@next "ST_LACT"
@prev "ST_LINE"


@{fg shine}@{bg fill}LACT Statement (section, room)@{fg text}@{bg back}

@{i}Contains actions in response to a certain dialogue alternative@{ui}


  @{b}LACT: dlg;line_no;{cond|comm}@{ub}

@{i}Important note:@{ui} All LACT: statements for a certain dialogue line must be
placed immediately  below that precise DLG: statement in the script
file.

The @{"LINE:" link "ST_LINE" 0} statement description holds some information about using
dialogues in section files.

@{b}dlg@{ub}

This is the number of the dialogue.

@{b}line_no@{ub}

This is the number of the line the player selected.

@{b}{cond|comm}@{ub}

These are any ordinary GRAAL conditions and/or commands, separated by
";" characters.


LACT statements often end with a DSET;EXIT combination to refresh the
dialogue status, or an EDLG;EXIT combination to end the dialogue and
return to normal input mode.

See also: @{"LINE" link "ST_LINE" 0} and @{"DLG" link "ST_DLG" 0} statements, and @{"DSET" link "GG_DSET" 0} and @{"EDLG" link "GG_EDLG" 0} commands.
@endnode

@node "Troubleshooting" " Trouble-shooting                      "
@next "T_statements"
@prev "Troubleshooting"


TROUBLE-SHOOTING

An ad-hoc creation like GRAAL is bound to have some niggles, many of
which I am probably not aware - because I invented the whole thing to
suit my needs and no-one else's. However, there are some common mistakes
easily made, which will get you into trouble. Here's how to deal with
some of them:


 @{"My command / statement doesn't work           " link "T_statements" 0} 
 @{"My iff pictures look awful / crash the system " link "T_graphics" 0} 
 @{">>Unknown error<< messages                    " link "T_Illegalfunc" 0} 
 @{"Mouse cursor does not register visible object " link "T_grabbingobjects" 0}      
 @{"My exits do not show up on screen             " link "T_showexits" 0}     
 @{"GRAAL 'looses' the exit number                " link "T_Exitnumber" 0}        

   

-
@endnode

@node "T_statements" "My command / statement doesn't work           "
@next "T_graphics"
@prev "Troubleshooting"


@{i}Trouble-shooting: @{ui}

MY COMMAND / STATEMENT DOESN'T WORK


You have probably got the number of parameters and / or delimiters
wrong. In most cases, GRAAL should detect this - in other cases, it
doesn't.

Check the syntax with the example files and this reference, and above
all, use the parameter editor and syntax checker facilities of the GRAAL
editor! Pay particular attention to the delimiters used: Semi-colons for
statements and commas for conditions and commands.

Be extra careful with those statements and commands where the last
parameter in itself may contain a variable number of other conditions or
commands, like the LINE and FLOOR statements. If you want to leave the
last parameter of a statement or command blank at the very end of a
line, there must be a blank space after the last delimiter. The GRAAL
Editor inserts this space automatically, but watch out if you use
another editor for some reason.

Also be extra careful when checking the syntax of animation strings!
@endnode

@node "T_graphics" "My iff pictures look awful / crash the system "
@next "T_Illegalfunc"
@prev "T_statements"


@{i}Trouble-shooting@{ui}

MY GRAPHICS CAUSE TROUBLE


A lot of the trouble that may arise is caused by the graphics
capabilities of Amos Pro. Remember that only ECS graphics can be used,
and not AGA modes.

If you use DPAINT as a paint package, you MUST make sure that stencils
and fixed background modes are turned OFF before saving the graphics -
otherwise, horrible things will occur when Amos encounter that
information which is included in the IFF file.

If you use a paint package with AGA capabilities, also remember that
there are more and subtler colour shades available: The colours in the
picture, and especially gradients, may look different when loaded into
GRAAL. In DPAINT IV (at least), there is a SCALE button in the palette
requester that scales all colours to "GRAAL-compatible" shades directly,
so you may see what the picture will actually look like.

Keeping the palette colours in order is pretty much up to you - just
remember,

 * colour 0 is always transparent

 * colour 1 should be white

 * colour 2 should be black

In the scene area it's colours 16, 17, and 18 that show up in the mouse
pointer, so you may wish to keep these the same in all your backdrop
graphics.
@endnode

@node "T_Illegalfunc" ""
@next "T_grabbingobjects"
@prev "T_graphics"


@{i}Trouble-shooting:@{ui}

Illegal Function Calls


GRAAL should no longer give the "illegal function" or similar message -
instead, you may encounter an "unknown error" message from GRAAL. Here
are some possible reasons:


 * You tried to @{"GOTO" link "GG_GOTO" 0} or @{"EXIT" link "ST_EXIT" 0} 
   to a room that has no .room file.

 * A @{"RESP" link "GG_RESP" 0} command pointed to a character that is 
   actually not displayed on screen - most likely, you got the dialogue

   number wrong in the command.

   Alternatively, the @{"OBJECT" link "ST_OBJECT" 0} defining the character 
   hasn't been made visible or was placed in the wrong room in the
   OBJECT statement.

 * Check that all objects / graphics that you have ordered to be
   present in the scene have actually been loaded into the image
   bank first using @{"CLPART" link "ST_CLPART" 0}, @{"IMGS" link "GG_IMGS" 0}, @{"ROOMIMGS" link "ST_IMGS" 0}, etc. 

 * You tried to use a room flag number higher than 20 or an object flag
   number higher than 6.
@endnode

@node "T_grabbingobjects" "Mouse cursor does not register visible object "
@next "T_showexits"
@prev "T_Illegalfunc"


@{i}Trouble-shooting@{ui}


@{b}Although an object is visible on screen, the mouse cursor does not pick
it up.@{ub}



This is due to the fact that if more than one object occupies the space
where the mouse cursor is, GRAAL only picks up the one that was first
added to the list of objects available in the room.

Use the @{"OBJONTOP" link "GG_OBJONTOP" 0} command to remedy the problem if and when it occurs.
@endnode

@node "T_showexits" "My exits do not appear"
@next "T_Exitnumber"
@prev "T_grabbingobjects"


@{i}Trouble-shooting@{ui}


@{b}My exits do not show up on screen@{ub}


1. You have not provided an exit name in the EXIT: statement. This means
no "Go to..." message is shown in the sentence box, and no name is shown
above the cursor in the scene area. However, this can also be put to
good use, because it allows you to use exits for defining any kind of
clickable area other than true exits and objects, for use as menu
selections and what  have you.


2. An exit is not detected by GRAAL if it is covered by an object. The
remedy is often to make the graphics that are to be shown when the exit
is available the backdrop picture. A common example would be a door
opening. The only time the exit is available is when the door is open.
Therefore, the open doorway should be the backdrop picture, the closed
door should be an object or a BOB put over the doorway when the door is
closed and the exit is hidden.

(Completely hiding an exit with an object this way actually means you do
not have do issue the HIDE EXIT command. However, I think it is good
coding practice to include it just the same. The code makes a lot more
sense that way, showing clearly what is going on in the room.)
@endnode

@node "T_Exitnumber" "GRAAL "
@next "T_Exitnumber"
@prev "T_showexits"


@{i}Trouble-shooting@{ui}

@{b}GRAAL looses the exit number@{ub}


Before you are finished going through the commands for an EXIT click
(ACTION: 0;IFOBJ....), the exit number seems to have changed or
disappeared.

Remember that the exit number is actually a special use of OBJ1, so any
commands put in these ACTION: statements that alter @{"OBJ1" link "GG_OBJ" 0} must put the
original back before it is time to check the exit number next time!
@endnode

@node "Audio Info" "audio info"


@{fg shine}@{bg fill}Audio Info@{fg text}@{bg back}


When @{"SPEECHMODE" link "GG_SPEECHMODE" 0} is set to AUDIO or BOTH, the information for the audio
files is fetched from an audio info string placed directly before the
corresponding text in angle brackets like this:

 @{b}<file/D|channels/D|frequency/D|length>Corresponding text@{ub}

@{b}myfile@{ub}

is the name of the file containing the IFF or RAW sample. Must be less
than 65536 bytes long!

@{b}D|channels@{ub}

are the audio channels to use. D will use the default (all channels, or
the arrangement set with the TRACK CHANNELS= command). Otherwise just
name the channels: "12" will output of channels 1 and 2, and so forth.

@{b}D|frequency@{ub}

is the playback frwquency. Specify D to use the default frequency for
the sample.

@{b}D|length@{ub}

is the length of the pause and should correspond to the length of the
sample, in 1/50ths of a second. D calculates the length from the
frequency and sample size.



If audio is on, and no audio info is present for a text string, the text
is displayed on screen in the normal way. If audio is off, audio info is
always ignored.


Audio info can be used in conjuction with text i @{"SAY" link "GG_SAY" 0}, @{"THINK" link "GG_THINK" 0}, @{"RESP" link "GG_RESP" 0} and
@{"TEXT" link "GG_TEXT" 0} commands, as well as @{"LINE:" link "ST_LINE" 0} statements.


Some examples:


SAY <hello.snd/D/D/D>Hello there!

Using all default options, the sample in the hello.snd file is played

s DLG: 1;11;<goodbye.snd/1/8363/D>; ; 

The goodbye.snd file is played on channel 1 with the frequency 8363.
@endnode

@node "imagesyntax" "Major name change to image related commands!"


@{fg shine}@{bg fill}Major name change to image related commands and statements@{fg text}@{bg back}



As of 2.3, a lot of image-related commands, conditions and statements
have changed names. This is to avoid confusion between image numbers and
BOB numbers. Simply put, I've tried to remove the term "BOB" in relation
to images, and simply call images images. These are the changes:


Statements:

 N_GLOBALBOBS:       is now    N_GLOBALIMGS: 
 N_SECTIONBOBS:      is now    N_SECTIONIMGS: 
 N_ROOMBOBS:         is now    N_ROOMIMGS:

 BOBS:               is now    IMGS:  
 SECTIONBOBS:        is now    SECTIONIMGS: 
 ROOMBOBS:           is now    ROOMIMGS:


Conditions and commands:

 BOBS                is now    IMGS
 CBOB                is now    CIMG
 IFCBOB              is now    IFCIMG
 PBOB                is now    PIMG


References

 RBOBn images should now be referenced RIMGn
 SBOBn images should now be referenced SIMGn


As you see, there is a certain logic to the name changes...

The parameters have not changed, and the GRAAL driver still accepts the
old forms. However, the syntax checker in the editor spots them and
urges you to change them. This means you can make the changes over time
when you're editing the scripts for some other reason.


Note that BOBON and BOBOFF haven't changed - they actually DO handle
bobs, and not just images!
@endnode

@node HeddleyAutoIndex "Index"
@remark Index auto-generated by Heddley
Index of database 002e4fd0-0

Documents

@{"" link "Main"}
@{"" link "T_Illegalfunc"}
@{" CUTSCENE_LAYOUT " link "ST_CUTSCENELAYOUT"}
@{" .room files " link "GG_ST_ROOM"}
@{" .section files " link "GG_ST_SECT"}
@{" A Very Short Introduction " link "GG_INTRO"}
@{" About this Tutorial                   " link "GG_Reference"}
@{" ADDOF " link "GG_ADDOF"}
@{" ADDRF " link "GG_ADDRF"}
@{" ADDTIME        " link "ADDTIME"}
@{" ARROW_CURSOR: " link "ST_ARROW_CURSOR"}
@{" BOBOFF " link "GG_BOBOFF"}
@{" BOBON " link "GG_BOBON"}
@{" CAMERA         " link "GG_CAMERA"}
@{" CANCEL         " link "GG_CANCEL"}
@{" CHAR " link "GG_CHAR"}
@{" CHAR " link "ST_CHAR"}
@{" CIMG " link "GG_CIMG"}
@{" CLPART " link "GG_CLPART"}
@{" CMOVE " link "GG_CMOVE"}
@{" COLOUR " link "GG_COLOUR"}
@{" CPOS " link "GG_CPOS"}
@{" CURSOR_PALETTE: " link "ST_CURSOR_PALETTE"}
@{" CUTSCENE " link "GG_CUTSCENE"}
@{" DATE_FORMAT " link "ST_DATEFORMAT"}
@{" DATE_LAYOUT " link "ST_DATELAYOUT"}
@{" DAY_TEXT " link "ST_DAYTEXT"}
@{" DEBUG " link "ST_DEBUG"}
@{" DECOF " link "GG_DECOF"}
@{" DECRF " link "GG_DECRF"}
@{" DISABLE_QUIT " link "ST_DISQUIT"}
@{" DISABLE_SAVE " link "ST_DISSAVE"}
@{" DLG_LAYOUT " link "ST_DLGLAYOUT"}
@{" DOAFTER        " link "GG_DOAFTER"}
@{" DSET " link "GG_DSET"}
@{" EDLG " link "GG_EDLG"}
@{" EXEC        " link "GG_EXEC"}
@{" EXIT " link "GG_EXIT"}
@{" FADE " link "GG_FADE"}
@{" FINAL" link "GG_FINAL"}
@{" FLOOR          " link "GG_FLOOR"}
@{" GET " link "GG_GET"}
@{" GOTO " link "GG_GOTO"}
@{" graal.main file " link "GG_ST_MAIN"}
@{" HANDLE " link "GG_HANDLE"}
@{" HIDE " link "GG_HIDE"}
@{" HIDEEXIT       " link "HIDEEXIT"}
@{" HOTSP          " link "GG_HOTSP"}
@{" ICON           " link "GG_ICON"}
@{" IFCARR / IFNOTCARR " link "GG_IFCARR"}
@{" IFCIMG             " link "GG_IFCIMG"}
@{" IFDATE             " link "GG_IFDATE"}
@{" IFEXISTS           " link "GG_IFEXISTS"}
@{" IFFLOOR            " link "IFFLOOR"}
@{" IFNOTSAVEDISK      " link "GG_IFNOTSAVEDISK"}
@{" IFOBJ / IFOBJ2 " link "GG_IFOBJ"}
@{" IFOF " link "GG_IFOF"}
@{" IFPICK " link "GG_IFPICK"}
@{" IFRF " link "GG_IFRF"}
@{" IFROOM " link "GG_IFROOM"}
@{" IFSPOS             " link "GG_IFSPOS"}
@{" IFTIME             " link "GG_IFTIME"}
@{" IFTYPE " link "GG_IFTYPE"}
@{" IFWEEKDAY          " link "GG_WEEKDAY"}
@{" IMGS " link "GG_IMGS"}
@{" INVENTORY      " link "GG_INVENTORY"}
@{" INV_UP " link "ST_INVUP_ETC"}
@{" LIGHTS " link "GG_LIGHTS"}
@{" Limitations, Ranges, Reserved Numbers " link "GG_Limits"}
@{" LINE " link "GG_LINE"}
@{" LINE_LENGTH " link "ST_linelength"}
@{" LOAD           " link "GG_LOAD"}
@{" Machine Requirements                  " link "GG_Requirements"}
@{" MARK " link "GG_MARK"}
@{" MEXIT          " link "GG_MEXIT"}
@{" MOBJ " link "GG_MOBJ"}
@{" MODE_SWITCH " link "ST_MODESWITCH"}
@{" MONTH_TEXT " link "ST_MONTHTEXT"}
@{" NAME           " link "GG_NAME"}
@{" NEWOBJ         " link "GG_NEWOBJ"}
@{" News in version 2                     " link "News"}
@{" NFLOOR         " link "GG_NFLOOR"}
@{" NOBREAK " link "GG_NOBREAK"}
@{" NORMAL_WAIT " link "ST_NORMWAIT"}
@{" N_DIALOGUES " link "ST_NDIALOGUES"}
@{" N_VERBS " link "ST_NVERBS"}
@{" OBJ1 / OBJ2 " link "GG_OBJ"}
@{" OBJONTOP       " link "GG_OBJONTOP"}
@{" OMOVE " link "GG_OMOVE"}
@{" PATH " link "ST_PATH"}
@{" PICK " link "GG_PICK"}
@{" PIMG           " link "GG_PBOB"}
@{" PREP           " link "GG_PREP"}
@{" QUIT           " link "GG_Quit"}
@{" REDO " link "GG_REDO"}
@{" REMOVE " link "GG_REMOVE"}
@{" RESP           " link "GG_RESP"}
@{" RESTORETIME    " link "GG_RESTORETIME"}
@{" RESUME " link "GG_RESUME"}
@{" ROOM " link "GG_ROOM"}
@{" SAMLOAD " link "GG_SAMLOAD"}
@{" SAMPLAY " link "GG_SAMPLAY"}
@{" SAVE           " link "GG_SAVE"}
@{" SAVETIME       " link "GG_SAVETIME"}
@{" SAY " link "GG_SAY"}
@{" SENTENCE_LAYOUT " link "ST_SENTLAYOUT"}
@{" SETDATE        " link "GG_SETDATE"}
@{" SETFLOOR       " link "GG_SETFLOOR"}
@{" SETOF " link "GG_SETOF"}
@{" SETRF " link "GG_SETRF"}
@{" SETTIME        " link "GG_SETTIME"}
@{" SHOW " link "GG_SHOW"}
@{" SHOWEXIT       " link "SHOWEXIT"}
@{" SOUND          " link "GG_SOUND"}
@{" SPLIT_LINE " link "ST_AREASIZES"}
@{" Syntax Conventions " link "GG_Syntax"}
@{" SYSTEM_TEXT " link "ST_SYSTEMTEXT"}
@{" TEXT           " link "GG_TEXT"}
@{" The GRAAL player interface" link "GG_Interface"}
@{" The Structure of a GRAAL Game " link "GG_STRUCTURE"}
@{" THINK " link "GG_THINK"}
@{" TIME_FORMAT " link "ST_TIMEFORMAT"}
@{" TIME_LAYOUT " link "ST_TIMELAYOUT"}
@{" TITLE " link "GG_TITLE"}
@{" TRACK " link "GG_TRACK"}
@{" Trouble-shooting                      " link "Troubleshooting"}
@{" TYPE " link "GG_TYPE"}
@{" Variables in Text Strings " link "GG_Vars"}
@{" VERB " link "GG_VERB"}
@{" VERB_TEXT " link "ST_VERBTEXT"}
@{" VERB_ZONE " link "ST_VERBZONE"}
@{" W(ait) " link "GG_WAIT"}
@{" WALK_BUTTON " link "ST_WALKBUTTON"}
@{"3D: statement" link "ST_3D"}
@{"ACTION" link "ST_ACTION"}
@{"ANIM" link "ST_ANIM"}
@{"animation sequences" link "GG_Animation"}
@{"audio info" link "Audio Info"}
@{"BG_IFF" link "ST_BG_IFF"}
@{"CHARACTER_BOB" link "ST_CHARACTER_BOB"}
@{"CHARACTER_COL" link "ST_CHARACTER_COL"}
@{"CHARACTER_HEIGHT" link "ST_CHARSIZE"}
@{"CLPART" link "ST_CLPART"}
@{"COMAREA command" link "GG_COMAREA"}
@{"COMGR command" link "GG_COMGR"}
@{"COMMAND_AREA" link "ST_AREAFILES"}
@{"DACT" link "ST_DACT"}
@{"DLG" link "ST_DLG"}
@{"EFFECT:" link "GG_EFFECT"}
@{"EXIT" link "ST_EXIT"}
@{"EXIT_COL" link "ST_EXIT_COL"}
@{"FLOOR" link "ST_FLOOR"}
@{"FOLLOW Command" link "GG_FOLLOW"}
@{"GLOBALOBJS" link "ST_OBJS"}
@{"GRAAL " link "T_Exitnumber"}
@{"GRAAL Commands" link "GG_Commands"}
@{"GRAAL Conditions" link "GG_Conditions"}
@{"HANDLE_MAP" link "ST_HANDLE_MAP"}
@{"IFCHAR Condition" link "GG_IFCHAR"}
@{"IFHERE Condition" link "GG_IFHERE"}
@{"IFNOTROOM" link "GG_IFNOTROOM"}
@{"IFVAR Condition" link "GG_IFVAR"}
@{"IMGS" link "ST_IMGS"}
@{"INV_LAYOUT" link "ST_INVLAYOUT"}
@{"LACT" link "ST_LACT"}
@{"LINE" link "ST_LINE"}
@{"Major name change to image related commands!" link "imagesyntax"}
@{"MAKE3D command" link "GG_MAKE3D"}
@{"MAX_ACTION: statement" link "ST_MAXACTION"}
@{"MAX_CACHE" link "ST_MAXCACHE"}
@{"MAX_DACT" link "ST_MAX_DACT"}
@{"MAX_DLG:" link "ST_MAXDLG"}
@{"MAX_ROOM" link "ST_MAX_ROOM"}
@{"MAX_SECTION" link "ST_MAX_SECTION"}
@{"Mouse cursor does not register visible object " link "T_grabbingobjects"}
@{"MSGFONT" link "ST_XXXFONT"}
@{"MUSIC" link "GG_MUSIC"}
@{"My command / statement doesn't work           " link "T_statements"}
@{"My exits do not appear" link "T_showexits"}
@{"My iff pictures look awful / crash the system " link "T_graphics"}
@{"NAME" link "ST_NAME"}
@{"NTSC_TIMING: Statement" link "ST_NTSCTIMING"}
@{"N_GLOBALIMGS" link "ST_NIMGS"}
@{"OBJECT" link "ST_OBJECT"}
@{"OBJ_COL" link "ST_OBJ_COL"}
@{"PAUSE_RIGHT" link "ST_PAUSE"}
@{"PLAYMACRO" link "GG_PLAYMACRO"}
@{"PROMPT Command" link "GG_PROMPT"}
@{"RESOURCE" link "ST_RESOURCE"}
@{"SECTION" link "ST_SECTION"}
@{"SELECT_CHAR: statement" link "ST_SELECTCHAR"}
@{"SETTEXT" link "GG_SETTEXT"}
@{"SETVAR Command" link "GG_SETVAR"}
@{"SPEECHMODE" link "GG_SPEECHMODE"}
@{"SPEECH_LAYOUT" link "ST_SPEECHLAYOUT"}
@{"START_POS" link "ST_START_POS"}
@{"START_ROOM" link "ST_START_ROOM"}
@{"STATIC" link "ST_STATIC"}
@{"STILL_RIGHT" link "ST_STILL"}
@{"SWITCH" link "GG_SWITCH"}
@{"TALK_MAP" link "ST_TALK_MAP"}
@{"TCURS command" link "GG_TCURS"}
@{"TRACE Command" link "GG_TRACE"}
@{"UPDATE" link "ST_UPDATE"}
@{"VERSION" link "ST_VERSON"}
@{"WALK_RIGHT" link "ST_WALK"}
@{"WALK_SPEED" link "ST_WALK_SPEED"}
@{"WALK_SPEED command" link "GG_WALK_SPEED"}

Buttons

@{" A Very Short Introduction             " link "GG_INTRO" 0}
@{" About this Reference                  " link "GG_Reference" 0}
@{" ACTION " link "ST_ACTION" 0}
@{" ADDOF          " link "GG_ADDOF" 0}
@{" ADDRF          " link "GG_ADDRF" 0}
@{" ADDTIME        " link "ADDTIME" 0}
@{" ANIM " link "ST_ANIM" 0}
@{" AREA_SIZES " link "ST_AREASIZES" 0}
@{" ARROW_CURSOR " link "ST_ARROW_CURSOR" 0}
@{" BACKDROP " link "ST_BG_IFF" 0}
@{" BOBOFF         " link "GG_BOBOFF" 0}
@{" BOBON          " link "GG_BOBON" 0}
@{" CAMERA         " link "GG_CAMERA" 0}
@{" CANCEL         " link "GG_CANCEL" 0}
@{" CHAR " link "ST_CHAR" 0}
@{" CHAR           " link "GG_CHAR" 0}
@{" CHARACTER_COL " link "ST_CHARACTER_COL" 0}
@{" CHARACTER_HEIGHT " link "ST_CHARSIZE" 0}
@{" CHARACTER_WIDTH " link "ST_CHARSIZE" 0}
@{" CIMG           " link "GG_CIMG" 0}
@{" CLPART " link "ST_CLPART" 0}
@{" CLPART " link "GG_CLPART" 0}
@{" CLPART         " link "GG_CLPART" 0}
@{" CMOVE          " link "GG_CMOVE" 0}
@{" COLOUR         " link "GG_COLOUR" 0}
@{" COMAREA        " link "GG_COMAREA" 0}
@{" COMFONT " link "ST_XXXFONT" 0}
@{" COMGR          " link "GG_COMGR" 0}
@{" Commands                              " link "GG_Commands" 0}
@{" COMMAND_AREA " link "ST_AREAFILES" 0}
@{" Conditions                            " link "GG_Conditions" 0}
@{" CPOS           " link "GG_CPOS" 0}
@{" CROSSHAIR_CURSOR " link "ST_ARROW_CURSOR" 0}
@{" CURSOR_PALETTE " link "ST_CURSOR_PALETTE" 0}
@{" CUTSCENE       " link "GG_CUTSCENE" 0}
@{" CUTSCENE_LAYOUT " link "ST_CUTSCENELAYOUT" 0}
@{" DACT " link "ST_DACT" 0}
@{" DATE_FORMAT " link "ST_DATEFORMAT" 0}
@{" DATE_LAYOUT " link "ST_DATELAYOUT" 0}
@{" DAY_TEXT " link "ST_DAYTEXT" 0}
@{" DEBUG " link "ST_DEBUG" 0}
@{" DECOF          " link "GG_DECOF" 0}
@{" DECRF          " link "GG_DECRF" 0}
@{" DISABLE_QUIT " link "ST_DISQUIT" 0}
@{" DISABLE_SAVE " link "ST_DISSAVE" 0}
@{" DLG " link "ST_DLG" 0}
@{" DLG_AREA " link "ST_AREAFILES" 0}
@{" DLG_DOWN " link "ST_INVUP_ETC" 0}
@{" DLG_LAYOUT " link "ST_DLGLAYOUT" 0}
@{" DLG_UP " link "ST_INVUP_ETC" 0}
@{" DOAFTER        " link "GG_DOAFTER" 0}
@{" DSET           " link "GG_DSET" 0}
@{" EDLG           " link "GG_EDLG" 0}
@{" EFFECT         " link "GG_EFFECT" 0}
@{" EXEC           " link "GG_EXEC" 0}
@{" EXIT " link "ST_EXIT" 0}
@{" EXIT           " link "GG_EXIT" 0}
@{" EXIT_COL " link "ST_EXIT_COL" 0}
@{" FADE           " link "GG_FADE" 0}
@{" FINAL          " link "GG_FINAL" 0}
@{" FLOOR " link "ST_FLOOR" 0}
@{" FLOOR          " link "GG_FLOOR" 0}
@{" FOLLOW         " link "GG_FOLLOW" 0}
@{" GET            " link "GG_GET" 0}
@{" GLOBALOBJS " link "ST_OBJS" 0}
@{" GOTO           " link "GG_GOTO" 0}
@{" HANDLE         " link "GG_HANDLE" 0}
@{" HANDLE_MAP " link "ST_HANDLE_MAP" 0}
@{" HIDE           " link "GG_HIDE" 0}
@{" HIDEEXIT       " link "HIDEEXIT" 0}
@{" HOTSP          " link "GG_HOTSP" 0}
@{" ICON           " link "GG_ICON" 0}
@{" IFCARR / IFNOTCARR " link "GG_IFCARR" 0}
@{" IFCHAR             " link "GG_IFCHAR" 0}
@{" IFCIMG             " link "GG_IFCIMG" 0}
@{" IFDATE             " link "GG_IFDATE" 0}
@{" IFEXISTS           " link "GG_IFEXISTS" 0}
@{" IFFLOOR            " link "IFFLOOR" 0}
@{" IFHERE             " link "GG_IFHERE" 0}
@{" IFNOTSAVEDISK      " link "GG_IFNOTSAVEDISK" 0}
@{" IFOBJ / IFOBJ2     " link "GG_IFOBJ" 0}
@{" IFOF / IFOF2       " link "GG_IFOF" 0}
@{" IFPICK             " link "GG_IFPICK" 0}
@{" IFRF               " link "GG_IFRF" 0}
@{" IFROOM             " link "GG_IFROOM" 0}
@{" IFSPOS             " link "GG_IFSPOS" 0}
@{" IFTIME             " link "GG_IFTIME" 0}
@{" IFTYPE             " link "GG_IFTYPE" 0}
@{" IFVAR              " link "GG_IFVAR" 0}
@{" IFWEEKDAY          " link "GG_WEEKDAY" 0}
@{" IMGS " link "ST_IMGS" 0}
@{" IMGS           " link "GG_IMGS" 0}
@{" INVENTORY      " link "GG_INVENTORY" 0}
@{" INV_DOWN " link "ST_INVUP_ETC" 0}
@{" INV_LAYOUT " link "ST_INVLAYOUT" 0}
@{" INV_UP " link "ST_INVUP_ETC" 0}
@{" LACT " link "ST_LACT" 0}
@{" LIGHTS         " link "GG_LIGHTS" 0}
@{" Limitations, Ranges, Reserved Numbers " link "GG_Limits" 0}
@{" LINE " link "ST_LINE" 0}
@{" LINE           " link "GG_LINE" 0}
@{" LINE_LENGTH " link "ST_linelength" 0}
@{" LOAD           " link "GG_LOAD" 0}
@{" Machine Requirements                  " link "GG_Requirements" 0}
@{" MARK           " link "GG_MARK" 0}
@{" MAX_ACTION " link "ST_MAXACTION" 0}
@{" MAX_CACHE " link "ST_MAXCACHE" 0}
@{" MAX_DACT " link "ST_MAX_DACT" 0}
@{" MAX_DLG " link "ST_MAXDLG" 0}
@{" MAX_ROOM " link "ST_MAX_ROOM" 0}
@{" MAX_SECTION " link "ST_MAX_SECTION" 0}
@{" MEXIT          " link "GG_MEXIT" 0}
@{" MOBJ           " link "GG_MOBJ" 0}
@{" MODE_SWITCH " link "ST_MODESWITCH" 0}
@{" MONTH_TEXT " link "ST_MONTHTEXT" 0}
@{" MSGFONT " link "ST_XXXFONT" 0}
@{" NAME " link "ST_NAME" 0}
@{" NAME           " link "GG_NAME" 0}
@{" NEWOBJ         " link "GG_NEWOBJ" 0}
@{" NFLOOR         " link "GG_NFLOOR" 0}
@{" NOBREAK        " link "GG_NOBREAK" 0}
@{" NORMAL_WAIT " link "ST_NORMWAIT" 0}
@{" N_DIALOGUES " link "ST_NDIALOGUES" 0}
@{" N_GLOBALIMGS " link "ST_NIMGS" 0}
@{" N_ROOMIMGS " link "ST_NIMGS" 0}
@{" N_SECTIONIMGS " link "ST_NIMGS" 0}
@{" N_VERBS " link "ST_NVERBS" 0}
@{" OBJ1 / OBJ2    " link "GG_OBJ" 0}
@{" OBJECT " link "ST_OBJECT" 0}
@{" OBJONTOP       " link "GG_OBJONTOP" 0}
@{" OBJ_COL " link "ST_OBJ_COL" 0}
@{" OMOVE          " link "GG_OMOVE" 0}
@{" PATH " link "ST_PATH" 0}
@{" PAUSE_BACK " link "ST_PAUSE" 0}
@{" PAUSE_FRONT " link "ST_PAUSE" 0}
@{" PAUSE_LEFT " link "ST_PAUSE" 0}
@{" PAUSE_RIGHT " link "ST_PAUSE" 0}
@{" PICK           " link "GG_PICK" 0}
@{" PIMG           " link "GG_PIMG" 0}
@{" Player interface and shortcut keys    " link "GG_Interface" 0}
@{" PREP           " link "GG_PREP" 0}
@{" PROMPT         " link "GG_PROMPT" 0}
@{" PUT            " link "GG_REMOVE" 0}
@{" QUIT           " link "GG_Quit" 0}
@{" REDO           " link "GG_REDO" 0}
@{" RESOURCE " link "ST_RESOURCE" 0}
@{" RESP           " link "GG_RESP" 0}
@{" RESTORETIME    " link "GG_RESTORETIME" 0}
@{" RESUME         " link "GG_RESUME" 0}
@{" ROOMIMGS " link "ST_IMGS" 0}
@{" ROOMOBJ " link "ST_OBJECT" 0}
@{" ROOMOBJS " link "ST_OBJS" 0}
@{" SAM            " link "GG_SAMPLAY" 0}
@{" SAMLOAD        " link "GG_SAMLOAD" 0}
@{" SAVE           " link "GG_SAVE" 0}
@{" SAVETIME       " link "GG_SAVETIME" 0}
@{" SAY            " link "GG_SAY" 0}
@{" SECTION " link "ST_SECTION" 0}
@{" SECTIONIMGS " link "ST_IMGS" 0}
@{" SECTIONOBJ " link "ST_OBJECT" 0}
@{" SECTIONOBJS " link "ST_OBJS" 0}
@{" SENTENCE_LAYOUT " link "ST_SENTLAYOUT" 0}
@{" SETDATE        " link "GG_SETDATE" 0}
@{" SETFLOOR       " link "GG_SETFLOOR" 0}
@{" SETOF          " link "GG_SETOF" 0}
@{" SETRF          " link "GG_SETRF" 0}
@{" SETTIME        " link "GG_SETTIME" 0}
@{" SETVAR         " link "GG_SETVAR" 0}
@{" SHOW           " link "GG_SHOW" 0}
@{" SHOWEXIT       " link "SHOWEXIT" 0}
@{" SOUND          " link "GG_SOUND" 0}
@{" Special Characters in Text Strings    " link "GG_Vars" 0}
@{" START_POS " link "ST_START_POS" 0}
@{" START_ROOM " link "ST_START_ROOM" 0}
@{" Statements in the graal.main file     " link "GG_ST_MAIN" 0}
@{" Statements in the n.room files        " link "GG_ST_ROOM" 0}
@{" Statements in the n.section files     " link "GG_ST_SECT" 0}
@{" STATIC " link "ST_STATIC" 0}
@{" STILL_BACK " link "ST_STILL" 0}
@{" STILL_FRONT " link "ST_STILL" 0}
@{" STILL_LEFT " link "ST_STILL" 0}
@{" STILL_RIGHT " link "ST_STILL" 0}
@{" SWITCH         " link "GG_SWITCH" 0}
@{" Syntax Conventions                    " link "GG_Syntax" 0}
@{" SYSTEM_TEXT " link "ST_SYSTEMTEXT" 0}
@{" TALK_MAP " link "ST_TALK_MAP" 0}
@{" TEXT           " link "GG_TEXT" 0}
@{" The Structure of a GRAAL Game         " link "GG_STRUCTURE" 0}
@{" THINK          " link "GG_THINK" 0}
@{" TIME_FORMAT " link "ST_TIMEFORMAT" 0}
@{" TIME_LAYOUT " link "ST_TIMELAYOUT" 0}
@{" TITLE          " link "GG_TITLE" 0}
@{" TITLEFONT1 " link "ST_XXXFONT" 0}
@{" TITLEFONT2 " link "ST_XXXFONT" 0}
@{" TRACE          " link "GG_TRACE" 0}
@{" TRACK          " link "GG_TRACK" 0}
@{" Trouble-shooting                      " link "Troubleshooting" 0}
@{" TYPE           " link "GG_TYPE" 0}
@{" UPDATE " link "ST_UPDATE" 0}
@{" VERB           " link "GG_VERB" 0}
@{" VERB_TEXT " link "ST_VERBTEXT" 0}
@{" VERB_ZONE " link "ST_VERBZONE" 0}
@{" VERSION " link "ST_VERSON" 0}
@{" W(ait)         " link "GG_WAIT" 0}
@{" WALK_AWAY " link "ST_WALK" 0}
@{" WALK_BUTTON " link "ST_WALKBUTTON" 0}
@{" WALK_LEFT " link "ST_WALK" 0}
@{" WALK_RIGHT " link "ST_WALK" 0}
@{" WALK_SPEED " link "ST_WALK_SPEED" 0}
@{" WALK_SPEED     " link "GG_WALK_SPEED" 0}
@{" WALK_TOWARD " link "ST_WALK" 0}
@{".ptrn" alink "1.ptrn/main" 0}
@{".scene" alink "1.scene/1.scene/main" 0}
@{"3D:" link "ST_3D" 0}
@{"=DEMO=>" alink "graal.main/main" 0}
@{"=DEMO=>" alink "1.section/main" 0}
@{"=DEMO=>" alink "1.room/main" 0}
@{">>Unknown error<< messages                    " link "T_Illegalfunc" 0}
@{"ACTION" link "ST_ACTION" 0}
@{"ACTION:" link "ST_ACTION" 0}
@{"ADDOF" link "GG_ADDOF" 0}
@{"ADDRF" link "GG_ADDRF" 0}
@{"ADDTIME" link "ADDTIME" 0}
@{"ANIM" link "ST_ANIM" 0}
@{"anim" link "GG_Animation" 0}
@{"ANIM:" link "ST_ANIM" 0}
@{"animation sequence" link "GG_Animation" 0}
@{"animation sequences" link "GG_Animation" 0}
@{"AREA_SIZES:" link "ST_AREASIZES" 0}
@{"audio info" link "Audio Info" 0}
@{"BOBOFF" link "GG_BOBOFF" 0}
@{"BOBON" link "GG_BOBON" 0}
@{"CANCEL" link "GG_CANCEL" 0}
@{"CHAR" link "GG_CHAR" 0}
@{"CHAR OFF" link "GG_CHAR" 0}
@{"CHAR:" link "ST_CHAR" 0}
@{"CHARACTER_WIDTH:" link "ST_CHARSIZE" 0}
@{"CHAR_HEIGHT:" link "ST_CHARSIZE" 0}
@{"CHAR_WIDTH:" link "ST_CHARSIZE" 0}
@{"CIMG" link "GG_CIMG" 0}
@{"CLPART" link "GG_CLPART" 0}
@{"CLPART" link "ST_CLPART" 0}
@{"CMOVE" link "GG_CMOVE" 0}
@{"COLOUR" link "GG_COLOUR" 0}
@{"CPOS" link "GG_CPOS" 0}
@{"CURSOR_PALETTE" link "ST_CURSOR_PALETTE" 0}
@{"CUTSCENE" link "GG_CUTSCENE" 0}
@{"DACT" link "ST_DACT" 0}
@{"DATE_FORMAT" link "ST_DATEFORMAT" 0}
@{"DATE_LAYOUT" link "ST_DATELAYOUT" 0}
@{"DAY_TEXT:" link "ST_DAYTEXT" 0}
@{"DECOF" link "GG_DECOF" 0}
@{"DECRF" link "GG_DECRF" 0}
@{"DISABLE_SAVE:" link "ST_DISSAVE" 0}
@{"DLG" link "ST_DLG" 0}
@{"DLG:" link "ST_DLG" 0}
@{"DOAFTER" link "GG_DOAFTER" 0}
@{"DSET" link "GG_DSET" 0}
@{"EDLG" link "GG_EDLG" 0}
@{"EFFECT" link "GG_EFFECT" 0}
@{"EXIT" link "GG_EXIT" 0}
@{"EXIT" link "ST_EXIT" 0}
@{"EXIT:" link "ST_EXIT" 0}
@{"FADE" link "GG_FADE" 0}
@{"FLOOR" link "GG_FLOOR" 0}
@{"FLOOR:" link "ST_FLOOR" 0}
@{"FOLLOW" link "GG_FOLLOW" 0}
@{"GET" link "GG_GET" 0}
@{"GOTO" link "GG_GOTO" 0}
@{"GRAAL 'looses' the exit number                " link "T_Exitnumber" 0}
@{"graal.main" link "GG_ST_MAIN" 0}
@{"HANDLE" link "GG_HANDLE" 0}
@{"HIDE" link "GG_HIDE" 0}
@{"HIDEEXIT" link "HIDEEXIT" 0}
@{"HOTSP" link "GG_HOTSP" 0}
@{"IFEXISTS" link "GG_IFEXISTS" 0}
@{"IFNOTROOM" link "GG_IFNOTROOM" 0}
@{"IFNOTSAVEDISK" link "GG_IFNOTSAVEDISK" 0}
@{"IFOF" link "GG_IFOF" 0}
@{"IFRF" link "GG_IFRF" 0}
@{"IFROOM" link "GG_IFROOM" 0}
@{"IFTYPE" link "GG_IFTYPE" 0}
@{"IFVAR" link "GG_IFVAR" 0}
@{"IMGS" link "GG_IMGS" 0}
@{"IMGS" link "ST_IMGS" 0}
@{"IMGS:" link "ST_IMGS" 0}
@{"INVENTORY" link "GG_INVENTORY" 0}
@{"LACT" link "ST_LACT" 0}
@{"LACT" link "ST_DACT" 0}
@{"LIGHTS ON" link "GG_LIGHTS" 0}
@{"LINE" link "ST_LINE" 0}
@{"LINE:" link "ST_LINE" 0}
@{"LOAD" link "GG_LOAD" 0}
@{"Major name change to image related commands!" link "imagesyntax" 0}
@{"MARK" link "GG_MARK" 0}
@{"MAX_DLG:" link "ST_MAXDLG" 0}
@{"MEXIT" link "GG_MEXIT" 0}
@{"MOBJ" link "GG_MOBJ" 0}
@{"MONTH_TEXT:" link "ST_MONTHTEXT" 0}
@{"Mouse cursor does not register visible object " link "T_grabbingobjects" 0}
@{"MUSIC" link "GG_MUSIC" 0}
@{"My command / statement doesn't work           " link "T_statements" 0}
@{"My exits do not show up on screen             " link "T_showexits" 0}
@{"My iff pictures look awful / crash the system " link "T_graphics" 0}
@{"n.room" link "GG_ST_ROOM" 0}
@{"n.section" link "GG_ST_SECT" 0}
@{"NAME" link "GG_NAME" 0}
@{"NFLOOR" link "GG_NFLOOR" 0}
@{"NOBREAK" link "GG_NOBREAK" 0}
@{"N_DIALOGUES:" link "ST_NDIALOGUES" 0}
@{"N_VERBS" link "ST_NVERBS" 0}
@{"OBJ1" link "GG_OBJ" 0}
@{"OBJ1" link "GG_Syntax" 0}
@{"OBJ1/OBJ2" link "GG_OBJ" 0}
@{"OBJECT" link "ST_OBJECT" 0}
@{"OBJECT" link "ST_OBJS" 0}
@{"OBJONTOP" link "GG_OBJONTOP" 0}
@{"OMOVE" link "GG_OMOVE" 0}
@{"PATH:" link "ST_PATH" 0}
@{"PAUSE_..." link "ST_PAUSE" 0}
@{"PICK" link "GG_PICK" 0}
@{"PIMG" link "GG_PIMG" 0}
@{"PLAYMACRO" link "GG_PLAYMACRO" 0}
@{"PROMPT" link "GG_PROMPT" 0}
@{"QUIT" link "GG_Quit" 0}
@{"Read the News!!!" link "News" 0}
@{"REDO" link "GG_REDO" 0}
@{"REMOVE" link "GG_REMOVE" 0}
@{"RESP" link "GG_RESP" 0}
@{"RESTORETIME" link "GG_RESTORETIME" 0}
@{"RESUME" link "GG_RESUME" 0}
@{"RESUME KEEP" link "GG_RESUME" 0}
@{"ROOMIMGS" link "ST_IMGS" 0}
@{"SAM" link "GG_SAMPLAY" 0}
@{"SAMLOAD" link "GG_SAMLOAD" 0}
@{"SAMPLAY" link "GG_SAMPLAY" 0}
@{"SAVE" link "GG_SAVE" 0}
@{"SAVE" link "ST_DISSAVE" 0}
@{"SAVETIME" link "GG_SAVETIME" 0}
@{"SAY" link "GG_SAY" 0}
@{"sentences" link "GG_Vars" 0}
@{"SETDATE" link "GG_SETDATE" 0}
@{"SETFLOOR" link "GG_SETFLOOR" 0}
@{"SETOF" link "GG_SETOF" 0}
@{"SETRF" link "GG_SETRF" 0}
@{"SETTEXT" link "Document_1" 0}
@{"SETTEXT" link "GG_SETTEXT" 0}
@{"SETTIME" link "GG_SETTIME" 0}
@{"SETVAR" link "GG_SETVAR" 0}
@{"SHOW" link "GG_SHOW" 0}
@{"SHOWEXIT" link "SHOWEXIT" 0}
@{"SOUND" link "GG_SOUND" 0}
@{"special characters" link "GG_Vars" 0}
@{"SPEECHMODE" link "GG_SPEECHMODE" 0}
@{"SPEECH_LAYOUT:" link "ST_SPEECHLAYOUT" 0}
@{"START_POS" link "ST_START_POS" 0}
@{"START_POS:" link "ST_START_POS" 0}
@{"STATIC" link "ST_ANIM" 0}
@{"STATIC:" link "ST_STATIC" 0}
@{"STILL_..." link "ST_STILL" 0}
@{"SWITCH" link "GG_SWITCH" 0}
@{"syntax" link "GG_Syntax" 0}
@{"TEXT" link "GG_TEXT" 0}
@{"THINK" link "GG_THINK" 0}
@{"TIME_FORMAT" link "ST_TIMEFORMAT" 0}
@{"TIME_LAYOUT" link "ST_TIMELAYOUT" 0}
@{"TITLE" link "GG_TITLE" 0}
@{"TITLEFONT:" link "ST_XXXFONT" 0}
@{"TRACK" link "GG_TRACK" 0}
@{"TRACK CHANNELS=" link "GG_TRACK" 0}
@{"TYPE" link "GG_TYPE" 0}
@{"variable" link "GG_Vars" 0}
@{"VERB" link "GG_VERB" 0}
@{"VERB" link "GG_Syntax" 0}
@{"VERB_TEXT:" link "ST_ExitMessage" 0}
@{"VERB_TEXT:" link "ST_VERBTEXT" 0}
@{"VERB_ZONE:" link "ST_VERBZONE" 0}
@{"WALK_..." link "ST_WALK" 0}
@{"WALK_SPEED" link "ST_WALK_SPEED" 0}
@{"WALK_SPEED:" link "ST_WALK_SPEED" 0}
@endnode
