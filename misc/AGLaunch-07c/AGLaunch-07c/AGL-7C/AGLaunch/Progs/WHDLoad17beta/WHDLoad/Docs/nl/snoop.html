<HTML>
<HEAD>
<TITLE>Snooping</TITLE>
<meta name="DC.Language" content="nl">
<meta http-equiv="content-language" content="nl">
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
<!-- $Id: snoop.html 1.3 2003/12/09 10:57:18 wepl Exp wepl $ -->
</HEAD>
<BODY>
<h3>Snooping</h3>

<h4>Wat het is</h4> Snooping is een eigenschap van WHDLoad waarvan de actie het is te bevestigen en het loggen
van toegangen naar de Custom en Cia registers. Als <a
href="opt.html#Snoop">Snoop</a> is geactiveerd zullen alle ongeldige toegangen een Toegangs Fout
creëren en het geïnstalleerde programma word beëindigd. WHDLoad laat een requester zien die uitlegt
wat de reden van deze fout is.
<h4>Custom registers</h4>Alle lees en schrijf toegangen naar de custom registers worden gecontroleerd.
Ongeldige toegangen zijn:
<ul>
<li>toegangen naar niet bestaande registers
<li>lees toegangen naar Alleen Schrijven registers
<li>schrijf toegangen naar Alleen lezen registers
<li>toegangen naar Eerder Gelezen registers
<li>byte schrijf toegangen (behalve <tt>bltcon0l</tt> en <tt>aud*vol+1</tt>)
</ul>
Strobe registers kunnen gelezen of beschreven worden. De set van geldige Custom registers kunnen
variëren tussen OCS (Oude ChipSet - A500, A1000, oude A2000), ECS (Enhanced ChipSet
- A600, nieuwe A2000, A3000) en AGA (Advanced Graphics - A1200, A4000). Dit is handig
speciaal om bugs te ontdekken in oude programma's veroorzaakt door ongedefinieerde toegangen tot
nieuwe AGA registers.

<h4>Cia registers</h4>Op de Cia registers worden alleen schrijf toegangen geverifiëerd
Dat betekend dat lees toegangen naar niet bestaande registers in het geheugen gebied
van $bfd000...$bfefff niet worden gedetecteerd. Voor alle schrijf toegangen word de geschreven
waarde intern weggeschreven door WHDLoad. Voor sommige Cia registers zijn daar speciale checks
voor afhankelijk van de geschreven waarde:

<p><table border=1 summary="table of cia registers">
<tr>
	<th>adres</th>
	<th>register</th>
	<th>controle</th>
</tr><tr>
	<td>$bfe001</td>
	<td>ciaa.ciapra</td>
	<td>het zetten van de Overlay bit op #0 is verboden</td>
</tr><tr>
	<td>$bfe201</td>
	<td>ciaa.ciaddra</td>
	<td>bits #6-7 kunnen elke waarde hebben (gebruikt met joypad), lagere bits moeten zijn %000011</td>
</tr><tr>
	<td>$bfe801</td>
	<td>ciaa.ciatodlow</td>
	<td rowspan=3>lees-wijzig-schrijf toegangen (bijv. bchg) zijn niet toegestaan als
	 ALARM bit is ingesteld in ciaa.ciacrb (alleen gecheckt op een 68060)</td>
</tr><tr>
	<td>$bfe901</td>
	<td>ciaa.ciatodmid</td>
</tr><tr>
	<td>$bfea01</td>
	<td>ciaa.ciatodhi</td>
</tr><tr>
	<td>$bfed01</td>
	<td>ciaa.ciaicr</td>
	<td>lees-wijzig-schrijf toegangen (bijv. bchg) zijn niet toegestaan (alleen gecheckt op een 68060)</td>
</tr><tr>
	<td>$bfd100</td>
	<td>ciab.ciaprb</td>
	<td>de bits voor MOTOR #7, SELECT #3-6 en STEP #0 moeten niet leeggehaald worden, andere bits
	kunnen veranderd worden; met dat kunnen alle toegangen tot floppy drives gedetecteerd worden</td>
</tr><tr>
	<td>$bfd200</td>
	<td>ciab.ciaddra</td>
	<td>de geschreven waarde moet zijn %11000000</td>
</tr><tr>
	<td>$bfd300</td>
	<td>ciab.ciaddrb</td>
	<td>de geschreven waarde moet zijn %11111111</td>
</tr><tr>
	<td>$bfd800</td>
	<td>ciab.ciatodlow</td>
	<td rowspan=3>lees-wijzig-schrijf toegangen (bijv. bchg) zijn niet toegestaan
	als ALARM bit is ingesteld in ciab.ciacrb (alleen gecheckt op een 68060)</td>
</tr><tr>
	<td>$bfd900</td>
	<td>ciab.ciatodmid</td>
</tr><tr>
	<td>$bfda00</td>
	<td>ciab.ciatodhi</td>
</tr><tr>
	<td>$bfdd00</td>
	<td>ciab.ciaicr</td>
	<td>lees-wijzig-schrijf toegangen (bijv. bchg) zijn niet toegestaan (alleen gecheckt op een 68060)</td>
</tr></table>

<h4>Hoe werkt het</h4>
Als Snoop geactiveerd is, markeert WHDLoad de adressen van de custom en cia registers als ongeldig/beveiligd 
tegen schrijven in de MMU vertaal boom. Hierom resulteert elke toegang naar een custom of cia register in 
een Toegangs Fout uitzondering.
De uitzondering handler in WHDLoad behandelt deze uitzondering. Eerst checkt het of de toegang geldig is.
Als de toegang ongeldig is wordt het programma beëindigd. Als de toegang geldig is en een lees operatie
is dan word het geëmuleerd en word de programma uitvoer hervat. Als het een schrijf operatie is zal WHDLoad
extra de waarden schrijven naar een interne opslag.
<br>Om de overhead van de uitzondering en de emulatie volgorde word de programma uitvoer
langzamer. Hoeveel langzamer ligt aan de CPU type, Chip Memory type (16/32-bit) en Stackpointer gepositioneerd 
als de Chip Memory 32-bit is (Lange Woord gepositioneerd of niet). Het verschilt ook voor de toegangs type
(Byte/Woord/Lange Woord, Lezen/Schrijven). Op de 68030 is Schrijven sneller dan Lezen (omdat bij lezen de stack
frame 92 bytes is en bij schrijven 32 bytes), op de 68060 is Lezen sneller omdat de emulatie voor schrijven
meer complex is.
<h4>Snelle Snoop Mode</h4>
De optie <a href="opt.html#Snoop">Snoop/S</a> activeert de snelle snooping. Lees toegangen
worden niet gecontroleerd. Geen speciale checks worden uitgevoerd. Deze mode kan handig zijn
om alleen de inhoud van custom registers te verkrijgen, bijv. om een plaatje weg te schrijven 
met <a href="sp.html">SP</a>.

<h4>Copper Lijst Scanner</h4>
Vanaf versie 13 van WHDLoad worden ook copperlijsten zelf gecheckt. 
De scanner word geactiveerd tijdens het schrijven naar de <tt>coplc</tt> registers als 
de copper dma geactiveerd is, of wanneer het geïnstalleerde programma de copper dma activeert door het
schrijven van de <tt>dmacon</tt> register. De scanner volgt de copperlijst en valideert
alle Verplaats instructies door restricties toe te passen veroorzaakt door de Snoop optie
(OCS/ECS/AGA). Sla over en Wacht (behalve CEND) instructies worden genegeerd. Wanneer het
ongeldige notities vind, word het geïnstalleerde programma beëindigd. De scanner
volgt takken (<tt>copjmp</tt>), detecteert loops en checkt tot wel 16 sublijsten.
De Verplaatsingen in de copperlijst worden weggeschreven in de interne custom register bestand
wat word gedumpt bij het verlaten van WHDLoad. De scanner is niet actief in Snelle 
Snoop Mode.

<h4>Blitter Prioriteiten Check</h4>
Wanneer de optie ChkBltHog/S is geactiveerd zal WHDLoad checken of het geïnstalleerde
programma niet <tt>BltHog</tt> activeert door het schrijven naar de <tt>dmacon</tt> register.
De Blitter prioriteit kan problemen veroorzaken op sommige hardware configuraties in samenwerking
met grote blitter operaties (alle kanalen gebruikt.)
<h4>Blitter Grootte Check</h4>
Wanneer de optie ChkBltSize/S is geactiveerd zal WHDLoad checken dat blitter werkzaamheden
niet toegang krijgen tot geheugen buiten het BaseMem gebied. Tijdens schrijf toegangen
naar <tt>bltsize</tt> of <tt>bltsizh</tt> checkt het of de regel mode is ingeschakeld 
in <tt>bltcon1</tt>. Als de regel mode actief is verbreekt het de grootte check.
Anders zal WHDLoad de toegang van het eerste en laatste woord berekenen voor elke
geactiveerde DMA kanaal. Als 1 adres buiten het BaseMem gebied bevind zal het programma
worden gestopt met een requester. De berekening is ontworpen om te werken met alle modes
(stijgend/dalend, positieve/negatieve modulos, oneven modulos/verwijzing).
<br>Weet dat de regel teken mode niet geverifieerd word en dat alle blitter registers
ook geschreven worden door de copper als <tt>copcon</tt> is ingeschakeld.
<h4>Blitter Wacht Check</h4>
Als de optie ChkBltWait/S is geactiveerd zal WHDLoad een instructie spoor gebruiken om 
te verifiëren dat het geïnstalleerde programma correct wacht op de blitter om te stoppen
voordat het start met een nieuwe blitter operatie. Het gebruikt een interne variabele 
welke de werkende staat van de blitter vertegenwoordigd. De variabele is ingeschakeld wanneer
een schrijf toegang naar de <tt>bltsize</tt> of <tt>bltsizh</tt> plaatsvind en leeggemaakt word
wanneer lees toegang naar het <tt>dmaconr</tt> register is uitgevoerd.
Op elke schrijven naar een blitter register word de interne variabele gecheckt,
als het een draaiende blitter operatie constateert word het geïnstalleerde programma gestopt
en zal WHDLoad de PC van de laatst gestarte blitter operatie samen met de eigenlijke toegang rapporteren.
<br>Er zijn 2 grote knelpunten met deze eigenschap. Ten eerste blitter gebruik
via de copper is niet gecheckt en ten tweede het gebruik van blitter onderbreking
zorgt ervoor dat de check routine fouten rapporteert die niet nodig zijn. 
<h4>Toekomst</h4>
Het is de bedoeling om eigenschappen toe te voegen zoals Freezing
en Iconifing. Van deze, is Snoop een essentiële aanname. Daarom is het
aanbevolen voor Install auteurs om hun Installs te checken met Snoop
om toekomstige compatibiliteit te waarborgen.
<h4>Benodigdheden</h4>
Een MMU is nodig voor de Snoop eigenschap. Ook moet WHDLoad de MMU <a
href="mmu.html#usercontrol">gebruiken</a>, daarom moet <a
href="opt.html#MMU">MMU/S</a> geactiveerd zijn op 68030 machines.
<h4>Beperkingen</h4>
<ul>
<li>68020 + 68851
<ul>
<li>Deze hardware word momenteel niet ondersteund
</ul>
<li>68030
<ul>
<li>geen bekende beperkingen
</ul>
<li>68040
<ul>
<li>Deze hardware word momenteel niet ondersteund
</ul>
<li>68060
<ul>
<li>de<tt> movem</tt> instructie kan toegang krijgen tot een ongeldig register
zonder een Toegangs Fout uitzondering te maken, dit is mogelijk omdat alleen de eerste
toegang wordt geverifiëerd voor een gelijkmatig geldig register
<li><tt>verplaats &lt;Cia/Custom register&gt;,sr</tt> word incorrect uitgevoerd
als het de supervisor gedeelte van het status register wil veranderen, de supervisor gedeelte
blijft onveranderd
<li>elke <tt>(ssp)+</tt> of <tt>-(ssp)</tt> in samenwerking met een schrijf toegang naar
een Cia of Custom register kan niet behandeld worden door stackframe problemen, WHDLoad
zal zulke toegangen detecteren en beëindigen met een geschikte requester
<li>instructies mag niet meer toegang hebben dan 1 snoop register per keer,
dat betekend dat de code zoals <tt>move.b ($dff006),($bfd800)</tt> niet behandeld
kunnen worden, als zo'n code ontstaat laat WHDLoad een Toegangs Fout requester zien
</ul>
</ul>
</BODY>
</HTML>


