

	Here you will find several source code files and programs which will
	help you in developing your own installs using WHDLoad.


	gci
	---

	The Graphical Coder Interface is a MUI program to display the contents
	of a dumpfile created by WHDLoad. Its not completely finished but the
	source is included so you can enhance it yourself (if you do so please
	share).


	imager-examples
	---------------

	These are sources for imager using RawDIC or Patcher.


	macros
	------

	some macros which are required for some sources


	memory-speed
	------------

	These are results from the Speed.Slave for various different hardware
	configurations. It shows how fast memory accesses are on differnt
	platforms. It also illustrates the limited cachebility on various
	accelerator boards or the access speed for Custom and Cia chips.


	programs
	--------

	some small tools, maybe useful for you

	WCmp:
	simple compare utility, has wide output (16 bytes per line), shows
	only differences, doesn't load whole file but works buffered,
	interruptable with ^C

	WDate:
	I use this to insert the date and time of assembling into the
	created executable (see example-slaves)

	WVer:
	I use this to increase the revision number each time the source
	will be assembled (similar usage like WDate)


	resource
	--------

	Support files to use with ReSource package by The Puzzle Factory.
	It contains symbol files and macros to decode WHDLoad, RawDIC and
	Patcher Slaves.


	slave-examples
	--------------

	The Slave examples are the recommend reading if you want yourself
	write Slaves.

	winditup.asm:
	this is a very simple Slave to give you an overview how a Slave is
	working, the Slave loads from a disk image and uses the keyboard
	routine provided in the sources directory

	oscar.asm:
	this is a simple example for using usual files, it also contains a
	simple exec.AllocMem() emulation which works fine as long as no
	FreeMem() is required

	interphase.asm:
	shows the usage of "savegame.s"


	sources
	-------

	these sources are code fragments containing one or more sub routines,
	they should be used by including them at the bottom of the Slave
	source and calling from the slave source

	blitfix_#?.s:
	these routines will patch instructions which are writing to the
	blitsize custom register, the patched instruction will be replaced by
	a routine doing the same but previously waiting for the blitter to
	finish,	very useful to fix programs which will not correctly wait
	for blitter finish

	keyboard.s:
	this file contains a complete keyboard initialisation and the required
	interrupt handler, it will be useful for programs without a own
	keyboard handling (most demos) or for programs with broken handling
	(in this case you have to disable the original)

	savegames.s:
	this routine contains a system for multiple savegames, there is
	special code which creates a interface to select a save position and
	to enter a description for each	savegame

	dbffix.s:
	contains a routine to fix empty dbf loops, that means all instructions
	like "dbf dn,*" will be patched by a wait routine based on vertical
	raster beam, a well known example for empty dbf loops is the playback
	routine of the old soundtracker used in many demos and games


	PLEASE NOTE
	-----------

	My Assembler is able to optimize the addressing mode (and much more):
		(xxxxxxxx).L	-->	(d16,PC)
	if possible.

	So I never do this myself!
	Remember Slaves must be 100% PC-relativ!
	So if your Assembler isn't able to do this and you want to use these
	sources you have to add the "(pc)" by yourself. (or just get a better
	assembler!)
