@database CodeWar.guide
@author Rhett and James Jacobs
@(c) ® Amigan Software 1995-2017. Freely distributable.
@$VER: CodeWar.guide 1.65 (10.9.2017)
@node Main "CodeWar"

                      @{b}#*===========================*#
                      #|       C O D E W A R       |#
                      #|       Version 1.65        |#
                      #|        10 Sep 2017        |#
                      #|                           |#
                      #| by Rhett and James Jacobs |#
                      #|    of Amigan Software     |#
                      #*===========================*#@{ub}

                           @{" Overview            " link Over}
                           @{" Requirements        " link Requ}
                           @{" Usage               " link Usag}
                           @{" Credits and Licence " link Cred}
                           @{" History             " link Hist}
                           @{" Other Releases      " link Rele}

                           @{" CodeWar Simulator   " link Simu}
                           @{" Robot Design        " link Desi}
                           @{" API Reference       " link Refe}
@endnode

@node Over "Overview"

@{b}Overview@{ub}

This is the CodeWar simulator, a game for programmers.

CodeWar is essentially a simulation engine which allows multiple processes
to execute simultaneously within the same virtual environment. This
in turn provides programmers with the facilities to compete against one
another by seeing who can write the program which exists the longest
within this environment.

Less formally, CodeWar allows programmers to create programs (robots)
which can compete against one another using a variety of
armaments (cannons, missiles, etc.) by executing them at the same time
within the CodeWar simulator. Robots have the ability to detect these
other robots and make up their own stategies to outsmart other
programmers' code.

Therefore, CodeWar is a "robots" type game, similar in flavour
to programs such CRobots and PCRobots. Those programmers
familiar with these programs will find CodeWar similar in aspects, but
will quickly realise that CodeWar allows competent programmers
more facilities to extend themselves and their robots. The design
goal was not to hold the hand of competing programmers; but rather to
provide an accurate simulation engine, and allow the programmers to do
the rest.

An important difference to other such simulators is that the competing
CodeWar robots are real programs for the relevant machine. This means that
competing robots can be written with any language, compiler and debugging
tools. Robots are ordinarily portable between the different platforms
CodeWar is available on, merely by recompiling them. They can be submitted
for competition as binaries only if desired, ensuring that competent robot
programmers do not have their strategies stolen by lamers once a robot is
distributed.

Currently, CodeWar is available for Linux, Windows, AmigaOS 3, AmigaOS 4
and MorphOS.

The following features of the Linux version are not implemented in the
Windows/AmigaOS/MorphOS versions:

    * TCP/IP-based networking. Ie. the simulator and robots must run
      together on the same machine, rather than over a network.
    * the channel subsystem.
    * user-replaceable graphics.
    * charges (which were only half-implemented anyway).

Also note that robots which were compiled for V1.63 and earlier will
need to be recompiled to function correctly under V1.64 and later.
@endnode

@node Requ "System Requirements"

@{b}SYSTEM REQUIREMENTS-------------------------------------------------------@{ub}

These are for the AmigaOS 3.x version of CodeWar:

@{b}Hardware@{ub}   Required       MC68EC020+
                          about 2Mb free RAM
           Recommended    Graphics card
                          1024*768 or higher Workbench
@{b}Firmware@{ub}   Required       Kickstart 3.1+
@{b}Software@{ub}   Required       AmigaOS 3.9+BB1
           Recommended    AmigaOS 3.9+BB4/AmigaOS 4.x/MorphOS
                           (for speed)
                          AmiUpdate (for OS4 version)

This program does not operate under the "AmigaOS 3.x" provided by Cloanto
in eg. the Amiga Forever 6.0 package, as it requires OS3.9+BB1 (or later)
versions of certain ReAction gadgets. The versions included in "AmigaOS
3.x" are obsolete and will not work. We suggest asking Cloanto for the
real OS3.9 which you have paid them for and which they have not supplied
to you, rather than a crippled version of OS3.5 which is basically what
their "AmigaOS 3.x" is.

For MorphOS users:

You need the appropriate ClassAct/ReAction classes (eg. window.class,
speedbar.gadget, etc.) installed. You can get these classes at
http://amigan.1emu.net/releases/RA-MOS.lha . Those files are sourced from
AmigaOS 3.9+BB2, except that window.class V42.84 is provided instead of
V45.16. This is because MorphOS is incompatible with window.class 45.16:
opening it will cause a hang. Simply copy these ReAction classes into
SYS:Classes/ . Although they are compiled for 68020, they will work under
MorphOS.

For AmigaOS 4 users:

The program uses audio.device (ie. Paula); you might need to use NallePUH
or a similar program to enable sound.
  OS4.1FE is recommended so that you get BOOPSI menus (with imagery). The
BOOPSI menu subsystem assumes you have AISS installed (it is part of a
standard OS4.1FE install). The simulator uses the MenuImageSize
environment variable when starting up to determine what size to make the
menu imagery. If this variable is is not present, the default is 16 pixels
square. If this variable is 0, menu imagery is not loaded nor shown.

The OS3 version is not intended for OS4 nor MorphOS, and compatibility of
it with those platforms is not assured. You should run the native port for
your platform (because some of the compatibility logic is done at compile-
time rather than at runtime).
@endnode

@node Simu "CodeWar Simulator"

@{b}CODEWAR SIMULATOR---------------------------------------------------------@{ub}

The CodeWar simulator (aka the "server") is the master program which
provides the CodeWar simulation engine, inter-process communication and
graphics display.

    * Robot communication handling
        This provides the facilities for all robots to communicate with
      the simulator. Communication between the robots (aka the "clients")
      and simulator is accomplished through message passing.
        Wrapper functions (eg. @{"cw_register_program()" link cw_register_program}) are provided,
      which encapsulate the private message-based interface.
      Use of the wrapper functions will help to ensure source-level
      portability of robots between different platforms. Therefore, the
      underlying interface to the simulator is deliberately undocumented
      and is to be considered private, unsupported and liable to be
      changed at any time. If the underlying interface changes,
      recompilation with the updated api.c/.o should be all that
      is required.
        The CodeWar simulator monitors its message port for incoming
      messages. When a robot connects (with the @{"cw_register_program()" link cw_register_program}
      call), the CodeWar simulator assigns it a robot number, creates the
      robot and then begins communicating with the robot. The CodeWar
      server maintains a list of robot connections and uses these to
      discriminate among the active robots inside the simulator. This way,
      multiple instances of the same robot can be spawned at the same
      time. However, running multiple concurrent instances of the
      *simulator* is unsupported and will not work reliably.

    * A simulation engine
        The simulator is responsible for handling the simulation of all
      aspects of the battle: movement, weapon detonation, etc.

    * A graphics display system
        The entire world is shown in the large CodeWar simulator window.
      Each robot is adorned with a "clock hand", which shows the robot's
      heading (ie. its direction of acceleration), and a triangle which
      shows the direction in which the robot is scanning (or last
      scanned), and the width of that scan.
        There also a small status window for each robot, which shows
      information about that robot:
          Acc = Acceleration (X,Y)
          Vel = Velocity     (X,Y)

@{b}Simulator controls@{ub}

B:   cycles through the available backgrounds (IBM PC only).
P:   pauses the simulator. The simulator continues to be responsive to
     robot messages as normal.
S:   toggles sound effects on or off.
T:   toggles turbo mode (unlimited speed) on or off.
Esc: kills all robots and quits the simulator.

You can also adjust the speed the simulator runs at, via the "Speed..."
item on the Settings/Options menu. (This has no effect in turbo mode.)
This is transparent to the competing robots (ie. at 50% speed, the
simulator will simulate 5 seconds' worth in 10 seconds, and report to
the robots that 5 seconds has elapsed).

These controls are for use in robot testing rather than for competition
play:

A:   rearms (ie. replenishes the ammunition of) all robots.
E:   replenishes the energy of all robots.
H:   heals (but does not resurrect) all robots.
R:   randomly repositions all robots.

If you hold down one or more of the alphanumeric keys 1..8 (not those on
the numeric keypad) before pressing the key, only the specified robot(s)
will be affected. Eg. if the 2 and 4 keys are held down and R is pressed,
robots #2 and #4 will be repositioned.
@endnode

@node Desi "Robot Design"

@{b}ROBOT DESIGN--------------------------------------------------------------@{ub}

There are a set of CodeWar function calls provided in api.c and
codewar.h. These calls automate and encapsulate all the necessary
housekeeping associated with passing messages between the robot and
simulator. Robots can be written in any language, though only a C
interface is provided.
  Essentially, robots are written and compiled. Then, when ready to
compete, the CodeWar simulator is run, with the competing robots given as
command line arguments. This should then begin executing all specified
robots within the simulator.
  Each robot is a standard program for the platform concerned (eg.
Windows, AmigaOS or MorphOS), which issues various commands (of the "do
this now" and "tell me this now" nature) to the CodeWar simulator.

@{b}The world@{ub}

Competing robots are simulated by the CodeWar server in a self-contained
virtual world. This environment has the following properties:

    * It is a two-dimensional plane.
    * There is no friction.
    * It has finite size.
    * It follows standard physical rules of plane kinematics.

Each of these points is important in constructing competitive robots; eg.
as there is no friction, once a robot begins moving in a certain
direction, it will theoretically continue at that velocity indefinitely.
However, as the world has finite size, this is not the case, and a robot
needs to monitor its position so that it remains within the world.

@{b}Creating a robot@{ub}

Robots are the processes which compete within the CodeWar simulator. The
only difference between these processes and any other program written
and compiled within a standard compiler, is the fact that they have an
initial call to @{"cw_register_program()" link cw_register_program}.

@{b}Where to start@{ub}

It is essential to be able to program in ANSI C or another language to be
able to create any form of competitive robot. We will (obviously) not go
into the ins and outs of programming in C and the reader is advised to get
a copy of Kernighan & Ritchie's "The C Programming Language" or similar. I
realise that a choice of C book is a religious issue so be a heathen if
you like.

@{b}"Hello, world"@{ub}

As an example of a bare-bones robot, a "hello, world" robot can be created
as follows:

    #include "codewar.h"

    void main(void)
    {   if (cw_register_program("Foobar"))
        {   cw_print_buffer("Hello, world!");
            for (;;);
    }   }

Once compiled and linked, this will create a robot (called "Foobar"),
which will write "Hello world" into its output window and then remain idle
within the CodeWar simulator until someone else's robot notices and
destroys it...hopefully.

The call to @{"cw_register_program()" link cw_register_program} sets up the connection to the CodeWar
simulator and registers the robot as being called "Foobar". The program
then calls @{"cw_print_buffer()" link cw_print_buffer} which writes the passed-in buffer through to
the robot's display window within the CodeWar server. The last busy loop
(hmmm), simply stops the robot from terminating, at least till another
robot kills it. :-)

Once a robot has successfully registered itself, that program should not
be terminated (eg. with exit(), or by the user or OS). It will be killed
off automatically by the simulator when it is dies in the game, when its
when its window is closed, or when the simulator itself exits.

The "hello world" robot does not provide any form of intelligence and has
no offensive functionality. However, once compiled and linked it is
capable of existing within the world.

@{b}The next step@{ub}

It is misleading to assume a magic formula for any robot, which will make
it a competitive and challenging process. Nevertheless, the following
general factors will be addressed by successful robots:

    * Robot status - the fundamental goal of CodeWar is for robots to stay
      alive/active. With this in mind, any robot should keep a
      monitor of their current damage and shield status. It may be
      necessary to expend some of the robot's energy to re-boost the
      shields from time to time, so a knowledge of how much
      energy is left in the robot is a bonus.

    * The world - CodeWar is a fairly "open" simulator, in that the
      simulation enviroment can be configured in a number of
      ways. Such things as wall types will probably affect
      how a robot will handle movement. If the walls are
      twilight (wrap-around), then precise movement routines
      will probably not be necessary; however, if abyss
      (obliteration) walls are set up, then a little more care
      will need to be taken. No robot should assume a static world
      configuration. All robots have the facilities to determine
      the exact configuration of the world and it is highly advised
      that they be adaptive.

    * Other robots - the second most important goal of CodeWar is to
      destroy other robots within the world. This requires a clever use of
      the detection facilities provided by CodeWar. The system has
      deliberately been designed so that clever detection strategies are
      rewarded, as should be the case.

    * Offensive capability - the weapon systems provided to each robot
      need to be carefully managed to make sure that weapons are not
      wasted.

@{b}Collisions@{ub}

    When two robots collide, each will take damage equal to the velocity
    of the other, and they will exchange velocities.

@{b}Weapons@{ub}

             Range      Damage   Inventory

Atomic        50m         25          5
Bomb          50m         25         10
Cannon         5m          5         20
Missile       10m         10         50

All weapons can be "thrown" an infinite distance. The "range" shown above
is the radius (not diameter) of the explosion. When firing most weapons,
you specify a velocity and direction for the weapon, which are independent
of the velocity and direction of the robot itself. You also specify a time
delay before the weapon detonates (explodes). Weapons do not cause damage
until they detonate.
  Cannons and missiles will detonate automatically when they hit an enemy
robot.
  Note that it is indeed possible for robots to be harmed by their own
weapons. Damage shown is the maximum possible; ie. this is the damage
caused by an exact hit. Hits near the edge of the explosion range will
do proportionately less damage.
  When a robot takes damage, the amount is shown near their head, in the
colour of the robot which caused the damage (ie. fired the weapon). This
is shown regardless of whether the damage was absorbed by the robot's
shields or actually harmed the robot.
  Once per second, the computer will pick a weapon at random, and if you
have none of that weapon, it will give you one.

Atomic: Under the default settings, these are effectively the same as
bombs, except they can be launched in any direction and at any speed.

Bomb: These weapons are by far the most difficult to launch as they do not
have a direction nor velocity setting. Instead, they work directly off
the velocity and heading the launching robot possesses. As such, they have
been given a high damage rating and should be used only by competent robot
designers.

Cannon: These will automatically detonate when they hit an enemy robot.

Missile: These weapons are intermediate in their damage and range.

@{b}Example robots@{ub}

In addition to the "hello world" robot listed above, additional example
robots, written by the authors, are provided, in binary and source form.
These robots are admittedly poor. They were written more to test the
simulator than to demonstrate any algorithms. You are invited to submit
your own robots for inclusion with future versions.

The Myralee robot is only included with the Windows version. The Gumby,
Hello, Targon and Xenya robots are included with all versions.

Also, robots may be submitted for tournament competition. Official
tournaments may be run by Amigan Software, and the results of any such
tournaments will be announced on the Amigan Software website.

@{b}Rules@{ub}

Robots are expected to compete against one another exclusively via calls
to the CodeWar API. Attempting to kill other programs by other means,
or to interfere with the normal operation of the simulator or other
robots, are considered to be unfair, unsupported and non-portable.
  Specifically, the following actions are examples of those not considered
allowable by competing robots and are grounds for disqualification from
tournaments:

    * adjusting the priority of any program;
    * interfering with task switching;
    * sending requests to the OS to kill or otherwise interfere with
       other processes;
    * reading from or writing to memory owned or used by other processes;
    * generating, examining, altering and/or destroying messages not
       pertaining to the robot;
    * spawning threads, or new instances of itself;
    * sending messages to other robots;
    * sending malformed, spurious or unsupported messages to the
       simulator;
    * jamming any message port; or
    * acting on real-time input from the user.

Some tournaments may demand that robot source code be submitted to
facilitate verification of compliance with these rules. If so, such source
code will not be publicly released without the permission of the robot
programmer.

@{b}Other languages@{ub}

It is possible to write CodeWar robots in languages other than C/C++;
however, you need to either link with api.o or reimplement the
functionality of api.c yourself.
@endnode

@node Usag "Usage"

@{b}USAGE---------------------------------------------------------------------@{ub}

@{b}CLI Arguments@{ub}

                                  @{b}CodeWar@{ub}

@{b}Format:    CodeWar@{ub}
           [ATOMICS=<number>]
           [BOMBS=<number>]
           [BOUNDARY=ABYSS|RUBBER|STONE|TWILIGHT]
           [DAMAGE=<number>]
           [ENERGY=<number>]
           [FORCE=<number>]
           [HEIGHT=<number>]
           [INTERVAL=<number>]
           [MASS=<number>]
           [MISSILES=<number>]
           [SHIELDS=<number>]
           [SOUND=ON|OFF]
           [TURBO=ON|OFF]
           [WINDOWWIDTH=<number>]
           [WINDOWHEIGHT=<number>]
           [WORLDWIDTH=<number>]
           [WORLDHEIGHT=<number>]
           [<filenames>...]

@{b}Template:@{ub}  FILE/M,
           ATOMICS/K/N,
           BOMBS/K/N,
           BOUNDARY/K,
           DAMAGE/K/N,
           ENERGY/K/N,
           FORCE/K/N,
           GFXWIDTH/K/N,
           GFXHEIGHT/K/N,
           INTERVAL/K/N,
           MASS/K/N,
           MISSILES/K/N,
           SHIELDS/K/N,
           SOUND/K,
           TURBO/K,
           WORLDWIDTH/K/N,
           WORLDHEIGHT/K/N

@{b}Purpose:@{ub}   To provide a virtual world simulator for use by robot
           programs.

@{b}Specification:@{ub}

    <filenames>:
           zero to eight robot programs (or any other programs, for that
		   matter) to run automatically at startup. It is also possible to
           launch robots manually. The maximum number of simultaneously
           running robots is currently 8.

    ATOMICS=<number>:
           The number of atomic weapons each robot is equipped with. The
		   default is 5.

    BOMBS=<number>:
           The number of bombs each robot is equipped with. The default is
		   10.

    BOUNDARY=ABYSS|RUBBER|STONE|TWILIGHT:
           This parameter controls the type of world boundaries (borders):

           * TWILIGHT: This is the standard "wrap-around" effect where
             exiting the world from the west brings the robot or weapon
             back from the east, etc. It should be noted that CodeWar does
             not allow explosions to perform this trick.

           * RUBBER: When a robot or weapon collides with a wall, all
             energy is reflected back off the wall in the opposite
             direction. This is similar to throwing a rubber ball off a
             wall and watching its path. No damage is taken from hitting a
             wall of this type. RUBBER is the default type of boundary.

           * STONE: When a robot collides with a stone wall their velocity
             is immediately reduced to nothing. They still remain
             accelerating in this direction but will be unable to move
             until they reset their acceleration into a direction away
             from the wall. No damage is taken from hitting a wall of this
             type. Weapons hitting a stone wall are destroyed.

           * ABYSS: Abyss walls immediately destroy any robots or weapons
             that touch them. This is an expert setting and it is not
             recommended that first-time robot designers choose this
             setting for the CodeWar simulator.

    DAMAGE=<number>:
           The maximum amount of damage that can be sustained by each
           robot. The default is 100.

    ENERGY=<number>:
           The energy store provided to each robot. This energy can be
           transferred to the shields at any time to boost them if they
           have been damaged. There is no way to repair damage which has
           already occurred. The default is 100.

    FORCE=<number>:
           The maximum force (in newtons) which a robot can be subjected
           to through acceleration. The simulator does not allow infinite
           acceleration and uses this value (coupled with the robot MASS)
           to determine the maximum acceleration for a robot. The default
           is 1000 newtons. The maximum acceleration with the default
           settings (FORCE of 1000 newtons and MASS of 10kg) is 100.

    INTERVAL=<number>:
           This parameter specifies the time interval which should pass
           between each call of the CodeWar simulation engine. The value
           is specified in milliseconds and results in 1,000 / n calls per
           second (eg. with a value of 20, there should be 50 calls (ie.
           frames) per second). The default is 40ms (25 FPS).

    MASS=<number>:
           The mass of a robot in kilograms. This is used (coupled with
           the robot FORCE) to determine the actual acceleration of a
           robot. The default is 10kg.

    MISSILES=<number>:
           The number of missiles each robot is equipped with. The default
           is 50.

    SHIELDS=<number>:
           Starting level of the shields. The default is 100. The maximum
           level of the shields under any circumstances is always 100;
           therefore SHIELDS must be <= 100.

    SOUND=ON|OFF:
           Whether you want sound. The default is ON.

    GFXWIDTH=<number>:
    GFXHEIGHT=<number>:
           The width and height of the simulator window, in pixels. The
		   default is 512*512. Note that the entire world - no more, no
		   less - is always shown. Scaling is applied (though not to
		   any imagery) to make this possible. Also be aware that
		   everything in the simulation is considered to be a point; ie.
		   the size of an object's sprite (ie. its graphics imagery) is
		   not necessarily its "true" size.

    TURBO=ON|OFF:
           Whether you want turbo mode (ie. unlimited speed). The default
           is OFF.

    WORLDWIDTH=<number>:
    WORLDHEIGHT=<number>:
           The width and height of the world, in meters. The default is
		   100m*100m.

Typing:

    CODEWAR ?

will display the available CLI parameters.
@endnode

@node Refe "API Reference"

Deprecated functions (eg. cw_register_network_program() and the channel
functions) are undocumented.

CodeWar provides an extensive set of commands for robots. Only the most
interesting ones are currently fully documented; the rest should be self-
explanatory (see also codewars.h).

Directions and angles are expressed in degrees, with the origin pointing
east, as follows:

           N           Coordinates are expressed in metres, with the
          270°         origin at the top left of the world.
           |
    W 180°-+-000° E
           |
          090°
           S

The cw_#?_d functions are the same as the corresponding cw_#? functions,
except that their arguments and return codes are double precision floating
point values, instead of single precision. The internal precision of the
CodeWar simulator is the same in either case; only the API is different.
Functions where a _d version is available are marked with '*'.

@{b}Initialisation@{ub}

Routines which are required for robot initialisation.

 @{"cw_register_program()" link cw_register_program}     Initialises robot and sets up a connection
                            to the simulator.
@{b}Movement@{ub}

Routines which control and provide status on the position of the robot.

*@{"cw_get_acceleration()" link cw_get_acceleration}     Returns the robot's acceleration.
*@{"cw_get_velocity()" link cw_get_velocity}         Returns the robot's velocity.
 @{"cw_halt()" link cw_halt}                 Halts the robot instantly.
*@{"cw_power()" link cw_power}                Accelerates the robot in the specified
                            direction.
*@{"cw_teleport()" link cw_teleport}             Teleports the robot.
*@{"cw_turn()" link cw_turn}                 Turns the robot instantly.

@{b}Weaponry@{ub}

Routines to launch all types of weapon and provide feedback on the
amounts of each that are left.

*@{"cw_atomic()" link cw_atomic}               Fires an atomic.
*@{"cw_bomb()" link cw_bomb}                 Fires a bomb.
*@{"cw_cannon()" link cw_cannon}               Fires a cannon.
*@{"cw_missile()" link cw_missile}              Fires a missile.
 @{"cw_get_atomics()" link cw_get_atomics}          Ascertains quantity of atomics left.
 @{"cw_get_bombs()" link cw_get_bombs}            Ascertains quantity of bombs left.
 @{"cw_get_cannons()" link cw_get_cannons}          Ascertains quantity of cannons left.
 @{"cw_get_missiles()" link cw_get_missiles}         Ascertains quantity of missiles left.

@{b}Status@{ub}

Routines to give status on the condition of the robot itself.

 @{"cw_get_damage()" link cw_get_damage}           Determines the current damage on the robot.
 @{"cw_get_damage_max()" link cw_get_damage_max}       Determines the maximum damage.
 @{"cw_get_energy()" link cw_get_energy}           Determines the current energy level.
 @{"cw_get_mass()" link cw_get_mass}             Determines the mass of the robot.
 @{"cw_get_shields()" link cw_get_shields}          Determines the current state of the shields.

@{b}Environment@{ub}

Routines relating to the state of the world.

*@{"cw_get_position()" link cw_get_position}         Ascertains the position of the robot.
*@{"cw_scan()" link cw_scan}                 Scans a region of the world for enemy robots.

@{b}Simulator@{ub}

Lower-level functions ascertaining properties of the simulator.

 @{"cw_get_boundary_type()" link cw_get_boundary_type}    Ascertains the boundary type.
*@{"cw_get_elapsed_time()" link cw_get_elapsed_time}     Ascertains the total elapsed time that the
                            simulator has been running.
*@{"cw_get_field_limits()" link cw_get_field_limits}     Ascertains the size of the world.
*@{"cw_get_time_interval()" link cw_get_time_interval}    Ascertains minimum simulator time interval.
*@{"cw_get_version()" link cw_get_version}          Ascertains simulator version.
 @{"cw_get_xcraft_force()" link cw_get_xcraft_force}     Ascertains robots' maximum force.

@{b}Miscellaneous@{ub}

Routines which do not fit into any of the above categories.

 @{"cw_boost_shields()" link cw_boost_shields}        Transfers energy to shields.
 @{"cw_print_buffer()" link cw_print_buffer}         Writes passed-in buffer to the console
                            window.
@endnode

@node cw_atomic "cw_atomic()"

/****** cw_atomic *************************************************************
*
*   NAME
*   cw_atomic -- fires an atomic.
*
*   SYNOPSIS
*   void cw_atomic(float velocity, float direction, float detonate);
*   void cw_atomic_d(double velocity, double direction, double detonate);
*
*   FUNCTION
*   Launches an atomic weapon.
*
*   INPUTS
*   velocity  - velocity of the weapon, in metres per second
*   direction - direction in which to launch, in degrees
*   detonate  - how long to wait before detonation, in seconds
*
*   RESULT
*   None
*/
@endnode

@node cw_bomb "cw_bomb()"

/****** cw_bomb ***************************************************************
*
*   NAME
*   cw_bomb -- fires a bomb.
*
*   SYNOPSIS
*   void cw_bomb(float detonate);
*   void cw_bomb_d(double detonate);
*
*   FUNCTION
*   Launches a bomb.
*     The velocity and direction of the bomb are equal to your robot's
*   velocity and direction at the time of launching.
*
*   INPUTS
*   detonate - how long to wait before detonation, in seconds
*
*   RESULT
*   None
*/
@endnode

@node cw_cannon "cw_cannon()"

/****** cw_cannon *************************************************************
*
*   NAME
*   cw_cannon -- fires a cannon.
*
*   SYNOPSIS
*   void cw_cannon(float velocity, float direction, float detonate);
*   void cw_cannon_d(double velocity, double direction, double detonate);
*
*   FUNCTION
*   Fires a cannon.
*
*   INPUTS
*   velocity  - velocity of the weapon, in metres per second
*   direction - direction in which to launch, in degrees
*   detonate  - how long to wait before detonation, in seconds
*
*   RESULT
*   None
*/
@endnode

@node cw_get_acceleration "cw_get_acceleration()"

/****** cw_get_acceleration ***************************************************
*
*   NAME
*   cw_get_acceleration -- returns the actual acceleration of the robot.
*
*   SYNOPSIS
*   float cw_get_acceleration(float* x, float* y);
*   double cw_get_acceleration_d(double* x, double* y);
*
*   INPUTS
*   x - address of where to store the X-axis acceleration.
*   y - address of where to store the Y-axis acceleration.
*
*   FUNCTION
*   cw_get_acceleration() writes into its two arguments the current actual
*   x and y acceleration of the robot.
*
*   RESULT
*   The actual acceleration of the robot is returned.
*/
@endnode

@node cw_get_atomics "cw_get_atomics()"

/****** cw_get_atomics ********************************************************
*
*   NAME
*   cw_get_atomics -- ascertains quantity of atomics left.
*
*   SYNOPSIS
*   int cw_get_atomics(void);
*
*   INPUTS
*   None
*
*   FUNCTION
*   cw_get_atomics() returns the quantity of atomics left.
*
*   RESULT
*   The current quantity of atomics left.
*/
@endnode

@node cw_get_bombs "cw_get_bombs()"

/****** cw_get_bombs **********************************************************
*
*   NAME
*   cw_get_bombs -- ascertains quantity of bombs left.
*
*   SYNOPSIS
*   int cw_get_bombs(void);
*
*   INPUTS
*   None
*
*   FUNCTION
*   cw_get_bombs() returns the quantity of bombs left.
*
*   RESULT
*   The current quantity of bombs left.
*/
@endnode

@node cw_get_boundary_type "cw_get_boundary_type()"

/****** cw_get_boundary_type **************************************************
*
*   NAME
*   cw_get_boundary_type -- ascertains the boundary type.
*
*   SYNOPSIS
*   int cw_get_boundary_type(void);
*
*   INPUTS
*   None
*
*   FUNCTION
*   cw_get_boundary_type() returns the type of boundary for this world.
*
*   RESULT
*   The boundary type. The currently defined boundary types are:
*
*       1: rubber
*       2: stone
*       3: abyss
*       4: twilight
*/
@endnode

@node cw_get_cannons "cw_get_cannons()"

/****** cw_get_cannons ********************************************************
*
*   NAME
*   cw_get_cannons -- ascertains quantity of cannons left.
*
*   SYNOPSIS
*   int cw_get_cannons(void);
*
*   INPUTS
*   None
*
*   FUNCTION
*   cw_get_cannons() returns the quantity of cannons left.
*
*   RESULT
*   The current quantity of cannons left.
*/
@endnode

@node cw_get_damage "cw_get_damage()"

/****** cw_get_damage *********************************************************
*
*   NAME
*   cw_get_damage - determines the current damage on the robot.
*
*   SYNOPSIS
*   int cw_get_damage(void);
*
*   INPUTS
*   None
*
*   FUNCTION
*   cw_get_damage() returns the current damage on the robot.
*
*   RESULT
*   The current damage on the robot.
*/
@endnode

@node cw_get_damage_max "cw_get_damage_max()"

/****** cw_get_damage *********************************************************
*
*   NAME
*   cw_get_damage_max - determines the maximum damage. (V1.61)
*
*   SYNOPSIS
*   int cw_get_damage_max(void);
*
*   INPUTS
*   None
*
*   FUNCTION
*   cw_get_damage_max() returns the maximum damage, ie. the damage level
*   that will kill the robot. (This is normally 100, but can be changed by
*   the user via the DAMAGE CLI argument.)
*
*   RESULT
*   The maximum damage.
*/
@endnode

@node cw_get_elapsed_time "cw_get_elapsed_time()"

/****** cw_get_elapsed_time ***************************************************
*
*   NAME
*   cw_get_elapsed_time -- ascertains the total elapsed time that the
*                          simulator has been running.
*
*   SYNOPSIS
*   float cw_get_elapsed_time(void);
*   double cw_get_elapsed_time_d(void);
*
*   INPUTS
*   None
*
*   FUNCTION
*   cw_get_elapsed_time() returns the total elapsed time that the
*   simulator has been running.
*
*   RESULT
*   Elapsed time, in seconds.
*/
@endnode

@node cw_get_energy "cw_get_energy()"

/****** cw_get_damage *********************************************************
*
*   NAME
*   cw_get_damage - determines the current energy level.
*
*   SYNOPSIS
*   int cw_get_energy(void);
*
*   INPUTS
*   None
*
*   FUNCTION
*   cw_get_energy() returns the current energy level of the robot.
*
*   RESULT
*   The current energy level of the robot.
*/
@endnode

@node cw_get_field_limits "cw_get_field_limits()"

/****** cw_get_field_limits ***************************************************
*
*   NAME
*   cw_get_field_limits -- ascertains the size of the world.
*
*   SYNOPSIS
*   float cw_get_field_limits(float* x_axis, float* y_axis);
*   double cw_get_field_limits_d(double* x_axis, double* y_axis);
*
*   INPUTS
*   x_axis - address of where to store the X-axis dimension.
*   y_axis - address of where to store the Y-axis dimension.
*
*   FUNCTION
*   cw_get_field_limits() writes into its two arguments the size of the
*   world (ie. the playfield), in metres.
*
*   RESULT
*   None
*/
@endnode

@node cw_get_mass "cw_get_mass()"

/****** cw_get_mass ***********************************************************
*
*   NAME
*   cw_get_mass - determines the mass of the robot.
*
*   SYNOPSIS
*   int cw_get_mass(void);
*
*   INPUTS
*   None
*
*   FUNCTION
*   cw_get_energy() returns the mass of the robot.
*
*   RESULT
*   The mass of the robot, in kilograms.
*/
@endnode

@node cw_get_missiles "cw_get_missiles()"

/****** cw_get_missiles *******************************************************
*
*   NAME
*   cw_get_missiles -- ascertains quantity of missiles left.
*
*   SYNOPSIS
*   int cw_get_missiles(void);
*
*   INPUTS
*   None
*
*   FUNCTION
*   cw_get_missiles() returns the quantity of missiles left.
*
*   RESULT
*   The current quantity of missiles left.
*/
@endnode

@node cw_get_position "cw_get_position()"

/****** cw_get_position *******************************************************
*
*   NAME
*   cw_get_position -- returns the x and y coordinates of the robot.
*
*   SYNOPSIS
*   void cw_get_position(long* x, long* y);
*
*   INPUTS
*   x - address of where to store the X-axis position.
*   y - address of where to store the Y-axis position.
*
*   FUNCTION
*   cw_get_position() writes into its two arguments the current x and y
*   coordinates of the robot. The x and y values correspond to the
*   column and row positions accordingly. The robot can obtain the
*   maximum battlefield size by a call to @{"cw_get_field_limits()" link cw_get_field_limits}.
*
*   RESULT
*   None
*
*   SEE ALSO
*   @{"cw_get_field_limits()" link cw_get_field_limits}
*/
@endnode

@node cw_get_shields "cw_get_shields()"

/****** cw_get_shields ********************************************************
*
*   NAME
*   cw_get_shields - Determines the current state of the shields.
*
*   SYNOPSIS
*   int cw_get_shields(void);
*
*   INPUTS
*   None
*
*   FUNCTION
*   cw_get_shields() returns the current state of the shields.
*
*   RESULT
*   The current level of shielding.
*/
@endnode

@node cw_get_time_interval "cw_get_time_interval()"

/****** cw_get_time_interval **************************************************
*
*   NAME
*   cw_get_time_interval -- ascertains minimum simulator time interval.
*
*   SYNOPSIS
*   float cw_get_time_interval(void);
*   double cw_get_time_interval_d(void);
*
*   INPUTS
*   None
*
*   FUNCTION
*   cw_get_time_interval() returns the minimum simulator time interval.
*
*   RESULT
*   The minimum simulator time interval, in seconds.
*/
@endnode

@node cw_get_velocity "cw_get_velocity()"

/****** cw_get_velocity *******************************************************
*
*   NAME
*   cw_get_velocity() -- gets the robot's velocity.
*
*   SYNOPSIS
*   float cw_get_velocity(float* x, float* y);
*   double cw_get_velocity(double* x, double* y);
*
*   INPUTS
*   x - address of where to store the X-axis velocity.
*   y - address of where to store the Y-axis velocity.
*
*   FUNCTION
*   Gets the robot's velocity. From the x and y variables, you can derive
*   the robot's heading direction mathematically.
*
*   RESULT
*   The velocity of the robot is returned.
*/
@endnode

@node cw_get_version "cw_get_version()"

/****** cw_get_version ********************************************************
*
*   NAME
*   cw_get_version -- returns the version of the CodeWar simulator. (V1.0)
*
*   SYNOPSIS
*   float cw_get_version(void);
*   double cw_get_version_d(void);
*
*   FUNCTION
*   The intended use of this is to enable robots to operate sensibly on
*   various versions of the simulator. Eg. if a new "grenade" weapon were
*   to be added for V2.0, a call to cw_get_version() could be made by the
*   robot, and if V2.0 or later were to be detected, a call to
*   cw_grenade() could then be made. Such a robot would also compile and
*   run without problems under V1.x.
*
*   RESULT
*   The version number of the simulator is returned.
*
*   NOTES
*   This function is unavailable under CodeWar 0.x.
*/
@endnode

@node cw_get_xcraft_force "cw_get_xcraft_force()"

/****** cw_get_xcraft_force ***************************************************
*
*   NAME
*   cw_get_xcraft_force -- ascertains robots' maximum force.
*
*   SYNOPSIS
*   int cw_get_xcraft_force(void);
*
*   INPUTS
*   None
*
*   FUNCTION
*   cw_get_xcraft_force() returns the maximum force which a robot can be
*   subjected to.
*
*   RESULT
*   Maximum force, in newtons.
*/
@endnode

@node cw_halt "cw_halt()"

/****** cw_halt() *************************************************************
*
*   NAME
*   cw_halt -- halts the robot instantly. (V1.5)
*
*   SYNOPSIS
*   void cw_halt(void);
*
*   FUNCTION
*   Halts the robot and sets acceleration to zero.
*     This costs 1 point of energy.
*
*   RESULT
*   None
*/
@endnode

@node cw_missile "cw_missile()"

/****** cw_missile ************************************************************
*
*   NAME
*   cw_missile -- fires a missile.
*
*   SYNOPSIS
*   void cw_missile(float velocity, float direction, float detonate);
*   void cw_missile_d(double velocity, double direction, double detonate);
*
*   FUNCTION
*   Fires a missile.
*
*   INPUTS
*   velocity  - velocity of the weapon, in metres per second
*   direction - direction in which to launch, in degrees
*   detonate  - how long to wait before detonation, in seconds
*
*   RESULT
*   None
*/
@endnode

@node cw_power "cw_power()"

/****** cw_power() ************************************************************
*
*   NAME
*   cw_power -- adjusts the robot's velocity and heading.
*
*   SYNOPSIS
*   void cw_power(float acceleration, float direction);
*   void cw_power_d(double acceleration, double direction);
*
*   FUNCTION
*   Adjusts the current engine settings.
*
*   RESULT
*   None
*/
@endnode

@node cw_boost_shields "cw_boost_shields()"

/****** cw_boost_shields ******************************************************
*
*   NAME
*   cw_boost_shields -- transfers energy to shields.
*
*   SYNOPSIS
*   void cw_boost_shields(int energy);
*
*   FUNCTION
*   The specified number of units of energy (or all available energy,
*   if available energy is less than specified) are subtracted from the
*   robot's energy store and added to the shield.
*     You cannot charge shields up above 100 points; the excess energy
*   will be wasted in this case.
*/
@endnode

@node cw_print_buffer "cw_print_buffer()"

/****** cw_print_buffer *******************************************************
*
*   NAME
*   cw_print_buffer -- displays text in the robot's status window.
*
*   SYNOPSIS
*   void cw_print_buffer(char* buffer);
*
*   FUNCTION
*   Each robot is given a display space in its status window by the
*   CodeWar simulator which they may use to output text. The
*   cw_print_buffer() function modifies the message being displayed.
*     This function is primarily used to give a robot character, or for
*   debug display during development of a robot.
*/
@endnode

@node cw_register_program "cw_register_program()"

/****** cw_register_program ***************************************************
*
*   NAME
*   cw_register_program -- register robot with CodeWar simulator.
*
*   SYNOPSIS
*   int cw_register_program(char* name);
*
*   FUNCTION
*   The cw_register_program() call initiates your robot's connection with
*   the CodeWar simulator. Multiple instances of the same program may be
*   started.
*     The CodeWar simulator needs to be already running, otherwise your
*   robot will be unable to compete.
*     Your robot program will be automatically killed off by the simulator
*   when it dies.
*
*   ARGUMENTS
*   name - a robot name of up to 254 characters.
*
*   RETURN VALUE
*     A value of TRUE is returned on successful connection to the CodeWar
*   server, FALSE if not.
*/
@endnode

@node cw_scan "cw_scan()"

/****** cw_scan() *************************************************************
*
*   NAME
*   cw_scan -- scans a region of the world for enemy robots.
*
*   SYNOPSIS
*   float cw_scan(float direction, float precision);
*   float cw_scan_d(double direction, double precision);
*
*   FUNCTION
*   Returns the range in meters to the nearest robot in the specified
*   direction. The scanned area is an arc (cone) originating from the
*   robot. You can visualize this as the two "arms" on the robot
*   extending out to infinity.
*
*   INPUTS
*   direction - direction of the scan, in degrees.
*   precision - error margin of the scan, in degrees. Robots at +/- this
*               value away from the exact scan angle will be seen.
*
*   RESULT
*   The range in metres to the nearest detected robot, or -1.0 if nothing
*   was found.
*/
@endnode

@node cw_teleport "cw_teleport()"

/****** cw_teleport() *************************************************************
*
*   NAME
*   cw_teleport -- teleports the robot instantly. (V1.6)
*
*   SYNOPSIS
*   void cw_teleport(float x, float y);
*   void cw_teleport_d(double x, double y);
*
*   FUNCTION
*     Instantly repositions the robot to the specified coordinates. This
*   costs 3 points of energy.
*     If x and y are both -1.0, the robot will "hyperspace" (ie. teleport
*   to a random location). This only costs 2 points of energy.
*
*   INPUTS
*   x - desired X-position of robot. This is absolute (eg. world-relative,
*       not robot-relative). -1.0 means hyperspace.
*   y - desired Y-position of robot. This is absolute (eg. world-relative,
*       not robot-relative). -1.0 means hyperspace.
*
*   RESULT
*   None
*/
@endnode

@node cw_turn "cw_turn()"

/****** cw_turn() *************************************************************
*
*   NAME
*   cw_turn -- turns the robot instantly. (V1.5)
*
*   SYNOPSIS
*   void cw_turn(float direction);
*   void cw_turn_d(double direction);
*
*   FUNCTION
*   Turns the robot to the specified direction. The magnitude of the
*   robot's velocity and acceleration remain constant but their
*   direction is changed.
*     This costs 2 points of energy.
*
*   INPUTS
*   direction - direction of movement, in degrees. This is an absolute
*   direction (ie. not relative to the current heading of the robot).
*
*   RESULT
*   None
*/
@endnode

@node Cred "Credits and Licence"

@{b}CREDITS AND LICENCE-------------------------------------------------------@{ub}

@{b}Credits@{ub}

CodeWar V0.x were written by Rhett Jacobs for Linux in 1995-1997.
This was ported and enhanced by James Jacobs of Amigan Software in 2008-
2017 to create the ports to other platforms.
  The MorphOS port was compiled by Stefan Haubenthal.

@{b}EMail:@{ub}                  amigansoftware\@gmail.com
                        rhett.jacobs\@gmail.com

@{b}Amiga Developer Number:@{ub} AD874

@{b}Websites:@{ub}               http://amigan.1emu.net/releases/
                        http://sunsite.unc.edu/

@{b}Licence@{ub}

CodeWar is open source freeware. These are the licence conditions:

    * you are not allowed to sell it, or modified versions of it, without
      consent (however, magazine covermounting is permitted);

    * any modified versions must be clearly marked as such, and not be
      misrepresented as being the original software;

    * you are not allowed to claim you wrote this software, or to remove
      or alter the existing credits (though you may append to them as
      appropriate);

    * you may distribute this unmodified executable either with or without
      the source code, at your discretion. (The official release packages
      will always include source code.) However, modified versions
      (including ports) must include both the executable and source code;

    * software into which code or algorithms are copied must be open
      source, and appropriate credit must be given;

    * you must allow us the right to backport improvements you make to
      this software or algorithms;

    * you are not allowed to modify the software to deliberately insert
      logic bombs, spyware, digital restrictions management, copy
      protection, online activation, virii or other malware;

    * any package or compilation of which this software forms a part must
      be entirely free of logic bombs, spyware, digital restrictions
      management, copy protection, online activation and other malware;
      and

    * there is no warranty on this software.

Note that obviously the above applies only to the CodeWar simulator. We do
not seek to impose any restrictions or requirements whatsoever on user-
written robots, of course.

If you would like to become an official co-developer of this simulator,
please contact us. Ports of this simulator to other platforms are
welcomed.

@{b}Bugs@{ub}

Please contact us immediately if any bugs are found. Please do not assume
that the bug has already been reported by another user; this is most
unlikely. We always investigate and (attempt to) fix any and all bugs
reported, and will keep you appraised of the status of the bug report.
  Also, game playability (eg. balance and fairness) issues are considered
to be important.

@{b}Future@{ub}

There is almost limitless scope for expansion around the existing core
functionality. Suggestions are welcomed. However, to be honest CRobots is
probably better ;-) , now that it is open source enhancing it might be
wiser.

This software is in maintenance mode: bug fixes will be forthcoming
if necessary, but major new features are unlikely. It does not meet our
current standards of quality, and a complete rewrite would probably be
best, but has been judged not worth doing in this case. If you would
like to take over, please email us.

@{b}Source code@{ub}

Source code for SAS/C 6.59 (OS3 version), GNU/C (OS4 and MorphOS versions)
and Microfilth Visual C++ 6.0SP6 (Windows version) is provided.
@endnode

@node Rele "Other Releases"

@{b}AmiArcadia/WinArcadia@{ub} (AmigaOS 3, AmigaOS 4, MorphOS, Windows)

AmiArcadia and WinArcadia are multi-emulators of these machines:

    * the Emerson Arcadia 2001 console family (Bandai, Emerson,
      Grandstand, Intervision, Leisure-Vision, Leonardo, MPT-03, Ormatu,
      Palladium, Poppy, Robdajet, Tele-Fever, Tempest, Tryom, Tunix,
      etc.) (1982);
    * the Interton VC 4000 console family (Acetronic, Fountain, Hanimex,
      Interton, Prinztronic, Radofin, Rowtron, Voltmace, Waddington, etc.)
      (c. 1978);
    * the Elektor TV Games Computer (1979);
    * PIPBUG-based machines (EA 77up2, EA 78up5, Signetics Adaptable Board
      Computer, Eurocard 2650, etc.) (c. 1977-1978);
    * the Signetics Instructor 50 trainer (1978);
    * the Central Data 2650 computer (1977);
    * the Astro Wars, Galaxia, Laser Battle and Lazarian coin-ops by
      Zaccaria (1979-1981);
    * the Malzak 1 and 2 coin-ops by Kitronix (c. 1980);
    * the Chaos 2 computer (1983);
    * the Dolphin trainer (1977);
    * the PHUNSY computer (c. 1980);
    * AY-3-8550/8600-based Pong systems (c. 1976-1977);
    * the Ravensburger Selbstbaucomputer aka 2650 Minimal Computer trainer
      (1984); and
    * the MIKIT 2650 trainer (1978).

Features include: ReAction GUI, load/save snapshots, windowed and full-
screen modes, CPU tracing, trainer, drag and drop support, graphics
scaling, automatic load/save of configuration/game, keyboard/joystick/
gamepad/paddle/mouse/trackball support, autofire, turbo mode, gameplay
recording/playback, PAL/NTSC modes, sprite demultiplexing, help windows,
source code, debugger, frame skipping, redefinable keys, save screenshots
(4 supported formats), ARexx port, network play, real-time monitor, locale
support, game selection sidebar, text-to-speech, printer output,
undithering, support for ZIPped games, clipboard support, palette editor,
tone retuning, high score management, force feedback, sprite editor, 3D,
assembler, CALM support.

The supported languages are currently English, Dutch, French, German,
Greek, Italian, Russian and Spanish.

@{b}Super Bug Advance@{ub} (GBA)

This is a port of a subset of the Ami/WinArcadia 11.71 emulator to the
Nintendo Game Boy Advance platform, for the purpose of emulating the
Super Bug 1 and 2 and Capture games.

@{b}Worm Wars@{ub} (Windows, AmigaOS 2-3, AmigaOS 4, MorphOS, GBA)

Worm Wars is an advanced Tron/Snake-style arcade game for up to 4
simultaneous players.

There are 36 types of creature, 36 types of object, and 12 types of bonus
level. The integral level editor allows you to load, edit and save user
levelsets. There is support for playing MED and IFF 8SVX files as music
and sound effects respectively.

It is can be played by one player, or as a competitive multiplayer
game, and demo mode is available. Amiga or human control can be specified
for any worm. Two keyboard players, four joystick players, and/or four
CD32 gamepad players are supported. It is system-friendly, style
compliant and screenmode-sensitive.

The supported languages are currently English, German, Greek, Italian and
Spanish.

@{b}Report+@{ub} (AmigaOS 3, AmigaOS 4, MorphOS)

Report+ is a freeware ReAction-based utility with nine functions:

 1. It is an enhanced, reverse-engineered, 100% byte-compatible
    replacement for the official Commodore bug reporting tool (40.2),
    optionally sending emails automatically.
 2. It can generate/edit Aminet-style readmes.
 3. It can edit A3000/A4000-type battery-backed memory.
 4. It can access the official manufacturer and product ID registries.
 5. It can view IFF/RIFF files and their component chunks.
 6. It can perform batch processing on icons.
 7. It can convert between various ASCII formats.
 8. It can show directory byte usage for any path, optionally also
    fixing protection bits and/or deleting files.
 9. It can take a snapshot of a path and later compare the
    path against this, showing added, missing and changed files.

@{b}Multi-game Character Editor@{ub} (AmigaOS 3, AmigaOS 4, MorphOS)

MCE (Multi-game Character Editor) is a user-friendly editor of character
files, saved games and high score tables for these 68 games:

    * Bard's Tale 1-3 & Construction Set (1987-1992)
    * BattleTech (1989)
    * Bloodwych (1989)
    * Chambers of Shaolin (1989)
    * Champions of Krynn 1 & 3 (1990-1992)
    * Citadel of Vras (1989)
    * Dark Castle (1988)
    * Deja Vu 1 & 2 (1986-1989)
    * Demon's Winter (1989)
    * Dragon Wars (1990)
    * Druid 2 (1988)
    * Eye of the Beholder 1 & 2 (1990-1992)
    * Faery Tale Adventure (1986)
    * Grand Monster Slam (1989)
    * Great Giana Sisters/Hard 'n' Heavy (1988-1989)
    * GridStart 1-3 (1987-1988)
    * Heroes of the Lance (1988)
    * Hillsfar (1989)
    * Impossible Mission 2 (1988)
    * Keef the Thief (1989)
    * Last Ninja Remix (1990)
    * Legend of Faerghail (1990)
    * Legend of Lothian (1991)
    * Mercenary: Escape from Targ & The Second City (1986)
    * Might & Magic 2 & 3 (1990-1992)
    * Neuromancer (1989)
    * Nitro (1990)
    * Panza Kickboxing 1 & 2 (1990-1992)
    * Phantasie 1 & 3 (1987)
    * Pinball Dreams/Fantasies/Illusions (1992-1995)
    * Pirates! (1990)
    * Pool of Radiance (1990)
    * Questron 2 (1988)
    * Return of the Jedi (1988)
    * Rockford (1988)
    * Rogue (1986)
    * Shadowgate (1987)
    * Shadowlands (1992)
    * Sinbad and the Throne of the Falcon (1987)
    * Slaygon (1987)
    * Syndicate (1993)
    * Temple of Apshai (1986)
    * Times of Lore (1988)
    * Transylvania 1 & 2 (1986)
    * Ultima 3-6 (1986-1992)
    * Uninvited (1987)
    * Winter Games (1987)
    * Wizardry 6 (1990)
    * World Games (1987)
    * Zerg (1989)

@{b}Tunnels & Trolls@{ub} (Windows, AmigaOS 3)

This is an implementation of the Tunnels & Trolls game (5th Edition), in
its solitaire form, consisting of the game engine and 27 adventures. It
allows you to play the adventures without pen, paper, dice, cards, nor the
adventures themselves. The complete T&T rulebook will prove handy but is
not essential.
  The included adventures are:

    * Abyss
    * Amulet of the Salkti
    * Arena of Khazan
    * Beyond the Silvered Pane
    * Blue Frog Tavern
    * Buffalo Castle
    * Captif d'Yvoire
    * Caravan to Tiern
    * Castle Ward
    * Circle of Ice
    * City of Terrors
    * Dargon's Dungeon
    * Deathtrap Equalizer
    * Gamesmen of Kasar
    * Goblin Lake
    * Hela's House of Dark Delights
    * Labyrinth
    * Mistywood
    * Naked Doom
    * Overkill
    * Red Circle
    * Sewers of Oblivion
    * Sorcerer Solitaire
    * Sword for Hire
    * Trollstone Caverns
    * Weirdworld

@{b}Other Releases@{ub} (Windows, AmigaOS 3, AmigaOS 4, MorphOS, GBA)

See http://amigan.1emu.net/releases/#others
@endnode

@node Hist "History"

@{b}HISTORY-------------------------------------------------------------------@{ub}

1.65         [Windows][OS3.9+][MOS?   ][OS4.0+]: Sun 10 Sep 2017.
    Summary:
        * Miscellaneous improvements and bug fixes.
    Details:
 mos: changed ship.mos script to work around a GCC bug.
 removed separator between "iconify" and "quit" on File/Project and
  system menus, and between "uniconify" and "exit" on tray menus.
 amiga: set the script bit for all scripts.
 amiga: removed amiupdate support.
 amiga: no longer uses HunkShort.
 ibm: fixed: iconification/uniconification didn't always work properly.
 amiga: added more keyboard shortcuts.
 amiga: replaced drawer icons.
 ibm: fixed: sample playback was playing the header as well as the body.
 amiga: about window now detects os4.1fe and os4.1feu1.
 os4: now build is fully optimized.
 os4.1fe: now uses BOOPSI menus (with imagery).
 os4: fixed: application.library messages were being ignored.
 amiga: added splash screen.
 os4: fixed: logo was being drawn in the wrong colours.
 amiga: now problems with eg. allocating sound channels are non-fatal.
 amiga: added some more keyboard shortcuts for menu items.
 os4: no longer has group labels (to work around an os4 bug).
 amiga: help key (when no gadget is active) now brings up the manual.
 improved bouncing algorithm.
 now emits a sound effect when robots bounce.
 amiga: now disallows resizing of the window (to work around a ReAction
  bug).
 ibm: fixed broken zatof() function.

1.64         [Windows]                         : Sat 14 Mar 2015.
1.63         [Windows][OS3.9+][MorphOS][OS4.0+]: Mon 16 Feb 2015.
1.62         [Windows][OS3.9+][MorphOS][OS4.0+]: Sat 31 May 2014.
1.61         [Windows][OS3.9+][MorphOS][OS4.0+]: Sat 22 May 2014.
1.6          [Windows][OS3.9+][MorphOS][OS4.0+]: Tue 13 May 2014.
1.5          [Windows][OS3.9+][MorphOS][OS4.0+]: Fri  2 May 2014.
1.41         [Windows][OS3.9+][MorphOS][OS4.0+]: Wed 15 Aug 2012.
1.4          [Windows][OS3.9+][MorphOS][OS4.0+]: Fri 20 Apr 2012.
1.3          [Windows][OS3.9+][MorphOS][OS4.0+]: Tue 13 Mar 2012.
1.24                  [OS3.9+][MorphOS][OS4.0+]: Fri  2 Mar 2012.
1.23         [Windows][OS3.9+][MorphOS]:         Wed 29 Feb 2012.
1.22a        [Windows]:                          Fri 22 Jul 2011.
1.22         [Windows]:                          Fri 12 Nov 2010.
1.21         [Windows]:                          Mon 13 Sep 2010.
1.2          [Windows]:                          Mon 16 Mar 2009.
1.12         [Windows]:                          Fri  6 Mar 2009.
1.11         [Windows]:                          Mon 15 Dec 2008.
1.1          [Windows]:                          Mon  1 Dec 2008.
1.0          [Windows]:                          Thu 27 Nov 2008.

0.4   [Linux]:                                   Fri 14 Mar 1997.
0.3   [Linux]:                                   ??? ?? ??? 199?.
0.2   [Linux]:                                   ??? ?? ??? 199?.
0.1   [Linux]:                                   ??? ?? ??? 199?.
0.0   [Linux]:                                   ??? ?? ??? 1995.
@endnode
