
            Level Editor



Overview

     In this section, I will briefly describe and explain the functions
that I want the Level Editor program to perform, and how these will link
together to form the final program.  The screen designs of all the screens
mentioned below will appear in a later section.


Main Menu

     The main menu will be the screen where most of the functions of the
program will be accessed from.  It will be split into two main parts: one
that will be concerned with the stage parameters (e.g. the game and stage
numbers, the password for the stage, etc.) and the level parameters (e.g.
the level number, time limit for the level, the error list, level comment,
and options to edit and test the level).

     The game and stage numbers may be altered on this screen, as can the
password for the stage.  This will be done simply by letting the user
click on the boxes containing the numbers (or password), and typing in the
new number or word.  There are problems with this: the user could has no
way of knowing which games and stages exist, what order they are in, or
what the other passwords are.  For this reason, the user will be able to
access another screen that will allow them to choose the game and stage
from a list.  This will be covered in more detail later.  However, being
able to just type in the numbers will help the experienced user to save
some time.

     The chosen stage can also be loaded and saved from the main menu. 
There will be only one stage held in memory at a time: to edit another,
the user must save their current stage, change the number, and load in the
new stage.  Loading in a new stage will erase the previous one from
memory.

     The level number (1-5) can be selected from the main menu.  The
chosen time limit for the selected level will be displayed, and will be
able to be edited.  There will be three more options that can be selected
that pertain to the selected level:  Edit Level, which will take the user
to the screen that will allow them to alter the level; Test Level, which
will allow them to manually test the selected level as they would play it
in the game; and Edit Comment, which will allow the user to change the
comment that will be displayed before the level is played.

     There will also be the option to test the stage for errors (obvious
errors made while creating a level, e.g. forgetting to include an Exit
tile, not connecting a teleport to a destination tile, and so on).  It
will test each level individually, and will place the results in a list
which the user can look through in his own time.

     The final option will be one allowing the user to quit the program.


Choose a stage

     This screen, as described above, will allow the user to select a game
and stage to either load or save to.  There will be two lists: one a list
of games, and the other a list of stages present in the game selected,
along with the passwords for each of them.  The screen will also provide
the user with a chance to edit the passwords for an entire game at a time,
without having to load and save each stage individually.

     There will also be a list of options available:  Create or Delete a
Game or Stage,  compress a game (i.e. renumber all the stage numbers so
they are sequential, starting from 0), validate the files for a game (the
files will be explained later), and options to actually load and save to a
particular stage number.


Edit Levels

     There will be 4 main sections to this screen.  Firstly, there will be
the status line.  This will show three pieces of information: messages to
the user (telling them what mode has been accessed, and so on), the
coordinates of where the mouse is when the map is being edited, and the
level number (which will be able to be changed on this screen as well as
the main menu).

     The second part of the screen will be the map itself: the display on
which the level can be altered.  A tile will be selected, and can then be
dragged over this display.  When the mouse button is pressed, a copy of
the tile will be placed on the map (if the right mouse button is pressed,
however, the tile under the pointer will be deleted.  This is in a similar
style to most art packages on the Amiga, and so most users should be
familiar with the convention).

     The third section is where the user will select the tile type he
wants.  It will consist of a display of all the tiles available, and a
pointer indicating which tile type is currently selected.  The fourth
section will be the "special options": these will consist of functions
allowing the user to connect a teleporter to another tile, selecting which
tile(s) will be affected by a switch, choosing the start position for the
player, clearing the level of tiles and returning to the main menu.


            >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



             Interface



Overview

     Possibly one of the most complex elements of the level editor that
will be programmed will be the interface.  It will be a graphical user
interface (GUI), as I find that these are usually the easiest to use, and
most potential users are familiar with this style of interface (it can't
really be called a WIMP interface as it contains no windows, icons or
menus).  In this section I will design how each of the interface elements
should work, and the interface will be used by the program itself.


Interface Elements:

1) Buttons

     These are simply "action" buttons.  When a user clicks on one, an
action will be performed.  They will have the look of being raised
slightly from the screen, by highlighting the left and top sides, and
darkening the lower and right hand sides.  They will contain text that
will indicate what pressing the button will do.

2) Input Boxes

     These will be boxes, containing text of some sort.  When the user
clicks on one of these, a cursor appears in the box and he can edit the
text, using cursor and editing keys.  There will be restrictions on what
type of character can be entered into a box (e.g. numbers only), and on
the length of text that can be entered.  This will not necessarily be the
same as the length of the box on-screen, as the text could be longer, and
scrolled left and right by the user.

3) Tick Boxes

     Tick boxes will be small square buttons, that can either be blank or
display a tick.  The presence or absence of a tick can be toggled by the
user (by them clicking on it, in much the same way as they would click on
a button).  The tick's presence will usually indicate that a particular
option has been turned on.

4) Radio Buttons

     Very similar to tick boxes, these instead represent a group of
options, of which only one can be selected.  By clicking on one button,
that button will be selected (ticked), and all the other buttons in the
group will be turned off.

5) Scroll lists

     These are lists of text items.  If there are too many items to
display in the list box, the user can scroll the list up or down to access
the others.  There are 3 ways in which the scrolling can be attained:
using the scroll bar, the user would click on this and drag it up or down;
the scroll buttons, two buttons (one up, one down) that, when clicked on,
will move the list up or down one item; and finally by selecting items. 
This final method is peculiar to Amiga: when selecting an item (i.e.
clicking on it to highlight it), if the mouse button is held down the list
can be moved up and down by moving the mouse above and below the list box.
 Items can be selected, and these are then highlighted.  Usually, they are
also copied into an input box, to let the user alter them.


Programming the interface

     Each gadget (interface element) in a particular interface will
require certain data to be known about it: e.g. it's contents, on-screen
position, size, and so on.  These data items will be stored in two arrays:
one for numerical data, the other for text.  The exact format for these
arrays should be found in the Maintenance Documentation.

     The data will first be read into the arrays (probably from Data
statements), and there will be a number of routines that the program could
use to interrogate and use the array.  There will be three basic functions

that will be needed when using the interface gadgets: initialise a gadget,
redraw a gadget, and update a gadget.

     Initialising a gadget will draw the gadget, and set a screen zone
around it.  A screen zone is simply an area of the screen set aside by
Amos, so that when the mouse is in that area, the "=Mouse Zone" function
will return the number of the screen zone.  It basically saves a lot of
trouble that just using screen coordinates to test which button the mouse
is over would cause.  Redrawing a gadget will completely redraw the button
again (as if it were initialised, but no screen zone is set).  Updating a
gadget would simply redraw the parts of a gadget that would be affected by
the data it holds being changed.

     Once an interface has been fully defined and initialised, the user
should be able to interact with it.  I plan to have an all-purpose routine
that could be called to let the user manipulate the interface, but would
end when the user finally pressed a button or changed some text.  The
routine would return the parameter of the gadget that had been changed or
pressed, whereupon a purpose-written routine for that particular interface
would act on that information (e.g. perform an action, change other
gadgets, and so on).


            >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



             Flowcharts



Overview

     This section will give an overall view of how the programs will run,
by showing the programs in terms of flowcharts.


            >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



          File Structures



Device

     All the files will be stored in a logical device called
"Cantaloupe:".  This will be assigned to a directory at the beginning of
each program, and will make it possible to store the game within other
directories than the root one.  It will be done using a line such as:

     Assign "Cantaloupe:" to Dir$

     Dir$ is an internal variable to Amos, and contains the path of the
current directory.  This path can from now on be referred to as
"Cantaloupe:".


Directory Structure

     Each game will be stored in a directory of it's own, in the "Games"
directory.  The directory name for each game will depend on the number of
the game.  For instance, the data for the game number 154 would be stored
in the directory:

     Cantaloupe:Games/154/

     They will be stored in the "Games" directory (rather than just
"Cantaloupe:"), so the directory access when the drawer is opened to
initially load the game or editor is not slowed down by having too many
files in.

     Only the game directories with any data to be stored in them will
need to exist, thus cutting down on the amount of data needed to be stored
on the disk.


Bitmaps

     To help speed up access to games and stages, I plan to use bitmaps. 
Rather than being pictures, these will be blocks of data that will
indicate whether certain stages or games exist or not.  These will be
loaded into memory as they are needed, and to check if a particular game
or stage exists, the data in memory will be tested rather than the actual
disk.  This should speed up data access considerably.


Stage Bitmaps

     Stage bitmaps will each be 100 bytes long, and there will be one for
each game.  A byte with a value of 1 in a position will mean that the
stage represented by that position exists.  For example, a 1 at position
45 will mean that stage 45 exists.  A nought will signify there being no
stage.

     Each stage bitmap will be saved with the following filename:

     Cantaloupe:Games/<game number>/Stage.Bmap




Game Bitmap

     The game bitmap will be 1000 bytes long.  Similar to the stage
bitmaps, the position of each byte in it will signify if a game exists or
not.  However, more information will be held in each byte.  The following
table should explain what the different numbers will mean:

0 - The game does not exist
1 - The game does exist, but has no stages in it.
2 - The game does exist, and has one stage in it.
3 - The game does exist, and has two stages in it.
4 - The game does exist, and has three stages in it.
...
101 - The game does exist, and has one hundred stages in it.

     As the maximum number of stages in a game is 100, the maximum number
that will be stored is 101, which is well below the limit imposed on bytes
(numbers in the range 0-255).

     The number of stages in each game is stored in each byte so that as
the game number is being chosen (on the options screen in the game), the
number of stages can be very quickly calculated and displayed for each
game selected.  This will give the player some idea of the size of each
game, and should help him choose the one he wanted.  There is also
provision for distinguishing between a game that does not exist, and one
that does but has no stages.


Bitmap Validation

     There will be an option in the level editor to "Validate files" for
the system.  This will check if all files are present, and if not then
create them.  It should also automatically recreate the stage bitmap for
the game being examined, and update the game bitmap.  It will recreate the
file by simply checking which files are present in the game directory.

     It will completely recreate the file, rather than just checking
through the existing one, because I suspect this will actually be quicker.
 In recreating the file, a block of memory will be reserved, each of the
stage files will be searched for in turn, and the bytes in memory will be
set accordingly.  This block of memory will then be saved to disk as the
stage bitmap.  However, to check the current bitmap, it would first be
loaded into memory, and then all the stages would be checked for, the
bytes would be checked and changed if necessary, and the block of memory
saved again.  The former method, therefore, would appear to be the more
sensible option as it has less stages and will execute quicker.


High Scores

     This file will contain all the data in the high score table.  There
will be options to save and load this table on the options screen of the
game.  As I have previously stated, there will be provision for a high
score table for each game to be stored.  The file will be stored as:

     Cantaloupe:Games/<game number>/Hiscores

     This will allow each game directory to have it's own high score
table.



High Score File Format

     When the high score file is accessed, ALL of it's contents will be
loaded into memory.  It will never be randomly accessed, single records
will never be extracted.  Therefore, it doesn't really matter how the data
is arranged in the file, just as long as it is all there and the routines
for loading and saving the data agree on the format.

     A strange quirk of Amos is the way it saves numerical data, which I
have noticed in previous projects.  Instead of saving it in a binary
format of 5 or 6 bytes as the Archimedes does, it saves the numbers in
ASCII format.  That is, if I wanted to save the number 1234 to a file, it
would save it as the string "1234".  This not only wastes space for larger
numbers, it also plays havoc with any file-handling techniques I might
want to use.

     I will therefore have to write my own routines that will convert
numbers to a binary format.  These will probably take advantage of the
fact that integers are stored in memory as four bytes, which are
accessible from Amos.

     The other data that will be stored in the file are the names and
highest stage numbers of each entry.  These will both be variable length
strings.  The maximum length of the name, as previously discussed, will
depend on which letters are in the name, and the width of each character
in the font.  The stage number will be stored in the format "2.3" (Stage 2
Level 3).  However, even if a name made entirely of "i"s was used ("i" is
usually the thinnest letter of any typeface), there would probably be no
more than 30-40 characters in it.

     The "Highest stage" data will be stored as a string because it is in
floating point format ("2.3"), and so it will be more accurately
represented in a string (there will only ever be one figure after the
decimal point), will take up less space (floating point numbers take 8
bytes to store), and no maths will be performed on it, so there is no
reason to store it as a number.

     The format for storing each string will be Length_Of_String, String
(i.e. the length of the string followed directly by the string).  It would
seem safe to assume that the length of the string can be stored as a byte
(i.e. a value 0-255), and the string itself would be stored in normal
ASCII directly after this.  The program will read in the length of the
string, and then read in the number of characters after this into a string
variable in the program.

     The actual format of the file will be as follows:

     1st Score               4 bytes
     2nd Score               4 bytes
     ...
     15th Score               4 bytes

     1st Name length               1 byte
     1st Name string               ?? characters
     1st "Highest stage" length          1 byte
     1st "Highest stage" string          ?? characters
     2nd Name length               1 byte
     ...
     15th "Highest stage" string     ?? characters



     This format will store all the necessary data, while hopefully
keeping the file length (and therefore storage capacity required) to a
minimum.

     All validation for the data in the file will be performed by the
program as the data is created (e.g. the length checks for the name, as
well as the allowable characters, will be checked as the data is being
entered).


Passwords

     All the passwords for each game will be stored in one file.  As each
game will have it's own set of passwords, it would make sense to keep the
passwords in the relevant game directory.  The file it will be stored as
will therefore be:

     Cantaloupe:Games/<game number>/Pass.dat

     The user will be able to decide whether to give a stage a password or
not.  If they don't, then the player will either have to play through the
entire previous stage to get to it, or use a password of a later stage. 
However, once the stage has been reached, the player will be allowed as
many goes of it as he wants, returning to the start of the stage when he
loses his lives (the loaded stage will stay in memory until it is either
completed, a valid password is entered, or the game number is changed).

     There is also the possibility that a particular stage will not exist.
 Therefore, a number of password entries will probably be empty.  Again,
to save storage space, I will only store those passwords that are not
empty.

     The length of passwords will also vary.  Their maximum length will
again be determined by the graphical length of the password (which will be
affected by which letters are in it).  A file format is needed, then, that
will hold a variable number of variable length passwords.

     Each password will have to be coupled with the stage number it is
for.  This will be adequately covered by using a byte to represent it:
stage numbers will range from 0-99, and a byte can hold values from 0-255.
 There will also need to be either a separator character, or a count of
the length of the password, so that separate passwords can be easily
distinguished.

     I have decided to use separator characters so that the searching for
passwords will be quicker.  I will explain why this is later.

     The file format will therefore be:

     <Separator>
     <Stage number>
     Password
     <Separator>
     <Stage number>
     ...
     <Separator>

     For example:

     <S> <0> Password nought <S> <5> Password five <S>

     (<S>: Separator  <n>: Stage n)



     When the passwords for a game are loaded, the whole file will be
loaded into memory (to lessen disk access).  To search for, say, the
password for stage 4, the program would look for the combination of the
separator and the stage number.  As the separator will be something like a
character with an ASCII value of zero, it will never occur in an actual
password (allowable ASCII values for a string are all above 31).  This
combination of characters will only occur, therefore, as a reference to a
following password, and never in a password itself.

     In a similar way to the high score data, all data will be checked on
entry (e.g. length of password and allowable characters), and so any
further validation checks would be a waste of time.


Encryption

     As it stands, anybody with access to a file viewing program could
simply view the password file, and find a list of passwords for the game. 
This should not be allowed, as it would encourage cheating and possibly
decrease the longevity of the game.

     To stop people looking at the file, I have decided to store it in
encrypted format.  It won't require anything elaborate, just a simple
two-way encryption method.  The following steps, applied to each byte,
should be more than enough protection:

- Invert all the bits
- "Roll" the bits to the left 3 times
- Add the file pointer position to it.  If this brings the number to more
than 255, then 256 will keep being subtracted until it is in the range
0-255.

     This will encrypt the data.  To retrieve the data, or decrypt it, the
above instructions would be executed in reverse order:

- Subtract the file pointer from the byte.  Add 256 until the number is in
the range 0-255.
- Roll the bits to the right 3 times
- Invert all the bytes

     For example, encrypting the byte 164 at position 75 in the file:

                         Byte     Bits
Original data                    164      10100100
Invert bits                    91      01011011
Roll left 3 times                    218      11011010
Add file position                    293     100100101
Subtract 256                    37      00100101


Stage File

     The stage file will contain all the data for a particular set of five
levels.  The stage number it represents will be determined by the name of
the file, and the game number by which directory it appears in.  The file
will therefore be stored as:

     Cantaloupe:Games/<game number>/<stage number>

     For example, the stage number 15 from game 23 will be stored as:

     Cantaloupe:Games/15/23

     The stage file will contain the following data:

- Actual level map data for each level
- Time limit for each level
- Comment for each level
- Player start position for each level
- Teleport data for every level
- Switch data for every level

     The file can therefore be thought of as a database, with five records
(the levels) and six fields (the categories above).  The following
summarises how the data is to be stored:

Start position: This will be represented as a single number (using the
alternative coordinate system described earlier).  The maximum value for
this number will be 227, and so can be represented by a byte.

Time limit: Stored in seconds, the maximum time limit for a level will be
999 seconds.  This means that a byte will be inadequate to store this.  I
will therefore use a word.  In Amiga terminology, a word is a number of 16
bits (even though the word length of the machine is 32 bits).  16 bits can
represent numbers in the range 0-65535, and so will be more than adequate
to store the time limit.  Amos provides easy ways to set and read ("poke"
and "peek") bytes and words, so no extra programming will be required.

Comment: This will obviously be a string.  The maximum length of the
string will again be determined by it's graphical length, rather than the
number of characters in it, due to a proportional-spaced font being used
to display it.  I have decided to store the string in ASCII, followed by a
terminator character (probably character code 0), for reasons of quick
access.  Amos provides a command whereby a string can be extracted from
memory until a specified terminator character is found.

Teleport and Switch data: These will be stored as strings for each level,
in a similar way to the comment.  The strings stored will simply be those
used as the dynamic arrays for the data in the program.

Map data: If stored as straight data, this would simply be a list of 228
bytes, each byte containing a number in the range 0-16.  Because I noticed
that each byte would only be roughly half used (5 bits out of eight), and
that quite a few levels would probably be mostly empty, I decided that the
data could be compressed.  This would again save storage space, one of my
main aims when I am designing these files.


Map Compression

     The compression technique I am planning to use is based on looking
for repeated tiles.  For compression purposes, the map will be seen as a
list of data (tile types), rather than a two dimensional grid.

     The routine will count how many times a certain tile type is repeated
consecutively: this count will then be stored before the tile type code. 
So if two numbers are read as 5 then 1, then this would mean that five
tiles of type 1 would be stored in the list.  (The list would then be
converted back into a two-dimensional array, so the game can be played.)

     If the two numbers (count and type) are stored separately as bytes,
then the resulting file could very well end up larger than if no
compression was used.  I have therefore decided to combine the two
numbers.


     5 bits will be needed to store a tile type.  This means that 3 bits
of each byte will be unused: it is here I have decided to store the tile
count.  3 bits can store numbers in the range 0-7, and 5 bits will allow
the tile type to be any number from 0-31.  Each byte will be formatted as
follows:

     Bit number:
     7     6     5     4     3     2     1     0
     c     c     c     t     t     t     t     t

     (Key: c - tile count, t - tile type)

     The tile count will be a number from 0-7.  However, this would leave
an unusable number: 0 would never be used (there will never be a case
where you would want to state that there would be no consecutive tiles of
a certain type in the map list).  Therefore, I have decided that the
number tile count minus one will be stored, allowing counts of between 1
and 9 to be stored.

     Even though there are only 17 tile types, I have had to allocate 5
bits to store each code (if it was 16, I could have used only 4 bits for
this).  However, with this system, up to 32 tile types can be stored, and
so new tile types can easily be added without changing the compression
system.

     To clarify this method of compression, take the following example:

     Variable          Value          Binary
     Tile type     11          01011
     Count          6          101  (5, 6-1)
     Stored byte     171          10101011

     There are two ways in which the two dimensional map can be changed
into a single dimensional data list.  One is starting at the top left hand
corner, picking up data from left to right along each row, and then moving
down a row when it has reached the end.  The other is basically the same
idea, but instead picking up data from top to bottom down each column, and
then moving to the next column, left to right.  The following diagrams
should clarify this a little more:















     Using the two methods, and comparing the size results from each, the
best method for a level could be found.  Levels with a lot of horizontal
stripes of tiles of the same type would be better compressed using the
first method: ones with vertical stripes of tiles would be better
compressed using the second.  The two different types of conversion would
be tried on the same level data every time it was to be compressed, and
the method with the shortest length would be used.


     As there are two different methods of compression, the type of
compression used will also need to be stored along with the data for each
level.

     As the data is being computed, there is little opportunity for
validation.  All the tile data will be validated as it is entered on the
level editor.  However, as a check when the level is being decompressed,
the total of the counts would be found, and should equal 228 (19*12).


Stage File Format

     In summary, here is the stage file format:

     Time limit          2 bytes
     Start position          1 byte
     Comment               ?? bytes
     Teleport data          ?? bytes
     Switch data          ?? bytes
     Compression method     1 byte
     Map data (compressed)     ?? bytes

     The above format is repeated for each of the five levels.


            >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



           Screen Design



Overview

     In this section, I will be designing most of the screens that will be
needed in the final system.  The size of each screen will be mentioned in
pixels by the side of each design.  However, due to the nature of the
Amiga's screens, I can't give character coordinates for the text.  The
Amiga doesn't support character based screens: it only supports graphical,
bitmap screens.  I feel it would be pointless to give exact coordinates
for all the features on each screen: rather I will give a rough indication
of where I would like each aspect of the screen to be in relation to the
rest of it.  Factors such as the width of the font, and hand-drawn parts
of each screen would make it difficult to give the precise coordinates.


            >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



            Pseudo-Code



Overview

     In this section, I will attempt to design in detail some of the
algorithms previously suggested in this section.  As there are a large
number of these, I will only include those algorithms that are either
important or complicated.

     Each piece of pseudo-code will be preceded by a brief description of
what it will achieve, and any other relevant information.


Password Encryption

     Internally, the passwords for the current game will be held as an
array of 100 strings.  This array will firstly be converted to a string,
of the type described in the file structures section.  In the following
pseudo code, Output$ will hold the final array, and the original array
will be shown as Pass$(p), where p will represent the password number.

Output$ = Null
For PassNumber = 0 to 99
     If Pass$(PassNumber) is not null
          Add to Output$ a terminator character
          Add to Output$ a character representing PassNumber
     End If
Next PassNumber
Add to Output$ a terminator character

     This will convert an array into a string.  However, the program will
also need to convert the string back into an array.  Input$ is the string,
and Pass$() will be the array it is converted to:

For PassNumber = 0 to 99
     Pass$(PassNumber) = Null
     Search Input$ for character combination (terminator + PassNumber)
     If the search was successful
          Find position in string where characters are
          Get the first character of the password, at this position.
          While character is not a terminator
               Add the character to Pass$(PassNumber)
               Get the next character
          End While
     End If
Next PassNumber

     The sequence of events will be thus: to save the passwords, convert
the password array into a string.  Encrypt this string and save it to the
password file.  To load the passwords in again, load in the string from
the password file.  Decrypt this, and expand it back into an array.

     The encryption and decryption procedures should be as independent as
possible, and should be able to convert any string to and from encrypted
format easily.  The following routine should encrypt the input string,
Input$, into an encrypted string, Output$.  The encryption format has been
explained fully in the File Structures Section.


Output$ = Null
L = Length of Input$
For CharNumber = 1 to L
     Char = Ascii value of character at position CharNumber
     For BitPosition = 0 to 7
          Bit = Bit number BitPosition from variable Char
          Bit = Not Bit
          Put Bit back into Char at position BitPosition
     Next BitPosition
     Roll the byte Char left three times
     Char = Char + Charnumber
     Char = Remainder of (Char/256)
     Add character Char to Output$
Next CharNumber

     To decrypt an encrypted string, the procedure would be similar to the
one above, but with all the actions reversed: (Input$ holds the encrypted
string, and will output Output$)

Output$ = Null
L = Length of Input$
For CharNumber = 1 to L
     Char = Ascii value of character at position CharNumber
     Char = Char - Charnumber
     Char = Remainder of (Char/256)
     Roll the byte Char right 3 times
     For BitPosition = 0 to 7
          Bit = Bit number BitPosition from variable Char
          Bit = Not Bit
          Put Bit back into Char at position BitPosition
     Next BitPosition
     Add character Char to Output$
Next CharNumber


Level Compression

     There will be two (very similar) methods of level compression.  Here
I will design one of the methods.  "Level" will contain the level number. 
Output$ will be the string that holds the compressed data.  The function
MakeByte will combine the type of tile and the count of how many tiles
there were in a way described in the file structures section.

Output$ = Null
TileType = 0
TileCount = 0
For YPos = 0 to 11
     For XPos = 0 to 18
          NewTileType = Tile at map position (Xpos,Ypos)
          If TileType <> NewTile
               If TileCount > 0
                    Char = MakeByte(TileType,TileCount)
                    Add character Char to Output$
               End If
               TileType = NewTileType
               TileCount = 1
          Else
               Increment TileCount
               If TileCount > 8
                    Char = MakeByte(TileType,TileCount)
                    Add character Char to Output$
                    TileCount = 1
               End If
          End If
     Next XPos
Next Ypos
Char = MakeByte(TileType,TileCount)
Add character Char to Output$


Main Game

     This will be the general format for the actual game itself.  The
level will have all ready been set up, and the main game loop will start
execution.  In this pseudo-code, Dead is a True/False flag of whether the
player is alive or not, and Win will similarly represent whether the level
has been completed:

Repeat
     Check if all destructible tiles have been destroyed
     If they have:
          Light up "Exit" signs
     End If
     If the time limit is up
          Sound klaxon
          Set flag so that this is only executed once
     End If
     Update the player's score
     Survey the tile being moved onto (check the exits)
     React to the tile type as appropriate
     Wait for a joystick input from player if necessary
Until Dead or Win


Title Screen

     The following pseudo-code will form the basis for the title screen
sequence.  "Exit" is an exit flag for the loop.

Start music
Exit = False
Repeat
     Display title screen
     Repeat
     Until <Fire> is pressed or time runs out
     Remove title screen from view
     If fire was not pressed
          Display High score table
          Repeat
          Until <Fire> is pressed or time runs out
          Remove high scores from view
          If Fire was pressed
               Exit = True
          End If
     Else
          Exit = True
     End If
Until Exit=True
Stop Music


            >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



          Testing Strategy



General

     As far as I can, I will develop each routine separately.  I will then
supply test data to it, and make sure that the output is correct.  When I
am satisfied, I will then incorporate it into the main program.

     As an example, in designing the password encryption system, I will
write an entirely different, stand alone, program that will have an array
of, say, 5 passwords.  These will be displayed on screen.  The
array-to-string routine would then be called, and the output would be
displayed on the screen also.  I would then write the string-to-array
routine, to convert the string back into an array of passwords, and
reprint the passwords to make sure there has been no problem in the
conversion.  If this has worked correctly, I would try different data
(very long, very short, and blank passwords), and ensure that these work.

     I would then go on to the encryption routines.  As it is encrypting a
string, I would make it print the character it was looking at, in the
format of the character image, the Ascii number in decimal, and (most
importantly) the Ascii number in binary.  This would be displayed after
every bit operation, so I could make sure that the bits were being
manipulated correctly.  The decryption routine would then be written, in a
similar style (i.e. character by character, displaying the bits after
every operation, etc.).  The routines would first be tested on simple
strings such as single letters and words such as "Hello".  Once I was
satisfied that they were working, I would then try the password strings.

     As a final test, I would then rip out all the parts of the program
that shows what is happening, except the displaying of the password array.
 The program would then be arranged to execute in the order:
- Display passwords
- Password array to string
- Encrypt string
- Decrypt string
- String to password array
- Display passwords

     Again, different sets of passwords would be used, to make sure that
it all works.  The routines would then be transferred to the main program.
 Amos makes this way of working very easy, as more than one program can be
loaded at any one time, and displayed in different windows where parts of
the program can be cut and pasted between them.


Amos Monitor

     The Amos Monitor will be a huge help when testing and inevitably
debugging it.  It is simply a program that lets the user single step
through a program.  A small version of the program's screen, the part of
the listing being executed, and a variable list are displayed on the
monitor screen.  The user can display the contents of any variable, set
break points, and determine what speed it should step through instructions
at.  These features make it extremely useful in spotting any mistakes in
the program that I have made.



Testing the Game

     The above techniques can't really be applied to testing the game
sequence itself.  This will have to be simply by looking through the
program, performing dry runs, and maybe setting points where a key will
have to pressed to proceed (to make sure certain routines are being
called).

     As some aspects of the game are time-critical, displaying numbers or
setting break points could prove unworkable.  To get round this, I may
have to resort to using sound effects to tell me which parts of the
program are being executed.  This should not slow the game down, as they
are played under interrupt.


General Precautions

     To cut down on the amount of possible bugs, I will have to be careful
about the way in which I program it.  By making each procedure totally
separate and independent will help in finding out where the bugs actually
are.  Also, I will have to be particularly careful about the names of
global and local variables.  An example of how I could do this is by
making all global variables have at least two characters: then I would be
able to use single character names for any local variables I may need
without having to make sure that they hadn't all ready been used.
