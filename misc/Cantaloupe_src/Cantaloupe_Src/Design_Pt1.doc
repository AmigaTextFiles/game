
         Proposed Solution



Proposed Solution

     I have decided that for the system to conform to the specifications
set down in section 1.4, there will need to be at least two separate
programs in the complete system: the main game, and a level editor. The
exact functions and design of these will be covered in subsequent
sections.

     The actual computer system that the game will be used on will also be
important, and possibly affect certain elements of the design.


Hardware + Software Requirements

     The system will be designed to be used on an Amiga 1200.  The main
reason for this is that I own one: therefore I will be able to use the
finished program myself, which was one of the reasons I chose the problem.

     As a consequence of this, I will be able to spend more time
developing and testing the system.  I also feel it is more suitable for
this type of project than either a PC or an Archimedes, because of it's
advanced graphic capabilities, and it has a selection of powerful
programming languages that can exploit these capabilities.

     After this was decided, I then had to choose which language to
develop the system for.  There are three main languages I could choose
from: C, Assembler or Basic.  Although C is a very structured and fast
language, I decided that it didn't fully exploit the graphic capabilities
of the Amiga as the others could.  Assembler, on the other hand, whilst
being the speediest of the three, required too much programming of
low-level routines that are provided as standard in the other two.  This
was especially important when considering the limited time span I have for
this project.

     The final option, therefore, is Basic.  The latest versions of Basic
are greatly improved over the original language: they can control almost
all of the aspects of the computer system, contain more elegant control
structures, and are very fast indeed.

     On the Amiga, there are two leading Basics: Amos Professional and
Blitz Basic 2.  Both are excellent, and have their own individual
advantages and disadvantages.  Blitz programs are compiled only, and Amos
programs can be interpreted or compiled.  The choice between them is
basically personal preference: I prefer Amos as I find it much easier to
program in, the editor is considerably more professional, and I have more
experience in Amos than Blitz.  While the program is in development, it
will use an interpreter, but the final version will be compiled for extra
speed.


Summary

     I have decided to produce the system on (and for use on) the Amiga
A1200, using Amos Professional and the Amos Professional Compiler.


            >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



            Basic Design



Overview

     Before much more design work can continue, some basic specifications
about the game and the level editor will have to be decided.  After this,
the main elements of both programs will be broken down using a top-down
design chart, and these final sub-problems will be examined in the final
parts of the design.


Game Structure

     Levels will be stored on disk as sets of five.  These groups of
levels will be called stages, and each has the possibility of having a
password, so players can jump to the start of a certain stage.

     Stages will in turn be grouped in batches of up to 100 stages: each
of these groups will be called games.  The player will be able to choose
which game he wants to play without the need for a password.  There will
be a maximum of 1000 games to choose from.

     The decision of how many stages will make up a game, and which
particular stages make up each game, will be made by the user operating
the level editor.  When playing the game, the player would select a
certain game to play, and then play through all the stages (and levels) in
sequence.

     I decided to split the levels up into stages and games (rather than
having a long single run of levels) for a number of reasons.  Firstly,
there are five levels in a stage to cut down on loading times during the
playing of the game: I would prefer one slightly longer pause between sets
of five levels than a shorter one between every level, due to the loading
of data.  I also suspect that it would make the game a lot easier if there
were passwords for every seperate level.

     The concept of having different "games" is to give the player more
choice.  If he becomes completely stuck on one level in a particular game,
he could always try his hand at a different set of levels, and come back
to it later.  They could also be used to train players: a certain game
could be used to introduce a new type of tile or technique to a player new
to the game, thus lessening the steepness of the learning curve.

     Also, "games" allow the user to partition his work into segments,
rather like a directories do on a disk.  This will allow for a better
organisation on behalf of the user, which will be needed if he is to
exploit the total number of levels he is allowed to create.

     I think that this new game structure will be better than the
original, whose levels had to played in strict order from start to finish,
which was occasionally irratating.  This method also allows for a maximum
of 500,000 (5 * 100 * 1000) different levels to be stored, limited by the
size of the storage medium.  In fact, the storage medium is more likely to
fill up and the user run out of ideas before all 500,000 levels are
filled.  The maximum number of games and number of stages in a game were
decided on so they would be a lot larger than the average user could ever
use.




Player attributes and Game Concepts

     In the game, the player will have various parameters associated with
him.  Firstly, there will be the number of "lives" he has (i.e. the number
of times his craft can be destroyed before the game ends).  It will start
off as a number such as 5, and decrease by one each time the player's
craft is destroyed.

     Another variable will be that of a score.  It will accumulate through
the game at a rate determined by how well the player is progressing (e.g.
through bonuses, how quickly a level is completed, how many blocks he has
destroyed, and so on), and will determine his position in the high-score
table at the end of the game.

     The player's score and number of lives, as well as the current stage
and level, will be displayed on the screen as he is playing a level, to
remind him how well he is doing.


            >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



          Top Down Design



Overview

     Using a top-down design, I will attempt to break up the main problem
into smaller, sub-problems, to such an extent that they can be broken down
no more.  I will then look at the final sub-problems, and solve them
individually, using techniques such as pseudo-code, flowcharts, and so on.
 However, I may well need to explain some of the stages in the top-down
design chart in some detail before that.


            >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



       Top-down Design Notes



Overview

     This section is designed to explain some of the aspects of the
top-down design chart that haven't previously been mentioned.  This will
allow me to clarify some of the points, and to explain why I chose to
include them.  The following notes are all preceded by a title explaining
whereabouts in the chart the points have been made.


Non-square tiles (Edit level/Choose Tile type)

     In the original game, all the tile types were square, except the Exit
tile.  This was twice the size of a normal tile, of dimensions 2 tiles
across and 1 down.  To try to keep the same "feel" of the game, I have
decided to implement the same feature in my version, even though it may
require a little extra programming.


Interface (Main Menu)

     This is a list of the different gadgets that the user will be able to
manipulate.  The system will be designed to be run on an Amiga (because
this is the computer I own, and one of the main stipulations of the
Analysis section was that I was to use the end system.  This will be
covered more fully in a later section).

     It is therefore important that Amiga owners should be able to use the
editor easily.  The interface for the program should therefore have a
similar look and feel to the official Amiga interface system, Intuition. 
The interface gadgets identified in the top-down design chart have been
named after similar standard Amiga intuition gadgets: for those unfamiliar
with Amiga interfaces, they are each described below:

Buttons:  These are standard "action" buttons.  When pressed (i.e. clicked
on with the mouse), an action will be performed by the program.

Input boxes:  These gadgets allow the user to edit a text variable using
the standard editing keys (i.e. cursor keys, delete, backspace, etc.)

Tick boxes:  These boxes can either be "on" (ticked) or "off" (not
ticked), and will refer to a parameter in the program.  When pressed by
the user, they toggle between on and off states.

Radio buttons:  These represent a set of parameters or choices in the
program, of which only one can selected.  It is rather like a group of
tick boxes (see above), in which the selecting of a new choice will turn
that box on, and the rest in the group off.

Scroll lists:  These are lists of text items that can be scrolled  through
(moved up and down), and one variable can be selected.  There are four
elements that go towards making a whole scroll list: the list of text
itself, a slider bar (or "proportional gadget"), and two arrow buttons. 
If there are more text items than can physically fit in the list box, then
the list must be scrolled through to access the other items.  The arrow
buttons allow the user to scroll the list up or down, as does the slider
bar.  To user the slider bar, the user "grabs" it by clicking on it and
holding the mouse button.  By then dragging the mouse up or down, the list
moves up and down.  Unlike the "Windows" environment on a PC, the slider
bars on the Amiga change size depending on how big the list and list
window are.


Test Game (Main Menu)

     An option in the level editor will be to test a level that has just
been designed (i.e. to let the user play that level as it would be played
in the full game, without having to switch between the two programs). 
This will allow the user to check if the level is possible, and if it is,
whether it is too easy or too difficult.  It will also allow the user to
decide on a sensible time limit.


Check for errors (Main Menu/Alter level attributes)

     This will be a routine that checks through all the levels in the
stage, and report errors or warnings if there is a badly designed level. 
It would only check for certain things, such as whether there was an Exit
tile, or any unconnected teleports or switches, and so on.  One thing it
would not do would be to test if a level was possible to complete or not
(bar the simple checks mentioned above).  I think I would find such an
option very difficult to program and time consuming to execute (it would
have to check every single route through the level).


Edit Level Comment (Main Menu/Alter level attributes)

     I have decided that each level should have a comment about it written
(if the level designer wants to), and that it should be displayed in the
game itself before the level is attempted.  This comment will simply be a
line of text that could be used in a number of ways, some of which are
described below.

- The comment could simply be an indication of the difficulty of the level
- A cryptic hint on how to solve the level
- Just a name for the level, similar to the game Lemmings, in which every
level had a title
- A clue to the next password.  I think this an interesting idea: for
example, each comment could contain a song lyric from a certain group,
starting off from an obscure lyric on the first level of a stage, to a
fairly well known lyric on level five.  If the player works out who the
group are, he would enter the name of the group as the password, and
therefore skip to the next stage.  Of course, if a user had no idea, he
could simply play through the five levels, and the answer would be
revealed as the next password.  This could also be used with general
knowledge questions, descriptions of famous people, and so on.
- Messages and jokes could be spread over several levels, to give the
player an extra incentive to get to the next level.


Compress Stage Numbers (Main Menu/Choose Stage)

     Each game will have a number of stages, each with their own
identification numbers, from 00-99.  There could be some gaps in their
sequence (e.g. a game could consist of stage numbers 7, 20, 53 and 76, due
to the inbetween stages being deleted, or those numbers were simply chosen
at random).  These would be played in numerical sequence.  However, to
make the game a little tidier, the option "compress stage numbers" would
renumber the stages to 0, 1, 2 and 3.

Read Instructions (Title Screen/Display Options Screen/Interface)

     This will simply be a routine to display the instructions for the
game.  However, as it is a game, there will be a need to make the screen
look more interesting than a simple text screen.  How this will be
achieved will be decided later in the design process.


"Get Ready" (Game Sequence)

     This will be a screen where the level and stage numbers, the current
password, and the level comment will be displayed.  The screen will be
brought up before each attempt at a level.  It's main purpose, apart from
looking pleasant, will be to distract the user while the level itself is
being drawn.


            >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



       Initial Graphics Design



Overview

     At first glance, the graphics of the game would seem unimportant and
one of the last things to be thought about.  This is correct up to a
point: the look of the graphics are fairly irrelevant, but their size is
of fundamental importance.  I will have to make some decisions on the size
of the in-game graphics before I am able to continue with the program
design.


Graphics Information

     The game itself is designed to be played on a domestic PAL television
(this is because most Amigas, including mine, are used this way).  The
physical television screen is roughly 320 x 256 pixels large, and updates
every 50th of a second.  (1 pixel = 1 picture element = 1 small, square
dot on a television.)

     One of Amos's most useful features is the ability to have up to 8
different screens open at once.  Each screen may be at any position on the
screen, have any size, have any number of colours from 2 to 64, be in any
resolution and have it's own colour "palette" (i.e. a list of 12-bit
colour values assigned to each "ink" colour on the screen).  Each screen
can be drawn to and used completely independently of any other screen.


Tiles

     Each tile will be a 16x16 pixel square.  This was decided for a
number of reasons:
- This will also be the size of the player (See below)
- This size allows a reasonable number of tiles on screen at once (a
similar number to the original game)
- It will allow more detail in the final graphics used than a smaller size


Player Craft

     In the game, the player will have to control an on-screen vehicle,
that he will be directly controlling to complete the level.  I have
decided that this will be a sprite.  The other alternative, bobs (Blitter
OBjects), would require double buffering the screen (using more memory)
and may slow the game down.  For these reasons, I wouldn't use them unless
I had to.

     Sprites aren't without their limitations, however: A choice is to be
made between 8 3-colour sprites or 4 15 colour sprites on screen at once
(without "multiplexing" them).  I chose the 15 colour sprites, and one of
them will be the player sprite.  This leaves me with 3 more sprites I can
use: I will decide what to do with them (if anything) at a later stage.

     The maximum size of the sprites is 16x256.  Because I want the tiles
to be square, the size will be 16x16, which will also be the size of the
tiles (see above).





Game Screen

     Using the Amos features described above, I have decided on the
following specifications for the game screen.  The status panel will
occupy a different screen from the main game.  The status panel will be
displayed above the main game screen, and will only need to be about 20
pixels high.  The screen will be designed later on.

     The main game screen will be a low resolution 64 colour screen.  This
is the highest number of colours Amos can display on a screen (although
the Amiga is capable of 256 colours) as it is designed to run on older
Amigas as well.  The dimensions of the screen will be 320x232 pixels. 
This was decided on to make the levels as big as possible (it will fill
the screen below the status bar).  The maximum map size is 19x12 tiles. 
There are 19 across rather than 20, so that if a player moves off the edge
of the map, they will still be able to see themselves being blown up in
the 8 pixels at either side.  For similar reasons, there is a one-tile gap
at the top and bottom of the screen (if there wasn't, the player would be
able to see himself move into the status bar!).  This leaves an extra 8
pixels at the top or bottom of the screen that can be used to decorate the
edges of the playing area.


Summary

     Each level will have a maximum size of 19x12 tiles.  Each tile will
be 16x16 pixels large.  The player will be a sprite the same size as the
tiles.


            >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



            Level Design



Level Specifications

     Size:  The size of each level will be 19 x 12 tiles.  The reasons for
this size are given in section 2.5.

     Comments:  Each level will have a "comment" attached to it.  For more
details about comments, see section 2.4.

     Time Limit: The player will earn bonus points if he/she completes a
level within a certain time limit (see section 1.3).

     Each level needs at least three components: a start point (where the
player enters the level), an amount of destructible tiles (determining how
to destroy these will form the main puzzle element of the game), and an
Exit tile, which the player will have to reach after destroying all the
tiles.  There are, of course, other types of tile that will either help or
hinder the player; these are detailed in section 1.2 and 1.3.


Level Designs

     I have prepared some test levels to show the sort of problems that
can be created.  These are by no means the final designs: they are merely
ideas, to be developed into full levels afterwards.


            >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



           Program Design



Overview

     I have now reached a stage in the design of the system where I feel I
can start the design of the program itself.  I have quite a clear idea in
my mind of what I want the system to do, and how it is going to do it.

     A great deal of the problems that will surface during the programming
of the system will be fairly routine ones, with no out of the ordinary
programming needed.  It would therefore be unnecessary to rigorously
design every single procedure that will be needed in the final system. 
Instead, what I am planning to do is to design all the main routines,
along with any that I feel will need special attention to solve.  If I do
miss out any routines that need extra work to be done, then this will be
documented in the Implementation and Testing section.


            >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



             The Game



Introduction

     In this section I will be designing the core of the system: the game
itself.  It will assume that the stage has already been loaded, and that
the level has been drawn.


Starting to play

     Even before the player appears, it has to be decided where they will
appear.  Two variables will be sufficient for this, the X and Y tile
coordinates.  The screen coordinates of where the player is going to start
can then be calculated.  All that is then needed is for the player to
appear on the screen and for the game to start.  However, just making the
craft blink into existence would look unprofessional, and so I have
decided to animate the craft onto the screen.


Animation

     The player is going to be a sprite (as was decided in section 2.5, to
let it be moved smoother and to save memory).  To allow the player to warp
(or whatever) onto the level, some method of animating the sprite is going
to have to be found.

     One feature of Amos that is particularly useful when it comes to game
writing is AMAL.  AMAL (AMos Animation Language) is a sub-language of
Amos, whose only purpose is to control several "channels".  Each channel
can be assigned to a screen, bob or sprite, and AMAL can then control it
independently of the main program.  AMAL works entirely under interrupt,
and can therefore be guaranteed to move and animate sprites smoothly, and
without main program guidance.

     The AMAL command that concerns animation is Anim, and basically works
like this:  "Anim (frame,count)(frame,count)...", where frame is the
picture number to be displayed, and count is the duration of that frame
being shown (measured in 50ths of a second).

     As this shows, AMAL is very easy to use.  I would simply type in the
list of frame numbers needed, assign the program to a channel and a
channel to the player sprite, and start the program running, while the
rest of the program continues, and waits for the animation to stop.


Amos Banks

     But how will the player graphics be stored in memory?  The only real
alternative is an Amos "Bank".  The concept of banks is a big advantage of
Amos, as they allow sets of data to be easily accessed from a program.

     There are several types of data that can be stored in banks: sprite
images, "icon" images, sound samples, music, pictures, or just numerical
data.  Each type has it's own specific format, as well as it's own
particular bank editor, that can be called from the program editor.  All
banks are saved along with the program itself, and so a program won't need
to load external files if it needs sound or graphics.

     As an example of how these are used, I would first draw the graphics
for the player in an independent paint package, and save this image to
disk.  I would then load the program and editor, and select the item "Edit
Sprites" from a menu to start the Sprite Image Editor accessory.  I would
then use the function "Grab from picture" to capture the individual frames
of animation.


Main Game Loop

     After the player has appeared on the screen, a game loop will have to
begin.  This will include getting input from the player, via a joystick,
moving the craft, reacting to the tile he has moved onto (if any reaction
is needed), and various housekeeping routines such as updating the score. 
This loop will continue until the player either loses a life, or completes
the level.


Player Movement

     While the player is over most types of tile, the user will need to
indicate which way to move using his joystick, and will be able to elect
to move up, down, left or right (no diagonals), or press the fire button
while over a teleport or switch.  Also, on some tiles (destructible
types), there will be a time limit placed on waiting for the user to move.

     Due to the existence of the horizontal and vertical movement-only
tiles, the player will not be able to move in certain directions whilst
either on or next to these tiles.  There will also be certain tile types
on which the player will have no control over his direction (i.e. the
arrows and ice tiles).

     There will therefore need to be a routine that will accept input from
the joystick, and validate it (i.e. make sure the user can go in that
direction), accept the pressing of fire over certain tiles, and have
provisions for a time limit on destructible tiles.

     The actual on-screen moving of the player should prove to be quite
easy.  There is a command in AMAL that allows the moving of a sprite,
similar to the Anim command mentioned earlier, and also with the added
bonus of it being moved under interrupt.  This will allow the other
procedures to be set up, ready for the next tile, and also allow the score
to be updated.

     I have decided that, for the validation of the direction chosen by
the player, there should be an array, already set up, of which directions
are valid.  The array would be set up as the player was moving on to the
next tile, and will allow the program to check in a quicker way which ways
the player can move.  It will be quicker as not only the type of tile has
to be considered, but also the direction of tile (e.g. the player could
move upwards into a vertical-movement-only tile, but not sideways).  To
illustrate this in a clearer way, the following diagram shows a small part
of a level, together with the contents of the array for each direction:










Reacting to tiles

     As there is such a wide variation in what each type of tile can do to
the player, each will have their own routine.  Most of these will either
simply wait for user input and let them move as normal, or change the
direction of the player and move him.  However, some tiles will have to
have special attention paid to to them:


Teleports

     Moving over one of these and pressing fire will transport the player
to a predetermined destination tile (not necessarily another teleport). 
The main problem with this is how the destination tile for each teleport
should be stored in memory.

     There can be between 0 and 228 (19 * 12) teleports in each level, and
four items of data to be stored about each (the X and Y coordinates of
both the teleport and the destination tile for that teleport).  It would
seem a waste of memory to use an array for all the (912) items of data
needed for each level (4560 for each stage), if there would be typically
between 0 and 4 teleports in an average level.

     To halve the amount of data needed to be stored, I have designed a
new coordinate system to describe each tile position.  As there are 228
possible tile positions, each can have it's own number from 0-227.  The
two coordinate systems can be interchanged using the following
mathematical formulae:

     BYTE = X + Y * 19

     X = (Remainder of) BYTE / 19
     Y = (Integer of) BYTE / 19

(Assuming X is between 0-18 and Y is between 0-11.  They will both always
be integers).  Using the above system, each teleport will only have to
have two items of data to be stored about it, it's source and destination
tiles.

     Although this helps with the amount of data needed (2280 numbers per
stage), it seems somewhat wasteful to store this amount for every single
stage, especially as most of them will not be for squares with teleports
on.

     I therefore decided to use a dynamic array to store the data (i.e.
one that changes size depending on how much data is stored in it).  The
only problem with this is that Amos has no support for dynamic arrays, so
I will have to program my own routines as a "shell" for accessing them.

     After thinking about dynamic arrays for a while, I came up with a
standard that I would use.  It was based on the following factors:

- The maximum number stored in the array would be 227 (using the
coordinate system described above)
- The maximum array size would be 228 items (there would be an array for
each level)

     In Amos, the only dynamic variable is the string, which can range
from 0-65536 bytes long.  It would therefore seem ideal for storing
dynamic arrays.  Each byte of the string can store a character with a code
from 0 to 255.  Therefore the structure will be:


     255     Source     Dest     255     Source     Dest     255 ...

E.g.:

     255     15     19     255     95     116     255

     Each of the numbers above represent 1 byte of the string.  The
"source" byte can be thought of as the index number for the item, and the
"Dest" byte can be thought of as the contents.  There are bytes holding
the number 255 between each index and content pair to separate them
(neither the index nor the content byte can ever contain a number bigger
than 228, and so the number 255 can only exist as either a separator or a
terminator).  This is to speed up the searching through an array for a
specific index.

     Presently, the separator seems to have little benefit to the array
operations, as without them every other byte could simply be looked at to
test whether that was the particular index being searched for.  The reason
it is there will be explained in the section about switches.

     The routines I will have to write to cope with dynamic arrays will be
as follows:

- Add an item
- Delete an item
- Find an item
- Replace an item with a new value


Switches

     When the player moves over one of these squares and presses fire,
either one or two "switchable" will change (from being fatal to non-fatal,
or vice versa).  The main problem with these tiles is much the same as the
teleports above.  There will have to be either one or two bytes of
information stored, describing the actions of each switch in a level (i.e.
which switchable blocks they will toggle).  Again, the solution I have
decided upon is a dynamic array.

     When the switch only affects one other block, the data structure will
be exactly the same as the teleport example above.  However, when it
affects two, there will need to be two items of data about it, e.g.:

     255     15     20     39     255     ...

     This is why the separator characters are necessary: so the routines
will be able to tell if there is one or two items of data about a certain
switch.

     To extract the data about a certain switch (at position 45), the
routine would search for the first occurrence of the byte combination 255
45.  The next occurrence of the byte 255 would be found, and the data
between these two positions would be obtained and returned.


Destructible tiles

     For normal destructible tiles, the player will have a certain time
after entering it to move off it, before being destroyed.  When the player
moves off the tile, it will disappear from the map.  The program will,
then, have to erase the tile from it's internal level map array, and
remove the tile from the screen display (possibly using animation).

     For the destructible tiles that have to be touched twice, the first
time the player passes over it, the program will have to change it to a
normal destructible tile both on the screen and in it's level map array. 
If the player stays on the tile too long, then it changes automatically,
and the program will treat it as if a normal destructible tile has been
moved onto.

     There must, therefore, be two copies of the map array in memory at
once.  One of them will change as the user plays the level, and the other
will act as a "backup" to be copied to the first array, so if the user
dies on a level, he can attempt it again using the original map of tiles.


            >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



         Drawing the Level



Level Structure

     As I have mentioned previously, the level being drawn will be held in
an array in memory.  It will be a two dimensional array, 19 * 12, and the
contents of each will refer to the tile type.

     To draw a level, all that would usually be required would be to work
through the array from left to right, top to bottom, printing the
appropriate image at the correct place on the screen (the images will be
stored in an icon bank).  However, to spruce up the graphics a little, I
will use some other effects.


Shadow

     In the original game, a shadow appeared underneath each tile.  This
was achieved by darkening the background to the right and below the tile. 
I quite liked this effect, and so I will include it in my version of the
game as well.

     The easy solution to this is to store the tile images in the icon
bank with a shadow already drawn.  Then, as the level is being drawn in
the way described above, there will be a shadow under all the tiles in the
level, without any cases of a shadow appearing over another tile.

     One precaution I will have to take is that when a destructible tile
is destroyed, it's shadow will have to be erased also.  When this happens,
account will have to be made of the other tiles surrounding it, as this
will determine which parts of the shadow will be deleted.


Bas-relief

     I already have some idea of what the tiles will each look like.  For
example, the ordinary tiles (i.e. those that can be moved about freely
over) will be grey, as in the original game.  However, as this could end
up looking a little dull, I have decided that I will add an effect called
bas-relief to them.  This basically means that the left and upper edges of
a tile will appear to be brighter than the rest of it, and darker to the
right and bottom sides of it.  The end effect should be that the tiles
will look a bit more 3D-like, and stand out a little more.

     This would not be a problem if I wanted to give each tile the effect
separately, as I would simply draw it on the image in the icon bank. 
However, I would like the effect to be applied to groups of normal tiles. 
This would mean that if two normal tiles were placed next to each other,
then the shading of the two tiles would be considered as a whole.

     The effect is easier to show than explain.  The following sketches
will first show a solitary tile having the effect applied to it, and then
what considerations would have to be made when other tiles are placed
around it.  Only one corner is shown: the reasons for this will be given
after the sketches.




Bas-Relief sketches


Bas-Relief Notes

     Where an X is shown, this means that it doesn't matter if there is a
normal tile there or not.  Please note that only the shading of the top
left corner of the bottom right tile is being considered, and so the other
tiles in the diagrams are not shaded.  A blue square indicates the
presence of either another type of tile or no tile, in a position relative
to the tile being considered as shown.  The grey tiles indicate a presence
of another normal tile.

     As can be seen, there can be five different patterns displayed in the
top left hand corner.  This is the same for every other corner, if the
tile combinations are imagined to be rotated for each other corner.  This
means that, if the tile is taken as a whole, there can be 625 different
patterns for a normal tile (54).  As this is rather a lot, I have decided
to look at each corner of the tile separately, and change the pattern for
each as it was being considered.

     As the level is being drawn, each of the normal tiles (and each of
the 4 corners of each tile) will be considered separately: the appropriate
pattern to display in this corner will be calculated and then printed on
screen.

     Overall, the effect should be one of the tiles appearing to "gel"
together, and should help the overall look of the game.  The actual
pattern of each of the corners will be designed later when I am
considering the design of the graphics.


Colour flashing

     Again, to brighten up the level, I have decided to make certain
colours on the screen flash.  This could help to highlight certain tiles,
or a set of colours could flash in sequence to give the impression of
movement.  This will be considered in greater detail when I design the
in-game graphics.


Get Ready

     As the screen is being drawn, the "Get Ready" screen will be
displayed.  This will consist of one screen instructing the user to "get
ready," and another that will display the stage and level numbers, the
password for the stage, and the comment for the level.  When the program
has finished drawing the main game screen, and the status panel has been
prepared, a message will appear telling the user to press fire to start
playing the level.


            >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



            High Scores



Basics

     There will be a list of 15 names stored in the computer, representing
the highest scoring players of the game.  Also, their score and the stage
and level they got to will be stored.

     This list will be displayed during the title screen sequence.  The
list may also be saved to disk (and loaded back), allowing different high
score tables to be used for different games.


Entering a New High Score

     After a user finishes a game (either by completion or losing all
their lives), their score will checked against the high score table.  If
it is bigger than the lowest score in the table, then the player has
attained a high score, and will then get the chance to enter their name
into the table.

     I am planning to let the player use whichever input method he is most
comfortable with.  This will mean a choice of typing it in using the
keyboard, or selecting letters using the joystick or mouse.  For these
last two to be feasible, there will have to be an on-screen display of a
table of letters, that the user can select by moving a pointer controlled
either by joystick or mouse, and then pressing fire or clicking a mouse
button.

     There will also have to be a display that will let the user see what
they have typed in.  The maximum length of this will not depend on the
number of characters in the name, but on the graphical length of the name.

     I am planning to use a proportional font (of my own design)
throughout the game (i.e. each letter will have a different width: an "i"
will be thinner than an "n", which in turn will be thinner than an "m"). 
Therefore, checks on the length of strings will mostly have to be on their
graphical length, rather than the number of characters in it.

     The maximum length of the string will simply depend on the space
available when the high score table is displayed.


Displaying the High Score Table

     This will occur as part of the title screen sequence.  The screen
will consist of the position, name, score and maximum stage and level
attained by that player.


Sorting the High Scores

     The high scores will have to be sorted (on the score field), so as to
show the relative performances by two players. The routine to do this will
be outlined in a later Pseudo-code section.


Loading and Saving High Scores

     These routines will be discussed in the File Formats section.


            >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



       Title Screen & Options



Name of the game

     The title screen of the game should, by definition, contain the title
of the game.  I will therefore have to decide on what the game is to be
called.  I eventually decided on Cantaloupe, as in "type of melon", purely
because the word sounds nice.


Title Screen

     This should be quite a simple affair.  It should contain the name of
the game, a brief credits message, and one telling the user to press fire
to begin the game.

     The "name" part of the screen will probably be hand drawn, and could
have a "rainbow" behind it.  A rainbow is a special effect that can be
accessed using Amos: it alters a certain colour on the screen as the
television is drawing the image.  It will change a certain colour index to
a list of predefined colour values, as the raster beam is actually
displaying the screen.  It does this by using the Amiga's Copper
(co-processor) chip under interrupt.  The end effect is usually a nice
colour gradient appearing behind a picture.

     I plan to display the credits message over a screen using colour
cycling.  Colour cycling is where a certain part of the screen palette is
rotated (i.e. all the colour values move down one index, the last one
moving back to the beginning, and so on).  This effect is again controlled
under interrupt, and with a sufficient number of colours, a good effect of
animation can be achieved.

     When the title screen has been displayed for a while, and assuming
that the fire button has not been pressed, it will disappear, and the High
Score table will be displayed.  (See the section on high scores for
further information.)  Again, if the fire button is not pressed while this
screen is displayed, after a while it will change back to the title
screen.


Options Screen

     If the fire button is pressed in the title screen sequence, the
options screen will be accessed.  As was detailed in the top down design,
this screen will have the following options available:

- Start the game
- Enter password
- Choose game number
- Read instructions
- Load high-scores
- Save high-scores
- Exit to title screen

     As the user will be getting ready to play the game, and he has just
pressed fire to get on to the options screen, he will probably be holding
a joystick.  It would therefore be sensible to let him choose his options
using a joystick.  An option would be highlighted: the user would press
fire to select it, or push up or down to select the option above or below
it.

     The first option, Start the game, will simply exit the menu and start
the game at the place (i.e. game and stage) the user has opted for.  Enter
password should also be a simple affair, allowing the user to easily enter
a password using the keyboard.  The system will then check through the
list of passwords in memory, to check if it is valid.  If it is, the stage
number will be altered accordingly.  Loading and Saving High-Scores will
simply load or save the high-score table in memory to/from a file
determined by the game number (allowing for separate high score tables to
be maintained for different games).  Exit to title screen should be no
problem, simply taking away the options screen and restarting the title
sequence.

     When Choose Game Number is selected, a new screen will open up, and
allow the user to alter the game number.  There will be a three figure
display, and the user will be able to alter each of the digits
individually.  There will also be some sort of indication as to whether
the chosen game actually exists, and options to go to the next (or
previous) game that does exist.  There will also be an "exit" option,
which will take the user back to the options menu.  This screen suggests a
graphic user interface (i.e. one with buttons and a pointer) due to it's
nature.  I plan to let the user control the pointer with either the mouse
or joystick.

     Read Instructions: This will allow the user to read several pages of
text, which will tell them how to play the game.  As it is a game, the
text display should look more interesting than just a page of text.  I am
therefore planning to display the text, white with a black outline, with
the title of the game at the top of each page.  The text will then be
displayed over another picture, which it will move independently of when
it changes between pages of text.  It will achieve this by using Dual
Playfields, a feature of Amos which will allow two different screens to be
displayed over each other.
