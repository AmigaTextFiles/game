@database "CaptureContest.guide"
@smartwrap
@font "Bitstream Vera Sans.font" 15
@$VER: CaptureContest.guide 0.0 (6.5.2011)                
@tab 8
@(c) "Copyright 2011 Thomas Breeden"
@macro "_HEADING_" "@{u}$1@{uu}@{_SMLDENT_}@{line}"
@macro "_SMLDENT_" "@{lindent 6}"
@macro "_LMARG_" "@{lindent 1}"
@macro "_LRGDENT_" "@{lindent 12}"
@macro "_ITEMEND_" "@{_SMLDENT_}@{line}"
@macro "_HLINE_" "_________________________________________________________________________________@{line}"
@macro "_ITEMBEG_" "@{tab}> @{lindent $1}"
@author "Thomas Breeden"
@macro "_TABS5_" "@{_TABS4_}@{tab}"
@macro "_TABS6_" "@{_TABS5_}@{tab}"
@macro "_ITM12_" "@{_ITEMBEG_ 12}"
@macro "_TABS2_" "@{tab}@{tab}"
@macro "_TABS3_" "@{_TABS2_}@{tab}"
@macro "_TABS4_" "@{_TABS3_}@{tab}"
@macro "_ITM48_" "@{_ITEMBEG_ 48}"
@macro "_ITM32_" "@{_ITEMBEG_ 32}"
@node "MAIN" "CaptureContest"
@{_LMARG_}@{JRIGHT}May 7, 2011@{line}
@{JCENTER}@{B}Capture Programming Challenge for Amiga@{UB}
@{line}
@{_HLINE_}@{JLEFT}
Capture 0.0 (02/09/2011)
@{_LRGDENT_}

@{_TABS6_}@{" Game Board Image " SYSTEM "Multiview 058.gif  WINDOWLEFT 400 WINDOWTOP 200"}@{line}

Overview@{_TABS3_}@{" > " LINK "Overview"}@{line}
Requirements@{_TABS2_}@{" > " LINK "Requirements"}@{line}
Installing@{_TABS3_}@{" > " LINK "Installing"}@{line}
Rules@{_TABS4_}@{" > " LINK "Rules"}@{line}
Example Players@{_TABS2_}@{" > " LINK "ExamplePlayers"}@{line}
Running@{_TABS4_}@{" > " LINK "Running"}@{line}
Developing Players@{tab}@{" > " LINK "DevelopingPlayers"}@{line}
Executables@{_TABS3_}@{" > " LINK "Executables"}@{line}
Traces@{_TABS4_}@{" > " LINK "Traces"}@{line}
Sources@{_TABS3_}@{" > " LINK "Sources"}@{line}
This and That@{_TABS3_}@{" > " LINK "Tournament"}@{line}





@endnode
@node "Overview" "Overview"
@{line}
@{_LMARG_}@{JCENTER}@{B}Capture Programming Challenge Overview@{UB}@{line}
@{_HLINE_}@{JLEFT}

Last year I came upon a programming challenge/contest, run by the
ACM Queue magazine, that seemed like it might be fun.@{line}

From their description:@{_SMLDENT_}@{line}

Beginning January 11th, 2010, ACM Queue is offering an online programming competition
based on the 2009 ACM International Collegiate Programming Competition (ICPC)
Challenge problem.@{line}

The Game of Capture is played on a [2D] field playing field
populated with many pucks. Each player controlls three playing pieces, a sled
and two bumpers, The point is to use your sled to a draw closed loop around groups
of pucks in an effort to convert as many as you can to your own color.@{line}

The player with the most pucks at the end of a 90-second match is the winner.@{_LMARG_}@{line}

There are no mice, joy-sticks, or keystrokes involved, the two opposing players are
entirely controlled by opposing user-written programs sending control commands to their
moving "sleds" and "bumpers" via the game engine. The game engine in turn supplies
each player to the entire game state - sleds, bumpers, and the 112 movable pucks.@{line}

Unfortunately, Amiga programmers were almost locked out of the game, since@{_SMLDENT_}@{line}

"Participants will get to code a player in C++, C#, or Java ..."@{_LMARG_}@{line}

You could not do any testing on the Amiga since the game engine
was a Java program.@{line}

Now I've generated an independent implementation of the game engine to run on AOS 4.1, to
see if I could do it, and to see if we could have some fun programming.@{line}

I think it is ready to have a go. The engine does the physics and graphics, so programming
your own player is not beyond a beginning or a rusty programmer, but programming a really
good player is a challenge for the best programmer.@{line}

The players and the engine are separate processes, communicating via Amiga pipes, so
it is open to anyone's favorite Amiga language, C, C++, E, Modula-2, etc.@{line}

Since I used my Aglet Modula-2 compiler to do the engine and also am supplying
sources for some simple example players in Modula-2, I'm hoping to spark some interest
in my favorite language.@{line}

I've also included however, as proof of concept, a working C source version of the RandomPlayer
in my doubtful C.@{line}







@endnode
@node "Requirements" "Requirements"
@{line}
@{_LMARG_}@{JCENTER}@{B}Requirements@{UB}
@{line}
@{_HLINE_}@{JLEFT}

I've developed Capture and tested it on an A1 800MHZ and Sam 440-flex, both with 1GB memory and Radeon 9250 video cards.@{line}

Most of the work was done on AmigaOS 4.1 SP2.@{line}

Both machines perform satisfactorily (assuming nothing else is running) on the example players here. Only system APIs are used, but little or no library version checking is included.@{line}

No testing has been done on other models or on AOS earlier than 4.1. No testing on the just released Classic Amiga version of AOS 4.1 (or on the A1 X1000 !)@{line}

May 8, 2011



@endnode
@node "Installing" "Installing"
@{line}
@{_LMARG_}@{JCENTER}@{B}Installing@{UB}
@{line}
@{_HLINE_}@{JLEFT}

Unpack the supplied Capture.lha file, which will create a directory tree "Capture" underneath the target directory.@{line}


@endnode
@node "Rules" "Rules"
@{line}
@{_LMARG_}@{JCENTER}@{B}Rules of the Game@{UB}
@{line}
@{_HLINE_}@{JLEFT}

The best documentation for this game of Capture is that directly provided for the Queue 2010 challenge.
Though they've moved on to a new game, as of now all their material for the 2010 game is still on-line. Their write-up of
the rules of the game and the format of the information that passes between the players
and the the game engine are well written and detailed.@{line}
See especially these URLs:
@{tab}@{" http://queue.acm.org.../main " SYSTEM "urlopen http://queue.acm.org/icpc/game_description/main.cfm"}@{line}
@{_TABS6_}@{" http://queue.acm.org.../rules " SYSTEM "urlopen http://queue.acm.org/icpc/game_description/rules.cfm"}@{line}
@{_TABS6_}@{" http://queue.acm.org.../environment " SYSTEM "urlopen http://queue.acm.org/icpc/game_description/environment.cfm"}@{line}

Let me know if these pages disappear and I can send you the information in them.@{line}

@{_HEADING_ "Differences from the Queue Descriptions"}@{line}
@{_ITM12_}@{i}Turn Time: @{ui}
The turn time runs at 100 msec as in the Queue description, but my implementation is
a bit more relaxed about the timing. In the Queue version, if a player does not respond
within 100 msec of the start of the turn, it simply continued the game without his move.@{line}

The Amiga version will wait a bit for a late response, but will simply end the game immediately
if it streches on to 250 msec.@{_ITEMEND_}

@{_ITM12_}@{i}Communication: @{ui} Instead of using standard input and output for communicating with the players, the Amiga version
uses separately named pipes, which works well and seemed to be necessary for performance.@{_ITEMEND_}




    


@endnode
@node "ExamplePlayers" "ExamplePlayers"
@{line}
@{_LMARG_}@{JCENTER}@{B}Example Players@{UB}
@{line}
@{_HLINE_}@{JLEFT}

To start things off, I've supplied a few sample players.@{line}

Players supplied:@{line}

@{_ITM48_}@{i}StaticPlayer @{ui}@{_TABS3_}Does null commands. This keeps out of the way to make it easier to see what your player is doing.@{_ITEMEND_}

@{_ITM48_}@{i}RandomPlayer @{ui}@{_TABS2_}Moves his sled and bumpers randomly. Should be easily beatable, but can disrupt your player by change.@{_ITEMEND_}

@{_ITM48_}@{i}RandomPlayer_C @{ui}@{_TABS2_}My attempt at implementing RandomPlayer in C instead of Modula-2.@{_ITEMEND_}

@{_ITM48_}@{i}RandomChasePlayer @{ui}@{tab}Moves his sled randomly, but sends his bumpers relentlessly chasing yours with no other
purpose than disrupting things.@{_ITEMEND_}

@{_ITM48_}@{i}HerdPlayer @{ui}@{_TABS3_}This player makes a real (though not clever) effort to use his sled and bumpers to effect. Observe him for a little while and you can see his unchanging strategy.@{_ITEMEND_}
@{_LRG_DENT}

@{b}Note@{ub}: even the HerdPlayer has a few seconds of random moving at the start, in order to avoid exact game duplicates
when playing this small number of opponents.@{line}


@endnode
@node "Running" "Running"
@{line}
@{_LMARG_}@{JCENTER}@{B}Running a Game@{UB}
@{line}
@{_HLINE_}@{JLEFT}

@{_HEADING_ "Capture"}

The template for the Capture program is @{_LRGDENT_}@{line}

@{b}-RedPlayer=-Red,-BluePlayer=-Blue,-Quiet/S,-TraceFile@{ub}
@{_LMARG_}@{line}

@{_ITM32_}"-Red"@{_TABS2_}name of executable to play red.@{_ITEMEND_}

@{_ITM32_}"-Blue"@{_TABS2_}name of executable to play blue.@{_ITEMEND_}

@{_ITM32_}"-Quiet"@{_TABS2_}run the game without any graphics display. This may make it slightly easier for the player programs
to meet the timing requirements.@{_ITEMEND_}

@{_ITM32_}"-Trace"@{_TABS2_}output a trace file. If running in Quiet mode, you will probably want the Capture engine to save a trace file.
You can use the CapturePlayback program to show the graphics after the game.@{_ITEMEND_}@{_LMARG_}

@{_HEADING_ "CapturePlayback"}

Template:@{tab}@{b}-InFile/A@{ub}@{line}

Used to playback a trace file produced by Capture. Will also do a fairly good job of playing back a trace file from the original Queue 2010 tournament.@{line}

I have included the trace file for the championship game in the LHA, but traces of all 192 tournament games are still on line as of now at:@{_LRGDENT_}@{line}

@{" http://queue.acm.org.../tournament.html " SYSTEM "urlopen http://queue.acm.org/challenge/2009/tournament/tournament.html"}@{line}

@endnode
@node "DevelopingPlayers" "DevelopingPlayers"
@{line}
@{_LMARG_}@{JCENTER}@{B}Developing Players@{UB}
@{line}
@{_HLINE_}@{JLEFT}

The player program needs to be a CLI program that receives the proper pipe names on its command line.@{line}

It should receive the game state, and then withing the 100 msec time calculate its move commands and write them out to the control pipe. It must handle the pipe communication efficiently in order to keep up with the specification timing.@{line}

As mentioned in the Queue documentation, the player program can assume that it is always playing Red. The Capture engine will adjust things before communication so that it is transparent if it is actually playing Blue.@{line}

The sources in Modula-2 and C for the sample players can server as a starting point for development.@{line}

@{_ITM12_}@{i}CLI Parameters: @{ui} The player program template is@{line}

@{b}-CmdPipeName=-cp/K,-StatePipeName=-sp/K@{ub}@{line}

The Capture engine will start your player and its command line will supply the pipe names for receiving the program state and sending your next set of commands.@{_ITEMEND_}

@{_ITM12_}@{i}State Pipe Buffer: @{ui} Quite a lot of data is transfered through the State pipe. For performance it is important to open the pipe itself with a large buffer (eg, 8192) and to call ADOS reads to read large chunks at a time.@{line}

@endnode
@node "Executables" "Executables"
@{line}
@{_LMARG_}@{JCENTER}@{B}Executables@{UB}
@{line}
@{_HLINE_}@{JLEFT}

    
@{_ITM12_}The example player programs, as listed @{"above" LINK "ExamplePlayers"}.@{_ITEMEND_}

@{_ITM12_}@{i}Capture @{ui}, the game controller and displayer.@{_ITEMEND_}

@{_ITM12_}@{i}CapturePlayback @{ui}, the trace file game displayer.@{_ITEMEND_}

@endnode
@node "Traces" "Traces"
@{line}
@{_LMARG_}@{JCENTER}@{B}Traces@{UB}
@{line}
@{_HLINE_}@{JLEFT}

@{_ITM12_}@{i}test.trace @{ui}, a sample game between RandomPlayer and HerdPlayer. @{" PlayIt... " SYSTEM "CapturePlayback Traces/test.trace"}@{_ITEMEND_}

@{_ITM12_}@{i}trace-Final.txt @{ui}, the Queue contest's final match for the championship.   @{" PlayIt... " SYSTEM "CapturePlayback Traces/trace-Final.txt"}@{_ITEMEND_}

@endnode
@node "Sources" "Sources"
@{line}
@{_LMARG_}@{JCENTER}@{B}Sources@{UB}
@{line}
@{_HLINE_}@{JLEFT}

Sources for all the software I used for developing this is included in the Capture.LHA (or the Aglet Modula-2 Compiler package or the Hyperion SDK).@{line}

@{_HEADING_ Capture itself}
Capture.MOD@{line}
CaptureDefs.DEF/MOD@{line}
CaptureSpecs.DEF/MOD@{line}
CaptureEngine.DEF/MOD@{line}
CaptureGraphics.DEF/MOD@{line}
CapturePlayerIO.DEF/MOD@{line}
CaptureComm.DEF/MOD@{line}
CaptureDebug.DEF/MOD@{line}
TraceFileIO.DEF/MOD@{line}
@{_LMARG_}

@{_HEADING_ CapturePayback}
CapturePlayback.MOD@{line}
<plus some modules from above>@{line}
@{_LMARG_}

@{_HEADING_ Example Player Programs}
StaticPlayer.MOD@{line}
RandomPlayer.MOD@{line}
RandomChasePlayer.MOD@{line}
HerdPlayer.MOD@{line}
@{_LMARG_}

@{_HEADING_ Player Library Routines}
PlayerLib.DEF/MOD@{line}
@{_LMARG_}
@{_LMARG_}

@{_HEADING_ "Aglet M2IDE Project Files"}
Capture.prj@{line}
CapturePlayback.prj@{line}
HerdPlayer.prj@{line}
StaticPlayer.prj@{line}
RandomChasePlayer.prj@{line}
RandomPlayer.prj@{line}
@{_LMARG_}

@{_HEADING_ C Player Software}
RandomPlayer.c@{line}
CaptureSpecs.h@{line}
ICPCPlayerLib.h/c@{line}
MyTypes.h@{line}
PipeIO.h/c@{line}  
@{_LMARG_}

@endnode
@node "Tournament" "This and That"
@{line}
@{_LMARG_}@{JCENTER}@{B}This and That@{UB}
@{line}
@{_HLINE_}@{JLEFT}

@{_ITM12_}@{i}Known Bugs: @{ui} The engine has been observed to occasionally pass one object right through another in situation when there are multi simultaneous collisions going on in the field.@{_ITEMEND_}

@{_ITM12_}@{i}Tournament: @{ui} I'm not contemplating running an "official" tournament with submissions and brackets as described in their docs. We could organize such a thing later if there is interest, and after bugs in the engine have been shaken out.@{line}

Meanwhile, the game engine is in the package. We can set up a repository of contributed players on OS4Depot if there is interest.@{line}

The engine source is in the archive in case anyone wants to improve or replace it.
@{_ITEMEND_}
@{_LMARG_}

Tom

Tom Breeden
tmb@virginia.edu

@endnode
