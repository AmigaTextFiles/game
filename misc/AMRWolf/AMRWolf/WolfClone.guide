@Database WolfClone
@Author Alastair M. Robinson
@Node Main "Title page"

  @{b}A Wolfenstein 3D Clone@{ub}
(This title is becoming less and less appropriate!)

  © copyright 1996 by @{"Alastair M. Robinson." link Author}

  Written partly in AMOSPro, with the calculations in machine code.

  This "final" release is just a work-in-progress snapshot of the project
  which i came across recently and decided to share.

  Compared with the previously released demo this version has a couple more
  levels, and also has the level editor and complete source.
  (In order to run the code in AMOSPro you'll need the GameSupport extension,
  uploaded separately, in slot 23.)


  @{"Legal stuff..." link Legal}

  @{"Requirements" link Requirements}

  @{"Controlling the `game'" link Controls}

  @{"About the Engine" link TheEngine}

  @{"Future plans" link WishList}

@Endnode

@Node Requirements "What do you need to run the engine."

  This engine requires only the AGA chipset, and an '020 or higher.  It has yet
to be tested on anything faster than a 40MHz '030, so if you have an '040 or '060
please let me know how it runs.
  FastRAM is not required but is highly recommended, since it makes the game much
faster, and more playable.  On a standard A1200 without fastram, the frame rate
is acceptable if you turn the floors and depth-cueing off.

The Icons I have provided may look more than a little strange under a standard
(Magic)WB palette.  For this reason, I have provided my own personal favourite
palette file, just so you can see what the icons are *supposed* to look like.
Just use one of ShoveColors type utilities with the palette file.

@EndNode

@Node Legal "Legal stuff regarding The program."

  THIS PROGRAM IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND.  ALL USE IS
AT YOUR OWN RISK, AND THE AUTHOR CANNOT BE HELD RESPONSIBLE FOR DAMAGES OF ANY
KIND, ARISING FROM THE USE OR MISUSE OF THE PROGRAM OR ANY OF ITS ACCOMPANYING
FILES.

Full source is provided.  Feel free to use any of the code or assets from AMRWolf
in non-commercial projects.  In the unlikely event that you want to use any of
my work in a commercial project, or need a specific license for an open-source
project, just get in touch.


@EndNode

@Node WishList "The future..."

  @{b}"Future" plans for this engine:@{ub}

  (15 years on, I no longer have any development plans for AMRWolf!
This text remains just for historical interest!)

  This engine will almost certainly become a game, hopefully reaching completion
by the end of the summer, and will probably be shareware.  I might also release
a level editor to go with it.
  I'm intending to make the gameplay as varied as possible, which will include
the possibility of taking several different routes through each level.  A cheif
criterion will be that the levels must make sense, i.e. everything must exist
for a @{i}reason. @{ui}

  Any comments or suggestions would be most welcome.

@Endnode

@Node TheEngine "Currently implemented features"

  My 3D engine uses the ray-casting system, as described by John Corigliano in
Steffen P. Haeuser's TMapFAQ, somewhere in the docs/misc directory of Aminet.
  Until I found this document on CU-Amiga's cover CD, I wouldn't have known how
even to begin programming a game of this type.
  I have also used the copper-chunky screen described in the same document.
I still think this looks better than blitter screens.  Besides, it's a real treat
to be able to use 12 bit High-Colour, even if the resolution is low.

  @{b}Basic features and details of this engine:@{ub}

  @{b}Textures:@{ub}  The current design permits 32 texture blocks (which are 64
pixels square.)  Of these, 16 are static textures, and the other 16 form two
animated textures of 8 frames each (the first animation slot is currently used
for the fans.)

  @{b}Objects:@{ub}  The rendering of objects in this engine is a huge cheat; an
object is drawn as though it is always facing the player.  (This method is
common to almost all games of this type.)  This was actually the most difficult
part of the entire engine to code in an efficient way.  My solution to the
problem is far from perfect, since the objects look like they're curved towards
the player.  I @{i}think @{ui}that a better solution would require that the
objects are taken separately from the map, but I'm not sure about this.  The
current method is certainly acceptable.

  @{b}Z-Buffer:@{ub}  Black areas of textures are treated as transparent, so
blocks with windows in them are possible.  Normally a ray for each column on
screen is cast into the world until it hits a block;  if the block has
transparency, the texture is stored in the z-buffer, and the ray cast further.
This was necessary to allow objects to be rendered in front of walls, so it
might as well be applicable to walls as well as objects.  It is interesting that
the only blocks you can `see round' in Wolfenstein are pillars, which would have
to be rendered as objects (i.e. always facing the player) anyway.

  @{b}Doors:@{ub}  The engine allows 32 stages of opening to be rendered.  Any
texture may be used as a door, so secret doors are no problem.  The door
attribute is not mutually exclusive with any other, so it would be perfectly
possible to have an animated door with a window in it!  Doors can only slide
sideways into an adjacent block; blocks which slide away from the player (à la
Wolfenstein's secret doors) are not supported.

  @{b}Realtime movement:@{ub}  All movements and animations in the demo are
independent of processor speed.  The fans may look a little jerky from a
distance (especially without fast ram) but I figured this was preferable to them
doubling in speed as you approach them!

  @{b}Floor Mapper:@{ub}  This is really a totally separate routine, not handled
by the ray caster - and it shows; the floor doesn't quite match up with the
walls, but I think the overall effect is pretty good.

  @{b}Explosions:@{ub}  When you shoot a barrel, it will explode and leave behind
a charred shell.  The explosions will now spread from barrel to barrel, so you
can set off a chain reaction by shooting the first barrel in a line.

  @{b}Switches:@{ub}  The switch handling code is now pretty well complete apart
from sound handling.

  @{b}Enemies:@{ub}  The enemy handling code is about half done at the moment;
currently supported are enemies which move towards the player, and static enemies
(used for the explosions, since they need to be @{i}in front @{ui}of the object
which is exploding.)

@Endnode

@Node Controls "Controlling the `game'"

  @{b}Controlling the `game'@{ub}

  Use the cursor keys or move the mouse horizontally to rotate left and right.
  The cursor up key can be used to move forward.
  The cursor down key will move you backwards.
  The left mouse button can be used to walk in either direction; while holding
down the button, move the mouse sharply towards you (about half an inch) to set
the direction to backwards.  The direction will be reset to forwards if you move
the mouse sharply away from you, or if you let go of the button.
  Use the right Amiga and Alt keys to sidestep left and right respectively.
  Holding the shift key will increase the speed at which you walk.
  Doors can be opened and switches operated with the space bar, or middle mouse
button (if applicable).
  Pressing the right mouse button or left alt key will play a machine gun sound
effect, and decrease the ammo counter.

  Please note: some of the following keybindings are out of date.  The map can
no longer be turned on and off at will; it's battery-powered.


  F1-2 sets the width of the screen, and F4-6 sets the Depth of field to match
screen widths 1-3.  Stand in front of a fan and play with these to see why I
included them.   These features are currently broken - I might fix them, I might
remove them.

  F3 toggles the view between any security cameras in the current level

  F4 returns to player view.

  F9 turns on the Depth Cueing effect, and F10 turns it off (for a slight but
noticable speed increase!)
  F7 turns on the floor, and F8 turns it off.
  You can't have a floor without depth cueing, and you can't turn off depth
cueing without turning off the floor as well.

  The Help key turns on the heads-up map, and the Del key removes it.
  The `+' and `-' keys (keyboard or numeric keypad) will allow you to zoom in and
out.

  The P key will pause the game, bring the workbench to the front and add an
appicon to the workbench screen.  Double-clicking on this icon will unpause the
game.

  Finally, the Escape key is used to quit.

  Most of these keys will be customisable in the near future.

@Endnode

@Node Author "About the Author"

Alastair M. Robinson

  The Old Chapel
   Syderstone
    Norfolk
     PE31 8SD
      United Kingdom

@Endnode

