                                ___
                _____  ___  ___(___) _____________      ______
             __/  __ \|   \/   |   |/ ______/  __ \____/   __/
              7    /  |     _  |   |  \__  7    /  |__/   __|__
              |   .   |  \  /  |   |    /  |   .   |  |        |
              |   |___|__|\/|__|___|\______|   |___|  |________|
              `---'                        `---'
                  _____________     ___ ______  _____  _____
                 / _______/ __ \.--|   |   __ \/    / /  __/
                 \_____ \7   /  |  |   |    /  \ |_/_|  __|__
                 /    '  |      |  |   |   .   < |   \       |
                 \_______|_____/|____,_|___|____)____/_______|
  
                     ...Mr Tickle of sPEARhEAD presents...
                                  E Audio v1.1
                            
-----------------------------------------------------------------------------

UPDATE NOTE!!

Improvements since v1.0:

  * Frequencies over 32767 now play correctly :)
  * Fixed nasty bug that set a wrong bit in DMACON. (Thanks to
    Jens Herhold for spotting this one)

To do:

  * IFF 8SVX loader
  * 8 bit WAV loader
  * Optimizations
  * Fix reported bugs
  
  (I actually have written routines that do this, but was too lazy to
  include them in this version :)
  
  
This is a little Amiga E module I knocked up because I wanted to easily add
sound to my programs. This module provides you with a simple command set
with which you can add sound to your Amiga E programs.

**NOTE** This module is 100% metal bashing code. Basically because
I dont like audio.device!

If your program is going to be a happy multitasking program, its probably
a good idea to open audio.device and allocate the channels you are going
to use with EAudio, just to make sure you dont mess up other sound producing
programs, but this is not compulsory.

OK, before you can play any samples, you must load some samples into chip
ram. If you are loading them from disk -> chip ram (recommended way of
doing it) just call loadRaw(), like this:

sampledata, samplelength:=loadRaw('PROGDIR:data/mylovelysample.raw')
IF(sampledata)
  ...
  ...
  ...
  Dispose(sampledata)
ENDIF

If you wish, you can write your own load routines (to load 8SVX etc.). If
your program does not contain a single loadRaw(), you MUST call "setup()",
as this sets up some variables ready for use by eaudio. If your program
contains loadRaw() anywhere, you dont need to call setup().

Once you have all your samples loaded into chip ram, you can play them
using "playData()" the arguments are:

playData(sampledata,samplelength,frequency,channels,volume)

sampledata   = A pointer to the sample to be played (in CHIP RAM!!)
samplelength = The length of the sample
frequency    = The playback frequency in hz (A-2 on Protracker = 13964)
channels     = This is which channel(s) you wish to play the sample in.
               This is decided by adding together the 4 channel ID constants
               in the module, e.g:
               
               CHAN_LEFT1+CHAN_RIGHT1
               
               would play in both left and right speakers. (you have two
               channels in each speaker)
volume       = Overall playback volume, from 0 to 64. (0= silent,
               64= Full volume)
               
This sample will now play over and over again, until you either:

A) Call stopChannels(), which basically halts all sounds in all specified
   channels, or
   
B) Call exitLoop(), which stops the sample at the end of the next loop.

exitLoop() cannot be called directly after playData(). It is recommended
that, for example, in a loop, exitLoop() is called before every
vertical blank, so that any sample played in that loop will only be played
once, e.g:

-> Plays a sample when user presses left mousebutton
REPEAT
  exitLoop(CHAN_LEFT1+CHAN_RIGHT1)
  WaitTOF()
  IF(Mouse() AND %001) THEN playData(sample,samplen,13964,CHAN_LEFT1+CHAN_RIGHT1,64)
UNTIL CtrlC()
stopChannels(CHAN_LEFT1+CHAN_RIGHT1)

Have fun,
Mr Tickle


-----------> A few notes to remember

* Never call exitLoop() DIRECTLY after playData(), at least leave some gap!
  It wont crash or anything, but the sample wont be played correctly.
  If a sample refuses to play correctly, try putting a WaitTOF() between
  the exitLoop() and playData() in question. If that solves it, the exitLoop
  is too near.
* Always load samples into chip ram if you arent using loadRaw()
* Always call stopChannels() at the end of the program for any channels
  used in your program, as this makes sure all audio DMA is halted.
  (exitLoop() doesnt actually stop the audio DMA...)
* Never specify a playback frequency of 0 (that wouldn't make any sense
  anyway)

