@database "Mancala"
@author Oliver Grätz
@(c) "©1994-96 Oliver Grätz"
@$VER: Mancala.guide 3.47
## 1. Oktober 1996

@node Main "Mancala"

              MANCALA
             ---------
       AmigaGuide für Mancala
  Mancala ist ©1994-95 Oliver Grätz
        Mancala ist Freeware

        @{" Rechtliches          " link Rechtliches}
        @{" Spielregeln          " link Regeln}
        @{" Installation         " link Installation}
        @{" Bedienung            " link Bedienung}
         @{" - Optionsfenster    " link Optionen}
         @{" - Spielertypen      " link Typ}
        @{" Partie-Editor        " link PEd}
        @{" ARexx-Befehle        " link ARexx}
        @{" Synchronisierung     " link Synchron}
        @{" Externe Spieler      " link Extern}
         @{" - Variablen         " link Vars}
         @{" - Befehle           " link Bef}
         @{" - Beispiel          " link Beispiel}
        @{" Das Executer-Utility " link Exec}

  Mancala wurde mit CanDo programmiert.

  CanDo ist © Copyright Inovatronics
  Workbench ist © Commodore Business Machines
  ARexx ist © Bill Hawes (Thank you ! Great !!!)
@endnode

## *** Spielregeln *********************************************

@node Rechtliches "Rechtliches"
  Das Rechtliche
 ----------------
 Dieses Programm und alle mitgelieferten Dateien
 sind Freeware mit den folgenden Einschränkungen:

 - Das Programmpaket darf immer nur komplett mit
   allen dazugehörigen Dateien kopiert werden.

 - An keiner der Dateien dürfen ohne meine vorherige
   Erlaubnis Veränderungen vorgenommen werden.

 - Wer Verbesserungsvorschläge hat oder es endlich geschafft hat,
   einen starken Computerspieler zu programmieren, soll sich bei mir
   unter der unten genannten Adresse melden. Sollte seine Arbeit
   Verwendung finden, wird er selbstverständlich als Co-Autor
   genannt.

 - Wenn dieses Paket auf Disketten weitergegeben wird, darf nur eine
   Aufwandsentschädigung verlangt werden. Auf keinen Fall darf dieses
   Paket auf Disketten weitergegeben werden, die mehr als DM 3,-- oder
   den entsprechenden Betrag in einer anderen Währung kosten.

 - Wird dieses Paket auf CD-ROM weitergegeben, darf der Preis
   der CD den Betrag von DM 40,-- oder den entsprechenden Betrag
   in einer anderen Währung nicht übersteigen.

 - Dieses Paket, auch nicht Teile daraus, dürfen nicht im Rahmen
   einer kommerziellen Veröffentlichung erscheinen, da dies die
   Nutzungsbestimmungen von CanDo (© Inovatronics) verbieten !
   Daran soll der folgende Text erinnern, der mit jedem
   CanDo-Programm ausgeliefert werden muß:

	This program was designed and written with CanDo v3.0 ©1995.

	Inovatronics, Inc.
	8499 Greenville Ave. #209B
	Dallas, TX  75231  USA
	(214)340-4991, FAX 340-8514

	CanDo, Deckbrowser and their support libraries are
	the copyrighted sole property of Inovatronics, Inc.
	Reproduction and distribution for any use other than
	non-commercial applications is strictly prohibited.

 Für weitere Fragen wenden Sie sich bitte an:

  Oliver Grätz
  Stemmering 46
  45259 Essen

  Sorry, nur snail-mail, hab' noch kein Modem !
@endnode
@node Regeln      "Spielregeln"
  Die Spielregeln
 -----------------
Mancala spielt man zu zweit auf einem Brett mit 12 Mulden und 2 Zielfeldern.
Dem ersten Spieler gehören die oberen 6 Mulden und das linke Zielfeld,
dem zweiten gehören die unteren 6 Mulden und das rechte Zielfeld.

  @{" Illustration des Spielfeldes " link Mancala.guide.Bild1/main} (Für Kickstart/Workbench 3.0)

  @{" Illustration des Spielfeldes " system "SYS:Utilities/WDisplay Mancala.guide.Bild1"} (Für Kick/WB 2.0 mit WDisplay)

Zu Beginn des Spiels liegen in jeder der 12 Mulden 4 Spielsteine.
Beide Spieler versuchen nun, im Verlauf des Spiels möglichst viele Spielsteine
in das eigene Zielfeld zu bringen, denn wer am Ende mehr hat, hat gewonnen.

Das Spiel beginnt, wenn der Spieler 1 eine der 12 Mulden mit der Maus anklickt.
Diese Mulde wird nun geleert und alle darin enthaltenen Spielsteine werden
gegen den Uhrzeigersinn in die anderen Mulden verteilt. Gelangt man dabei an
das eigene Zielfeld, wird der Spielstein hineingelegt und man hat einen Punkt.
Das Zielfeld des anderen Spielers wird beim Verteilen einfach übersprungen.

Zusätzlich zu diesem normalen Zugschema gibt es einige Sonderregeln.
Sollte der letzte Spielstein eines Zuges in das eigene Zielfeld fallen,
so ist der Spieler, der den Zug ausgeführt hat, nochmal dran.

Fällt der letzte Spielstein eines Zuges in eine leere Mulde, so wird
automatisch die darüber- bzw. darunterliegende Mulde ebenfalls ausgeleert
und für denselben Spieler gespielt. Landet der letzte wieder in einer
leeren Mulde, so wird auch diese gespielt und so weiter.

Ist der Zug beendet, ist der andere Spieler dran.
Das geht solange, bis oben oder unten alle Mulden leer sind.
Sind also zum Beispiel die oberen 6 Mulden leer (also die von Spieler 1),
so erhält Spieler 2 automatisch alle in den unteren Mulden übriggebliebenen
Spielsteine und das Spiel ist beendet. Man muß also aufpassen, seine eigenen
Mulden nicht zu leer werden zu lassen, denn auch der andere Spieler kann
diese leeren und so eventuell das Spiel zu seinen Gunsten beenden.
@endnode

## *** Installation ********************************************

@node Installation "Installation"
  Die Installation
 ------------------ 
 Die Installation braucht man nicht groß erklären.
 Schublade auf die Festplatte ziehen, fertig !
 Es gibt zwei Versionen des Programms.
 Welche sie benutzen sollten und warum, lesen sie weiter unten.



 Viel umfangreicher sind die Vorraussetzungen zum Start:

 Zunächst einmal eine schlechte Nachricht : Mancala braucht viel RAM.
 Mindestens 1,5 MB davon muß man in seinem Rechner haben, beser 2 MB.

 Jetzt eine noch schlechtere Nachricht: Die voll funktionsfähige Version
 von Mancala benötigt die Libraries von CanDo ! Diese haben immer noch
 keine wirklich eindeutigen Weitergabebestimmungen, weshalb sie in
 dieser Veröffentlichung nicht beiliegen.

 Da aber neben den Besitzern der Vollversion von CanDo und der Versionen
 von den AmigaPlus-Coverdisks und CDs wahrscheinlich auch noch viele die
 Dateien als Raubkopie auf ihrem Rechner haben, dürfte die Library-Version
 von Mancala dennoch ihre Zielgruppe finden ;-)

 Für diejenigen, die leider nicht die Library-Version verwenden können,
 gibt es noch das Programm "MancalaNoLib", bei dem dann leider keine
 externen Spieler verwendet werden können. Um diese Version zu verwenden,
 löschen Sie bitte die Datei "Mancala" und benennen dann "MancalaNoLib"
 um in "Mancala". Desweiteren können Sie die Programme "Partie-Editor"
 und "Executer" sowie die Schublade "Spieler" samt Inhalt löschen,
 denn diese Dateien benötigen ebenfalls die Library-Version.

 Alle Benutzer der Library-Version können "MancalaNoLib" löschen.



 Sehr wichtig :

 Die Dateien "Mancala.info" und "Partie-Editor.info" dürfen nicht umbenannt
 werden !!! Wenn man die Online-Hilfe nutzen möchte, muß nämlich der Pfad
 für die Datei "Mancala.guide", also diese Datei, bei den ToolTypes der
 beiden Icons unter "HilfsPfad=" eingetragen werden.
 Dazu klickt man das jeweilige Icon an und wählt "Informationen" aus dem
 "Piktogramm"-Menü der Workbench aus. Im erscheinenden Fenster klickt man
 auf "Neu" bzw. "New" und trägt dann "HilfsPfad=" gefolgt vom Pfad ein.
 Anschließend auf "Speichern" bzw. "Save" klicken. Fertig !
 Beispiel : "RAM:Texte/Mancala.guide" + Return + Speichern

 Im Icon des Hauptprogrammes kann man außerdem noch das ToolType
 "SynchronBefehl=" eintragen. Es definiert den Pfad für das
 Programm, das von der @{" Synchron-Funktion " link Synchron} aufgerufen wird.

 Außerdem sind für ein einwandfreies Arbeiten mit Mancala einige
 Dateien der Workbench nötig:

 - Der Font "Courier" sollte in Größe 13 installiert sein.
 - In ENVARC: bzw. ENV: sollte die Datei "palette.ilbm" stehen,
   die die Farben der Workbench definiert. Bei meiner Workbench
   macht das das "Palette" Programm aus der Prefs-Schublade.

 Außerdem muß, wenn Mancala auf der Workbench laufen soll, die Workbench
 mindestens 3 Bitplanes (8 Farben) haben und der Screen muß mindestens
 eine Größe von 640*400 Punkten haben. Es kann z.B. auch ein Screen
 mit dem Screenmode Hires-NonInterlaced sein, der autoscrollend ist.
 So kann man den Flimmerbildschirm umgehen. Erfüllt die Workbench
 diese Vorraussetzungen nicht, so wird ein Hires-Interlaced Screen
 mit 640*400 Punkten und 8 Farben geöffnet.

 Sind alle diese Vorkehrungen getroffen, kann Mancala problemlos per
 Doppelklick von der Workbench oder per Aufruf aus dem CLI gestartet werden.

 Für den Partie-Editor sollten exakt die gleichen Dateien verfügbar sein.

 Ach ja, Workbench 2.0 braucht man natürlich auch :-)
@endnode

## *** Menü Bedienung ******************************************

@node Bedienung "Bedienung"
  Die Bedienung
 ---------------
 Nachdem Mancala gestartet wurde, werden die gespeicherten Voreinstellungen
 geladen. Beim ersten Starten des Programmes wird sich der Screen in Rottönen
 einfärben. Mancala verändert die Farben des Workbenchscreens, allerdings
 werden diese beim Programmende wiederhergestellt.

 In der Mitte des Fensters ist das @{" Spielbrett " link Brett} zu sehen.

 Am unteren Rand des Fensters sind 6 Gadgets zu sehen :

 @{" NEUES SPIEL   " link Neu}    @{" SPIELREGELN   " link CallRegeln}    @{" ZURÜCKNEHMEN  " link Undo}
 @{" SPIEL BEENDEN " link Spielende}    @{" OPTIONEN      " link Optionen}    @{" PROGRAMMENDE  " link ProgEnde}

 Außerdem besitzt das Fenster noch 2 Menüs :

 Projekt                 Utilities
 ----------              ----------
 @{" Neues Spiel   " link Neu}         @{" Partie-Editor         " link CallPEd}
 @{" Spiel beenden " link Spielende}         @{" Hilfsmodus            " link CallHelp}
 @{" Programminfo  " link Info}         @{" Zug rückgängig machen " link Undo}
 @{" Greetings     " link Greet}
 @{" Programmende  " link ProgEnde}
@endnode

@node Brett      "Das Spielbrett"
@toc Bedienung
  Das Spielbrett
 ----------------
 Das Spielbrett besteht aus 12 runden Mulden und 2 eckigen Mulden.
 Die 2 eckigen sind die Zielfelder der beiden Spieler.
 Das linke gehört Spieler 1 und das rechte Spieler 2.
 Spielen kann man nur mit den 12 runden Mulden.
 Um eine Mulde zu spielen, wird sie einfach angeklickt.
@endnode
@node Neu        "Neues Spiel"
@toc Bedienung
  Neues Spiel
 -------------
 Menü-Aufruf  : Rechte Amiga-Taste + n
 ARexx-Befehl : CallNeu

 Das Spielbrett wird gelöscht und dann neu aufgebaut.
 Dann ist der linke Spieler am Zug (Spieler 1).
 Hiermit kann man nicht nur ein Neues Spiel beginnen, nachdem
 man das vorige beendet hat, sondern man kann ein laufendes
 Spiel abbrechen und sofort ein neues beginnen.
@endnode
@node Spielende  "Spielende"
@toc Bedienung
  Spiel beenden
 ---------------
 Menü-Aufruf  : Rechte Amiga-Taste + e
 ARexx-Befehl : CallSpielende

 Hiermit kann man ein bereits laufendes Spiel vorzeitig beenden.
 Die Steine in den beiden Zielmulden werden gezählt und ein
 Requester erscheint, in dem der Sieger bekanntgegeben wird.

 Wenn ein Mensch gegen den Computer gespielt hat, gibt der
 Computer in diesem Requester seinen Kommentar zur Partie.
@endnode
@node CallRegeln "Spielregeln"
@toc Bedienung
  Spielregeln
 -------------
 Hiermit wird, falls Mancala richtig @{" installiert " link Installation} wurde, der
 AmigaGuide von Mancala an der Stelle geöffnet, an der die
 @{" Spielregeln " link Regeln} für Mancala nachgelesen werden können.
@endnode
@node Info       "Programminfo"
@toc Bedienung
  Programminfo
 --------------
 Menü-Aufruf  : Rechte Amiga-Taste + i
 ARexx-Befehl : CallAbout

 Hiermit wird ein Fenster mit Namen und Adresse des Programmautors geöffnet.
 Zusätzlich ist hier auch die Version des Programmes, das Datum der
 Fertigstellung dieser Version und der Name des ARexx-Ports abzulesen.
 Bugreports und Vorschläge bitte mit der Versionsnummer
 und dem Datum an die angegebene Adresse schicken.
@endnode
@node Undo       "Zug rückgängig machen"
@toc Bedienung
  Zug rückgängig machen
 -----------------------
 Menü-Aufruf  : Rechte Amiga-Taste + u
 ARexx-Befehl : CallUndo

 Diese Funktion macht nicht nur einfach den letzten Zug rückgängig.
 Vielmehr verhält sie sich in gewisser Weise intelligent.

 Wenn zwei Menschen gegeneinander spielen,
 so wird einfach nur der letzte Zug rückgängig gemacht.
 Jeder der beiden Spieler kann also auch zum Beispiel
 eine Zugserie im Nachhinein anders gestalten.

 Spielt ein Mensch gegen den Computer, so werden so viele
 Züge rückgängig gemacht, wie der menschliche Spieler
 braucht, um SEINEN letzten Zug zu korrigieren.
 Würde man einfach nur den letzten Zug rückgängig
 machen und der Computer hatte gerade eine Serie, so
 ist nach dem Rückgängigmachen der Computer dran und
 der wird wahrscheinlich genau seinen Zug wiederholen.

 Spielen zwei Computerspieler gegeneinader, so
 bewirkt das Aufrufen dieser Funktion gar nichts.

 Man kann durch mehrmaliges Aufrufen dieser Funktion
 das Brett in den Anfangszustand zurücksezten.
@endnode
@node ProgEnde   "Programmende"
@toc Bedienung
  Programmende
 --------------
 Menü-Aufruf : Rechte Amiga-Taste + q

 Es wird eine Sicherheitsabfrage geöffnet, in der sich der
 Benutzer seine Entscheidung nochmal gründlich überlegen kann.
 Bestätigt er sein Entscheidung, wird das Mancala-Fenster bzw.
 der Mancala-Screen wieder geschlossen und die Originalfarben
 der Workbench werden wiederhergestellt.
@endnode
@node Greet      "Greetings"
@toc Bedienung
  Greetings
 -----------
 Menü-Aufruf  : Rechte Amiga-Taste + g
 ARexx-Befehl : CallGreetings

 Es erscheint ein Requester, in dem der Autor diversen
 Leuten für ihre Mithilfe oder ihre Ideen dankt.
@endnode
@node CallPEd    "Partie-Editor"
@toc Bedienung
  Partie-Editor
 ---------------
 Menü-Aufruf : Rechte Amiga-Taste + p

 Hiermit kann der @{" Partie-Editor " link PEd} aus Mancala heraus aufgerufen werden.
 Dazu muß die separate Datei "Partie-Editor" nicht vorhanden sein.
 Der Editor ist ins Hauptprogramm integriert.
@endnode
@node CallHelp   "Hilfsmodus"
@toc Bedienung
  Hilfsmodus
 ------------
 Menü-Aufruf : Rechte Amiga-Taste + h oder auch einfach die Help-Taste

 Hiermit wird in allen aktiven Fenstern von Mancala der Hilfsmodus
 aktiviert. Damit man das auch merkt, wird in allen Fenstern an
 den Fenstertitel die Bemerkung "(Hilfsmodus)" gehängt.

 Wenn man jetzt auf einen beliebigen Knopf in einem der Fenster klickt,
 erscheint der AmigaGuide (TM) von Mancala und zeigt die passende
 Information zum angeklickten Objekt an. Das funktioniert mit fast
 allen Objekten des gesamten Spiels.

 Natürlich bekommt man keine Hilfe zum Menüpunkt Hilfsmodus selbst !!!

 Achtung !!!
 Diese Funktion ist nur dann verfügbar, wenn in den ToolTypes
 ein korrekter Pfad für die Guide-Datei eingetragen ist !!
 Nähere Informationen siehe @{" Installation " link Installation}.
@endnode

## *** Menü Optionen *******************************************

@node Optionen "Optionen"
@toc Bedienung
  Optionen
 ----------
 Hiermit wird das Optionsfenster aufgerufen, in dem man zahlreiche
 Parameter des Programms verändern kann.

  @{" Illustration des Optionsfensters " link Mancala.guide.Bild3/main} (Für Kickstart/Workbench 3.0+)

  @{" Illustration des Optionsfensters " system "SYS:Utilities/WDisplay Mancala.guide.Bild3"} (Für Kick/WB 2.0 mit WDisplay)

 Rechts neben "Spieler 1 :" und "Spieler 2 :" sind zwei Stringgadgets,
 in die man Die Namen der beiden Spieler eintragen kann.

 Rechts daneben sind zwei sogenannte Cycle-Gadgets, mit denen
 man den @{" Typ " link Typ} des jeweiligen Spielers auswählen kann.

 Darunter steht bei "Extern 1:" bzw. "Extern 2:" jeweils ein Gadget :

 @{" LADEN                   " link LoadEx}

 Außerdem gibt es hier noch einige Gadgets :

 @{" Punktzahlen anzeigen    " link ShowPunkte}
 @{" Muldenbeschriftung      " link Beschriftung}
 @{" Zugverzögerung          " link Verzögerung}
 @{" Synchronisierung        " link Synchron}
 @{" EINSTELLUNGEN SPEICHERN " link Speichern}
 @{" BEENDEN                 " link QuitOpt}

 Ganz unten links ist noch ein Cycle Gadget zu sehen :

 @{" Farben                  " link Farben}

@endnode

## *** Menü Spielstärken ***************************************

@node Typ    "Spielertypen"
@toc Optionen
  Spielertypen
 --------------
 Neben dem menschlichen Spieler gibt es noch Computerspieler.
 Der Computer kennt drei interne Spielstärken, außerdem gibt
 es noch die Möglichkeit, externe Spieler zu laden.

 Menschliche Spieler
 @{" Mensch               " link Mensch}

 Interne Computerspieler
 @{" Computer (Normal)    " link Normal}
 @{" Computer (Gemein)    " link Gemein}
 @{" Computer (Taktik)    " link Taktik}

 Externe Computerspieler
 @{" Computer (Extern 1)  " link ExP}
 @{" Computer (Extern 2)  " link ExP}
@endnode

@node Mensch "Menschlicher Spieler"
@toc Optionen
  Mensch
 --------
 Der menschliche Spieler wird selbstverständlich von einer der
 Personen übernommen, die VOR dem Computer sind und nicht darin.
 Stellt man beide Spieler auf Mensch, so verhält sich Mancala
 wie ein einfaches Spielbrett. Es führt nur die Züge durch.
@endnode
@node Normal "Computerspieler : Normal"
@toc Stärke
  Normal
 --------
 In dieser Einstellung spielt der Computer noch sehr dumm.
 Er kann zwar in begrenztem Umfang schon einsammeln, hat
 aber noch arge Probleme, Taktiken zu erkennen oder gar
 zu durchkreuzen.
@endnode
@node Gemein "Computerspieler : Gemein"
@toc Stärke
  Gemein
 --------
 Dies ist die Weiterentwicklung von @{" Normal " link Normal}.
 Der Computerspieler kann jetzt sehr gut einsammeln.
 Er ist taktisch zwar immer noch sehr dumm, aber er versucht
 bereits rabiat, Einsammelmöglichkeiten des anderen Spielers
 zu verhindern.
@endnode
@node Taktik "Computerspieler : Taktik"
@toc Stärke
  Taktik
 --------
 Dieser Spieler ist nicht unbedingt immer besser
 als @{" Gemein " link Gemein}, er ist vollkommen anders konzipiert.
 Der Computerspieler kann hier am besten einsammeln.
 Er hat dann aber nachher eine vollkommen andere
 Taktik, den Zug zu beenden.
@endnode
@node ExP    "Computerspieler : Extern"
@toc Stärke
  Externer Spieler
 ------------------
 Man kann bis zu zwei externe Spieler einladen, die durch
 eine Textdatei definiert sind. Es gibt die Möglichkeit,
 zwei verschiedene externe Spieler einzuladen, damit auch
 ein Turnier zwischen verschiedenen selbstprogrammierten
 Spielern möglich ist.
@endnode

## *** Unterpunkte Optionen ************************************

@node LoadEx       "Externen Spieler laden"
@toc Optionen
  Laden
 -------
 Mit diesem Knopf kann ein Filerequester geöffnet werden.
 In diesem kann man dann eine Datei auswählen, die einen
 externen Spieler darstellt. Ist es tatsächlich ein
 externer Spieler, so wird die Datei geladen und es
 erscheint ein Kommentar neben dem Gadget.

 Mit dem oberen Knopf kann die Datei für den ersten externen
 Spieler ausgewählt werden, mit dem unteren die für den zweiten.

 Eine Anleitung, wie man einen externen Spieler programmiert,
 ist im Abschnitt @{" Externe Spieler " link Extern} zu finden.
@endnode
@node ShowPunkte   "Punktzahlen anzeigen"
@toc Optionen
  Punktzahlen anzeigen
 ----------------------
 Mit diesem Gadget kann die Anzeige der Punktzahlen der
 beiden Spieler während des Spiels abgeschaltet werden.

 Einige haben es gerne spannend bis zum Schluß,
 andere hingegen wollen immer voll im Bilde sein.

 Ist ein Häkchen zu sehen, so werden die Punkte angezeigt.
@endnode
@node Beschriftung "Muldenbeschriftung"
@toc Optionen
  Muldenbeschriftung
 --------------------
 Hiermit kann man wählen, ob an den Mulden die jeweilige
 Nummer der Mulde stehen soll. Dies ist sehr hilfreich,
 wenn man eine Analyse aus dem Partie-Editor nachvollziehen
 will oder aber z.B. durchs Telefon spielt.

 Ist ein Häkchen zu sehen, dann ist die Beschriftung an.
@endnode
@node Verzögerung  "Zugverzögerung"
@toc Optionen
  Zugverzögerung
 ----------------
 Wenn ein Zug ausgeführt wird, so gibt es beim Verteilen
 der Spielsteine auf die anderen Mulden jeweils eine Pause
 von etwa einer Zwanzigstel-Sekunde. Das soll helfen, bei
 einer Turbokarte die Züge noch verfolgbar zu machen.
 Hiermit kann man sie deaktivieren.

 Ist ein Häkchen zu sehen, so ist die Verzögerung eingeschaltet.
@endnode
@node Synchron     "Synchronisierung"
@toc Optionen
  Synchronisierung
 ------------------
 Diese Funktion kann eigentlich für fast alles benutzt werden.
 Das Wort Synchronisierung heißt, daß Mancala synchron zu
 allen Aktionen des Spiels ein vom Benutzer definiertes
 Programm startet und diesem die Aktionen übermittelt.

  Weitere Informationen
  @{" Anwendungsbeispiele       " link SynMög}
  @{" Installation              " link SynInst}
  @{" Format der Parameter      " link SynFormat}
  @{" Wann erfolgt der Aufruf ? " link SynWann}

 Hier sind die Parameter, die Mancala dem Programm übergeben kann :

  @{" Undo      " link SynUndo}
  @{" Neu       " link SynNeu}
  @{" Spielende " link SynSpielende}
  @{" Zug       " link SynZug}
@endnode
@node Speichern    "Einstellungen speichern"
@toc Optionen
  Einstellungen speichern
 -------------------------
 Mit diesem Knopf werden alle Einstellungen abgespeichert,
 die im Optionsfenster eingestellt werden können:

  - Die Spielernamen
  - Die Spielstärken der beiden Spieler
  - Die Definitionen für die externen Spieler
  - Die Wahl, ob die Punkte gezeigt werden sollen
  - Die gewählten Farben
@endnode
@node Farben       "Farben"
@toc Optionen
  Farben
 --------
 Mit diesem Cycle-Gadget kann man diverse Farbeinstellungen auswählen :

  Rottöne    - Alles in rot
  Grüntöne   - In grün und orange
  Blautöne   - Alles in blau
  Graurot    - Workbench-Grau mit rot
  Brauntöne  - Dunkle Brauntönung
  Workbench  - Original-Workbenchfarben

 Der Punkt Workbench setzt voraus, daß die Datei "ENV:sys/palette.ilbm"
 existiert. Ich arbeite mit Workbench 2.1, und da speichert das Programm
 "Palette" aus der Prefs-Schublade diese Datei ab. Ich weiß allerdings
 nicht, wie dies bei anderen Workbenchversionen geht.
 Existiert die Datei nicht, so werden häufig verwendete Workbench-Farben
 angezeigt, die hoffentlich ebenfalls den gewünschten Effekt erzielen.
@endnode
@node QuitOpt      "Optionen Beenden"
@toc Optionen
  Beenden
 ---------
 Hiermit wird das Optionsfenster wieder geschlossen.
 Der Knopf hat die gleiche Funktion wie das Close-Gadget des Fensters.
@endnode

## *** Synchron-Unterpunkte ************************************

@node SynMög       "Anwendungsbeispiele"
@toc Synchron
  Was geht ?
 ------------
 Hier nur einige der vielen Anwendungsmöglichkeiten :

 - Man läßt ein ARexx-Skript automatisch ein
   Protokoll aller Aktionen anfertigen.

 - Man kann per ARexx-Skript über Netzwek oder Nullmodem an
   zwei verschiedenen Computern Mancala gegeneinander spielen.

 - Man kann per Zufall Bilder, Samples oder ähnliches
   in die Partie einblenden und sie so auflockern.

 Wahrscheinlich gibt es eine Menge Möglichkeiten,
 die mir jetzt auf Anhieb gar nicht einfallen !
@endnode
@node SynInst      "Installation"
@toc Synchron
  Installation der Synchron-Funktion
 ------------------------------------
 Um die Synchron-Funktion zu nutzen, muß im Icon von
 Mancala das ToolType "SynchronBefehl" eingetragen werden.
 Dieser Befehl wird dann mit den jeweiligen Parametern
 aufgerufen. Am sinnvollsten ist es, hier ein DOS-Skript
 oder ein ARexx-Skript aufzurufen.

 Beispiele :

  SynchronBefehl=C:Execute S:Synchron.bat

  SynchronBefehl=RX Rexx:Synchron.rexx

  SynchronBefehl=SYS:System/Format drive DH0: name "Leer" noicons ffs
  (Hä ?????)
@endnode
@node SynFormat    "Format der Parameter"
@toc Synchron
  Das Format
 ------------
 Dem vom Benutzer im Icon festgelegten Programm, welches
 selbstverständlich auch ein ARexx-Skript sein kann, werden
 Parameter in einem festgelegten Format übergeben.

 Zuerst kommt immer die Nummer des ARexx-Ports des aufrufenden Mancalas.
 Wenn also auf einem Computer mehrere Mancalas laufen und auf
 dem zweiten wird ein Zug durchgeführt, so wird als erster
 Parameter eine 2 übergeben.

 Es folgt das Parameterwort, das die Art der Aktion auf dem aufrufenden
 Mancala erklärt. Wurde ein neues Spiel gestartet, so steht hier "Neu".

 Danach kommen je nach Aktion noch diverse weitere Parameter.

 Beispiel:
 Die Parameter sehen so aus : "1 Zug 2 8"
 Man interpretiert das dann wörtlich zum Beispiel so :
 "Das 1. Mancala meldet Zug von Spieler 2 auf Feld 8"

 Man trennt die Ergebnisse mit ARexx genauso
 wie die Antworten auf eine "Get..." Anfrage.
 Siehe : @{" Wie kommt man an die Ergebnisse ? " link AErgs}
@endnode
@node SynWann      "Wann erfolgt der Aufruf ?"
@toc Synchron
  Wann erfolgt der Aufruf ?
 ---------------------------
 Das definierte Programm wird aufgerufen,
 BEVOR die gemeldete Aktion tatsächlich stattfindet.

 Dies ist bei einer Neztwerkverbindung vorteilhaft, da man so
 keine Zeit verliert, bis die Information ihr Ziel erreicht.

 Laufen allerdings zwei miteinander verbundene Mancalas auf EINEM
 Rechner (mit ARexx-Skript verbunden), so führt ein sofortiges
 Durchführen der gemeldeten Aktion auf dem zweiten Mancala nur
 zu einem totalen Zusammenbruch der Systemperformance, da
 Mancala sehr rechenintensiv sein kann.

 Außerdem werden per ARexx aufgerufene Aktionen NICHT
 zurückgemeldet, um eine Endlosschleife zu vermeiden :
 Auf Mancala.1 wird auf "Neu" geklickt, Meldung kommt, ARexx sendet,
 Mancala.2 führt auch Neu aus, Meldung kommt, ARexx sendet,
 Mancala.1 führt wieder Neu aus, Meldung kommt, und so weiter.
 Dies würde zum Endlosaufruf von Neu führen.
@endnode
@node SynUndo      "Undo"
@toc Synchron
  Undo
 ------
 Komplett : <Portnummer> Undo

 Es wurde die Funktion @{" Undo " link Undo} aufgerufen.
@endnode
@node SynNeu       "Neu"
@toc Synchron
  Neu
 -----
 Komplett : <Portnummer> Neu

 Es wurde die Funktion @{" Neues Spiel " link Neu} aufgerufen.
@endnode
@node SynSpielende "Spielende"
@toc Synchron
  Spielende
 -----------
 Komplett : <Portnummer> Spielende

 Das Spiel wurde beendet und der Sieger ermittelt.
@endnode
@node SynZug       "Zug"
@toc Synchron
  Zug
 -----
 Komplett : <Portnummer> Zug <Spieler> <Feld>

 Einer der Spieler hat einen Zug gemacht.
 Es folgt die Nummer des Spielers, der den Zug gemacht hat.
 Steht hier eine 1, so war es der linke Spieler, bei einer 2 der rechte.
 Zuletzt kommt schließlich das Feld, das gezogen wurde.

 Hinweis :
 Mit Zug sind nur solche Züge gemeint, bei denen einer der Spieler
 eine der 12 Mulden gewählt hat. Eventuell automatisch nachfolgende
 Züge werden nicht gemeldet, da sie selbstverständlich sind.
 Auch ein eventuell per Netz empfangendes Mancala wäre wohl
 kaum der Meinung, ein automatisch nachfolgender Zug im Stil
 "Letztes Feld leer, also gegenüber" muß im noch extra gesagt
 werden; es ist schließlich nicht dumm !
@endnode

## *** Partie-Editor Hauptmenü *********************************

@node PEd        "Partie-Editor"
  Der Partie-Editor
 -------------------
 Der Partie-Editor kann sowohl aus Mancala heraus als auch seperat
 gestartet werden. In beiden Fällen erscheint das gleiche Fenster.

  @{" Illustration des Partie-Editors " link Mancala.guide.Bild2/main} (Für Kickstart/Workbench 3.0)

  @{" Illustration des Partie-Editors " system "SYS:Utilities/WDisplay Mancala.guide.Bild2"} (Für Kick/WB 2.0 mit WDisplay)

 Links ist eine @{" Liste " link PListe} zu sehen, die eventuell auch leer sein kann.
 Rechts neben dieser Liste ist eine Reihe von Gadgets zu sehen :

 @{" EDITOR BEENDEN        " link QuitPEd}   @{" POSITION HERSTELLEN   " link Herstellen}
 @{" PARTIE LADEN          " link PLaden}   @{" AB HIER WEITERSPIELEN " link AbHier}
 @{" PARTIE SPEICHERN      " link PSpeichern}   @{" Partie abhören        " link Hören}

 Darunter gibt es noch ein Gadget :

 @{" ZUGLISTE AUSGEBEN NACH >>> " link PAusgabe}

 Rechts daneben ist ein Cycle-Gadget zu sehen. Es wechselt zwischen
 "Drucker" und "Datei" und ist wichtig für das linke Gadget.

 Unten rechts ist eine @{" Miniaturausgabe des Spielfelds " link PMini} zu sehen.

 Das Gadget "Partie abhören" ist nur anwählbar, wenn
 der Partie-Editor aus Mancala heraus aufgerufen wurde.
@endnode

@node PMini      "Miniaturausgabe des Spielfelds"
@toc PEd
  Spielfeld
 -----------
 In diesem kleinen Spielfeld werden Positionen einer Partie dargestellt,
 wenn man auf den Knopf @{" POSITION HERSTELLEN " link Herstellen} klickt.

 Zur besseren Übersicht sind hier statt der entsprechenden Zahl
 Spielsteinen Zahlen zu sehen. Eine 8 heißt also, daß hier acht
 Spielsteine liegen.

 Damit man nicht während eines Spiels schummelt, ist die
 Herstellen-Funktion während eines Spiels gesperrt.
@endnode
@node PListe     "Liste"
@toc PEd
  Liste
 -------
 In der Liste werden die Züge einer Partie dargestellt.
 Ein Zug wird in der folgenden Form dargestellt :

  Zugnummer : Spieler - Feld

 Also z.B. "34:2-9", was bedeutet,
 daß im 34. Zug Spieler 2 Feld 9 gespielt hat.

 Ein Doppelklick auf die Liste bewirkt dasselbe wie ein
 Anklicken des Knopfes @{" POSITION HERSTELLEN " link Herstellen}.
@endnode
@node QuitPEd    "Editor beenden"
@toc PEd
  Editor beenden
 ----------------
 Hiermit kann der Partie-Editor wieder verlassen werden.
 Der Knopf hat die gleiche Funktion wie das Close-Gadget des Fensters.
@endnode
@node PLaden     "Partie laden"
@toc PEd
  Partie laden
 --------------
 Es wird ein Filerequester geöffnet, in dem eine Partie-Datei ausgewählt
 werden kann. Diese Datei wird geladen und falls es sich tatsächlich um
 eine Partie-Datei handelt, wird die Zugliste der Partie in die Liste
 geschrieben. Gleichzeitig wird der Abhörmodus abgeschaltet.
@endnode
@node PSpeichern "Partie speichern"
@toc PEd
  Partie speichern
 ------------------
 Es wird ein Filerequester geöffnet, in dem ein Dateiname ausgewählt
 werden kann. Der Inhalt der Liste und alle Brettpositionen der Partie
 werden in diese Datei abgespeichert.
@endnode
@node PAusgabe   "Zugliste ausgeben nach >>>"
@toc PEd
  Zugliste ausgeben nach >>>
 ----------------------------
 Wenn das Cycle-Gadget auf "Drucker" steht, wird der Inhalt
 der Liste nach "PRT:", also auf den Drucker ausgegeben.

 Steht das Cycle-Gadget auf "Datei", erscheint ein Filerequester,
 in dem ein Dateiname ausgewählt werden kann.
 In diese Datei wird dann der Inhalt der Liste als ASCII-Text ausgegeben.
@endnode
@node Herstellen "Position Herstellen"
@toc PEd
  Position Herstellen
 ---------------------
 Dieses Gadget ist nur anwählbar, wenn der Abhörmodus ausgeschaltet ist
 oder aber momentan keine Partie läuft. Es ist also immer anwählbar,
 wenn der Partie-Editor ohne Mancala gestartet wurde.

 Klickt man auf dieses Gadget und ist in der Liste am linken Fensterrand
 ein gültiger Zug angewählt, so wird das Miniatur-Spielbrett am unteren
 Fensterrand auf den Status des echten Spielbrettes dieser Partie NACH
 dem angewählten Zug gebracht.

 Wenn es nicht anwählbar ist, läuft gerade eine Partie, und wir wollen ja
 nicht, daß jemand sich die Anzahl der Steine in den Mulden im Klartext
 ansieht und daraus einen Vorteil hat.

 Die gleiche Funktion wie dieser Knopf hat auch ein Doppelklick
 auf eine Zeile der @{" Liste " link PListe} auf der linken Seite des Fensters.
@endnode
@node AbHier     "Ab hier weiterspielen"
@toc PEd
  Ab hier weiterspielen
 -----------------------
 Dieses Gadget hat eigentlich zwei Funktionen.
 In jedem Fall muß man zunächst aus der Liste einen Zug auswählen.
 Betätigt man dann das Gadget, folgt eine Sicherheitsabfrage, nach
 der dann, falls man bejaht, folgendes passiert :

 Ist @{" Partie abhören " link Hören} eingeschaltet, so wird die Partie auf die
 Brettposition nach dem gewählten Zug zurückgesetzt. Hiermit
 kann man mehrere Aufrufe von @{" Zurücknehmen " link Undo} ersetzen.

 Ist "Partie abhören" aber ausgeschaltet, und das ist das eigentliche
 Highlight dieser Funktion, so stellt Mancala das Spielbrett so wieder
 her, wie es nach dem gewählten Zug aussah und man kann weiterspielen.
 So kann man alte abgespeicherte Partien auch nach Jahren noch
 "wiederbeleben" und zu Ende spielen oder anders enden lassen.

 ACHTUNG :
 Bei einigen älteren abgespeicherten Partien wurde eine wichtige
 Information noch nicht mit abgespeichert. Bei diesen Partien
 funktioniert die Funktion leider nicht ordnungsgemäß.
@endnode
@node Hören      "Partie abhören"
@toc PEd
  Partie abhören
 ----------------
 Dieses Gadget ist nur anwählbar, wenn der Partie-Editor
 aus Mancala heraus aufgerufen wurde.

 Ist hier ein Häkchen zu sehen, ist das Gadget also angewählt,
 so wird die momentan laufende Mancala-Partie abgehört.

 Das heißt folgendes:

 Nach jedem Zug merkt sich der Partie-Editor, welches Feld
 gespielt wurde, und wie das Spielbrett nach dem Zug aussah.
 Der Zug wird im Format "Zugnummer : Spieler - Feld" in
 die Liste getippt.

 Nach dem Ende der Partie kann man diese Daten dann abspeichern.
@endnode

## *** ARexx Hauptmenü *****************************************

@node ARexx            "Der ARexx-Port"
  Der ARexx-Port
 ----------------
 Mancala bietet dem Benutzer einen ARexx-Port.
 Der Name des Ports ist normalerweise "Mancala.1".
 Startet man mehr als ein Mancala auf einmal, so heißt
 der Port des zweiten Mancala's "Mancala.2" und so weiter.

 Die zur Verfügung gestellten Befehle unterteilen sich in zwei Gruppen :

  1. Information
  @{" GetSpielStatus  " link AGetSpielStatus}
  @{" GetSpielertypen " link AGetSpielertypen}
  @{" GetBrett        " link AGetBrett}
  @{" GetPunkte       " link AGetPunkte}
  @{" GetSummen       " link AGetSummen}
  @{" GetAmZug        " link AGetAmZug}
  @{" GetAufBrett     " link AGetAufBrett}
  @{" GetEvenPoint    " link AGetEvenPoint}

  2. Aktionen
  @{" CallZug         " link ACallZug}
  @{" CallUndo        " link ACallUndo}
  @{" CallSpielende   " link ACallSpielende}
  @{" CallNeu         " link ACallNeu}
  @{" CallAbout       " link ACallAbout}
  @{" CallGreetings   " link ACallGreetings}
  @{" CallPause       " link ACallPause}

 Zusätzlich für ARexx-Anfänger einige kurze Informationen :

 @{" Wie kommt man an die Ergebnisse ? " link AErgs}
@endnode
@node AErgs            "Wie kommt man an die Ergebnisse ?"
@toc ARexx
  Ergebnisse
 ------------
 Wenn man Mancala mit einem der "Get..." Befehle anspricht,
 bekommt man die einzelnen Ergebnisse nicht getrennt, sondern
 auf einem Haufen zurück. Man muß sie dann erst noch trennen.
 Wie man das anstellt, ist in folgendem Beispiel zu sehen :

  /* Ein Beispiel */
  address 'Mancala.1'                     <-- Mancala ansprechen
  options results                         <-- Ergebnisse einschalten
  getpunkte                               <-- Befehl abschicken
  parse var result punkte1 punkte2        <-- Ergebnis trennen
  say "Spieler 1 hat "punkte1" Punkte."   <-- Ausgabe
  say "Spieler 2 hat "punkte2" Punkte."   <-- Ausgabe

  Die Zeile "parse..." geht so :
  "parse" ist der Befehl zum Trennen eines Textes.
  "var" bedeutet, daß man eine Variable trennen will.
  "result" ist der Name der Variable.
  "punkte1" und "punkte2" sind die Namen der beiden Ergebnisvariablen.
@endnode
@node AGetSpielStatus  "ARexx - GetSpielStatus"
@toc ARexx
  GetSpielStatus
 ----------------
 Aufruf   : GetSpielStatus

 Ergebnis : Status 

 Funktion :

 Hiermit kann man feststellen, ob gerade ein Spiel läuft.
 Ist Status 0, so läuft kein Spiel, bei 1 läuft ein Spiel.
@endnode
@node AGetSpielertypen "ARexx - GetSpielertypen"
@toc ARexx
  GetSpielertypen
 -----------------
 Aufruf   : GetSpielertypen

 Ergebnis : Typ1 Typ2

 Funktion :

 Es werden die Typen der beiden Spieler zurückgegeben.
 Mögliche Ergebnisse für jede der Rückgabevariablen
 sind "Mensch" und "Computer".
@endnode
@node AGetBrett        "ARexx - GetBrett"
@toc ARexx
  GetBrett
 ----------
 Aufruf   : GetBrett

 Ergebnis : Feld1 Feld2 [...] Feld11 Feld12

 Funktion :

 Als Ergebnis werden 12 Zahlenwerte zurückgegeben, welche
 die Anzahl der Spielsteine in den 12 Mulden darstellen.
 Feld 1 ist oben links, Feld 6 oben rechts,
 Feld 7 unten links und Feld 12 unten rechts.
@endnode
@node AGetPunkte       "ARexx - GetPunkte"
@toc ARexx
  GetPunkte
 -----------
 Aufruf   : GetPunkte

 Ergebnis : PunkteSpieler1 PunkteSpieler2

 Funktion :

 Es werden zwei Zahlenwerte zurückgegeben, wobei der erste die
 Punktzahl von Spieler 1 und der zweite die von Spieler 2 ist.
@endnode
@node AGetSummen       "ARexx - GetSummen"
@toc ARexx
  GetSummen
 -----------
 Aufruf   : GetSummen

 Ergebnis : SummeOben SummeUnten

 Funktion :

 Ergibt die Anzahl aller Steine in den sechs oberen bzw. unteren Mulden.
@endnode
@node AGetAmZug        "ARexx - GetAmZug"
@toc ARexx
  GetAmZug
 ----------
 Aufruf   : GetAmZug

 Ergebnis : AmZug

 Funktion :

 Hiermit kann man feststellen, welcher Spieler gerade dran ist.
 Ist AmZug 1, so ist der linke Spieler dran, bei 2 der rechte.
@endnode
@node AGetAufBrett     "ARexx - GetAufBrett"
@toc ARexx
  GetAufBrett
 -------------
 Aufruf   : GetAufBrett

 Ergebnis : AnzahlSteine

 Funktion :

 Ergibt die momentane Anzahl aller Steine in den 12 Mulden.
@endnode
@node AGetEvenPoint    "ARexx - GetEvenPoint"
@toc ARexx
  GetEvenPoint
 --------------
 Aufruf   : GetEvenPoint

 Ergebnis : EvenPoint

 Funktion :

 Ergibt die Anzahl Punkte, die man für ein Unentschieden benötigt.
 Normalerweise ist sie 24, da bei 4 Steinen pro Mulde und 12 Mulden
 maximal 48 zu holen sind. Also ist bei 24 Punkten das Unentschieden
 sicher. Das muß aber in späteren Versionen von Mancala nicht zwingend
 so sein, also ist das Benutzen dieses Befehls zu empfehlen.
@endnode
@node ACallZug         "ARexx - CallZug"
@toc ARexx
  CallZug
 ---------
 Aufruf   : CallZug <Feld>

 Beispiel : CallZug 4

 Funktion :

 Mit Feld wird eine Zahl von 1 bis 12 übergeben.
 Sollte in der angegebenen Mulde mindestens ein
 Stein liegen, so wird der Zug ausgeführt.
 Wurde kein Feld übergeben oder ist die Mulde leer,
 so wird per Zufall ein Feld ausgewählt und gezogen.
@endnode
@node ACallUndo        "ARexx - CallUndo"
@toc ARexx
  CallUndo
 ----------
 Aufruf   : CallUndo

 Funktion :

 Es wird die @{" Undo-Funktion " link Undo} aufgerufen.
@endnode
@node ACallSpielende   "ARexx - CallSpielende"
@toc ARexx
  CallSpielende
 --------------
 Aufruf   : CallSpielende

 Funktion :

 Das Spiel wird beendet und der Gewinner bekanntgegeben.
@endnode
@node ACallNeu         "ARexx - CallNeu"
@toc ARexx
  CallNeu
 ---------
 Aufruf   : CallNeu

 Funktion :

 Es wird die Funktion @{" Neues Spiel " link Neu} aufgerufen.
@endnode
@node ACallAbout       "ARexx - CallAbout"
@toc ARexx
  CallAbout
 -----------
 Aufruf   : CallAbout

 Funktion :

 Das @{" Programminfo-Fenster " link Info} wird angezeigt.
@endnode
@node ACallGreetings   "ARexx - CallGreetings"
@toc ARexx
  CallGreetings
 ---------------
 Aufruf   : CallGreetings

 Funktion :

 Das @{" Greetings-Fenster " link Greet} wird angezeigt.
@endnode
@node ACallPause       "ARexx - CallPause"
@toc ARexx
  CallPause
 -----------
 Aufruf   : CallPause <Minuten> <Sekunden> <Jiffies>

 Beispiel : CallPause 0 5 0

 Funktion :

 Veranlaßt das ARexx-Skript und das angesprochene Mancala,
 die angegebene Zeit zu warten und nichts zu tun.
 Dies ist sehr nützlich, wenn man zwei synchrone Mancalas auf einem
 Rechner laufen hat. Da Mancala sehr CPU-intensiv sein kann, muß man
 verhindern, daß beide Mancalas gleichzeitig zu rechnen versuchen,
 und so den Rechner total lahmlegen.

 Die Zeit ist in Minuten, Sekunden und Jiffies anzugeben.
 Ein Jiffy ist 1/Bildfrequenz Sekunden lang, also
 bei PAL 1/50 Sekunde und bei NTSC 1/60 Sekunde.
@endnode

## *** Externer Spieler Hauptmenü ******************************

@node Extern    "Externe Spieler"
  Externe Spieler
 -----------------
 Im @{" Options-Fenster " link Optionen} gibt es die Möglichkeit, sogenannte externe Spieler zu
 laden. Dies sind Textdateien, die ein kleines Stück Programm enthalten.
 Dieses Stück Programm ermittelt, welches Feld der externe Spieler spielt.

 Hier alles über die Erstellung eines externen Spielers :

   @{" Was braucht man ?       " link Nötig}
   @{" Das Format der Datei    " link Format}
   @{" Programmaufbau          " link Aufbau}
   @{" Die Variablen           " link Vars}
   @{" Die wichtigsten Befehle " link Bef}
   @{" Ein Mini-Beispiel       " link Beispiel}
@endnode

## *** Externer Spieler Unterpunkte ****************************

@node Nötig     "Was braucht man ?"
@toc Extern
  Was braucht man ?
 -------------------
 Um einen externen Spieler zu programmieren, braucht man all das NICHT :

  - eine Programmiersprache
  - Assemblerkenntnisse
  - 4 Megabyte RAM
  - Dampfwalze

 Stattdessen reicht schon folgende Ausstattung :

  - ein Texteditor
  - Basic-Kenntnisse
  - 512 Kilobyte RAM
  - Tastatur

 Genauer gesagt, wenn man ein Programm hat, mit dem man Texte schreiben
 kann und mit dem man diese Texte dann auch noch im ASCII-Format
 abspeichern kann, ist man schon einen Schritt weiter.

 Wenn man irgendwann einmal mit Basic in Kontakt kam und damit ein
 vielleicht nur klitzekleines Programm geschrieben hat, und wenn dieses
 Programm dann auch noch funktioniert hat, hat man gute Chancen, auch
 die zweite Vorraussetzung zu erfüllen.

 Die restlichen Vorraussetzungen sollen nur zeigen, daß man auch auf
 solchen Computern einen Spieler programmieren kann, auf denen Mancala
 selbst überhaupt nicht läuft.

 Alle Vorraussetzungen erfüllt ? Na dann ran ans Programmieren !!!
@endnode
@node Format    "Externe Spieler - Dateiformat"
@toc Extern
  Format der Datei eines externen Spielers
 ------------------------------------------
 Das Format der Textdatei, mit der der Spieler definiert wird,
 ist denkbar einfach. Die ersten zwei Zeilen müssen bestimmte
 Kommentare enthalten, danach folgt der Programmtext :

     Nop; Mancala.Extern
     Nop; <Kommentar>
     <Befehle>
      ...

 Die erste Zeile ist nötig, um Mancala mitzuteilen, das die Datei
 tatsächlich einen Computerspieler enthält. Sie muß genauso am
 Anfang stehen.

 Die zweite Zeile enthält nach dem Leerzeichen einen Kommentar von
 bis zu 43 Zeichen Länge. Dieser erscheint im @{" Optionsfenster " link Optionen} rechts
 neben dem Gadget @{" LADEN " link LoadEx}. Hier kann man dem Computerspieler einen
 Namen geben und noch eine kurze Beschreibung oder den Namen des
 Autors anhängen.

 Ab der dritten Zeile folgt der Programmtext.
 Wie dieser aufgebaut sein muß, steht bei @{" Programmaufbau " link Aufbau}.
@endnode
@node Aufbau    "Programmaufbau"
@toc Extern
  Aufbau des Programms
 ----------------------
 Das Programm stellt einen basic-ähnlichen Text dar, an desse Ende in
 der Variable F eine Zahl von 1 bis 12 stehen muß , die definiert,
 welches Feld der Computerspieler spielen will.

 Dabei sind die Mulden auf dem Spielfeld wie folgt numeriert :

      1   2   3   4   5   6

      7   8   9  10  11  12

 Die Mulde oben links ist also Mulde 1, die unten rechts Mulde 12.

 Typischerweise wird während des Programmablaufs in Schleifen geprüft,
 wieviele Steine in einem bestimmten Feld liegen oder mit ähnlichen
 Methoden ein virtueller Zug durchgeführt. Man prüft vielleicht auch
 noch, ob man dem Gegner keine gute Zugmöglichkeit gibt, wenn man einen
 bestimmten Zug durchführt.

 Ein Problem gibt es für den Programmierer momentan noch :
 Es ist nicht ohne weiteres möglich, Unterroutinen zu erstellen.
 Daher muß der gesamte Spieler am Stück programmiert werden. Sorry :-(
 Sollte einer der CanDo-Programierer dies lesen :
 Bitte schick mir Infos zum internen Aufbau der undokumentierten Befehle.

 Um überhaupt einen Überblick über das momentane Spielfeld zu haben,
 muß man natürlich diverse Werte in vordefinierten Variablen vorfinden.
 Wie diese Variablen heißen und was drinsteht, ist unter @{" Die Variablen " link Vars}
 nachzulesen.
@endnode
@node Vars      "Die Variablen"
@toc Extern
  Die Variablen
 ---------------
 Um sich auf dem momentanen Spielbrett zurechtzufinden, muß man natürlich
 wissen, wieviele Spielsteine in jeder einzelnen Mulde liegen usw.
 Dazu stehen diverse Variablen zur Verfügung, in denen diese Werte stehen.
 Ich bitte jeden Programmierer eines externen Spielers, diese Variablen nur
 zu LESEN. Wenn man sie einfach verändert, entsteht ein nicht kalkulierbares
 Chaos auf dem Spielbrett und ein normales Spielen wird unmöglich.

 Hier die einzelnen Variablen :

   @{" AmZug            " link vAmZug}
   @{" AufBrett         " link vAufBrett}
   @{" EvenPoint        " link vEven}
   @{" Brett[]          " link vBrett}
   @{" Summe[]          " link vSumme}
   @{" Spieler[].Punkte " link vPunkte}
@endnode

@node vAmZug    "AmZug"
@toc Vars
  AmZug
 -------
 Format   : Let <Var>=AmZug

 Beispiel : Let X=AmZug

 Ergibt 1, wenn der erste und 2, wenn der zweite Spieler dran ist.
@endnode
@node vAufBrett "AufBrett"
@toc Vars
  AufBrett
 ----------
 Format   : Let <Var>=AufBrett

 Beispiel : Let X=AufBrett

 Ergibt eine Zahl zwischen 1 und 48, die angibt, wieviele
 Spielsteine sich momentan noch auf dem Brett befinden.
@endnode
@node vEven     "EvenPoint"
@toc Vars
  EvenPoint
 -----------
 Format   : Let <Var>=EvenPoint

 Beispiel : Let X=EvenPoint

 Ergibt beim Standardspiel (in jeder Mulde liegen zu Beginn 4 Steine)
 immer den Wert 24. Man sollte sich aber nicht darauf verlassen, denn
 es könnten in einer der nächsten Versionen auch mehr oder weniger
 Steine pro Mulde sein.
 Die Variable heißt EvenPoint, weil man beim Erreichen dieser Punktzahl
 ein Unentschieden sicher hat, bei mehr Punkten hat man gewonnen.
@endnode
@node vBrett    "Brett[]"
@toc Vars
  Brett[]
 ---------
 Format   : Let <Var>=Brett[<1 bis 12>]

 Beispiel : Let X=Brett[3]

 Ergibt je nach der Zahl zwischen 1 und 12 die Anzahl der
 Spielsteine in der jeweiligen Mulde. Die Mulde oben links
 ist Mulde 1, die oben rechts Mulde 6, die unten links
 Mulde 7 und die unten rechts Mulde 12.

 Sollte eine andere Zahl außer denen von 1 bis 12
 angegeben werden, erzeugt dies eine Fehlermeldung.
@endnode
@node vSumme    "Summe[]"
@toc Vars
  Summe[]
 ---------
 Format   : Let <Var>=Summe[<1 oder 2>]

 Beispiel : Let X=Summe[1]

 Summe[1] ergibt die Anzahl aller Spielsteine in den oberen
 und Summe[2] die aller Spielsteine in den unteren 6 Mulden.

 Sollte eine andere Zahl außer 1 oder 2 angegeben werden,
 erzeugt dies eine Fehlermeldung.
@endnode
@node vPunkte   "Spieler[].Punkte"
@toc Vars
  Spieler[].Punkte
 ------------------
 Format   : Let <Var>=Spieler[<1 oder 2>].Punkte

 Beispiel : Let X=Spieler[1].Punkte

 Spieler[1].Punkte ergibt die Punkte des ersten (linken) Spielers und
 Spieler[2].Punkte ergibt die Punkte des zweiten (rechten) Spielers.
 Bei 24 Punkten ist ein Unentschieden sicher,
 bei 25 oder mehr hat man schon gewonnen.
 Danach kann man taktieren (27 ? Dann ist sowieso alles egal !).

 Sollte eine andere Zahl außer 1 oder 2 angegeben werden,
 erzeugt dies eine Fehlermeldung.
@endnode

@node Bef         "Die wichtigsten Befehle"
@toc Extern
  Die wichtigsten Befehle
 -------------------------
 Das Programm wird in der internen CanDo-Sprache geschrieben.
 Diese Sprache ist dem normalen Basic sehr ähnlich, trotzdem
 gibt es kleine Abweichungen. Deshalb hier eine Erklärung der
 aller wichtigsten Befehle für die Programmierung eines
 externen Spielers :

   @{" Nop                     " link bNop}
   @{" Let                     " link bLet}
   @{" =IfThen()               " link bIfThen}
   @{" =Random()               " link bRandom}
   @{" If..ElseIf..Else..EndIf " link bIf}
   @{" Loop..Until             " link bLoop}
   @{" ExitLoop                " link bExitLoop}
   @{" ExitScript              " link bExitScript}
@endnode
@node bNop        "Nop"
@toc Bef
  Nop
 -----
 Format   : Nop ; <Kommentar>

 Beispiel : Nop ; Dies ist ein Kommentar !

 Der Befehl Nop ist der Nichts-Befehl.
 Hiermit kann man Kommentarzeilen erzeugen.
 Kommentarzeilen sollte jeder Programmierer verwenden,
 um sein eigenes Programm auch noch nach mehr als einer
 Woche zu kapieren und ändern zu können.
@endnode
@node bLet        "Let"
@toc Bef
  Let
 -----
 Format   : Let <Var>=<Wert>

 Beispiel : Let X=Brett[3]+4

 Mit Let kann einer Variablen ein Wert zugewiesen werden.
 Dabei kann man natürlich für <Wert> nicht nur Zahlen
 einsetzen, sondern man kann eine komplexe Formel
 verwenden, in der andere Variablen und auch
 Funktionsaufrufe stattfinden können.

 Beispiele für Funktionsaufrufe sind @{" =IfThen() " link bIfThen} und @{" =Random() " link bRandom}.
@endnode
@node bIfThen     "=IfThen()"
@toc Bef
  =IfThen()
 -----------
 Format   : Let <Variable>=IfThen(<Bedingung>,<Wahr-Wert>,<Falsch-Wert>}

 Beispiel : Let X=IfThen(AmZug=1,1,12)

 IfThen ist eine vereinfachte einzeilige Variante der Konstruktion
 "If..ElseIf..Else..EndIf". Man kann einer Variable einen von zwei
 Werten zuweisen. Ist die Bedingung erfüllt (z.B. 3=2+1), so wird
 der Variable der Wahr-Wert zugewiesen, ansonsten der Falsch-Wert.

 Dabei kann man natürlich für <Wahr-Wert> bzw. <Falsch-Wert> nicht
 nur Zahlen einsetzen, sondern man kann eine komplexe Formel verwenden,
 in der andere Variablen und auch Funktionsaufrufe stattfinden können.
 Man kann sogar als Wert eine erneute IfThen-Funktion benutzen.
 Man kann das ganze nahezu unbegrenzt verschachteln
 (Spaghetti-Code läßt grüßen !!!).
@endnode
@node bRandom     "=Random()"
@toc Bef
  =Random()
 -----------
 Format   : Let <Variable>=Random(<Von>,<Bis>)

 Beispiel : Let X=Random(1,12)

 Hiermit kann man der Variablen eine Zufallszahl im Bereich
 von <Von> bis <Bis> zuweisen. (Schlauer Satz !?!!??!?)

 Für <Von> und <Bis> kann man natürlich wieder Formeln
 verwenden wie bei @{" Let " link bLet}.
@endnode
@node bIf         "If..ElseIf..Else..EndIf"
@toc Bef
  If..ElseIf..Else..EndIf
 -------------------------
 Format : If <Bedingung>        Beispiel : If AmZug=1
           <Befehle>                        Let Y=Random(1,6)
          ElseIf <Bedingung>               Else
           <Befehle>                        Let Y=Random(7,12)
          Else                             EndIf
           <Befehle>
          EndIf

 Eine Bedingung ist ein Vergleich von zwei Werten.
 So ist zum Beispiel 3=2+1 wahr und 5=6+4 unwahr.
 Die beiden Werte können natürlich wieder so aussehen wie bei @{" Let " link bLet}.

 Ist die Bedingung bei If erfüllt, so werden die
 nachfolgenden Befehle abgearbeitet.
 Ansonsten wird die Bedingung bei ElseIf überprüft.
 Ist diese erfüllt, so werden die dort folgenden Befehle abgearbeitet.
 Es können beliebig viele ElseIf's folgen.
 Trifft keine aller Bedingungen zu, so werden die
 Befehle hinter Else abgearbeitet.

 Man kann natürlich ElseIf, Else oder beides auch weglassen.
@endnode
@node bLoop       "Loop..Until"
@toc Bef
  Loop..Until
 -------------
 Format : Loop                Beispiel : Let Z=1
           <Befehle>                     Loop
          Until <Bedingung>               Let F=Random(1,12)
                                          Let Z=Z+1
                                         Until Z=11

 Mit Loop lassen sich Schleifen erzeugen.
 Mit dem obigen Beispiel werden nacheinander zehn Zufallszahlen
 zwischen 1 und 12 gezogen und der Variablen F zugewiesen.
 Das ist zawr unsinnig aber ein gutes Beispiel 8-D.

 Nach dem Loop folgen die Befehle innerhalb der Schleife.
 Immer, wenn das Until erreicht wird, wird überprüft,
 ob die Bedingung wahr ist (Bedingung siehe @{" If " link bIf}).
 Ist sie wahr, so wird die Schleife verlassen.

 Um ein For...Next wie in Basic zu realisieren, muß man
 wie im Beispiel eine Zählvariable (hier Z) verwenden
 und diese bei jedem Schleifendurchlauf erhöhen.

 Es gibt noch mehr Schleifenkonstrukte.
 So wird bei While..EndLoop am Anfang eine Bedingung überprüft,
 und nur wenn diese wahr ist, wird die Schleife überhaupt betreten.
 Mit While..Until lassen sich ganz exotische Schleifen programmieren.

 Ein Sonderfall ist Loop..EndLoop.
 Diese Endlosschleife läßt sich nur mit @{" ExitLoop " link bExitLoop} verlassen.
 Es geht natürlich auch @{" ExitScript " link bExitScript}.
@endnode
@node bExitLoop   "ExitLoop"
@toc Bef
  ExitLoop
 ----------
 Format : ExitLoop

 Hiermit wird eine momentan laufende Schleife verlassen
 und die Abarbeitung des Programms am ersten Befehl nach
 dem Schleifenende (z.B. nach dem Until) fortgesetzt.
@endnode
@node bExitScript "ExitScript"
@toc Bef
  ExitScript
 ------------
 Format : ExitScript

 Hiermit wird das Programm verlassen.
 Fällt einem vielleicht überhaupt kein guter Zug ein,
 so kann man hiermit einfach aus dem Programm springen.
 Mancala berechnet dann einen zufälligen Zug.
@endnode

@node Beispiel "Ein Mini-Beispiel"
@toc Extern
  Beispiel eines externen Spielers
 ----------------------------------
 Zum Abschluß des Kurses "Wie programmiert man einen externen Spieler ?"
 ist an dieser Stelle das Listing eines externen Spielers abgedruckt,
 der früher einmal in Mancala integriert war. Der Spieler ist zwar nicht
 besonders spielstark, aber ein gutes Beispiel zur Programmierung.
 Die Zeilennummern dienen nur der Orientierung in der Erklärung :

  1    Nop; Mancala.Extern
  2    Nop; Anfänger (von Oliver Grätz)
  3    Let Z=IfThen(AmZug=1,1,12)
  4    Loop
  5      If Brett[Z]=IfThen(AmZug=1,Z,13-Z)
  6        Let F=Z
  7        ExitLoop
  8      EndIf
  9      Let Z=Z+IfThen(AmZug=1,1,-1)
 10    Until Z=IfThen(AmZug=1,7,6)
 11    If F=0
 12      Loop
 13        Let F=Random(1,12)
 14      Until Brett[F]>0
 15    EndIf

 Zeile 1 muß genauso sein. Zeile 2 enthält einen kurzen Kommentar.
 Zeile 3 setzt den Anfangszähler der Schleife, je nachdem, welcher
 Spieler dran ist, auf 1 oder 12. Bei Spieler 1 fängt man mit Feld 1
 an, bei Spieler 2 mit Feld 12. In Zeile 4 beginnt die Schleife.
 In Zeile 5 wird überprüft, ob im Feld Z genausoviele Steine liegen,
 wie das Feld vom eigenen Zielfeld entfernt ist, was ja dazu führen
 würde, daß man nochmal dran ist. Erklärung der Überprüfung :
 Ist z.B. Spieler 2 dran, dann ist Z beim ersten Mal ja gleich 12.
 Feld 12 (unten rechts) ist genau 1 Feld vom Zielfeld von Spieler 2
 entfernt. Also müssen In Brett[12] genau 13-12 (13-Z), also 1 Stein
 liegen. Stimmt der Vergleich aus dem If-Befehl, so wird das zu ziehende
 Feld F in Zeile 6 auf den aktuellen Schleifenzähler gesetzt und in
 Zeile 7 die Schleife verlassen, da man ja das richtige gefunden hat.
 Zeile 8 ist das Ende der If-Abfrage. In Zeile 9 wird Z je nach Spieler
 um eins erhöht oder erniedrigt. Bei Spieler 2 wurde mit 12 angefangen,
 also muß man um eins senken, um sich vom eigenen Zielfeld zu entfernen.
 In Zeile 10 ist das Schleifenende. Hier wird überprüft, ob die Schleife
 schon sechsmal durchlaufen wurde. Diese Schleife wird nur sechsmal
 durchlaufen, weil nach dem Feld, das sechs Felder vom eigenen Zielfeld
 entfernt ist, das gegnerische Zielfeld kommt, und sich dann auch die
 Feldnummer wieder ändern. Bei Spieler 2 ist Feld 7 sechs Felder entfernt,
 Feld 1 ist 7 Felder entfernt. Wollte man die Schleife also noch erweitern,
 so würde sich die Schleife noch komplizierter gestalten.
 Nach der Schleife wird in Zeile 11 überprüft, ob die Schleife überhaupt
 ein günstiges Feld ergeben hat. Ist aber F immer noch gleich 0, war die
 Suche erfolglos. In diesem Falle wird in den Zeilen 12 bis 14 solange
 ein Feld per Zufall ausgewählt, bis in der ausgewählten Mulde mindestens
 ein Spielstein liegt, denn leere Felder kann man nicht spielen.
 In Zeile 15 endet diese If-Abfrage.
 Die Zeilen 11 bis 15 könnte man sich sparen, denn ergibt der externe
 Spieler einen ungültigen Zug (z.B. F=13 oder F=3 und Brett[3]=0), so
 wird sowieso per Zufall ein Feld ausgewählt.
@endnode
@node Exec     "Das Executer-Utility"
  Das Zuastzprogramm "Executer"
 -------------------------------
 Das Programm Executer ist für die Synchron-Funktion von
 Mancala im speziellen und für AmigaDOS allgemein nützlich.

 Systemvoraussetzungen:
  Dieses Programm benötigt OS 2.0 oder höher, da es die
  Notify()-Funktion des neuen Betriebssytems nutzt.
  Außerdem muß die CanDo-Library installiert sein.

 Starten:
  Einfach aufrufen oder doppelklicken.

 Nach dem Start wird ein kleines Fenster geöffnet.
 Ab jetzt wird das Verzeichnis RAM: überwacht.
 Sobald dort eine Datei namens "Executer.skript"
 hinkopiert wird, wird der Execute-Befehl auf die Datei
 angewandt und die Datei danach sofort wieder gelöscht.

 Man kann damit also ein Programm starten, indem man eine Datei kopiert.
 Diese Datei kann leicht über ein Netzwerk geschickt werden, wo es doch
 oft so schwer ist, am anderen Netzende AUF dem anderen Rechner ein
 Programm zu starten. Es gibt zwar viele andere Lösungen hierfür,
 aber dieses Programm löst das Problem sehr elegant und ist noch
 dazu nur 904 Bytes groß !!!
@endnode
