IMPLEMENTATION MODULE SkakBrain; (* (c) E.B.Madsen, DK 1991      Rev 26/1-97.01 *)

(* 1-97 CheckSkak2 disabled, CheckSkak optimized                          *)
(*      GetD now for both White and Black (to optimize SkakKey.CalcMunde) *)
(*      (GetNextDB,GetNextTilDB included to handle black)                 *)
(*      Testing more advanced GetD approach, (OK)                         *)
(* 2-97 GetV,GetD,GetNextTilV,GetNextD,GetNextTilD moved to SkakBrainX,OK *)
(* 46k stack overrun on lv 1, create a max-stack detect, OK               *)
(* 4-97 Now corrected to see stalemates correctly as draws,OK             *)
(* 4-97 Now checks move repetition to avoid/claim draw (only 3-in-row     *)
(*      generated by engine detected). It gives a stronger engine, OK     *)
(*      Now moved PreProcess,PreProcessor and Eval to a separate module   *)
(*      Now moved InitTeo and Init to SkakBrainX, arrays moved to .def    *)
(*      Now made Spil a POINTER to avoid >64K global variables            *)
(*      Now prefers mate in fewest moves, skips rest when mate in one     *)
(*      or skips deepening when mate (in >1 and Level>1)                  *)
(*      Now only extend Eval when chess in LAST move (faster levels>1)    *)
(*      Now statical evaluation of own attacked pieces, Black ONLY!       *)
(* 5-97 Now FindTrk will evaluate position when depth=0                   *)
(*      Now QFind will give small bonus/penalties for attack(ed) pieces   *)
(*      Now pd is colour-sensitive, adjusted pd data                      *)
(* 6-97 Now pd correct set to pdw and pdb                                 *)
(*      Now pawn endgame code. Now small bonus if in move.                *)
(*      GetNextTil: Slag for enpassant markeres IKKE for sort, bør laves  *)
(*      Now take en-passant is working in QFind                           *)
(*      Now promotion to knight again in QFind                            *)
(*      Now up one level when < about 50 positions analyzed               *) 
(* 3-98 Now fixed problem with level 2+3 (beta disabled in Find)          *)
(*      Now fewer hard-cutoffs and better 'rollback' if it happens (time) *)
(*      Now alpha cut in Eval (about 3-6% faster), WORKING                *)
(*      Now better k+p endgames (A or H file pawns only = draw if king in *)
(*      the corner), use king better to support pawns promotion.          *)
(* 4-98 Eval: Queen not in front of a unmoved center pawn                 *)
(*            Kings positions, better development og king-side            *)
(*                                                                        *)

(*$ DEFINE Stamp:=FALSE *) 
(*$ DEFINE Test :=FALSE *) (* HUSK at Stamp:=FALSE når ikke-test. DESUDEN:     *)
(*$ DEFINE Test0:=FALSE *) (* HUSK at Test:=TRUE i Eval for at WRITEF virker   *)
(*$ DEFINE Chks :=FALSE *)
(*$ DEFINE True :=TRUE  *) (* For at kunne enable/disable kommenterede procs *)
(*$ DEFINE False:=FALSE *) (* For at kunne enable/disable kommenterede procs  *)

(*$ DEFINE Tst:=FALSE   *)

(*$ LongAlign:=TRUE StackParms:=FALSE CStrings:=TRUE LargeVars:=FALSE *)
(*$ IF Chks *)
  (*$ Volatile:=FALSE StackChk:=TRUE RangeChk:=TRUE OverflowChk:=TRUE
  NilChk:=TRUE EntryClear:=FALSE CaseChk:=TRUE ReturnChk:=TRUE *)
(*$ ELSE *)
  (*$ Volatile:=FALSE StackChk:=FALSE RangeChk:=FALSE OverflowChk:=FALSE
  NilChk:=FALSE EntryClear:=FALSE CaseChk:=FALSE ReturnChk:=FALSE *)
(*$ ENDIF *)

FROM SYSTEM IMPORT
  BYTE,ADR,TSIZE,SHIFT;

FROM Arts	IMPORT	Assert;

FROM FileSystem IMPORT
  File, FileMode, FileModeSet, Lookup, Close, ReadChar, Response,
  WriteChar;

FROM Heap IMPORT
  Allocate, Deallocate;

FROM VersionLog IMPORT
  LogVersion;

FROM RandomBetter IMPORT
  RND;

FROM SkakBase IMPORT
  HvisTur, MaxTeori, TraekNr, MaxTraek, STILLINGTYPE, TFra, TTil;

FROM SkakBrainEval IMPORT
 ValueT,ValueR,ValueM,ValueK,ValueD,ValueL,ValueS,ValueB,ValueE,
 OpenGame,EndGame, pd, pdw, pdb,
 Vis,PreProcessor,Eval,
 matr,posi,wbonus,bbonus,
 Depth,WRITEF,WRITELNF,TestFil,ToFile;

IMPORT SkakBrainEval; (* to get SkakBrainEval.Evals *)

(*$ IF Test *)
FROM W IMPORT
   WRITE,WRITELN,CONCAT,c,s,l,lf,b,READs,Buf;
(*$ ENDIF *)

(*$ IF Stamp *)
IMPORT W;
FROM IntuitionL IMPORT
  CurrentTime;
FROM String IMPORT
  Copy, Length, Concat,ConcatChar;
FROM Conversions IMPORT
  ValToStr;
(*$ ENDIF *)

(* Profiler ved Tænk/List/Ryk/Load20:

Anteil|    Prozedur selbst:  |    Prozedur gesamt:  |  Anzahl  | Prozedur
  %   |   Zeit   |Zeit/Aufruf|   Zeit   |Zeit/Aufruf|  Aufrufe |
------+----------+-----------+----------+-----------+----------+---------

Tænk:

 36.1 |    843.4 |      0.68 |    843.4 |      0.68 |     1237 | Eval
 14.1 |    329.3 |      0.08 |    329.3 |      0.08 |     4116 | GetNextTil
 13.6 |    317.0 |      0.12 |    317.0 |      0.12 |     2577 | CheckSkak
  9.3 |    216.7 |      2.23 |   2661.2 |     27.44 |       97 | Find
  7.8 |    182.7 |      0.07 |   1167.6 |      0.44 |     2669 | GetNext
  5.4 |    125.3 |      0.05 |    501.0 |      0.19 |     2577 | IkkeSkak
  3.0 |     69.8 |      0.05 |     69.8 |      0.05 |     1346 | DoMove

List (Søg Stilling):

 52.4 |   1124.6 |      0.08 |   1124.6 |      0.08 |    13522 | GetNextTil
 19.0 |    408.5 |      0.06 |   1842.7 |      0.26 |     7185 | GetNextQ
 15.2 |    327.3 |      0.62 |    327.3 |      0.62 |      526 | still
  6.4 |    137.0 |      0.24 |   2186.5 |      3.89 |      562 | GetMove
  1.4 |     30.6 |      0.05 |     30.6 |      0.05 |      568 | DoMove
  1.2 |     25.3 |      0.37 |     25.3 |      0.37 |       69 | Equal

Ryk:

 31.3 |    231.2 |      0.06 |    231.2 |      0.06 |     3584 | GetNextTilV
 21.9 |    161.9 |      0.05 |    161.9 |      0.05 |     3220 | GetNextTilD
 17.6 |    130.0 |      2.60 |    443.5 |      8.87 |       50 | GetV
 13.4 |     98.7 |      0.04 |    336.1 |      0.13 |     2514 | GetNextD
  4.9 |     36.5 |      0.73 |    430.5 |      8.61 |       50 | GetD
  2.6 |     19.0 |      0.11 |     19.0 |      0.11 |      171 | CheckSkak

Load20:

 51.4 |   1723.4 |      0.07 |   1723.4 |      0.07 |    23932 | GetNextTil
 26.5 |    887.4 |      0.05 |   3156.1 |      0.17 |    18182 | GetNextQ
  9.6 |    322.4 |      0.30 |   3977.1 |      3.74 |     1062 | GetMove
  3.1 |    102.3 |      0.06 |    102.3 |      0.06 |     1652 | GetNextTilV
  2.7 |     89.9 |      0.06 |     89.9 |      0.06 |     1512 | GetNextTilD
  1.8 |     60.9 |      2.18 |    201.4 |      7.19 |       28 | GetV
  1.7 |     55.7 |      0.05 |     55.7 |      0.05 |     1066 | DoMove
*)

(*               PROCEDURER :

GetNextD (FLYTTET TIL SkakBrainX)
   finder næste (hvide) dækning i stillingen, fra=89 når ikke flere
GetNextDB (FLYTTET TIL SkakBrainX)
   finder næste (sorte) dækning i stillingen, fra=89 når ikke flere
GetD (FLYTTET TIL SkakBrainX)
   finder Dominans (felter) for hvide brikker
GetV (FLYTTET TIL SkakBrainX)
   finder værdi (munde) for hvide brikker
GetNextTilV : (FLYTTET TIL SkakBrainX)
   næste trækmulighed med nuværende HVIDE brik, til=fra -> til=89 når ikke flere
GetNextTilD : (FLYTTET TIL SkakBrainX)
   finder næste dækning med nuværende HVIDE brik, til=fra -> til=89 når ikke flere
GetNextTilDB : (FLYTTET TIL SkakBrainX)
   finder næste dækning med nuværende SORTE brik, til=fra -> til=89 når ikke flere
InitTeo (FLYTTET TIL SkakBrainX)
  Intitierer mikro-teori, der laver 1'ste træk med random
Init (FLYTTET TIL SkakBrainX)
  Initierer træk/værdi-tabeller

GetNextTil :
   finder s/h næste træk med nuværende brik, til=fra -> til=89 når ikke flere
   Beregner desuden MoveType som bruges i DoMove og IkkeSkak
DoMove
   udfører (Hvidt/Sort) træk, der i forvejen er valideret OK.
   underforvandling er sat til: 20 mindre så Tårn, 30 så Springer, 40 så Løber.
   MoveTyp SKAL sættes til enpassant og rokade når relevant!!!
DoMoveC
  som DoMove, men kræver IKKE MoveTyp information
CheckSkak
   checker om felt n er truet af sort/hvid.
IkkeSkak
   checker om (hvidt/sort) træk er ulovligt p.gr.a. skak eller over/fra skak.
   MoveTyp SKAL sættes til rokade og pat når relevant!!!
GetNext
   finder næste (hvide/sorte) træk i stillingen, fra=89 når ikke flere
Mirror
   Spejler stilling, så sort/hvid byttes rundt
DoMoveOk
   fuldstændigt check af om (s/h) træk er ok, genererer sort/hvide træk med DoMove
QSortTrk
  Sorterer en liste af træk efter værdi (størst først?)
Equal
  Compare for alle data-typer (også StrVAR med StrCONST, men IKKE StrVar)
still
  opsætter en stilling udfra en streng (st='' giver udgangsstilling)
DoMoveC
  som DoMove, men kræver IKKE MoveTyp information
Find
  recursiv træk-generator/bedømmer
NEq
  sammeligner om to stillinger er ens (NotEqual) bruges af Mikroteori
FindTrk
  StartStub for Find
ClearHistory
 clears engine history data 3* array: cnt=1-4,black=colour 

PreProcess (FLYTTET TIL SkakBrainEval)
  sets the pd array to default positional values
PreProcessor (FLYTTET TIL SkakBrainEval)
  adjusts the pd-array+OpenGame+EngGame according to the actual position.
Eval (FLYTTET TIL SkakBrainEval)
  Evaluerer en stillings værdi

     PROCEDURE OVERSIGT : if () then in SkakKey,
                          if {} then in SkakBrainX.
                          if [] then in SkakBrainEval

     (CalcMunde)__________{GetV} ______________________________ {GetNextTilV}
                \_________{GetD} ______________ {GetNextD} ____ {GetNextTilD}
                 \________Mirror

     GetMoveNr____
                  \
     GetMove_      \
             \      \
     DoMoveOk_\______\_ GetNext ____________ GetNextTil
               \________ DoMove       \_____ IkkeSkak _____ CheckSkak
     DoMoveC
               _________{InitTeo}
     {Init}___/     
                  _____[PreProcessor]______[PreProcess]
                 /
     FindTrk  __/______ Find _______________ (AEM)
                               \____________+GetNext
                                \___________+DoMove
                                 \__________+Mirror
                                  \_________+IkkeSkak
     (MarkMoves) ______+GetNext    \________ QSortTrk
                                    \_______ [Eval]
*)

CONST
  SkakBrainModCompilation="1041";
  MaxDistance  =  18; (* Hvilken plads i retn array som maxdistancen gemmes i *)
  DrawAccept   =  -25;(* only for repetition: positive=peaceful, default=0 *)

VAR
  (* retn: ARRAY['B'..'t'] OF ARRAY[-31..31] OF INTEGER; flyttet til .Def *)
  movetyp  : MOVETYPE;
  Traek    : TRKDATA;
  ValueCalc:ARRAY['A'..'T'],[' '..'T'] OF INTEGER;
  FraTag   :=INTEGER{0}; (* test only (25=e2, 0=all) *)
  MaxStackDepth :INTEGER; (* to avoid stack overrun (45000 stack: max 30) *)
  BlacksTurn:BOOLEAN; (* who is move calculated for, is set by FindTrk *)
  STOPP:BOOLEAN;
(************* Brain (orig. fra TURBO-PASCAL) ************************)
(* rev 0.1.1  work-list :
  visstilling, OK
  træk pre-generator, OK
  træk post-check, OK
  træk-check, OK
  maskine sorter, OK
  maskine dybde n, OK
  maskine evaluation, OK
  maskine pruning, OK
  stilling-opsætter, OK
  maskine mat/pat breaking, OK
  advarer/stopper ikke ved skak/skakmat/pat i player mode
  maskine kan ikke spille sort, OK
  pd (Positions Data) bør differentieres i Sort/Hvid p.gr.a. B og K, (OK)
  forlænge søgedybde ved slag, OK
  GetV, beregn de enkelte brikkers værdi, OK
  Underforvandling i DoMove, OK
  Quicksort udbygget med Insertsort på lister <8 elementer OK
  rykkeTabel (init) optimeret/udvidet til underforvandlingstræk OK
  Underforvandling i GetNextTil, OK, OK, OOOOKKKKK!!!!!
  GetNextD,GetNextV udvidet med skip af underforvandling  OK
  MarkMoves viser nu også Underforvandling internværdier, OK
  Find, FindTrk o.a flyttet til SkakBrain, OK
  DoMove sort R -> T konvertering fejl, OK

  logisk struktur for en stilling :
    RECORD
      stilling :ARRAY[-1..11,-1..11] OF BRIK;
      hvistur  :BOOLEAN;
    END;
  hvor 1,1 -> 8,8  A1 -> H8 , så 11-88 er A1-H1
  og resten omkring er en dobbelt kant ('.'). 
   
  retn indeholder data til at generere brikkernes gang. Hver brik har
  et antal retnings vektorer (4-8) samt en MaxDistance (TRDL=8, BSKM=1).
  retn[brik,MaxDistance]
  retn[brik,0]           indeholder første retning.
  retn[brik,retning]     indeholder så næste retning indtil den er 0.

  Springeren regnes for MaxDistance=1 og otte retningsvektorer pegende
  direkte på felterne, den kan gå til.

  Underforvandling er lagt som 'b' til-20 = tårn, -30=s, -40=l
                               'B' til+20 = Tårn, +30=S, +40=L

  Er logisk en sparse matrice. 20x43x2=1.6 Kbytes for at holde
  63 bytes (4%). Men en direkte opslagstabel er hurtig, derfor bibeholdes
  den som fysisk repræsentation
*)

(*$ IF Stamp *)
VAR
  micros,seconds,secondso,SChessCnt,SChessCntTotal,StackCuts,xcnt:LONGINT;

PROCEDURE Stamp(INIT:BOOLEAN;Traek:TRKDATA;xstr:ARRAY OF CHAR);
VAR
  n     :INTEGER;
  st,st2:ARRAY[0..31] OF CHAR;
  str   :STRING; (* 2000 chars *)
  err   :BOOLEAN;
PROCEDURE StrTime(seconds:LONGINT);
BEGIN
  IF seconds>59 THEN
    ValToStr(seconds DIV 60,FALSE,st,10,3,' ',err);
    ConcatChar(st,':');
    ValToStr(seconds MOD 60,FALSE,st2,10,2,'0',err);
    Concat(st,st2);
  ELSE
    ValToStr(seconds MOD 60,FALSE,st,10,6,' ',err);
  END;
END StrTime;
BEGIN
  IF INIT THEN
    CurrentTime(ADR(seconds),ADR(micros));
    SChessCnt:=0;
    SChessCntTotal:=0;
    StackCuts:=0;
  ELSE
    secondso:=seconds;
    CurrentTime(ADR(seconds),ADR(micros));
    StrTime(seconds-secondso);
    str:='#time : '; Concat(str,st);       (* # in first position for debug, SkakAlt *)
    ValToStr(SkakBrainEval.Evals,FALSE,st,10,6,' ',err); (* will then keep the comment *)
    Concat(str,'\nEvals : '); Concat(str,st);
    ValToStr(Traek.Vlu,TRUE,st,10,6,' ',err);
    Concat(str,'\nVlu   : '); Concat(str,st);
(*
    ValToStr(SChessCnt,FALSE,st,10,6,' ',err);
    Concat(str,'\nChCnt : '); Concat(str,st);
*)
    ValToStr(SChessCntTotal,FALSE,st,10,6,' ',err);
    Concat(str,'\nChsCut: '); Concat(str,st);
    ValToStr(StackCuts,FALSE,st,10,6,' ',err);
    Concat(str,'\nStkCut: '); Concat(str,st);
    ConcatChar(str,'\n'); Concat(str,xstr);
    IF Spil^[TraekNr+1].Tekst<>NIL THEN Deallocate(Spil^[TraekNr].Tekst); END;
    Allocate(Spil^[TraekNr+1].Tekst,Length(str)+1);
    IF Spil^[TraekNr+1].Tekst<>NIL THEN
      n:=-1;
      REPEAT
        INC(n);
        Spil^[TraekNr+1].Tekst^[n]:=str[n];
      UNTIL str[n]=0C;
    END;
  END;
END Stamp;

(*$ ENDIF *)

(*$ IF Test *)
VAR
  Nodes:LONGINT;
  
PROCEDURE d(n:INTEGER);
BEGIN
  WRITELN(n);
END d;
(*$ ENDIF *)

(*$ IF Tst *)
CONST
  Mmax=20;

VAR
  MORE:LONGINT;

PROCEDURE W(n:INTEGER);
BEGIN
  WRITE(n);
END W;

PROCEDURE WN(n:INTEGER);
VAR
  str:ARRAY[0..80] OF CHAR;
BEGIN
  WRITELN(n);
  INC(MORE);
  IF MORE>Mmax THEN 
    MORE:=0;
    WRITE(s('<more>'));
    READs(str);
  END;
END WN;
(*$ ENDIF *)

(* Compare for alle data-typer (også StrVAR med StrCONST, men IKKE StrVar) *) 
PROCEDURE Equal(a,b:ARRAY OF BYTE):BOOLEAN;
(*$ CopyDyn:=FALSE *)
VAR
  n,h:CARDINAL;
BEGIN
  IF HIGH(a)<HIGH(b) THEN
    h:=HIGH(a);
  ELSE
    h:=HIGH(b);
  END;
  FOR n:=0 TO h DO
    IF CHAR(a[n])<>CHAR(b[n]) THEN
      RETURN(FALSE);
    END;
  END;
  RETURN(TRUE);
END Equal;

PROCEDURE still(VAR stilling:STILLINGTYPE; st:str65);
VAR
  x,y:INTEGER;
BEGIN
  IF st[0]=0C THEN
    st:='RSLDMLSRBBBBBBBB                                bbbbbbbbrsldmlsrH';
  END;
  FOR x:=-10 TO 109 DO stilling[x]:='.' END;
  FOR y:=1 TO 8 DO 
    FOR x:=1 TO 8 DO stilling[x+10*y]:=st[(8-y)*8+x-1] END;
  END;
  stilling[HvisTur]:=st[64];
END still;

PROCEDURE GetNextTil(VAR stilling:STILLINGTYPE; VAR fra,til,retning:INTEGER;
                     VAR MoveTyp:MOVETYPE);
(* finder s/h næste træk med nuværende brik, til=fra -> til=89 når ikke flere *)
(* !!!!!!!!!! slag for enpassant markeres IKKE for sort, bør laves *)
VAR
  Done :BOOLEAN;
  Brik :CHAR;
  Max,just  :INTEGER;
  hvid,Max1,BondeH,BondeS :BOOLEAN;
BEGIN
  hvid:=stilling[HvisTur]='H';
  Brik:=stilling[fra];
  Max :=retn[Brik,MaxDistance];
  Max1:=Max=1;
  IF retning=0 THEN retning:=retn[Brik,retning] END;
  Done:=FALSE;
  BondeH:= Brik='b';
  BondeS:= Brik='B';
  REPEAT
    IF hvid THEN

      (* juster ved underforvandling *)
      IF BondeH & (retning<0) THEN
(*
WN(s('GNTjFør : just=')+l(just)+s(' Fra=')+l(fra)+s(' Til=')+l(til)+s(' retn=')+l(retning));
*)
        just:=20;
        WHILE retning+just<9 DO
          just:=just+10;
        END;
      ELSE
        just:=0;
      END;
(*
WN(s('GNTjEft : just=')+l(just)+s(' Fra=')+l(fra)+s(' Til=')+l(til)+s(' retn=')+l(retning));
*)
      (* næste retning hvis :
         Max eller ufrit felt nået,
         nået til kant,
         eller egen brik *)
      IF (fra<>til) & (Max1 OR (stilling[til]<>' '))
      OR (stilling[til+retning]='.')
      OR (stilling[til+retning+just]>'a') THEN
(*
WN(s('GNTnyRs: just=')+l(just)+s(' Fra=')+l(fra)+s(' Til=')+l(til)+s(' retn=')+l(retning));
*)
        IF BondeH & (fra<71) & (retning=20) THEN (* så skip underforvandlinger *)
          retning:=0;
        ELSE
          retning:=retn[Brik,retning];
        END; 
        til:=fra;
        IF retning=0 THEN
          Done:=TRUE;
          til:=89;
        END;
      ELSE
(*
WN(s('GNTnxtS : just=')+l(just)+s(' Fra=')+l(fra)+s(' Til=')+l(til)+s(' retn=')+l(retning));
*)
        til:=til+retning;

        just:=0;      
        IF BondeH THEN
          IF til<fra THEN (* juster ved underforvandling *)
            just:=20;
            WHILE til+just-fra<9 DO
              just:=just+10;
            END;
            IF stilling[til+just]<>' ' THEN
              MoveTyp:=MOVEslag;
            ELSE
              MoveTyp:=MOVEnormal;
            END;
          ELSE
            IF stilling[til]<>' ' THEN
              MoveTyp:=MOVEslag;
            ELSE
              IF BondeH & (stilling[til-10]='E') THEN
                MoveTyp:=MOVEslag;
              ELSE
                MoveTyp:=MOVEnormal;
              END;
            END;
          END;
        ELSE
          IF stilling[til]<>' ' THEN
            MoveTyp:=MOVEslag;
          ELSE
            MoveTyp:=MOVEnormal;
          END;
        END;
        IF BondeH THEN (* Bonde *)
          CASE retning OF
            | -30,-20,-10,10   : Done := (stilling[til+just]=' ');
            | -31,-29,-21,-19,-11,-9,9,11 :
              IF stilling[til+just]<>' ' THEN
                Done:=TRUE;
              ELSE
                Done:=stilling[til-10]='E';
                INCL(MoveTyp,enpassant);
              END;
            | 20   : Done := (fra>=21) AND (fra<=28) AND (stilling[til-10]=' ')
                     AND (stilling[til]=' ');
          ELSE END;
        ELSE (* ikke-bonde *)
          IF ABS(retning)=2 THEN  (* er kun 2 ved rokade *)
            INCL(MoveTyp,rokade);
            IF retning=2 THEN  (* O-O *)
              Done:=(stilling[16]=' ') AND (stilling[17]=' ')
              AND (stilling[18]='r');
            ELSE    (* O-O-O *)
              Done:=(stilling[14]=' ') AND (stilling[13]=' ')
              AND (stilling[12]=' ') AND (stilling[11]='r');
            END;
          ELSE 
            Done:=TRUE;
          END;
        END;
      END;
    ELSE (* for sort *)

      (* juster ved underforvandling *)
      IF BondeS & (retning>0) THEN
        just:=-20;
        WHILE retning+just>-9 DO
          just:=just-10;
        END;
      ELSE
        just:=0;
      END;

      (* næste retning hvis :
         Max eller ufrit felt nået,
         nået til kant,
         eller egen brik *)
      IF  (fra<>til) & ( Max1 OR (stilling[til]<>' '))
      OR (stilling[til+retning]='.')
      OR (stilling[til+retning+just]>' ') & (stilling[til+retning+just]<'a') THEN
        IF BondeS & (fra>28) & (retning=-20) THEN (* skip underforvandlinger *)
          retning:=0;
        ELSE
          retning:=retn[Brik,retning];
        END; 
        til:=fra;
        IF retning=0 THEN
          Done:=TRUE;
          til:=89;
        END;
      ELSE
        til:=til+retning;

        (* juster ved underforvandling *)
        IF BondeS & (til>fra) THEN
          just:=-20;
          WHILE fra-til-just<9 DO
            just:=just-10;
          END;
        ELSE
          just:=0;
        END;

        IF stilling[til+just]<>' ' THEN
          MoveTyp:=MOVEslag;
        ELSE
          MoveTyp:=MOVEnormal;
        END;
        IF BondeS THEN (* Bonde *)
          CASE retning OF
            | 30,20,10,-10    : Done := (stilling[til+just]=' ');
            | 31,29,21,19,11,9,-9,-11 :
              IF stilling[til+just]<>' ' THEN
                Done:=TRUE;
              ELSE
                Done:=stilling[til+just+10]='e';
                INCL(MoveTyp,enpassant);
              END;
            | -20    : Done := (fra>=71) AND (fra<=78) AND (stilling[til+10]=' ')
                       AND (stilling[til]=' ');
          ELSE END;
        ELSE (* ikke-bonde *)
          IF ABS(retning)=2 THEN  (* er kun 2 ved rokade *)
            INCL(MoveTyp,rokade);
            IF retning=2 THEN  (* O-O *)
              Done:=(stilling[86]=' ') AND (stilling[87]=' ')
              AND (stilling[88]='R');
            ELSE    (* O-O-O *)
              Done:=(stilling[84]=' ') AND (stilling[83]=' ')
              AND (stilling[82]=' ') AND (stilling[81]='R');
            END;
          ELSE 
            Done:=TRUE;
          END;
        END;
      END;
    END;
(*
WN(s('GNT     : just=')+l(just)+s(' Fra=')+l(fra)+s(' Til=')+l(til)+s(' retn=')+l(retning));
*)
  UNTIL Done;
(*
WN(s('GNTdone : just=')+l(just)+s(' Fra=')+l(fra)+s(' Til=')+l(til)+s(' retn=')+l(retning));
*)
END GetNextTil;

PROCEDURE DoMove(VAR stilling:STILLINGTYPE; fra,til:INTEGER; MoveTyp:MOVETYPE);
(* udfører (Hvidt/Sort) træk, der i forvejen er valideret OK *)
(* MoveTyp skal være defineret (og ændres ikke her) *)
VAR
  n :INTEGER;
BEGIN
  IF stilling[HvisTur]='H' THEN
    CASE stilling[fra] OF
      | 'b'  :
        IF fra>70 THEN 
          CASE til-fra OF
            |  9, 10, 11: stilling[til]:='d';    (* bondeforvandling til dronning *)
            |-11,-10, -9: stilling[til+20]:='t'; (* for lav til=>underforvandl*)
            |-21,-20,-19: stilling[til+30]:='s';
            |-31,-30,-29: stilling[til+40]:='l';
          END;
        ELSE
          IF (til-fra=20) & ((stilling[til-1]='B') OR (stilling[til+1]='B')) THEN
            stilling[til]:='e'; (* sæt en-passant mulighed *)
          ELSE
            stilling[til]:=stilling[fra];
          END;
        END;
      | 'r'  : stilling[til]:='t';        (* fjern tårns rokaderet *)
               (* hvis også andet tårn har været flyttet så fjern konges rokaderet *)
               IF ((fra=11) & (stilling[18]#'r') OR (fra=18) & (stilling[11]#'r')) 
               & (stilling[15]='m') THEN stilling[15]:='k' END;
      | 'm'  : stilling[til]:='k';        (* fjern konges rokaderet *)
               IF stilling[11]='r' THEN stilling[11]:='t' END;
               IF stilling[18]='r' THEN stilling[18]:='t' END;
    ELSE   
      stilling[til]:=stilling[fra];
    END;
    stilling[fra]:=' ';
    IF enpassant IN MoveTyp THEN
      stilling[til-10]:=' ';      (* fjern e.p. bonde *)
    ELSIF rokade IN MoveTyp THEN
      IF til<fra THEN             (* flyt/konverter tårn *)
        stilling[14]:='t';
        stilling[11]:=' ';
        IF stilling[18]='r' THEN stilling[18]:='t' END;
      ELSE
        stilling[16]:='t';
        stilling[18]:=' ';
        IF stilling[11]='r' THEN stilling[11]:='t' END;
      END;
    END;
    FOR n:=51 TO 58 DO
      IF stilling[n]='E' THEN stilling[n]:='B' END;  (* slet evt. e.p. mulighed. *)
    END;
    stilling[HvisTur]:='S';
  ELSE
    CASE stilling[fra] OF
      | 'B'  :
        IF fra<29 THEN
          CASE fra-til OF
             |  9, 10, 11: stilling[til]:='D';    (* bondeforvandling til dronning *)
             |-11,-10, -9: stilling[til-20]:='T';(* for lav til=>underforvandle*)
             |-21,-20,-19: stilling[til-30]:='S';(* og nedjuster til *)
             |-31,-30,-29: stilling[til-40]:='L';
          END;
        ELSE
          IF (fra-til=20) & ((stilling[til+1]='b') OR (stilling[til-1]='b')) THEN
            stilling[til]:='E'; (* sæt en-passant mulighed *)
          ELSE
            stilling[til]:=stilling[fra];
          END;
        END;
      | 'R'  : stilling[til]:='T';        (* fjern tårns rokaderet *)
               IF ((fra=81) & (stilling[88]#'R') OR (fra=88) & (stilling[81]#'R')) 
               & (stilling[85]='M') THEN stilling[85]:='K' END;
      | 'M'  : stilling[til]:='K';        (* fjern konges rokaderet *)
               IF stilling[81]='R' THEN stilling[81]:='T' END;
               IF stilling[88]='R' THEN stilling[88]:='T' END;
    ELSE   
      stilling[til]:=stilling[fra];
    END;
    stilling[fra]:=' ';
    IF enpassant IN MoveTyp THEN
      stilling[til+10]:=' ';      (* fjern e.p. bonde *)
    ELSIF rokade IN MoveTyp THEN
      IF til<fra THEN             (* flyt/konverter tårn *)
        stilling[84]:='T';
        stilling[81]:=' ';
        IF stilling[88]='R' THEN stilling[88]:='T' END;
      ELSE
        stilling[86]:='T';
        stilling[88]:=' ';
        IF stilling[81]='R' THEN stilling[81]:='T' END;
      END;
    END;
    FOR n:=41 TO 48 DO 
      IF stilling[n]='e' THEN stilling[n]:='b' END;  (* slet evt. e.p. mulighed *)
    END;
    stilling[HvisTur]:='H';
  END;
(*
  Vis('Efter DoMove:',stilling);
*)
END DoMove;

PROCEDURE DoMoveC(VAR stilling:STILLINGTYPE; fra,til:INTEGER);
(* udfører (Hvidt/Sort) træk, der i forvejen er valideret OK *)
(* som DoMove, men kræver IKKE MoveTyp information *)
(* Hurtigere end DoMoveOK når træk ER valideret OK *)
VAR
  MoveTyp:MOVETYPE;
BEGIN
  IF stilling[til]=' ' THEN
    MoveTyp:=MOVEnormal;
  ELSE
    MoveTyp:=MOVEslag;
  END;
  IF stilling[HvisTur]='H' THEN
    IF (stilling[fra]='b') 
    &  ((til-fra=9) OR (til-fra=11))
    &  (stilling[til]=' ') THEN
      INCL(MoveTyp,enpassant);
    END;
    IF (stilling[fra]='m')
    &  (ABS(til-fra)=2) THEN
      INCL(MoveTyp,rokade);
    END;
  ELSE
    IF (stilling[fra]='B') 
    &  ((fra-til=9) OR (fra-til=11))
    &  (stilling[til]=' ') THEN
      INCL(MoveTyp,enpassant);
    END;
    IF (stilling[fra]='M')
    &  (ABS(til-fra)=2) THEN
      INCL(MoveTyp,rokade);
    END;
  END;
  DoMove(stilling,fra,til,MoveTyp);
END DoMoveC;

(*$ IF False *) (* alternativ måde uden CASE *)

PROCEDURE CheckSkak2(VAR stilling:STILLINGTYPE; n:INTEGER; hvid:BOOLEAN):BOOLEAN;
(* checker om felt n er truet af sort/hvid *)
VAR
  retning,tst,cnt:INTEGER;
  skak:BOOLEAN;
BEGIN
  IF hvid THEN (* Hvid check !! *)
    skak:=(stilling[n-21]='S') OR (stilling[n-19]='S') OR (stilling[n-12]='S')
    OR (stilling[n- 8]='S') OR (stilling[n+ 8]='S') OR (stilling[n+12]='S')
    OR (stilling[n+19]='S') OR (stilling[n+21]='S');
    retning:=retn['t',0];       (* led i alle tårn retninger *)
    REPEAT
      tst:=n;
      cnt:=0;
      REPEAT                    (* find første ikke-tomme felt i retningen *)
        tst:=tst+retning;
        INC(cnt);
      UNTIL stilling[tst]<>' ';
      IF (stilling[tst]='D') OR (stilling[tst]='T') OR (stilling[tst]='R') THEN
        skak:=TRUE;
      ELSIF (cnt=1) & ((stilling[tst]='K') OR (stilling[tst]='M')) THEN
        skak:=TRUE;
      END ;
      retning:=retn['t',retning];
    UNTIL (retning=0) OR skak;
    IF ~skak THEN
      retning:=retn['l',0];       (* led i alle løber retninger *)
      REPEAT
        tst:=n;
        cnt:=0;
        REPEAT                    (* find første ikke-tomme felt i retningen *)
          tst:=tst+retning;
          INC(cnt);
        UNTIL stilling[tst]<>' ';
        IF (stilling[tst]='D') OR (stilling[tst]='L') THEN
          skak:=TRUE;
        ELSIF cnt=1 THEN
          IF (stilling[tst]='K') OR (stilling[tst]='M') OR (stilling[tst]='B') & ((retning=9) OR (retning=11)) THEN
            skak:=TRUE;
          END;
        END ;
        retning:=retn['l',retning];
      UNTIL (retning=0) OR skak;
    END;
  ELSE (* sort check *)
    skak:=(stilling[n-21]='s') OR (stilling[n-19]='s') OR (stilling[n-12]='s')
    OR (stilling[n- 8]='s') OR (stilling[n+ 8]='s') OR (stilling[n+12]='s')
    OR (stilling[n+19]='s') OR (stilling[n+21]='s');
    retning:=retn['t',0];       (* led i alle tårn retninger *)
    REPEAT
      tst:=n;
      cnt:=0;
      REPEAT                    (* find første ikke-tomme felt i retningen *)
        tst:=tst+retning;
        INC(cnt);
      UNTIL stilling[tst]<>' ';
      IF (stilling[tst]='d') OR (stilling[tst]='t') OR (stilling[tst]='r') THEN
        skak:=TRUE;
      ELSIF (cnt=1) & ((stilling[tst]='k') OR (stilling[tst]='m')) THEN
        skak:=TRUE;
      END ;
      retning:=retn['t',retning];
    UNTIL (retning=0) OR skak;
    IF ~skak THEN
      retning:=retn['l',0];       (* led i alle løber retninger *)
      REPEAT
        tst:=n;
        cnt:=0;
        REPEAT                    (* find første ikke-tomme felt i retningen *)
          tst:=tst+retning;
          INC(cnt);
        UNTIL stilling[tst]<>' ';
        IF (stilling[tst]='d') OR (stilling[tst]='l') THEN
          skak:=TRUE;
        ELSIF cnt=1 THEN
          IF (stilling[tst]='k') OR (stilling[tst]='m') OR (stilling[tst]='b') & ((retning=-9) OR (retning=-11)) THEN
            skak:=TRUE;
          END;
        END ;
        retning:=retn['l',retning];
      UNTIL (retning=0) OR skak;
    END;
  END;
  RETURN(skak);
END CheckSkak2;

(*$ ENDIF *)

PROCEDURE CheckSkak(VAR stilling:STILLINGTYPE; n:INTEGER; hvid:BOOLEAN):BOOLEAN;
(* checker om felt n er truet af sort/hvid *)
VAR
  retning,tst,cnt:INTEGER;
BEGIN
  IF hvid THEN (* Hvid check !! *)
    IF (stilling[n-21]='S') OR (stilling[n-19]='S') OR (stilling[n-12]='S')
    OR (stilling[n- 8]='S') OR (stilling[n+ 8]='S') OR (stilling[n+12]='S')
    OR (stilling[n+19]='S') OR (stilling[n+21]='S') THEN
      RETURN(TRUE);
    ELSE
      retning:=retn['d',0];       (* led i alle otte retninger *)
      REPEAT
        tst:=n;
        cnt:=0;
        REPEAT                    (* find første ikke-tomme felt i retningen *)
          tst:=tst+retning;
          INC(cnt);
        UNTIL stilling[tst]<>' ';
        CASE stilling[tst] OF     (* check om den fundne brik giver skak *)
          | 'D'     : RETURN(TRUE);
          | 'L'     : CASE retning OF
                        | -11,-9,9,11 : RETURN(TRUE);
                      ELSE END;
          | 'T','R' : CASE retning OF
                        | -10,-1,1,10 : RETURN(TRUE);
                      ELSE END;
          | 'K','M' : IF cnt=1 THEN RETURN(TRUE) END;
          | 'B'     : IF (cnt=1) AND ((retning=9) OR (retning=11)) THEN RETURN(TRUE) END;
        ELSE END ;
        retning:=retn['d',retning];
      UNTIL (retning=0);
    END;
    RETURN(FALSE);
  ELSE (* sort check *)
    IF (stilling[n-21]='s') OR (stilling[n-19]='s') OR (stilling[n-12]='s')
    OR (stilling[n- 8]='s') OR (stilling[n+ 8]='s') OR (stilling[n+12]='s')
    OR (stilling[n+19]='s') OR (stilling[n+21]='s') THEN
      RETURN(TRUE);
    ELSE
      retning:=retn['d',0];       (* led i alle otte retninger *)
      REPEAT
        tst:=n;
        cnt:=0;
        REPEAT                    (* find første ikke-tomme felt i retningen *)
          tst:=tst+retning;
          INC(cnt);
        UNTIL stilling[tst]<>' ';
        CASE stilling[tst] OF     (* check om den fundne brik giver skak *)
          | 'd'     : RETURN(TRUE);
          | 'l'     : CASE retning OF
                        | -11,-9,9,11 : RETURN(TRUE);
                      ELSE END;
          | 't','r' : CASE retning OF
                        | -10,-1,1,10 : RETURN(TRUE);
                      ELSE END;
          | 'k','m' : IF cnt=1 THEN RETURN(TRUE) END;
          | 'b'     : IF (cnt=1) AND ((retning=-9) OR (retning=-11)) THEN RETURN(TRUE) END;
        ELSE END ;
        retning:=retn['d',retning];
      UNTIL (retning=0);
    END;
    RETURN(FALSE);
  END;
END CheckSkak;

PROCEDURE IkkeSkak(VAR stilling:STILLINGTYPE; fra,til:INTEGER;
                  MoveTyp:MOVETYPE):BOOLEAN;
(* checker om (hvidt/sort) træk er ulovligt p.gr.a. at kongen er skak *)
(* eller rokerer fra/over truet felt *)
(* kræver at MoveTyp er sat korrekt når rokade og pat *)
VAR
  skak:BOOLEAN;
  n,vej:INTEGER;
  cfra,ctil:CHAR;
  hvid:BOOLEAN;
BEGIN
  hvid:=stilling[HvisTur]='H';
  IF rokade IN MoveTyp THEN
(*$ IF False *)
  WRITELN(s('O-O'));;
(*$ ENDIF *)
    skak:=CheckSkak(stilling,fra,hvid); (* rokeres FRA truet felt ? *)
    IF NOT skak THEN
      IF til<fra THEN vej:=-1 ELSE vej:=1 END;
      skak:=CheckSkak(stilling,fra+vej,hvid);  (* rokeres OVER truet felt ? *)
      IF NOT skak THEN
        cfra:=stilling[fra];
        stilling[fra]:=' ';
        skak:=CheckSkak(stilling,til,hvid);    (* rokeres TIL truet felt ? *)
        stilling[fra]:=cfra;
      END;
    END;
  ELSE

    IF pat IN MoveTyp THEN
      RETURN(FALSE);
    END;

    IF hvid THEN
      cfra:=stilling[fra];
      IF (cfra='b') & (fra>70) & (til<fra) THEN
(*$ IF False *)
  WRITELN(s('H Underforvandling'));;
(*$ ENDIF *)
        til:=til+20;
        WHILE til<fra DO
          til:=til+10;
        END;
      END;       
      ctil:=stilling[til];
      stilling[til]:=cfra;
      stilling[fra]:=' ';
(*$ IF False *)
  WRITELN(s('H til,fra,ctil,cfra ')+lf(til,3)+lf(fra,3)+c(ctil)+c(ctil));;
(*$ ENDIF *)
      IF stilling[15]='m' THEN
        skak:=CheckSkak(stilling,15,hvid) 
      ELSIF stilling[17]='k' THEN
        skak:=CheckSkak(stilling,17,hvid)
      ELSE
        n:=11;         (* find konge *)
        WHILE (stilling[n]<>'k') AND (stilling[n]<>'m') AND (n<89) DO INC(n) END;
        IF n<89 THEN
          skak:=CheckSkak(stilling,n,hvid);
        ELSE skak:=FALSE END; (* er kongen skak? *)
      END;
      stilling[fra]:=cfra;
      stilling[til]:=ctil;
    ELSE
      cfra:=stilling[fra];
      IF (cfra='B') & (fra<29) & (til>fra) THEN
(*$ IF False *)
  WRITELN(s('S Underforvandling'));;
(*$ ENDIF *)
        til:=til-20;
        WHILE til>fra DO
          til:=til-10;
        END;
      END;       
      ctil:=stilling[til];
      stilling[til]:=cfra;
      stilling[fra]:=' ';
(*$ IF False *)
  WRITELN(s('S til,fra,ctil,cfra ')+lf(til,3)+lf(fra,3)+c(ctil)+c(cfra));;
(*$ ENDIF *)
      IF stilling[85]='M' THEN
        skak:=CheckSkak(stilling,85,hvid) 
      ELSIF stilling[87]='K' THEN
        skak:=CheckSkak(stilling,87,hvid)
      ELSE
        n:=88;
        WHILE (stilling[n]<>'K') AND (stilling[n]<>'M') AND (n>10) DO DEC(n) END;
        IF n>10 THEN
          skak:=CheckSkak(stilling,n,hvid);
        ELSE skak:=FALSE END; (* er kongen skak? *)
      END;
      stilling[fra]:=cfra;
      stilling[til]:=ctil;
    END;
  END ;
(*$ IF False *)
IF skak THEN
  WRITELN(s('skak'));
ELSE
  WRITELN(s('Ikke-skak'));
END;
(*$ ENDIF *)
  RETURN(~skak);
END IkkeSkak;

PROCEDURE GetNext(VAR stilling:STILLINGTYPE; VAR fra,til,retning:INTEGER;
                  VAR MoveTyp:MOVETYPE);
(* finder næste (hvide/sorte) træk i stillingen, fra=89 når ikke flere *)
VAR
  hvid:BOOLEAN;
BEGIN
(*
WRITELN(s('Getnext entry: ')+l(fra)+s('-')+l(til)+s(' retn:')+l(retning));
*)
  IF stilling[HvisTur]='H' THEN
    REPEAT
      REPEAT
        IF til>88 THEN
          REPEAT (* find næste hvide brik *)
            INC(fra);
          UNTIL (fra>88) OR (stilling[fra]>'a');
          til:=fra;
          retning:=0;
        END;
        IF fra<>89 THEN GetNextTil(stilling,fra,til,retning,MoveTyp) END;
      UNTIL (til<>89) OR (fra=89);
(*
WRITELN(s('Getnext FørSkakCheck: ')+l(fra)+s('-')+l(til)+s(' retn:')+l(retning));
*)
    UNTIL (fra=89) OR IkkeSkak(stilling,fra,til,MoveTyp);
  ELSE (* sort *)
    REPEAT
      REPEAT
        IF til>88 THEN
          REPEAT
            INC(fra);
          UNTIL (fra>88) OR (stilling[fra]>'A') & (stilling[fra]<'a');
          til:=fra;
          retning:=0;
        END;
        IF fra<>89 THEN GetNextTil(stilling,fra,til,retning,MoveTyp) END;
      UNTIL (til<>89) OR (fra=89);
    UNTIL (fra=89) OR IkkeSkak(stilling,fra,til,MoveTyp);
  END;
(*
WRITELN(s('Getnext exit: ')+l(fra)+s('-')+l(til)+s(' retn:')+l(retning));
*)
END GetNext;

PROCEDURE Mirror(VAR stilling:STILLINGTYPE);
VAR
  n,m,nm,om:INTEGER;
  ch,ch2 :CHAR;
BEGIN
  (*$IF Test *)
(*
    d(s('Mirror'));
*)
  (*$ENDIF *)
  IF stilling[HvisTur]='S' THEN 
    stilling[HvisTur]:='H'
  ELSE 
    stilling[HvisTur]:='S';
  END;
  FOR n:=1 TO 4 DO 
    nm:=10*n;
    om:=90-nm;
    FOR m:=1 TO 8 DO
      INC(nm);
      INC(om);
      ch:=stilling[nm];
      IF ch>'a' THEN
        DEC(ch,32); 
      ELSIF ch>'A' THEN
        INC(ch,32);
      END;
      ch2:=stilling[om];
      IF ch2>'a' THEN 
        DEC(ch2,32); 
      ELSIF ch2>'A' THEN
        INC(ch2,32);
      END;
      stilling[nm]:=ch2;  
      stilling[om]:=ch;
    END;
  END;
END Mirror;

PROCEDURE DoMoveOk(VAR stilling:STILLINGTYPE; fra,til:INTEGER; VAR MoveTyp:MOVETYPE):BOOLEAN;
(* fuldstændigt check af om (s/h) træk er ok, genererer sort/hvide træk med DoMove *)
(* IF not DoMoveOk() then fejl.. -> udfører et træk hvis det er lovligt *)
VAR
  fr,ti,retning:INTEGER;
  black,DoMoveOkh:BOOLEAN;
BEGIN
  (*$IF Test0 *)
    d(s('DoMoveOk'));
  (*$ENDIF *)
  fr:=fra-1;
  ti:=89;
  REPEAT
    GetNext(stilling, fr,ti, retning, MoveTyp);
(*
WRITELN(s('I DoMoveOk, Efter GetNext: fr=')+l(fr)+s(' fra=')+l(fra));
*)
  UNTIL (ti=til) OR (fr>fra);
  IF fr>fra THEN
(*
WRITELN(s('Efter GetNext: OKh=0 fr=')+l(fr)+s(' fra=')+l(fra));
*)
    DoMoveOkh:=FALSE
  ELSE
    DoMove(stilling,fr,ti,MoveTyp);
    DoMoveOkh:=TRUE;
  END;
  RETURN(DoMoveOkh);
END DoMoveOk;

PROCEDURE QSortTrk(VAR Trk:TRAEKDATA;From,Upto:INTEGER);
VAR
  swp:TRKDATA;
  i,j:INTEGER;
  dh,ih:INTEGER;
BEGIN
  IF Upto-From<6 THEN (* brug INSERT-SORT på lister 2-6 lange *)
    FOR j:=From TO Upto-1 DO
      ih:=j;
      FOR i:=ih+1 TO Upto DO (* Find den største *)
        IF Trk[ih].Vlu<Trk[i].Vlu THEN
          ih:=i;
        END;
      END;
      IF ih<>j THEN (* swap *)
        swp:=Trk[j];
        Trk[j]:=Trk[ih];
        Trk[ih]:=swp;
      END;  
    END;
  ELSE (* QUICK-SORT lister over 7 lange *)
    i:=From; j:=Upto; dh:=Trk[(From+Upto) DIV 2].Vlu;
    REPEAT
      WHILE dh<Trk[i].Vlu DO INC(i) END;
      WHILE dh>Trk[j].Vlu DO DEC(j) END;
      IF i<=j THEN
        swp:=Trk[i];
        Trk[i]:=Trk[j];
        Trk[j]:=swp;
        INC(i);
        DEC(j);
      END;
    UNTIL i>j;
    IF From<j THEN QSortTrk(Trk,From,j) END;
    IF i<Upto THEN QSortTrk(Trk,i,Upto) END;
  END;
END QSortTrk;

(*$ IF Test *)
VAR
  dt:ARRAY[FALSE..TRUE],[1..40] OF TRKDATA;
  dr:ARRAY[FALSE..TRUE],[1..40] OF CHAR;
  st,strT:ARRAY[0..9] OF CHAR;
  LastDepth:INTEGER;

PROCEDURE Tag():BOOLEAN; (* tag a move to show (supress all other) *)
BEGIN
  IF FraTag=0 THEN RETURN(TRUE) ELSE RETURN(dt[FALSE,1].Fra=FraTag) END;
END Tag;

PROCEDURE ShowMove(fma:TRKDATA; MirIt:BOOLEAN);
BEGIN
  IF (fma.Fra<10) OR (fma.Til<10) OR (fma.Fra>89) OR (fma.Til>89) THEN
    WRITEF(s('NOTAMOVE ')+l(fma.Fra)+s('-')+l(fma.Til)+s(' ')); 
  ELSE
    IF MirIt THEN (* white to black *)
      fma.Fra:=fma.Fra MOD 10+10*(9-fma.Fra DIV 10);
      fma.Til:=fma.Til MOD 10+10*(9-fma.Til DIV 10);
    END;
    WRITEF(c(CHR(96+fma.Fra MOD 10))+c(CHR(48+fma.Fra DIV 10)));
    IF slag IN fma.Typ THEN WRITEF(c('x')) END;
    WRITEF(c(CHR(96+fma.Til MOD 10))+c(CHR(48+fma.Til DIV 10)));
    IF skak IN fma.Typ THEN WRITEF(c('+')) END;
    WRITEF(c(' '));
  END;
END ShowMove;

PROCEDURE ShowLine(Txt:ARRAY OF CHAR; res:INTEGER; Best:BOOLEAN);
VAR
  n:INTEGER;
  fma:TRKDATA;
BEGIN
  IF ~(CAP(st[0])='Q') THEN
    LastDepth:=Depth;
    IF Tag() THEN 
      IF Txt[2]<>'Q' THEN
        IF ~Best THEN
          FOR n:=1 TO Depth-1 DO  
            INC(Nodes);
            fma:=dt[FALSE,n];
            IF dr[FALSE,n]<>' ' THEN WRITEF(c(dr[FALSE,n])) END;
            ShowMove(fma,ODD(n));
          END;
        ELSE
          FOR n:=1 TO Depth-1 DO  
            fma:=dt[TRUE,n];
            IF dr[TRUE,n]<>' ' THEN WRITEF(c(dr[TRUE,n])) END;
            ShowMove(fma,ODD(n));
          END;
        END;
      END;
      IF ODD(Depth) THEN res:=-res; END;
      WRITEF(s(Txt)+l(res));
    END;
  END;
END ShowLine;

(*$ ENDIF *)

TYPE
  stDarrType = ARRAY [1..7] OF INTEGER;
CONST
  stDarr=stDarrType{ValueB,ValueS,ValueT,ValueD,ValueS,ValueT,ValueK};
  stDcount   =0;
  stDpawns   =1;
  stDknights =2;
  stDbishops =2;
  stDrooks   =3;
  stDqueens  =4;
  stDbishopsB=5; (*behind Queen *)
  stDrooksB  =6; (*behind Queen *)
  stDking    =7;

(* FirstCountAttacker returns the number for the smallest piece to take back *)
PROCEDURE Egain(VAR stilling:STILLINGTYPE;fr,ti:INTEGER;
                VAR OwnCount,FirstCountAttacker:INTEGER):INTEGER;
TYPE
  FIGHTERS=ARRAY[stDcount..stDking] OF INTEGER;
PROCEDURE Fight(Fown,Fopp:FIGHTERS; Pool:INTEGER):INTEGER;
VAR
  p,sum,risk:INTEGER;
BEGIN
(*$ IF False *)WRITELNF(s('Fight'));(*$ ENDIF *)
  p:=stDpawns;
  WHILE Fown[p]=0 DO INC(p) END;
  DEC(Fown[p]);
  DEC(Fown[stDcount]);

  risk:=stDarr[p];
(*
CASE p OF
| stDpawns                : risk:= ValueB; 
| stDknights              : risk:= ValueS;
| stDbishops,stDbishopsB  : risk:= ValueL;
| stDrooks,stDrooksB      : risk:= ValueT;
| stDqueens               : risk:= ValueD;
| stDking                 : risk:= ValueK;
END;
*)
  IF Fopp[stDcount]=0 THEN
    sum:=Pool;
  ELSE
    sum:=Pool-Fight(Fopp,Fown,risk);
  END;
(*$ IF False *)WRITELNF(s('FightX'));(*$ ENDIF *)
  IF sum<0 THEN RETURN(0) ELSE RETURN(sum) END;
END Fight;
VAR
  n,risk,ValueC:INTEGER;
  Wh,Bl:FIGHTERS; 
PROCEDURE scan(r:INTEGER;Diag:BOOLEAN);  (* to count queens,rooks,bishops *)
VAR
  n:INTEGER;
  Black:BOOLEAN;
  ch:CHAR;
BEGIN
(*$ IF False *)WRITELNF(s('Scan'));(*$ ENDIF *)
  n:=ti;
  REPEAT
    n:=n+r;
    ch:=stilling[n];
  UNTIL ch<>' ';
  IF ch<>'.' THEN
    IF CAP(ch)='D' THEN
      Black:= ch='D';
      IF Black THEN INC(Bl[stDqueens])  ELSE INC(Wh[stDqueens]) END;
      REPEAT (* find piece behind queen *)
        n:=n+r;
        ch:=stilling[n];
      UNTIL ch<>' ';
      IF CAP(ch)='D' THEN
        IF ch='D' THEN INC(Bl[stDqueens])  ELSE INC(Wh[stDqueens]) END;
      ELSIF ~Diag & ((CAP(ch)='T') OR (CAP(ch)='R')) THEN
        IF (ch='T') OR (ch='R') THEN 
          IF Black THEN INC(Bl[stDrooksB]) ELSE INC(Bl[stDrooks]) END;
        ELSE
          IF ~Black THEN INC(Wh[stDrooksB]) ELSE INC(Wh[stDrooks]) END;
        END;
      ELSIF Diag & (CAP(ch)='L') THEN
        IF ch='L' THEN
          IF Black THEN INC(Bl[stDbishopsB]) ELSE INC(Wh[stDbishops]) END;
        ELSE
          IF ~Black THEN INC(Wh[stDbishopsB]) ELSE INC(Wh[stDbishops]) END;
        END;
      END;
    ELSIF ~Diag & ((CAP(ch)='T') OR (CAP(ch)='R')) THEN
      IF (ch='T') OR (ch='R') THEN INC(Bl[stDrooks]) ELSE INC(Wh[stDrooks]) END;
      REPEAT (* find piece behind rook *)
        n:=n+r;
        ch:=stilling[n];
      UNTIL ch<>' ';
      IF CAP(ch)='D' THEN
        IF ch='D' THEN INC(Bl[stDqueens]) ELSE INC(Wh[stDqueens]) END;
      ELSIF (CAP(ch)='T') OR (CAP(ch)='R') THEN
        IF (ch='T') OR (ch='R') THEN INC(Bl[stDrooks]) ELSE INC(Wh[stDrooks]) END;
      END;
    ELSIF Diag & (CAP(ch)='L') THEN
      IF ch='L' THEN INC(Bl[stDbishops]) ELSE INC(Wh[stDbishops]) END;
      REPEAT (* find piece behind bishop *)
        n:=n+r;
        ch:=stilling[n];
      UNTIL ch<>' ';
      IF CAP(ch)='D' THEN
        IF ch='D' THEN INC(Bl[stDqueens]) ELSE INC(Wh[stDqueens]) END;
      ELSIF (CAP(ch)='L') THEN
        IF ch='L' THEN INC(Bl[stDbishops]) ELSE INC(Wh[stDbishops]) END;
      END;
    END;
  END;
(*$ IF False *)WRITELNF(s('ScanX'));(*$ ENDIF *)
END scan;
BEGIN
(*$ IF False *)WRITELNF(s('Egain'));(*$ ENDIF *)
  FOR n:=stDcount TO stDking DO
    Wh[n]:=0;
    Bl[n]:=0;
  END;

  (* count pawns *)
  IF (stilling[ti+ 9]='B') OR (stilling[ti+ 9]='E') THEN INC(Bl[stDpawns]) END;
  IF (stilling[ti+11]='B') OR (stilling[ti+11]='E') THEN INC(Bl[stDpawns]) END;
  IF  stilling[ti- 9]='b' THEN INC(Wh[stDpawns]) END;
  IF  stilling[ti-11]='b' THEN INC(Wh[stDpawns]) END;

  (* count knights *)
  IF  CAP(stilling[ti+21])='S' THEN
    IF stilling[ti+21]='S' THEN INC(Bl[stDknights]) ELSE INC(Wh[stDknights]) END;
  END;
  IF  CAP(stilling[ti+19])='S' THEN
    IF stilling[ti+19]='S' THEN INC(Bl[stDknights]) ELSE INC(Wh[stDknights]) END;
  END;
  IF  CAP(stilling[ti+12])='S' THEN
    IF stilling[ti+12]='S' THEN INC(Bl[stDknights]) ELSE INC(Wh[stDknights]) END;
  END;
  IF  CAP(stilling[ti+ 8])='S' THEN
    IF stilling[ti+ 8]='S' THEN INC(Bl[stDknights]) ELSE INC(Wh[stDknights]) END;
  END;
  IF  CAP(stilling[ti-12])='S' THEN
    IF stilling[ti-12]='S' THEN INC(Bl[stDknights]) ELSE INC(Wh[stDknights]) END;
  END;
  IF  CAP(stilling[ti- 8])='S' THEN
    IF stilling[ti- 8]='S' THEN INC(Bl[stDknights]) ELSE INC(Wh[stDknights]) END;
  END;
  IF  CAP(stilling[ti-21])='S' THEN
    IF stilling[ti-21]='S' THEN INC(Bl[stDknights]) ELSE INC(Wh[stDknights]) END;
  END;
  IF  CAP(stilling[ti-19])='S' THEN
    IF stilling[ti-19]='S' THEN INC(Bl[stDknights]) ELSE INC(Wh[stDknights]) END;
  END;

  (* count kings *)
  IF    (CAP(stilling[ti+ 1])='K') OR (CAP(stilling[ti+ 1])='M') THEN
    IF stilling[ti+ 1]=CAP(stilling[ti+ 1]) THEN INC(Bl[stDking]) ELSE INC(Wh[stDking]) END;
  ELSIF (CAP(stilling[ti- 1])='K') OR (CAP(stilling[ti- 1])='M') THEN
    IF stilling[ti- 1]=CAP(stilling[ti- 1]) THEN INC(Bl[stDking]) ELSE INC(Wh[stDking]) END;
  ELSIF (CAP(stilling[ti+10])='K') OR (CAP(stilling[ti+10])='M') THEN
    IF stilling[ti+10]=CAP(stilling[ti+10]) THEN INC(Bl[stDking]) ELSE INC(Wh[stDking]) END;
  ELSIF (CAP(stilling[ti+11])='K') OR (CAP(stilling[ti+11])='M') THEN
    IF stilling[ti+11]=CAP(stilling[ti+11]) THEN INC(Bl[stDking]) ELSE INC(Wh[stDking]) END;
  ELSIF (CAP(stilling[ti+ 9])='K') OR (CAP(stilling[ti+ 9])='M') THEN
    IF stilling[ti+ 9]=CAP(stilling[ti+ 9]) THEN INC(Bl[stDking]) ELSE INC(Wh[stDking]) END;
  ELSIF (CAP(stilling[ti- 9])='K') OR (CAP(stilling[ti- 9])='M') THEN
    IF stilling[ti- 9]=CAP(stilling[ti- 9]) THEN INC(Bl[stDking]) ELSE INC(Wh[stDking]) END;
  ELSIF (CAP(stilling[ti-10])='K') OR (CAP(stilling[ti-10])='M') THEN
    IF stilling[ti-10]=CAP(stilling[ti-10]) THEN INC(Bl[stDking]) ELSE INC(Wh[stDking]) END;
  ELSIF (CAP(stilling[ti-11])='K') OR (CAP(stilling[ti-11])='M') THEN
    IF stilling[ti-11]=CAP(stilling[ti-11]) THEN INC(Bl[stDking]) ELSE INC(Wh[stDking]) END;
  END;
(*$ IF False *)WRITELNF(s('Egain.2'));(*$ ENDIF *)

  (* count queens,rooks,bishops *)
  scan(  1,FALSE);
  scan( -1,FALSE);
  scan( 10,FALSE);
  scan(-10,FALSE);
  scan( 11,TRUE);
  scan(-11,TRUE);
  scan(  9,TRUE);
  scan( -9,TRUE);

  (* count White and Black total attacks *)
  FOR n:=stDpawns TO stDking DO
    Wh[stDcount]:=Wh[stDcount]+Wh[n];
    Bl[stDcount]:=Bl[stDcount]+Bl[n];
  END;
  OwnCount:=Wh[stDcount];

(*$ IF False *)WRITELNF(s('Egain.3'));(*$ ENDIF *)
  FirstCountAttacker:=0;
  IF (Wh[stDcount]>0) THEN
    risk:=ValueCalc['A',CAP(stilling[ti])];
    ValueC:=Fight(Wh,Bl,risk);
    IF Bl[stDcount]>0 THEN
      n:=stDpawns;
      WHILE Bl[n]=0 DO INC(n) END;
      FirstCountAttacker:=n;
    END;
  END;

(*$ IF False *)
IF (ti<>99) & Tag() THEN
  WRITEF(s('Egain, ValueC=')+l(ValueC)+s(' CountA=')+l(FirstCountAttacker)+s(' fratil=')+l(fr)+s('-')+l(ti)+s(' WCnt=')+l(Wh[stDcount])+s(' BCnt=')+l(Bl[stDcount])+s('  '));
  FOR n:=stDpawns TO stDking DO
    WRITEF(s('W')+l(n)+s(':')+l(Wh[n])+s(' B')+l(n)+s(':')+l(Bl[n])+s(' '));
  END;
  WRITELNF(0);
END;
(*$ ENDIF *)

(*$ IF False *)WRITELN(s('EgainX, ValueC=')+l(ValueC)+s('FirstCountAttacker=')+l(FirstCountAttacker));(*$ ENDIF *)
  RETURN(ValueC);  
END Egain;


(*$ IF Test *)              
PROCEDURE ShowData(VAR stilling:STILLINGTYPE; res:INTEGER);
VAR
  n,m:INTEGER;
BEGIN
  IF Tag() THEN
    (*
    FOR n:=1 TO 8 DO
       FOR m:=1 TO 8 DO
         WRITEF(c(stilling[(9-n)*10+m])+c(' '));
       END;
       WRITELNF(0);
    END;
    *)
    ShowLine('Eval=',res,FALSE);
    WRITEF(s(' (matr=')+l(matr)+s(' posi=')+l(posi)+s(' wbonus=')+l(wbonus)+s(' bbonus=')+l(bbonus)+s(')'));
    WRITELNF(0);
(*  WRITEF(s('Best: '));
    ShowLine(' ',0,TRUE);
    WRITELNF(0);*)
  END;
END ShowData;
(*$ ENDIF *)

VAR
  AEM:AEMtype;
  StartEval:INTEGER;
  SkakDepth,XchDepth,MaxPosValGain : INTEGER;
  MaxEvals :LONGINT; (* not used in Qfind *)
(*cf=20, Activity not used *)
PROCEDURE QFind(stilling:STILLINGTYPE; Activity,far,farfar,cf,Qdepth:INTEGER;
                Chess:BOOLEAN; farFra,farTil,farfarFra,farfarTil:INTEGER):INTEGER;
VAR
  dyb,fr,ti,retning,cnt,count,VluTmp,c1,c2,c3,cntAtt,ha1st,ha2nd,cntAm,
  n,m,SkipValue,MinEgain,KING,ChsCnt,FirstCountAttacker,OwnCount,vc,tiC:INTEGER;
  vl,HAfr,repFra,repTil: INTEGER;
  frc:CHAR;
  movetyp: MOVETYPE;
  Trk:TRAEKDATA;
  TraekTst,fmax:TRKDATA;
  Still:STILLINGTYPE;
  Mirrt,MATE,CHESS,EatOnly,skip,ChessYes:BOOLEAN;
  HA:ARRAY[11..88] OF INTEGER;
(*$ IF Test *)
  Flg:BOOLEAN;
  FraTest:INTEGER;
(*$ ENDIF *)
BEGIN
(*$ IF Test0 *)
  WRITELNF(s('QF: far=')+l(far)+s(' farfar=')+l(farfar)+s(' Qdepth=')+l(Qdepth)+s(' Chess=')+b(Chess)+s(' Depth=')+l(Depth));
(*$ ENDIF *)
  INC(Depth);
  INC(Qdepth);
  MATE:=TRUE;
  Mirrt:=stilling[HvisTur]='S';
  IF Mirrt THEN
    Mirror(stilling);
  END;
  IF ODD(Depth)=BlacksTurn THEN
    pd:=pdb;
(*$ IF Test0 *)
  WRITELNF(s('QF: Mirrt (pd:=pdb)'));
(*$ ENDIF *)
  ELSE
    pd:=pdw;
  END;
  IF ~Chess THEN
    FOR n:=11 TO 88 DO
      IF stilling[n]>'a' THEN
        HA[n]:=2; (* own piece, but still not proofed movable *)
(*$ IF Test0 *)  WRITELNF(s('ATT=2: ')+l(n)+s(' ')+c(stilling[n]));(*$ ENDIF *)
      ELSE
        HA[n]:=0;
      END;
    END;
  END;
  IF Depth>MaxStackDepth THEN
(*$ IF Test *) IF Tag() THEN WRITELNF(s('Stack overrun cut-off:')); END; (*$ ENDIF *)
(*$ IF Stamp *) INC(StackCuts); (*$ ENDIF *)
    SkipValue:=Eval(stilling,Activity,FALSE,-9999,9999);
(*$ IF Test *) ShowData(stilling,SkipValue); (*$ ENDIF *)
    DEC(Depth);
    DEC(Qdepth);
    RETURN(SkipValue);
  END;
  ChessYes := Depth<MaxStackDepth-2;
(*$ IF False *) WRITELN(s('QFind'));(*$ ENDIF *)
(*$ IF Test *) Flg:= FALSE; (*$ ENDIF *)

  IF stilling[85]='M' THEN
    KING:=85
  ELSE
    KING:=88;
    WHILE (stilling[KING]<>'K') & (KING>10) DO DEC(KING) END;
  END;
  fr:=10;
  ti:=89;
  retning:=0;
  MinEgain:=1;
  count:=0;
  EatOnly:=FALSE;
  REPEAT           (* lav liste med alle slag (count) + skakker + QNpromotions *)
    GetNext(stilling,fr,ti,retning,movetyp);
    IF (fr<89) THEN
      MATE:=FALSE;

      frc:=stilling[fr];
      HA[fr]:=1;
(*$ IF Test0 *)  WRITELNF(s('ATT=1: ')+l(fr));(*$ ENDIF *)
(*$ IF Test0 *)
  WRITEF(s('ATT: fr=')+l(fr)+s(' ti=')+l(ti));
  IF slag IN movetyp THEN WRITEF(s('x')); END;
  IF skak IN movetyp THEN WRITEF(s('+')); END;
  WRITELNF(0);
(*$ ENDIF *)

      IF (frc<>'k') & (frc<>'m') THEN
        IF ChessYes OR (slag IN movetyp) THEN
          IF (frc='l') OR (frc='d') THEN (* check for chess on diagonals *)
            IF ((ti-KING) MOD 11=0) OR ((ti-KING) MOD 9=0) THEN
              IF (ti-KING) MOD 11=0 THEN
                IF ti>KING THEN
                  n:=ti-11;
                  WHILE stilling[n]=' ' DO n:=n-11 END;
                ELSE
                  n:=ti+11;
                  WHILE stilling[n]=' ' DO n:=n+11 END;
                END;
              ELSE
                IF ti>KING THEN
                  n:=ti-9;
                  WHILE stilling[n]=' ' DO n:=n-9 END;
                ELSE
                  n:=ti+9;
                  WHILE stilling[n]=' ' DO n:=n+9 END;
                END;
              END;
              IF n=KING THEN INCL(movetyp,skak) END; (* else mark as bound piece *)
            END;                                     
          END;
          IF (frc='t') OR (frc='r') OR (frc='d') THEN (* check for chess on rows *) 
            IF (ti DIV 10=KING DIV 10) OR (ti MOD 10=KING MOD 10) THEN
              IF (ti DIV 10=KING DIV 10) THEN
                IF ti>KING THEN
                  n:=ti-1;
                  WHILE stilling[n]=' ' DO n:=n-1 END;
                ELSE
                  n:=ti+1;
                  WHILE stilling[n]=' ' DO n:=n+1 END;
                END;
              ELSE
                IF ti>KING THEN
                  n:=ti-10;
                  WHILE stilling[n]=' ' DO n:=n-10 END;
                ELSE
                  n:=ti+10;
                  WHILE stilling[n]=' ' DO n:=n+10 END;
                END;
              END;
              IF n=KING THEN INCL(movetyp,skak) END; (* else mark as bound piece *)
            END;
          END;
          IF (frc='s') & ((ti-KING=12) OR (ti-KING=-12) OR
                          (ti-KING=21) OR (ti-KING=-21) OR
                          (ti-KING= 8) OR (ti-KING= -8) OR
                          (ti-KING=19) OR (ti-KING=-19)) THEN
            INCL(movetyp,skak);
            (* and check for attack on Q and R (family chess) *)
          END;
        END;     
        IF (frc='b') THEN
          IF fr>70 THEN (* promote  *)
            frc:=' ';
            IF ti>80 THEN  (* promote to queen *)
              frc:='d'
            ELSIF (ti>50) & (ti<59) THEN (* promote to knight if chess *)
              tiC:=ti+30;
              IF (tiC-KING=12) OR (tiC-KING=21) OR (tiC-KING= 8) OR (tiC-KING=19) THEN
                INCL(movetyp,skak);
                frc:='s';
              END;
            END;
          ELSIF (ti+9=KING) OR (ti+11=KING) THEN
            INCL(movetyp,skak);
          END;
        END;
      END;
      IF (slag IN movetyp)
      OR ChessYes & (skak IN movetyp) & (Qdepth<=SkakDepth)
      OR (fr>70) & (stilling[fr]='b') & ((ti>80) OR (ti>50) & (ti<59))
      OR Chess THEN
        IF slag IN movetyp THEN
          IF (stilling[ti]=' ') & (fr<59) & (frc='b') THEN (* en-passant *)
(*$ IF Test *)
 WRITELNF(s('ENPAS:'));
(*$ ENDIF *)
            n:=0;
          ELSE
            n:=ValueCalc[CAP(stilling[fr]),CAP(stilling[ti])];
          END;
          IF (n=0) & (Qdepth<=XchDepth) THEN n:=MinEgain; END;
(*$ IF Test0 *)
IF Flg & Tag() THEN WRITEF(s('Flg: ValueCalc=')+l(n)+s(' ')); END;
(*$ ENDIF *)
          IF n<MinEgain THEN
            m:=Egain(stilling,fr,ti,OwnCount,FirstCountAttacker);
            IF m>0 THEN
              IF (n>-190) OR (FirstCountAttacker=0) THEN (* TAB: 470-300=170,300-100=200 *)
                n:=m;
              ELSE
                CASE FirstCountAttacker OF (* !!!!!!!!! FirstCountAttacker var 25518 CASE INDEX!!!*)
                | stDpawns                 : vl:=ValueB;
                | stDknights,stDbishopsB   : vl:=ValueS;
                | stDrooks,stDrooksB       : vl:=ValueT;
                | stDqueens                : vl:=ValueD;
                | stDking                  : vl:=ValueK;
                ELSE
                  vl:=0;
                END;
                IF n+vl>-100 THEN n:=m; END; (*!!!!!!!!!!!*)
              END;
            ELSIF (skak IN movetyp) & (Qdepth<2) THEN (* 1: se på ofre med skak*)
              n:=1;
            END;
(*$ IF Test0 *)
IF Flg & Tag() THEN WRITEF(s('Flg: Egain=')+l(n)+s(' ')); END;
(*$ ENDIF *)
          END;

          IF Chess & (n>0) THEN
            EatOnly:=TRUE;
(*$ IF Test *)
IF Tag() THEN WRITEF(s('¶')); END;
(*$ ENDIF *)
          END;
          IF n>=MinEgain THEN n:=n+20 END; (* Keeps'em better than just chess *)
        ELSIF ChessYes & (skak IN movetyp) & (Qdepth<=SkakDepth) THEN (* but not slag *)
          m:=Egain(stilling,fr,ti,OwnCount,FirstCountAttacker); (* needs FirstCountAttacker ONLY!!! *) 
          IF FirstCountAttacker=0 THEN
            n:=3;
          ELSE
            n:=-ValueCalc['A',CAP(stilling[fr])];
            CASE FirstCountAttacker OF (* 3-98 minus one *)
            | stDpawns                 : n:=n+ValueB-1;
            | stDknights,stDbishopsB   : n:=n+ValueS-1;
            | stDrooks,stDrooksB       : n:=n+ValueT-1;
            | stDqueens                : n:=n+ValueD-1;
            | stDking                  : n:=900;
(*$ IF Test0 *) IF Tag() & (ti=0) THEN
   WRITELNF(s(' #')+l(fr)+s('-')+l(ti)+s(' ')+l(0)+s(' #'));
 END;(*$ ENDIF *)

            END;
            IF n>0 THEN n:=2+n DIV 64; END;
          END;
        ELSIF Chess THEN
          n:=-1; (* ! must be negative to mark as a move after a check *)
        ELSE (* promotion, (fr>70) & (stilling[fr]='b') & ((ti>80) OR (ti>50) & (ti<59)) *)
          n:=800;
        END;
        IF (n>=MinEgain) OR Chess & (~EatOnly OR (ChessYes & (slag IN movetyp))) THEN (* worth to try, store move *)
          INC(count);
          Trk[count].Vlu:=      n;
          Trk[count].Fra:=     fr;
          Trk[count].Til:=     ti;
          Trk[count].Typ:=movetyp;
          IF ~Chess & (ValueCalc[CAP(stilling[fr]),CAP(stilling[ti])]>0) THEN
(*$ IF Test0 *)  WRITELNF(s('ATT=3: ')+l(fr));(*$ ENDIF *)
            HA[fr]:=3; (* mark as already found a gaining move *)
          END;
(*$ IF Test0 *)
IF Tag() & (ti=0) THEN
   WRITELNF(s(' #')+l(fr)+s('-')+l(ti)+s('#'));
END;
(*$ ENDIF *)
        END;
      ELSE
(*$ IF Stamp *)
IF (skak IN movetyp) THEN
  IF (Qdepth>SkakDepth) THEN INC(SChessCntTotal);END;
END;
(*$ ENDIF *)
      END;
    END;
  UNTIL fr>88;

  cntAtt:=count;
  ha1st:=0;
  ha2nd:=0;
  IF ~Chess THEN
    FOR fr:=11 TO 88 DO (* is piece attacked? *)
      IF HA[fr]>0 THEN
(*$ IF Test *) FraTest:=25;(*$ ENDIF *)
(*$ IF Test0 *)
      IF fr=FraTest THEN WRITELNF(s('ATTACKED: 1 ')+l(fr)+s(' HA[fr]=')+l(HA[fr]));END;
(*$ ENDIF *)
        HAfr:=0;
        frc:=stilling[fr]; (* skip if k,m,p ???!!!*)
        IF (stilling[fr+11]='B') OR (stilling[fr+11]='E')
        OR (stilling[fr+ 9]='B') OR (stilling[fr+ 9]='E') THEN
(*$ IF Test0 *)
     IF fr=FraTest THEN WRITELNF(s('ATTACKED: sltrd by BE ')+l(fr));END;
(*$ ENDIF *)
          CASE frc OF
          | 's','l'     : HAfr:=200;
          | 't','r','d' : HAfr:=370;
          ELSE END;
        ELSIF (frc='d') OR (frc='t') OR (frc='r') THEN
(*$ IF Test0 *)
     IF fr=FraTest THEN WRITELNF(s('ATTACKED: dtr by SL ')+l(fr)+c(stilling[38])+c(stilling[83]));END;
(*$ ENDIF *)
          IF (stilling[fr+12]='S') OR (stilling[fr-12]='S')
          OR    (stilling[fr+21]='S') OR (stilling[fr-21]='S')
          OR    (stilling[fr+ 8]='S') OR (stilling[fr- 8]='S')
          OR    (stilling[fr+19]='S') OR (stilling[fr-19]='S') THEN
(*$ IF Test0 *)
     IF fr=FraTest THEN WRITELNF(s('ATTACKED: by S ')+l(fr));END;
(*$ ENDIF *)
            CASE frc OF
            | 'd'     : HAfr:=350;
            | 't','r' : HAfr:=170;
            ELSE END;
          ELSIF (stilling[fr+11]='L') OR
                (stilling[fr+ 9]='L') OR
                (stilling[fr-11]='L') OR
                (stilling[fr- 9]='L') OR
                (stilling[fr+11]=' ') & (stilling[fr+22]='L')  OR 
                (stilling[fr-11]=' ') & (stilling[fr-22]='L')  OR 
                (stilling[fr+ 9]=' ') & (stilling[fr+18]='L')  OR 
                (stilling[fr- 9]=' ') & (stilling[fr-18]='L')  OR
                (stilling[fr+11]=' ') & (stilling[fr+22]=' ') & (stilling[fr+33]='L')  OR 
                (stilling[fr-11]=' ') & (stilling[fr-22]=' ') & (stilling[fr-33]='L')  OR 
                (stilling[fr+ 9]=' ') & (stilling[fr+18]=' ') & (stilling[fr+27]='L')  OR 
                (stilling[fr- 9]=' ') & (stilling[fr-18]=' ') & (stilling[fr-27]='L')  THEN (*uncomplete!*)
(*$ IF Test0 *)
     IF fr=FraTest THEN WRITELNF(s('ATTACKED: by L ')+l(fr));END;
(*$ ENDIF *)
            CASE frc OF
            | 'd'     : HAfr:=350;
            | 't','r' : HAfr:=170;
            ELSE END;
          ELSIF (frc='d') & (
            (stilling[fr+10]='T') OR
            (stilling[fr-10]='T') OR
            (stilling[fr+ 1]='T') OR
            (stilling[fr- 1]='T') OR
            (stilling[fr+10]=' ') & (stilling[fr+20]='T')  OR 
            (stilling[fr-10]=' ') & (stilling[fr-20]='T')  OR 
            (stilling[fr+ 1]=' ') & (stilling[fr+ 2]='T')  OR 
            (stilling[fr- 1]=' ') & (stilling[fr- 2]='T')  OR
            (stilling[fr+10]=' ') & (stilling[fr+20]=' ') & (stilling[fr+30]='T')  OR 
            (stilling[fr-10]=' ') & (stilling[fr-20]=' ') & (stilling[fr-30]='T')  OR 
            (stilling[fr+ 1]=' ') & (stilling[fr+ 2]=' ') & (stilling[fr+ 3]='T')  OR 
            (stilling[fr- 1]=' ') & (stilling[fr- 2]=' ') & (stilling[fr- 3]='T')) THEN
            HAfr:=180;
          END;
        END;
        IF HAfr>0 THEN (* attacked, store move(s) *)
(*$ IF Test0 *)
     WRITELNF(s('ATTACKED: Dpth=')+l(Depth)+s(' trk=')+l(fr));
(*$ ENDIF *)
          IF HAfr>ha2nd THEN
            IF HAfr>ha1st THEN
              ha2nd:=ha1st;
              ha1st:=HAfr;
            ELSE
              ha2nd:=HAfr;
            END;
          END;
          n:=fr-1;
          ti:=89;
          retning:=0;
          cntAm:=0; (* count of moves for attacked piece *)
          REPEAT  (* maybe only on HA[fr]=1 ??? *)
            GetNext(stilling,n,ti,retning,movetyp);
            IF (n=fr) THEN
              (* what about checks to set chess flag ? *)
(*$ IF Test0 *)
     WRITELNF(s('ATTACKED: til=')+l(ti));
(*$ ENDIF *)
              INC(cntAm);
              INC(cntAtt);
              Trk[cntAtt].Vlu:=   HAfr;
              Trk[cntAtt].Fra:=     fr;
              Trk[cntAtt].Til:=     ti;
              Trk[cntAtt].Typ:=movetyp;
            END;
          UNTIL n>fr;
          IF cntAm=0 THEN (* bound or lost piece *)
            IF ha2nd<HAfr THEN
(*$ IF Test *)
     WRITELNF(s('ATTACKED 0: ha2nd:=HAfr = ')+l(HAfr));
(*$ ENDIF *)
              ha2nd:=HAfr;
            END;
          ELSIF cntAm<3 THEN (* only one move possible *)
(*$ IF Test0 *) WRITELNF(s('ATTa'));(*$ ENDIF *)
            IF stilling[Trk[cntAtt].Til]>' ' THEN
(*$ IF Test0 *) WRITELNF(s('ATTb ')+c(stilling[Trk[cntAtt].Til]));(*$ ENDIF *)
              vc:=ValueCalc[CAP(stilling[fr]),CAP(stilling[Trk[cntAtt].Til])];
(*$ IF Test0 *)
     WRITELNF(c(CAP(stilling[fr]))+c(CAP(stilling[Trk[cntAtt].Til])));
     WRITELNF(s('ATTACKED 1: slag, vc=')+l(vc)+s(' -HA[fr]=')+l(-HA[fr])+s(' fr=')+l(fr)+s(' Trk[cntAtt].Til=')+l(Trk[cntAtt].Til));
(*$ ENDIF *)
              IF vc<=-HAfr THEN
(*$ IF Test0 *)
     WRITELNF(s('ATTACKED 1: vc<=-HAfr'));
(*$ ENDIF *)
                IF (cntAm=1) OR (stilling[fr]='d') THEN
                  IF ha2nd<HAfr THEN
(*$ IF Test0 *)
     WRITELNF(s('ATTACKED 1: ha2nd:=HAfr'));
(*$ ENDIF *)
                    ha2nd:=HAfr;
                  END;
                END;
              END;
            END;
          END;
        END;
        (* HA[fr]:=HAfr; p.t. not used later *)
      END;
    END;
  END;

  IF MATE THEN (* no moves possible *)
    IF Chess THEN
      fmax.Typ:=MOVETYPE{mat};
      fmax.Vlu:=-16383;
    ELSE
      fmax.Typ:=MOVETYPE{pat};
      fmax.Vlu:=0;
    END;
  ELSE
    SkipValue:=Eval(stilling,Activity,FALSE,fmax.Vlu,far)-(ha2nd-ha1st) DIV 32;
    IF Chess THEN
      fmax.Vlu:=-20000;
    ELSE
      fmax.Vlu:=SkipValue;
    END;
    IF (count>1) & (fmax.Vlu<far) THEN
      QSortTrk(Trk,1,count);
      IF Trk[1].Vlu>31 THEN SkipValue:=SkipValue+Trk[1].Vlu DIV 32; END;
      IF ~Chess THEN fmax.Vlu:=SkipValue END;
    END;

(*$ IF Test *) ShowData(stilling,SkipValue); (*$ ENDIF *)

    IF Qdepth=1 THEN
      IF Mirrt THEN
        StartEval:=-SkipValue;
      ELSE
        StartEval:=SkipValue;
      END;
    END;

    IF (count>0) & (fmax.Vlu<far) THEN 
(*$ IF False *)
WRITELNF(s('QFind, Qdepth=')+l(Qdepth)+s(' Moves=')+l(count));
(*$ ENDIF *)
      fmax.Fra:=10;
      fmax.Til:=89;
      cnt:=0;
      REPEAT                            (* for cnt:=1 to count *)
        INC(cnt);
        IF ~EatOnly OR (Trk[cnt].Vlu>0) THEN
          skip:=FALSE;
          IF ~Chess THEN

(*$ IF FALSE *)
            (* some cuts of the tree: *)
            (* 1: if not a chess and behind with more than 1600 then require
                  moves worth more than 1/8 of the loss *)
            IF ~(skak IN Trk[cnt].Typ) & (SkipValue<-1600) THEN
              IF SkipValue+Trk[cnt].Vlu*8<0 THEN
                skip:=TRUE;
                Trk[cnt].Vlu:=SkipValue+Trk[cnt].Vlu; (*!!!*)
WRITELNF(s('?SKIP? < -1600 ')+l(Trk[cnt].Fra)+s('-')+l(Trk[cnt].Til)
        +s(' Vlu:')+l(Trk[cnt].Vlu));
              END;
            END;
            (* 2: if advance of more than 1600 then require moves worth more than
                  1/8 of the win *)
            IF (SkipValue>1600) THEN
              IF SkipValue>Trk[cnt].Vlu*8 THEN
                skip:=TRUE;
                Trk[cnt].Vlu:=SkipValue+Trk[cnt].Vlu; (*!!!*)
WRITELNF(s('?SKIP? > 1600 ')+l(Trk[cnt].Fra)+s('-')+l(Trk[cnt].Til)
        +s(' Vlu:')+l(Trk[cnt].Vlu));
              END;
            END;
(*$ ENDIF *)

            (* 3: if not a chess and fmax gain is bigger than the piece to
                  eat + an max positional value gain (MaxPosValGain about 50)*)
            IF ~(skak IN Trk[cnt].Typ)
            & (fmax.Vlu-SkipValue>ValueCalc['A',CAP(stilling[Trk[cnt].Til])]+MaxPosValGain) THEN
(*$ IF False *) IF Tag() & (Trk[cnt].Fra=99) THEN
  WRITELNF(lf(fmax.Vlu,8)+lf(SkipValue,8)+lf(Trk[cnt].Til,8)); END;
(*$ ENDIF *)
              skip:=TRUE; (* !!!!!! under-promotion,ep fails? !!!!!!!*)
            END;
          ELSE
            IF count>2 THEN
              frc:=CAP(stilling[Trk[cnt].Fra]);
              IF (frc<>'K') & (frc<>'M') & ~(slag IN Trk[cnt].Typ) THEN
                m:=Egain(stilling,Trk[cnt].Fra,Trk[cnt].Til,OwnCount,FirstCountAttacker);
(*$ IF Test *)  IF Tag() & (OwnCount<2) THEN WRITELNF(s('SKIP<2 =')+l(OwnCount)); END;(*$ ENDIF *)
                IF OwnCount<2 THEN skip:=TRUE; END;
              END;
            END; 
          END;

          (* 4: skip if best position and move is piece back again *)
          IF ((SkipValue>0) OR (fmax.Vlu>0))
            & (Trk[cnt].Fra=farfarTil)
            & (Trk[cnt].Til=farfarFra) THEN
(*$ IF Test *)
     WRITELNF(s('Skip 4: ')+l(farfarTil)+s('-')+l(farfarFra));
(*$ ENDIF *)
            (*skip:=TRUE;*)
          END;

          IF ~skip THEN
            Still:=stilling;
(*$ IF False *) WRITELNF(s('QFind, Qdepth=')+l(Qdepth)+s(' MoveFra=')+l(Trk[cnt].Fra)+s(' MoveTil=')+l(Trk[cnt].Til));(*$ ENDIF *)
(*$ IF Test *)
  dt[FALSE,Depth]:=Trk[cnt];
  IF slag IN Trk[cnt].Typ THEN
    dr[FALSE,Depth]:='.';
  ELSIF skak IN Trk[cnt].Typ THEN
    dr[FALSE,Depth]:='*';
  ELSE
    dr[FALSE,Depth]:='!';
  END;
  IF (slag IN Trk[cnt].Typ) & (skak IN Trk[cnt].Typ) THEN
    dr[FALSE,Depth]:='_';
  END;  
(*$ ENDIF *)
            CHESS:=skak IN Trk[cnt].Typ;
            IF (slag IN Trk[cnt].Typ)
            OR (Trk[cnt].Fra>70) & (stilling[Trk[cnt].Fra]='b') THEN
              repFra:=0;
              repTil:=0;
              farFra:=0;
              farTil:=0;
            ELSE 
              repFra:=Trk[cnt].Fra;
              repTil:=Trk[cnt].Til;
            END;
            DoMove(Still, Trk[cnt].Fra, Trk[cnt].Til, Trk[cnt].Typ);
            Trk[cnt].Vlu:=-QFind(Still,Activity,-fmax.Vlu,-far,cf,Qdepth,
                                 CHESS,repFra,repTil,farFra,farTil);
(*$ IF Test0 *)WRITELNF(s('Vlu=')+l(Trk[cnt].Vlu)+s(' Dpth=')+l(Depth));(*$ ENDIF *)
(*$ IF Test *) dt[FALSE,Depth].Vlu:=Trk[cnt].Vlu;(*$ ENDIF *)
            IF ~Push & (Qdepth<10) THEN 
              AEM(); 
            END;
            IF Trk[cnt].Vlu>fmax.Vlu THEN 
(*$ IF Test0 *) WRITEF(s('FMAX! Old=')+l(fmax.Vlu)+s(' new=')+l(Trk[cnt].Vlu));(*$ ENDIF *)
              fmax:=Trk[cnt];
(*$ IF Test *)
  dt[TRUE,Depth]:=Trk[cnt];
  IF slag IN Trk[cnt].Typ THEN
    dr[TRUE,Depth]:='.';
  ELSIF skak IN Trk[cnt].Typ THEN
    dr[TRUE,Depth]:='*';
  ELSE
    dr[TRUE,Depth]:='!';
  END;
  IF (slag IN Trk[cnt].Typ) & (skak IN Trk[cnt].Typ) THEN
    dr[TRUE,Depth]:='_';
  END;  
  FOR fr:=Depth+1 TO 30 DO
    dt[TRUE,fr]:=dt[FALSE,fr];
    dr[TRUE,fr]:=dr[FALSE,fr];
  END; 
(*$ ENDIF *)
            END;
(*$ IF Test0 *)
     WRITELNF(s('Dpth=')+l(Depth)+s(' Vlu=')+l(fmax.Vlu)+s(' trk=')+l(Trk[cnt].Fra)+l(Trk[cnt].Til));
(*$ ENDIF *)
          END;
        ELSE
(*$ IF False *)  IF Tag() THEN WRITELNF(s('!!!!!!!!!EatOnly!!!!!!!!')); END;(*$ ENDIF *)
        END;
      UNTIL (fmax.Vlu>far) OR (cnt=count) OR Push
      (* OR (fmax.Vlu>1200)
         OR ~Mirrt & (fmax.Vlu>StartEval+1000)
         OR Mirrt & (fmax.Vlu>1000-StartEval) *) ;

(*$ IF Test0 *)
IF (fmax.Vlu>1200)
OR ~Mirrt & (fmax.Vlu>StartEval+1000)
OR  Mirrt & (fmax.Vlu>1000-StartEval) THEN
  WRITELNF(s('¤fmax.Vlu=')+l(fmax.Vlu)+s(' StartEval=')+l(StartEval)+s('¤'));
END;
(*$ ENDIF *)

      IF ~Chess & ((fmax.Vlu<SkipValue) OR (fmax.Fra=10)) THEN
        fmax.Vlu:=SkipValue;
      END;
    ELSE (* IF count=0: *) (* slut *)
(*$ IF False *)WRITELN(s('QFind, Qdepth=')+l(Qdepth)+s(' SkipValue=')+l(SkipValue));READs(strT);(*$ ENDIF *)
      fmax.Vlu:=SkipValue;
    END;
  END;
(*$ IF Test *) IF Tag() THEN ShowLine('EvQf=',fmax.Vlu,FALSE); WRITELNF(0); END;(*$ ENDIF *)
  DEC(Depth);
  DEC(Qdepth);
(*$ IF False *)WRITELN(s('QFindX'));(*$ ENDIF *)
(*$ IF Test0 *)
     WRITELNF(s('QFX: Dpth=')+l(Depth)+s(' Vlu=')+l(fmax.Vlu)+s(' trk=')+l(fmax.Fra)+s('-')+l(fmax.Til));
(*$ ENDIF *)
  IF fmax.Vlu>16000 THEN DEC(fmax.Vlu) END;
  RETURN(fmax.Vlu);
END QFind;

CONST
  HisMax=20; (* change value in SkakFil.GetStilling too *)

VAR         (* FALSE=Hvid 1..HisMax sidste HisMax stillinger+træk *) 
  Repete:ARRAY[FALSE..TRUE],[1..HisMax] OF RECORD
                                     st:STILLINGTYPE;
                                     tr:TRKDATA;
                                   END;
(*$IF Test0 *)
PROCEDURE ShowHistory(str:ARRAY OF CHAR);
VAR
  black:BOOLEAN;
  n:INTEGER;
BEGIN
  WRITELN(s(str));
  FOR black:=FALSE TO TRUE DO
    FOR n:=1 TO HisMax DO
      IF Repete[black,n].tr.Fra>0 THEN
        WRITELN(l(n)+s(': ')+l(Repete[black,n].tr.Fra)+s('-')+l(Repete[black,n].tr.Til)+s(' ')+l(Repete[black,n].tr.Vlu)+s(' HvisTur=')+c(Repete[black,n].st[HvisTur]));
      END;
    END;
  END;
END ShowHistory;
(*$ENDIF *)

PROCEDURE ClearHistory(cnt:INTEGER; black:BOOLEAN);
VAR
  n:INTEGER;
BEGIN
  IF cnt>0 THEN
    IF cnt>HisMax THEN cnt:=HisMax; END;
    FOR n:=1 TO HisMax-cnt DO
      Repete[black,n]:=Repete[black,n+cnt];
    END;
    FOR n:=1+HisMax-cnt TO HisMax DO
      Repete[black,n].tr.Fra:=0;
      Repete[black,n].tr.Til:=0;
    END;
  END;
(*$IF Test0 *)
  ShowHistory(' ClearHistory:');
(*$ENDIF *)
END ClearHistory;

(* use skakfil.getstilling to Add/ClearHistory *)

PROCEDURE AddHistory(VAR stilling:STILLINGTYPE; fra,til,vlu:INTEGER);
(* NOTE: black positions are stored mirror'ed *)
VAR
  black:BOOLEAN;
  n:INTEGER;
BEGIN
  IF (CAP(stilling[fra])='B') OR (stilling[til]<>' ') THEN
    ClearHistory(999,FALSE);
    ClearHistory(999,TRUE);
  ELSE
    black:=stilling[HvisTur]='S';
    FOR n:=HisMax TO 2 BY -1 DO
      Repete[black,n]:=Repete[black,n-1];
    END;
    WITH Repete[black,1] DO
      st:=stilling;
      IF black THEN
        Mirror(st);
        fra:=fra MOD 10+10*(9-fra DIV 10);
        til:=til MOD 10+10*(9-til DIV 10);
      END;
      tr.Fra:=fra;
      tr.Til:=til;
      tr.Vlu:=vlu;
    END;
  END;
 (*$IF Test0 *)
  ShowHistory(' AddHistory:');
(*$ENDIF *)
END AddHistory;

VAR
  FirstCall:BOOLEAN; (* FindTrk sets, then Find see it's first time *)
                     (* and resets FirstCall                        *)

PROCEDURE Find(stilling:STILLINGTYPE; dybde:INTEGER; far,farfar:INTEGER;
(*cf=20*)      cf:INTEGER; VAR traek:TRKDATA; farFra,farTil,farfarFra,farfarTil:INTEGER);
VAR
  dyb,fr,ti,retning,cnt,count,VluTmp,c1,c2,c3,n,KING,reps,til: INTEGER;
  repFra,repTil:INTEGER;
  movetyp: MOVETYPE;
  Trk:TRAEKDATA;
  TraekTst,fmax,repmove:TRKDATA;
  Still:STILLINGTYPE;
  Mirrt,repper,rep1,Chess, FirstCalled:BOOLEAN;
BEGIN
  INC(Depth);
  FirstCalled := FirstCall; (* tells it's called from FindTrk *)
  FirstCall   := FALSE;
(*$ IF Test *)
IF ~(st[0]='Q') THEN
  WRITELNF(s('FIND: Dybde=')+l(dybde)+s(' far=')+l(far)+s(' farfar=')+l(farfar)+s(' Evals=')+l(SkakBrainEval.Evals));
  IF ~(CAP(st[0])='Q') THEN
    IF ToFile THEN
      (* WRITELN(s('see ram:SkakLog')); *)
    ELSE
      WRITE(s(' Q,q,Fra:'));READs(st);
    END;
    IF st[0]=0C THEN 
      FraTag:=0;
    ELSIF (st[0]>='a') & (st[0]<='h') & (st[1]>'0') & (st[1]<'9') THEN
      FraTag:=10*(ORD(st[1])-48)+ORD(st[0])-96;
    ELSE
      FraTag:=99;
    END;
  ELSE
    WRITELN(0);
  END;
END;
(*$ ENDIF *)
  Mirrt:=stilling[HvisTur]='S';
  IF Mirrt THEN
    Mirror(stilling);
  END;
  Chess:=FALSE;
  IF ODD(Depth)=BlacksTurn THEN
    pd:=pdb;
(*$ IF Test0 *)
  WRITELNF(s('F: Mirrt (pd:=pdb)'));
(*$ ENDIF *)
  ELSE
    pd:=pdw;
  END;
  IF stilling[85]='M' THEN
    KING:=85
  ELSE
    KING:=11;
    WHILE (stilling[KING]<>'K') & (KING<89) DO INC(KING) END;
  END;
(*
WRITELN(s('KING=')+l(KING));
*)
  fr:=10;
  ti:=89;
  retning:=0;
  count:=0;
  reps:=0;
  REPEAT           (* lav liste med alle træk (count) *)
    GetNext(stilling,fr,ti,retning,movetyp);
    IF (fr<89) THEN
      INC(count);
      IF slag IN movetyp THEN
        IF (stilling[fr]='b') & (fr>70) THEN
          til:=ti;
          IF til<fr+9 THEN
            VluTmp:=-50;  (* Rook-promotion, so give low priority *)
            til:=til+20;
            IF til<fr+9 THEN
              IF til+2>fr THEN
                VluTmp:=200;  (* knight *)
                til:=til+10;
              ELSE
                VluTmp:=-90;  (* Bishop *)
                til:=til+20;
              END;
            END;
          ELSE  
            VluTmp:=880-100;  (* Queen *)
          END;
          VluTmp:=VluTmp+ValueCalc[CAP(stilling[fr]),CAP(stilling[til])];
        ELSE
          IF stilling[ti]=' ' THEN
            VluTmp:=1;
          ELSE
            VluTmp:=ValueCalc[CAP(stilling[fr]),CAP(stilling[ti])];
          END;
        END;
      ELSE
        IF (stilling[fr]='b') & (fr>70) THEN
          til:=ti;
          IF til<fr+9 THEN
            VluTmp:=-50;  (* Rook-promotion, so give low priority *)
            til:=til+20;
            IF til<fr+9 THEN
              IF til+2>fr THEN
                VluTmp:=200;  (* knight *)
                til:=til+10;
              ELSE
                VluTmp:=-90;  (* Bishop *)
                til:=til+20;
              END;
            END;
          ELSE  
            VluTmp:=880-100; (* Queen *)
          END;
        ELSE
          VluTmp:=pd^[stilling[fr],ti]-pd^[stilling[fr],fr];
        END;
      END;
      Trk[count].Vlu:=VluTmp;
      Trk[count].Fra:=fr;
      Trk[count].Til:=ti;
      Trk[count].Typ:=movetyp;
      IF Depth=1 THEN
        n:=2;
        til:=Repete[Mirrt,n].tr.Til;
        WHILE (n<=HisMax) & (til<>0) & (til<>90) DO 
          IF (ti=Repete[Mirrt,n].tr.Til) THEN
            IF (fr=Repete[Mirrt,n].tr.Fra) THEN
              IF Equal(stilling,Repete[Mirrt,n].st) THEN
                (*$ IF Test0 *)WRITELN(s('!x7!:')+l(n));(*$ ENDIF *)
                INC(reps);
                repmove:=Trk[count];
              END;
            END;
          END;
          n:=n+1;
          IF n<=HisMax THEN
            til:=Repete[Mirrt,n].tr.Til;
          END;
        END;
      END;
    END;
  UNTIL fr=89;
  IF count>1 THEN QSortTrk(Trk,1,count); END; (* new! pre-sort to get better cut-offs *)
(*$ IF Test *)
IF Tag() THEN
  WRITELNF(s('Pre-QS: dybde=')+l(dybde));
  FOR n:=1 TO count DO
    WRITEF(lf(n,3)+s(' ')+lf(Trk[n].Vlu,5)+s(' '));
    ShowMove(Trk[n],Mirrt);
    WRITELNF(0); 
  END
END;
(*$ ENDIF *)

  dyb:=1;
  IF count>0 THEN 
    IF (Depth=1) & (count=1) THEN (* first move is only move! *)
(*$ IF Test *)
IF Tag() THEN WRITELNF(s('Only Move!')); END;
(*$ ENDIF *)
      fmax:=Trk[1];
    ELSE
      (*farfar := -20000;*)
      REPEAT                              (* for dyb:=1 to dybde *)
        IF (dyb=1) & FALSE THEN
          fmax.Vlu:=farfar;
        ELSE
          fmax.Vlu:=-20000;
        END;
        cnt:=0;
        REPEAT                            (* for cnt:=1 to count *)
          INC(cnt);
          IF (dyb=1) OR (Trk[cnt].Vlu>-12000) THEN (* hvis ikke sat mat *)
            Still:=stilling;
            DoMove(Still, Trk[cnt].Fra, Trk[cnt].Til, Trk[cnt].Typ);
  
(*$ IF Test *)
(*IF (Depth=1) & Tag() & (SkakBrainEval.Evals MOD 16 =0) THEN WRITELN(s('Evals: ')+l(SkakBrainEval.Evals)); END;*)
dt[FALSE,Depth]:=Trk[cnt];
dr[FALSE,Depth]:=' ';
(*$ ENDIF *)
            repper:=(reps>0) & (repmove.Til=Trk[cnt].Til) & (repmove.Fra=Trk[cnt].Fra);
            IF repper THEN
(*$ IF Test0 *)  WRITELNF(s('!Find: reps=')+l(reps)+s('!'));(*$ ENDIF *)
              IF reps>1 THEN      (* 3'rd time *)
                Trk[cnt].Vlu:=DrawAccept;                    (* -50 .. 50 *) 
                rep1:=FALSE;
              ELSE
                rep1:=TRUE;
              END;
            END;
            IF ~repper OR rep1 THEN
              IF (slag IN Trk[cnt].Typ)
              OR (Trk[cnt].Fra>70) & (stilling[Trk[cnt].Fra]='b') THEN
                repFra:=0;
                repTil:=0;
                farFra:=0;
                farTil:=0;
              ELSE
                repFra:=Trk[cnt].Fra;
                repTil:=Trk[cnt].Til;
              END;
              IF dyb=1 THEN
                Chess:=CheckSkak(Still,KING,FALSE);
                IF Chess & (dybde=1) THEN (* expand when last move is a chess *)
(*
WRITELN(s('S K A K !'));
*)
                  Find(Still,1,-fmax.Vlu,-far,cf,TraekTst,repFra,repTil,farFra,farTil);
                  IF ~STOPP THEN Trk[cnt].Vlu:=-TraekTst.Vlu; END;
(*$ IF Test0 *)
IF TraekTst.Typ=MOVETYPE{mat} THEN WRITELNF(s('M A T, Vlu=')+l(Trk[cnt].Vlu));END;
dr[FALSE,Depth]:='+';
(*$ ENDIF *)
                ELSE
                  Trk[cnt].Vlu:=-QFind(Still,count,-fmax.Vlu,-far,cf,0,Chess,repFra,repTil,farFra,farTil);
(*$ IF False *)
IF Trk[cnt].Vlu<-12000 THEN WRITELN(s('<-12000 fra=')+l(Trk[cnt].Fra)+s(' Til=')+l(Trk[cnt].Til)); END;
(*$ ENDIF *) 
                END;
              ELSE
                Find(Still,dyb-1,-fmax.Vlu,-far,cf,TraekTst,repFra,repTil,farFra,farTil);
                IF ~STOPP THEN Trk[cnt].Vlu:=-TraekTst.Vlu; END;
                IF ~Push THEN 
                  AEM(); 
                END;
              END;
              IF repper THEN (* adjust eval down 'cause opponent can take repetition *)
(*$ IF Test0 *)
WRITELNF(s('!repPossible->AdjDown! from Vlu=')+l(Trk[cnt].Vlu)+s('fmax=')+l(fmax.Vlu));
(*$ ENDIF *)
                IF Trk[cnt].Vlu>DrawAccept THEN Trk[cnt].Vlu:=DrawAccept; END;
              END;
            END;
            IF STOPP THEN
              IF (fmax.Vlu=farfar) OR (fmax.Vlu=-20000) THEN
                fmax:=Trk[1];
(*$ IF Stamp *) W.CONCAT(W.s('=farfar ')+W.l(fmax.Fra)+W.c(12C)); (*$ ENDIF *)
               END;
            ELSE
              IF Trk[cnt].Vlu>fmax.Vlu THEN
                fmax:=Trk[cnt];
(*$ IF Test0 *)
WRITELNF(s('!fmax!')+l(fmax.Vlu)+s(' far=')+l(far));
(*$ ENDIF *)
(*$ IF Test *)
dt[TRUE,Depth]:=Trk[cnt];
dr[TRUE,Depth]:=' ';
FOR fr:=Depth+1 TO 30 DO
  dt[TRUE,fr]:=dt[FALSE,fr];
  dr[TRUE,fr]:=dr[FALSE,fr];
END; 
(*$ ENDIF *)
              END;
            END;
          END;
        UNTIL (cnt>=count) (* normal END for cnt=1 TO count *)
           OR (fmax.Vlu>far) (* pruning cut *)
           OR (SkakBrainEval.Evals>MaxEvals) & (dyb>1) (* Time cut *)
           OR (fmax.Vlu>16382) (* mate in one found, stop *)
           OR Push;            (* break, stop *)

        (* !!!! if more than 3000 nodes on depth 1 then lower total depth>1 by 1 *)
        (* set between 1000 and 20000 (def: 3000) *)

        IF (SkakBrainEval.Evals>MaxEvals) & (dyb>1) THEN
(*$ IF Stamp *)
   IF FirstCalled THEN
     W.CONCAT(W.s('cnt=')+W.l(cnt)+ W.s(' Evals=')+W.l(SkakBrainEval.Evals)+
              W.s(' dyb=')+W.l(dyb)+W.s(' xcnt=')+W.l(xcnt)+
              W.s(' dybde=')+W.l(dybde)+W.c(12C));
   ELSE
     INC(xcnt);
   END;
(*$ ENDIF *)
          IF dyb<dybde THEN
            dybde:=dyb;
          END;
          STOPP:=TRUE;
(*$ IF Test0 *)
          WRITELN(s('QQQ: Evals=')+l(SkakBrainEval.Evals)+s(' cnt/count=')+l(cnt)+c('/')+l(count)+s(' dyb=')+l(dyb));
(*$ ENDIF *)
        END;
        IF FirstCalled THEN
          IF dyb<=1 THEN 
            (*$ IF Test *) WRITELNF(s('FirstCalled, dybde=')+l(dybde));(*$ ENDIF *)
            IF (SkakBrainEval.Evals>2000) & (dyb<dybde) THEN
              DEC(dybde);
              (*$ IF Test *) WRITELNF(s('AAA evals=')+l(SkakBrainEval.Evals)+s(', dec(dybde)'));(*$ ENDIF *)
            END;
            IF ~Chess & (SkakBrainEval.Evals<30) THEN
              INC(dybde);
              (*$ IF Test *) WRITELNF(s('BBB evals=')+l(SkakBrainEval.Evals)+s(', inc(dybde)'));(*$ ENDIF *)
            END;
          END;
        END;
        IF (fmax.Vlu>12000) THEN dyb:=dybde; END; (* mate found, stop *)
        IF dyb<dybde THEN 
          QSortTrk(Trk,1,cnt);
(*$ IF Test *) 
IF Tag() THEN
  WRITELNF(s('QS: dybde=')+l(dybde)+s(' dyb=')+l(dyb));
  FOR n:=1 TO cnt DO
    WRITEF(lf(n,3)+s(' ')+lf(Trk[n].Vlu,5)+s(' '));
    ShowMove(Trk[n],Mirrt);
    WRITELNF(0);
  END
END;
(*$ENDIF *)

(*$IF Test *)
(*
IF ~(CAP(st[0])='Q') & Tag() THEN
  WRITELN(s('QSortTrk dyb=')+lf(dyb,2));
  FOR n:=1 TO cnt DO
    WRITELN(lf(Trk[n].Fra,3)+lf(Trk[n].Til,3)+lf(Trk[n].Vlu,4));
  END;
END;
*)
(*$ENDIF *)

        END;
        INC(dyb);
      UNTIL dyb>dybde;
    END;
    IF Depth=1 THEN

(* AddHistory called by SkakFil.GetStilling
      FOR n:=HisMax TO 2 BY -1 DO
        Repete[Mirrt,n]:=Repete[Mirrt,n-1];
      END;
      Repete[Mirrt,1].st:=stilling;
      Repete[Mirrt,1].tr:=fmax;
*)
      IF (reps>1) & (repmove.Til=fmax.Til) & (repmove.Fra=fmax.Fra) THEN
        fmax.Typ:=MOVETYPE{x7};
        (*$ IF False *)  WRITELN(s('!Find:x7!'));(*$ ENDIF *)
      END;
    END;
(*$ IF Test *)
    WRITEF(s('Best: Vlu=')+l(fmax.Vlu)+s(' '));
    ShowMove(fmax,Mirrt);
    WRITELNF(0);
(*$ ENDIF *)
  ELSE                  (* no moves, end *)
    fmax.Fra:=89;
    fmax.Til:=10;
    IF stilling[15]='m' THEN
      n:=15;
    ELSE
      n:=11;
      WHILE (n<89) & (stilling[n]<>'k') DO
        INC(n);
      END;
    END;
    IF CheckSkak(stilling,n,TRUE) THEN
      fmax.Typ:=MOVETYPE{mat};
      fmax.Vlu:=-16383;
(*$ IF Test *)
  WRITELNF(s('!MAT!'));
(*$ ENDIF *)
    ELSE
      fmax.Typ:=MOVETYPE{pat};
      fmax.Vlu:=0;
(*$ IF Test *)
  WRITELNF(s('!PAT!'));
(*$ ENDIF *)
    END;
  END;
  IF fmax.Vlu>16000 THEN DEC(fmax.Vlu) END;
  traek:=fmax;
  DEC(Depth);
(*$ IF Test *)
  
(*$ ENDIF *)
END Find;

(*    $ POP RangeChk POP OverflowChk POP StackChk POP ReturnChk *)

PROCEDURE NEq(VAR s1,s2:STILLINGTYPE):BOOLEAN;
VAR
  n:INTEGER;
BEGIN
  n:=11;
  WHILE (n<=HvisTur) & (s1[n]=s2[n]) DO
    INC(n);
  END;
  RETURN(n<=HvisTur);
END NEq;

 (* dybde: 0-9 (0,1,4,7)        ekstra: p.t. unused *)
PROCEDURE FindTrk(VAR stilling:STILLINGTYPE; dybde,ekstra:INTEGER;
                  VAR Traek:TRKDATA; AEMproc:AEMtype);
CONST
  TeoNvn='OPENINGS.TXT';
VAR
  X,N,p,p2,Tnr,fra,til,dyb:INTEGER;
  OK,SLUT:BOOLEAN;
  f:File;
  TN,TL:ARRAY[0..255] OF CHAR;
  ch:CHAR;
BEGIN
  STOPP:=FALSE;
  IF dybde=0 THEN
    til:=10;
    IF stilling[HvisTur]<>'S' THEN
      FOR fra:=11 TO 88 DO
        IF (stilling[fra]='k') OR (stilling[fra]='m') THEN til:=fra; END;
      END;
    ELSE
      FOR fra:=11 TO 88 DO
        IF (stilling[fra]='K') OR (stilling[fra]='M') THEN til:=fra; END;
      END;
    END;
    SkakDepth:=1; XchDepth:=1; MaxPosValGain:=20;
    Traek.Vlu:=QFind(stilling,10,20000,-20000,20,0,
                     CheckSkak(stilling,til,stilling[HvisTur]<>'S'),0,0,0,0);
  ELSE
(*$ IF Stamp *)
  W.Buf := '';
  xcnt := 0;
  Stamp(TRUE,Traek,'');
(*$ ENDIF *)
    OK:=FALSE;

   (* Check om varianttræ har et ok forslag !!!!!!!!!!!!!!!!!!!!!!*)
    IF (TFra>10) & (TTil>10) & (TFra<89) & (TTil<89) THEN
      IF (stilling[HvisTur]='S') & (stilling[TFra]<'a')
      OR (stilling[HvisTur]<>'S') & (stilling[TFra]>'Z') THEN
        MaxTeori:=TraekNr+1;
        Traek.Fra:=TFra;
        Traek.Til:=TTil;
        Traek.Typ:=MOVEnormal;
        OK:=TRUE;
      END;
    END;
(*$IF Test *) WRITELN(s('TFra-Til=')+l(TFra)+s('-')+l(TTil)); (*$ENDIF *)

    IF ~OK & (dybde>1) & (MaxTeori>TraekNr-2) & Equal(DefStill,start.Still) THEN
      (* Open file *)
(*
WRITELN(s('GetTeori'));
*)
      TN:=TeoNvn;
      Lookup(f,TN,1024,FALSE);
      IF f.res=done THEN
        SLUT:=FALSE;
        REPEAT

          (* Get line *)
          p:=-1;
          REPEAT
            INC(p);
            ReadChar(f,TL[p]);
          UNTIL ~(f.res=done) OR (p=SIZE(TL)-1) OR (TL[p]=12C);
          TL[p]:=0C;

          (* Get teori *)
          p2:=0;
          IF (TL[p2]<>';') & (TL[p2]<>0C) THEN (* ikke en kommentar/tom linie *)
            Tnr:=0;
            REPEAT
              INC(Tnr);
              WHILE TL[p2]=' ' DO
                INC(p2);
              END;
              IF TL[p2]='o' THEN (* rokade *)
                fra:=15;
                til:=17;
                IF TL[p2+3]='-' THEN (* lang *)
                  til:=13;
                END;
                IF ~ODD(Tnr) THEN (* sort *)
                  fra:=85;
                  til:=til+70;
                END;
              ELSE
                fra:=ORD(TL[p2+0])-96+(ORD(TL[p2+1])-48)*10;
                til:=ORD(TL[p2+2])-96+(ORD(TL[p2+3])-48)*10;
              END;
(*
WRITE(l(fra)+s('-')+l(til)+s(' '));
*)
              WHILE (TL[p2]<>' ') & (TL[p2]<>0C) DO
                INC(p2);
              END;
            UNTIL (TL[p2]=0C)
            OR (fra<>Spil^[Tnr].Fra)
            OR (til<>Spil^[Tnr].Til)
            OR (Tnr>TraekNr);
(*
WRITELN(l(Tnr)+s(' ')+l(TraekNr));
*)
            IF Tnr>TraekNr THEN
              OK:=TRUE;
(*
WRITELN(s('Gottit'));
*)
              MaxTeori:=TraekNr+1;
              IF ODD(Tnr) THEN (* hvid, så brug FØRSTE variant (ellers sidste) *)
                SLUT:=TRUE;
              END;
              Traek.Fra:=fra;
              Traek.Til:=til;
              Traek.Typ:=MOVEnormal;
            END;
          END;
        UNTIL SLUT OR ~(f.res=done) OR f.eof;
      END;
      Close(f);
    END;

    IF ~OK & (TraekNr<TeoMaxTrk) THEN

      IF ~OK THEN (* Check om kendt mikro teori *)
        X:=0;
        WHILE (X<=TeoMax) & NEq(Teo[X],stilling) DO
          INC(X);
        END;
        IF X<=TeoMax THEN (* fundet stilling *)
          N:=RND(4)+1;
          WHILE (N>0) & (TeoT[X,N].Fra=TeoT[X,N].Til) DO
            DEC(N);
          END;
          IF N>0 THEN (* ryk *)
(*
WRITELN(s('TeoSfundet, Ryk. X=')+l(X)+s(' N=')+l(N));
*)
            Traek:=TeoT[X,N];
            OK:=TRUE;
          END;
        END;
      END;
    END;

    IF ~OK THEN
      FirstCall:=TRUE;
      SkakBrainEval.Evals:=0;
      Depth:=0;

(*$ IF Test *)
Nodes:=0;
IF st[0]<>'Q' THEN st:=''; END;
Lookup(TestFil,'h:SkakLog',8192,TRUE);
(*$ ENDIF *)
      AEM:=AEMproc;
      PreProcessor(stilling);

(*$ IF Test0 *)
FOR ch:='B' TO 't' DO
  CASE ch OF
(*  | 'B','E','T','R','K','M','D','S','L','b','e','t','r','k','m','d','s','l' :*)
    | 'k','K' :           
    WRITELNF(s('pdw^[')+c(ch)+s(']'));
    FOR N:=8 TO 1 BY -1 DO
      WRITEF(l(N)+s(' '));
      FOR X:=1 TO 8 DO 
        fra:=N*10+X;
        WRITEF(lf(pdw^[ch,fra],4));
      END;
      WRITELNF(0);
    END;
    WRITELNF( s('     a   b   c   d   e   f   g   h'));
    WRITELNF(s('pdb^[')+c(ch)+s(']'));
    FOR N:=8 TO 1 BY -1 DO
      WRITEF(l(N)+s(' '));
      FOR X:=1 TO 8 DO 
        fra:=N*10+X;
        WRITEF(lf(pdb^[ch,fra],4));
      END;
      WRITELNF(0);
    END;
    WRITELNF( s('   a   b   c   d   e   f   g   h'));
  ELSE END;
END;
(*$ ENDIF *)

  (* Max Positional Value Gain, used for cutoff 3: *)
  (* 0=77 20=94, 50=137, 100=140 so use:     20-50 *)
  (* SkakDepth:    1-4 *)
  (* XchDepth:     1-4 *)

      MaxEvals          := SHIFT(192,dybde); 
      dyb               := (dybde-1) DIV 3 + 1;         (* 1-3   (1-3)  *)
      SkakDepth         := (dybde+1) MOD 3 + 0;         (* 2-4   (2)    *)
      XchDepth          := (dybde  ) MOD 3 + 1;         (* 1-3   (2)    *)
      MaxPosValGain     := (dybde  ) MOD 3 * 15 + 20;   (* 20-50 (35)   *)
      MaxStackDepth     := 11+dyb*2+(SkakDepth+XchDepth) DIV 2;

      BlacksTurn:=stilling[HvisTur]='S';
      Find(stilling,dyb,20000,-20000,20,Traek,0,0,0,0);
      IF BlacksTurn THEN
        Traek.Fra:=Traek.Fra MOD 10+10*(9-Traek.Fra DIV 10);
        Traek.Til:=Traek.Til MOD 10+10*(9-Traek.Til DIV 10);
      END;
    END;
(*$ IF Stamp *)
  Stamp(FALSE,Traek,W.Buf);
(*$ ENDIF *)
(*$IF Test *)
    WRITELNF(s('Evals=')+l(SkakBrainEval.Evals)+s(' Nodes=')+l(Nodes));
    IF Traek.Typ=MOVETYPE{x7} THEN WRITELN(s('!Traek=x7!')); END;
    Close(TestFil);
(*$ENDIF *)
  END;
END FindTrk;

PROCEDURE GetNextQ(VAR stilling:STILLINGTYPE; VAR fra,til,retning:INTEGER;
                  VAR MoveTyp:MOVETYPE);
(* GetNext i en version der ikke respekterer skak, kun for GetMove(Quick) *)
VAR
  hvid:BOOLEAN;
BEGIN
  IF stilling[HvisTur]='H' THEN
    REPEAT
      IF til>88 THEN
        REPEAT (* find næste hvide brik *)
          INC(fra);
        UNTIL (fra>88) OR (stilling[fra]>'a');
        til:=fra;
        retning:=0;
      END;
      IF fra<>89 THEN GetNextTil(stilling,fra,til,retning,MoveTyp) END;
    UNTIL (til<>89) OR (fra=89);
  ELSE (* sort *)
    REPEAT
      IF til>88 THEN
        REPEAT
          INC(fra);
        UNTIL (fra>88) OR (stilling[fra]<'a') & (stilling[fra]>'A');
        til:=fra;
        retning:=0;
      END;
      IF fra<>89 THEN GetNextTil(stilling,fra,til,retning,MoveTyp) END;
    UNTIL (til<>89) OR (fra=89);
  END;
END GetNextQ;

(* 1'ste træk =1, Udfører træk hvis OK (fra<89) *)
(* Efter kald vil EatChar= den slagne brik (bBsSlLtdDTtR ellers ' ') *)
PROCEDURE GetMove(VAR st:STILLINGTYPE; VAR t:TRKDATA; MoveNr:CARDINAL; Quick:BOOLEAN);
VAR
  fra,til,retning,n:INTEGER;
  movetyp:MOVETYPE;
BEGIN
  fra:=10;
  til:=89;
  retning:=0;
  FOR n:=1 TO MoveNr DO
    IF fra<89 THEN
      IF Quick THEN
        GetNextQ(st,fra,til,retning,movetyp);
      ELSE
        GetNext(st,fra,til,retning,movetyp);
      END;
(*$IF Test *)
    ELSE
  d(s('GetMove: Not that many moves!!!'));
  n:=MoveNr;
(*$ENDIF *)
    END;
  END;
  IF fra<89 THEN  (* udfør træk *)
    IF slag IN movetyp THEN
      EatChar:=st[til];
      IF EatChar=' ' THEN
        IF st[HvisTur]='S' THEN
          EatChar:='b';
        ELSE
          EatChar:='B';
        END;
      END;
    ELSE
      EatChar:=' ';
    END;
    DoMove(st,fra,til,movetyp);
  END;
  t.Fra:=fra;
  t.Til:=til;
  t.Typ:=movetyp;
  t.Vlu:=0;
  (*$IF Test *)
    d(s('GetMove: Fra=')+l(fra)+s(' Til=')+l(til)+s(' MoveNr=')+l(MoveNr));
  (*$ENDIF *)
END GetMove;

PROCEDURE GetMoveNr(VAR st:STILLINGTYPE; Fra,Til:INTEGER; VAR MoveNr:CARDINAL; Quick:BOOLEAN);
VAR
  fra,til,retning:INTEGER;
  movetyp:MOVETYPE;
BEGIN
  fra:=10;
  til:=89;
  retning:=0;
  MoveNr:=0;
  REPEAT
    INC(MoveNr);
    IF fra<89 THEN
      IF Quick THEN
        GetNextQ(st,fra,til,retning,movetyp);
      ELSE
        GetNext(st,fra,til,retning,movetyp);
      END;
  (*$IF False *)
    ELSE
    d(s('GetMoveNr: Move not found!!!'));
  (*$ENDIF *)
    END;
  UNTIL (fra=Fra) & (til=Til) OR (fra=89);
  (*$IF False *)
    d(s('GetMoveNr: Fra=')+l(fra)+s(' Til=')+l(til)+s(' MoveNr=')+l(MoveNr));
  (*$ENDIF *)
END GetMoveNr;

(*  ValueCalc:ARRAY['A'..'T'],[' '..'T'] OF INTEGER; *)
PROCEDURE InitValueCalc;
VAR
  Fra,Til:CHAR;
BEGIN
  ValueCalc['A','B']:=ValueB;
  ValueCalc['A','D']:=ValueD;
  ValueCalc['A','E']:=ValueE;
  ValueCalc['A','K']:=ValueK;
  ValueCalc['A','L']:=ValueL;
  ValueCalc['A','M']:=ValueM;
  ValueCalc['A','R']:=ValueR;
  ValueCalc['A','S']:=ValueS;
  ValueCalc['A','T']:=ValueT;
  ValueCalc['A',' ']:=0;
  FOR Fra:='B' TO 'T' DO
    IF (Fra='B') OR (Fra='D') OR (Fra='E') OR (Fra='K') OR (Fra='L') OR (Fra='M') OR (Fra='R') OR (Fra='S') OR (Fra='T') THEN
      FOR Til:=' ' TO 'T' DO
        IF (Til=' ') OR (Til='B') OR (Til='D') OR (Til='E') OR (Til='K') OR (Til='L') OR (Til='M') OR (Til='R') OR (Til='S') OR (Til='T') THEN
          IF (Fra='K') OR (Fra='M') THEN
            ValueCalc[Fra,Til]:=ValueCalc['A',Til];
          ELSE
            ValueCalc[Fra,Til]:=ValueCalc['A',Til]-ValueCalc['A',Fra];
(*WRITE(s(':')+c(Fra)+c(Til)+s('=')+l(ValueCalc[Fra,Til]));*)
          END;
        END;
      END;
(*WRITELN(0);*)
    END;
  END;
END InitValueCalc;
 
BEGIN
(*$IF Test *)
  WRITELN(s('SkakBrain.1'));
(*$ENDIF *)
  LogVersion("SkakBrain.def",SkakBrainDefCompilation);
  LogVersion("SkakBrain.mod",SkakBrainModCompilation);
  Allocate(Spil,TSIZE(SPIL));
  Assert(Spil#NIL, ADR(" spil: Low memory! "));
  InitValueCalc;
  ClearHistory(999,FALSE);
  ClearHistory(999,TRUE);
(*$IF False *)
  WRITELN(s('SkakBrain.2'));
(*$ENDIF *)
CLOSE
  Deallocate(Spil);
END SkakBrain.
