\input amigatexinfo
\input texinfo
@c %**start of header
@setfilename Chaos_deutsch.guide
@settitle Chaos @value{VERSION}    Dokumentation
@setchapternewpage off

@c
@c  Chaos:                  The Chess HAppening Organisation System     V5.4
@c  Copyright (C)   1993    Jochen Wiedmann
@c
@c  This program is free software; you can redistribute it and/or modify
@c  it under the terms of the GNU General Public License as published by
@c  the Free Software Foundation; either version 2 of the License, or
@c  (at your option) any later version.
@c
@c  This program is distributed in the hope that it will be useful,
@c  but WITHOUT ANY WARRANTY; without even the implied warranty of
@c  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@c  GNU General Public License for more details.
@c
@c  You should have received a copy of the GNU General Public License
@c  along with this program; if not, write to the Free Software
@c  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
@c
@c
@c  $RCSfile: Chaos_deutsch.texinfo,v $
@c  $Revision: 3.3 $
@c  $Date: 1994/12/03 18:02:26 $
@c
@c  This file contains the german documentation.
@c
@c  Computer:   Amiga 1200                  Compiler:   DICE V2.07.54 (3.0)
@c
@c  Autor:      Jochen Wiedmann
@c              Am Eisteich 9
@c        72555 Metzingen
@c              Tel. 07123 / 14881
@c              Internet: jochen.wiedmann@zdv.uni-tuebingen.de
@c

@set VERSION 5.4
@set xrefstring siehe
@set Xrefstring Siehe
@set Chapterstring Abschnitt
@set Sectionstring Abschnitt
@set sectionstring Abschnitt
@set pagestring Seite
@set Contentsstring Inhaltsverzeichnis
@iftex
@afourpaper
@parskip=0.75em
@end iftex
@c %**end of header


@titlepage

@title{Chaos}
@subtitle{The Chess HAppening Organisation System}
@subtitle{}
@subtitle{Version @value{VERSION}}
@author Jochen Wiedmann
@vskip 0pt plus 1filll
@tex
@halign{@hfil#&#@hfil@cr
Copyright @copyright 1993 & Jochen Wiedmann@cr
	   & Am Eisteich 9@cr
	  72555 & Metzingen (Deutschland)@cr
	   & Tel. 07123 / 14881@cr
	   & Internet: jochen.wiedmann@@zdv.uni-tuebingen.de@cr
}
@end tex

Diese Dokumentation sowie das gesamte Programmpaket dürfen im Rahmen der
``GNU General Public License''
kopiert, verändert und weitergegeben werden solange diese
Copyright-Notiz und diese Erlaubnis unverändert auf allen Kopien enthalten
ist und die
``GNU General Public License'' der Free Software Foundation (in der Datei
@code{COPYING}) mitkopiert und weitergegeben wird.

@ignore
Permission is granted to process this file by TeX and print the results,
provided the printed document carries a copying permission notice identical to
this one except for the removal of this paragraph (this paragraph not being
relevant to the printed manual).
@end ignore

Es wird @strong{keine} Garantie gegeben, daß die Programme, die in dieser
Dokumentation beschrieben werden, 100%ig zuverlässig sind. Sie benutzen
diese Programme auf eigene Gefahr. Der Autor kann auf @strong{keinen} Fall
für irgendwelche Schäden verantwortlich gemacht werden, die durch die
Anwendung dieser Programme entstehen.

Das Programm und der Quelltext (oder Teile davon) dürfen ausdrücklich
auf Maschinen benutzt werden, die für die Forschung,
Entwicklung, Konstruktion, Tests oder Produktion von Waffen oder anderen
militärischen Gütern benutzt werden. (Je mehr die Leute sich mit Schach
beschäftigen, desto weniger kommen sie dazu, anderen Unsinn zu treiben. :-)
@end titlepage
@iftex
@headings double
@end iftex

@ifinfo
@node Top
@top Chaos V@value{VERSION} Dokumentation
Diese Datei beschreibt den Umgang mit Chaos V@value{VERSION}, einem Programm
zur Organisation von Schachturnieren. Chaos kann Turniere nach Schweizer
System ebenso wie Rundenturniere ausrichten und anschließend auf Wunsch
sogar die DWZ-Zahlen der Teilnehmer neu berechnen.

@menu
Allgemeines:

* Copyright::        Copyrights, (Nicht)-Garantie
* Übersicht::        Was ist Chaos?
* Installation::     Wie kriege ich das Ding zum Laufen?

Arbeit mit dem Programm:

* Turnierorganisation::   Allgemeines zum Umgang mit dem Programm
* Programmstart::         Aufruf des Programms (CLI oder Workbench)
* Dateneingabe::     Über die Eingabemasken
* Menüs::        Beschreibung der Menüs des Programms
* DWZ-Wertung::      Zur Ausgabe der DWZ-Wertung
* ARexx::            Chaos als Batchprogramm

Überflüssiges:

* Algorithmen::      oder: Was macht das Ding eigentlich?
* (Prä)-historisches:Historie.    Entwicklung des Programms
* Zukunft::        Was will ich (und was könnt ihr) machen?
* Danksagungen::     Was ich schon lange mal sagen wollte@dots{}
* Literatur::        Lesenswertes
* Index::        Wo das steht, was garantiert nicht gesucht wird
@end menu
@end ifinfo





@ifinfo
@node Copyright
@chapter Copyright und andere rechtliche Dinge
@cindex Copyright
@cindex Distribution
@cindex Rechtliche Dinge
@cindex Genehmigungen
@cindex Verbote
@cindex Autor
@cindex Adresse
@cindex Internet
@cindex Mail
@example
Copyright @copyright{} 1993     Jochen Wiedmann
			Am Eisteich 9
		  72555 Metzingen (Deutschland)
			Tel. 07123 / 14881
			Internet: jochen.wiedmann@@zdv.uni-tuebingen.de
@end example

Diese Dokumentation sowie das gesamte Programmpaket dürfen im Rahmen der
``GNU General Public License''
kopiert, verändert und weitergegeben werden solange diese
Copyright-Notiz und diese Erlaubnis unverändert auf allen Kopien enthalten
ist und die
``GNU General Public License'' der Free Software Foundation (in der Datei
@code{COPYING}) mitkopiert und weitergegeben wird.

@ignore
Permission is granted to process this file by TeX and print the results,
provided the printed document carries a copying permission notice identical to
this one except for the removal of this paragraph (this paragraph not being
relevant to the printed manual).
@end ignore

Es wird keine Garantie gegeben, daß die Programme, die in dieser Dokumentation
beschrieben werden, 100%ig zuverlässig sind. Sie benutzen diese Programme auf
eigene Gefahr. Der Autor kann auf @strong{keinen} Fall für irgendwelche
Schäden verantwortlich gemacht werden, die durch die Anwendung dieser
Programme entstehen.

Das Programme und der Quelltext (oder Teile davon) dürfen ausdrücklich
auf Maschinen benutzt werden, die für die Forschung,
Entwicklung, Konstruktion, Tests oder Produktion von Waffen oder anderen
militärischen Gütern benutzt werden. (Je mehr die Leute sich mit Schach
beschäftigen, desto weniger kommen sie dazu, anderen Unsinn zu treiben. :-)

@end ifinfo


@node Übersicht
@chapter Übersicht
@cindex Übersicht
@cindex Compiler
@cindex Programmiersprache
Chaos V@value{VERSION} ist ein vollständig in C geschriebenes und mit
DICE V2.07.54-3.0 compiliertes Programm. Es kann Turniere nach
dem Schweizer System (@pxref{Schweizer System}) ebenso wie Rundenturniere
(@pxref{Rundenturnier}) verwalten und auf Wunsch anschließend
die DWZ-Wertung ausführen. Dabei arbeitet es nach den
im @cite{Turnierleiterhandbuch des Deutschen Schachbundes} beschriebenen
Algorithmen (@pxref{Algorithmen}). Diese dürften in Details vom
FIDE-Algorithmus abweichen, im großen und ganzen aber damit übereinstimmen.
(Mir sind die FIDE-Algorithmen nicht bekannt.) Es ist damit gut für kleinere
Turniere, etwa Vereinsturniere und aufgrund seiner Geschwindigkeit auch für
Schnellturniere oder Blitzturniere geeignet, bei denen es vor allem auf
Bedienungskomfort ankommt. Dank der bereits angesprochenen und später
genauer beschriebenen Algorithmen sollte es dabei die jeweiligen
Auslosungen zur allgemeinen Zufriedenheit durchführen.

Bei ungerader Teilnehmerzahl vergibt das Programm ein Freilos (Schweizer
System) bzw. gibt einem Teilnehmer pro Runde spielfrei (Rundenturnier).
Im Schweizer System ist es möglich, nach der 1. Runde noch Teilnehmer
aufzunehmen. Ausgeschiedene Teilnehmer kann man markieren, die Auslosung
wird dann daran angepaßt. @xref{Teilnehmer}.

Das Programm macht (fast) alle Ausgaben wahlweise auf Bildschirm oder
Drucker, kann Tabellen nach Punkten, Buchholzpunkten (sogar nach verfeinerten
Buchholzpunkten) oder nach der Sonneborn-Berger-Wertung sortieren
(@pxref{Voreinstellungen}), kann Fortschritts- und Kreuztabellen ausgeben
(letztere allerdings nur als @TeX{}-Quelltexte) und das alles mit einer
Standard-Intuition-Oberfläche, die eigentlich sogar ohne Erläuterungen
bedienbar sein sollte. (Kein Grund, diese Dokumentation und speziell den
Abschnitt über Vorsichtsmaßnahmen nicht weiterzulesen!
@xref{Vorsichtsmassnahmen, ,Vorsichtsmaßnahmen}.)

@cindex Einschränkungen
@cindex Anzahl der Teilnehmer
@cindex Anzahl der Runden
Die Anzahl der Teilnehmer ist nur durch die Speicherkapazität begrenzt.
(Ca. 3 KByte pro Teilnehmer sollten schon da sein)


@node Installation
@chapter Installation des Programms
@cindex Installation
@cindex Systemanforderungen
Chaos ist unter Kickstart 3.0 entwickelt und sollte mit Kickstart 2.0 oder
höher laufen. Chaos kann mit der @code{locale.library} arbeiten, aber auch
unter 2.0 ist die Verwendung verschiedener Sprachen möglich. Wer immer noch
mit Kickstart 1.2 oder 1.3 arbeitet, ist meiner Meinung nach selber schuld.
Für den Programmierer ebenso wie für den Anwender ist 2.x eine wunderbare
Sache.

Was Chaos unbedingt benötigt, ist die mui.library, Version 2.0 oder neuer.
Diese ist Shareware und kann frei kopiert werden. MUI (@code{Magic User
Interface}) findet sich z.B. auf dem Aminet (Directory
@file{/pub/aminet/dev/gui}) oder auf den Fish-CD's. Es widerspricht eigentlich
meinen Intentionen, Software zu verwenden, für die bezahlt werden muß, aber
die Vorteile von MUI sind meines Erachtens so groß, daß ich mich trotzdem
dazu entschlossen habe. Außerdem ist die Registrierungsgebühr von MUI mit
20DM recht niedrig und prinzipiell kann man das Programm auch als
nicht registrierter MUI-Anwender benutzen. Allerdings möchte ich alle
Chaos-Benutzer ausdrücklich dazu auffordern, sich für MUI auch tatsächlich
registrieren zu lassen.

Eine Festplatte ist nicht unbedingt nötig, aber (wie üblich) sinnvoll.
Allerdings dürfte es schwierig sein, Chaos @emph{und} MUI auf einer Diskette
unterzubringen.

Die Installation ist simpel: Die Datei @file{chaos.lha} muß ausgepackt werden.
Dies ist an dieser Stelle vermutlich bereits geschehen, sonst könnte
dieser Text wohl nicht gelesen werden. ;-)  Falls nicht, so kann das mit
dem Befehl

@t{lha x Chaos@value{VERSION}bin.lha}

@noindent
erledigt werden. (Das Programm LhA findet man auf z.B. Fish-Disketten.)
Ähnlich kann man auf Wunsch auch die Quelltexte auspacken, die sich in der
Datei @file{Chaos@value{VERSION}src.lha} befinden.

Damit ist die Installation eigentlich auch schon beendet! Wenn Sie allerdings
kein eigenes Verzeichnis für das Programm haben wollen, dann müssen Sie
die benötigten Dateien evtl. über mehrere verschiedene Directories verteilen.
Zur Installation steht Ihnen dann das Install-Skript zur Verfügung, das Sie
einfach durch Anklicken des entsprechenden Icons aufrufen. Dieses
kopiert im Novice-Mode einfach das Programm nach @file{c:}, das Vorgabeicon
nach @file{s:} und die gewünschten Catalogs nach @file{Locale:Catalogs}
(falls vorhanden). Beachten Sie bitte, daß Chaos auch unter Workbench 2.0 mit
Catalogs arbeiten kann und Sie deshalb auch hier ein solches Verzeichnis
erzeugen sollten. Das Skript benötigt zur Ausführung das Programm
@code{Installer}, das ab Workbench 2.1 Teil des Betriebssystem ist. Es gibt
auch eine frei kopierbare Version dieses Programms, die Sie ebenfalls auf
den Fish-Disketten und auf dem Aminet im Directory
@file{/pub/aminet/util/misc} finden sollten.

Wer @code{Installer} nicht besitzt, muß die Installation von Hand vornehmen.
Das Programm benötigt evtl. (bei Benutzung der @code{locale.library}) das
Verzeichnis @file{Catalogs} und die darin befindlichen Dateien. Damit diese
gefunden werden, muß entweder das Verzeichnis @file{Catalogs} im gleichen
Verzeichnis wie das Programm stehen oder nach @file{locale:} kopiert werden.
Letzteres geschieht mit dem Befehl

@t{copy Catalogs locale:Catalogs all}

@noindent
Ohne die @code{locale.library} steht leider nur die englischsprachige Version
zur Verfügung. Derzeit gibt es nur ein deutsches Catalogfile. Wer andere
Sprachen verwenden möchte, kann die Datei @file{src/NewCatalog.ct} als
Vorlage benutzen. Neue Catalogfiles bitte ich an mich zu senden.

Analog dazu muß das Verzeichnis @file{s} mit der Datei
@file{Chaos_project.info} vorhanden oder nach @code{s:} kopiert werden. Hier
lautet der Kopierbefehl

@t{copy s s: all}

@file{Chaos_project.info} enthält das Project-Icon, mit dem die
abgespeicherten Turniere auf Wunsch versehen werden und kann z.B. mit
@code{IconEd} verändert werden. @xref{Programmstart}.

Schließlich finden Sie im Directory @file{Rexx} einige Beispielprogramme,
die die Benutzung von Chaos von einem ARexx-Programm aus demonstrieren.
Evtl. sollten Sie auch diese kopieren.

@cindex Stack
Der Aufruf des Programms erfolgt vom CLI oder von der Workbench durch
Anklicken des Icons. Wesentlich ist dabei, daß Chaos mit seinen rekursiv
arbeitenden Algorithmen genügend Stack hat! Pro Teilnehmer sollten
etwa 50 Bytes Stack gerechnet werden plus 4000 für das Betriebssystem und
andere Dinge. Mit einem Stack von 20000 Bytes sollte man also bequem und
ohne Befürchtungen auskommen. (Dieser Wert ist die Voreinstellung im
Chaos-Icon.) Die Größe des Stack wird mit dem Workbench-Menüpunkt Info
(bzw. Informationen bei der deutschsprachigen Workbench) oder im CLI mit
dem Stack-Kommando vor dem Aufruf des Programms eingestellt. Letzteres
geschieht mit folgendem Befehl (entweder in der Datei @file{shell-startup}
oder von Hand vor jedem Aufruf des Programms):

@t{stack 20000}

Anzumerken ist schließlich noch, daß Chaos einige besondere Zeichen bei der
Bildschirmausgabe verwendet. Bitte achten Sie deshalb darauf, daß auf der
Workbench ein Font eingestellt ist, der @strong{alle} 256 Amiga-Zeichen
enthält!

@node Turnierorganisation
@chapter Turnierorganisation
Dieses Kapitel enthält mehr allgemeine Hinweise und ist für die
Arbeit mit dem Programm nicht unbedingt nötig. Speziell den Abschnitt über
Vorsichtsmaßnahmen sollten Sie sich aber unbedingt ansehen.

@menu
* Vorbereitungen   ::   Woran @emph{Sie} bestimmt ohnehin denken@dots{}
* Vorsichtsmaßnahmen:Vorsichtsmassnahmen. Murphy läßt grüßen ;-)
@end menu

@node Vorbereitungen
@section Vorbereitungen
@cindex Spielraum
@cindex Vorbereitungen
Zu den Vorbereitungen kommen (neben den ohnehin anfallenden Arbeiten wie
Beschaffung des Raumes, der Figuren usw.) beim Einsatz eines Computers
einige zusätzliche Probleme und Fragen, die Sie vorher klären sollten:

@itemize @bullet
@item
Wieviele Personen werden an dem Turnier teilnehmen? Falls das mehr als
ca. 20 sind, dann müssen Sie damit rechnen, daß beim Turnierbeginn
plötzlich ein Haufen von Leuten gleichzeitig angemeldet werden müssen.
Da immer nur @emph{ein} Mitarbeiter Daten in den Computer eingeben kann,
führt das leicht zu einer überflüssigen und unerwünschten Verzögerung.
Sie sollten deshalb bestrebt sein, durch Voranmeldungen schon vorher
alle nötigen Daten bereitzustellen und einzugeben.

@item
Betrachten Sie den Raum, in dem das Turnier stattfindet: Gibt es einen
Nebenraum für den Computer? Falls nicht: Können Sie einen Laser- oder
Tintenstrahldrucker organisieren? (Nadeldrucker sind entsetzlich laut!)
Gibt es genügend Steckdosen?

@item
Wenn Sie nicht ihren eigenen Drucker benutzen, müssen Sie daran denken,
die nötigen Druckertreiber zu installieren. Vor dem Start des Programms
(präziser: Vor dem ersten Ausdruck :-) müssen Sie außerdem die
Preferences auf diesen Drucker einstellen.

@item
Sorgen Sie dafür, daß der Computer einen Platz hat, wo keine
unberechtigten Personen hinkommen. (Ich habe diesbezüglich sehr
schlechte Erfahrungen mit kleinen Kindern.)
@end itemize

@node Vorsichtsmassnahmen
@section Vorsichtsmaßnahmen
@cindex Vorsichtsmaßnahmen
``Was nicht sein kann, das nicht sein darf!'' Wenn Sie genauso denken,
dann lassen Sie diesen Abschnitt ruhig aus. Falls nicht, dann überlegen
Sie einmal: Was passiert, wenn mitten im Turnier mein Computer ausfällt?
Wenn Sie entsprechend vorgesorgt haben, dann kann Sie das eigentlich
kalt lassen.

@cindex Backup
Ihr oberstes Prinzip sollte sein, stets mindestens eine Kopie des
Programms sowie aller wichtigen Daten parat zu haben. Da Auslosungen
(wie schon der Name sagt) wenigstens ein kleines bißchen durch den
Zufall bestimmt werden, sollten Sie nach @emph{jeder} Auslosung
diese Kopie auf den neuesten Stand bringen. Nach meiner Erfahrung ist es
außerdem sinnvoll, nach jeder Auslosung eine @emph{andere} Datei anzulegen.
(Beispielsweise könnte nach einer Auslosung und nach dem Abspeichern, aber
noch vor der Austragung der Spiele entdeckt werden, daß ein Ergebnis falsch
eingegeben wurde. Dann haben Sie durch Laden der alten Kopie die Möglichkeit,
die Auslosung mit dem korrigierten Ergebnis zu wiederholen.
@xref{Turnier, ,Speichern als}.) Ferner wäre es für den
Fall aller Fälle sinnvoll, einen zweiten Amiga-Besitzer im gleichen
Ort zu kennen@dots{}

Was außerdem passieren könnte, ist ein Fehler des Programms. :-(
(Versuchen Sie das als Vorzug zu sehen, daß der Programmautor daran
denkt und nicht als drohendes Anzeichen. @w{:-)} In diesem Fall müssen Sie
das Turnier von Hand weiterführen. Das Programm gibt Ihnen in diesem
Fall die Möglichkeit, mit dem entsprechenden Menüpunkt
@code{Spielerkarten} alle dazu nötigen Daten auszudrucken.
(Die Ausgabe erfolgt derzeit in eine @TeX{}-Datei. Die Ausgabe von
@TeX{} ist bekanntlich recht langsam. Ich wäre dankbar für Anregungen,
wie man dies anders gestalten kann.) @xref{Ausgabe, ,Spielerkarten}.

@node Programmstart
@chapter Programmstart
@cindex CLI
@cindex Workbench
@cindex Programmstart
@cindex Optionen
@cindex Tooltypes
@cindex Argumente
Das Programm wird wahlweise vom CLI oder von der Workbench durch Anklicken
des Programmicons oder eines Turniericons gestartet. Im CLI sieht die Syntax
des Aufrufs folgendermaßen aus:

@center @code{Chaos FILE,MAKEICONS/S,DEFICON/K,LANGUAGE/K,NOWINDOW/S}

Dies ist die Bedeutung der Argumente:
@table @code
@item FILE
ist der Name einer zu ladenden Turnierdatei. Wird kein Dateiname angegeben,
so wird startet das Programm mit einem neuen Turnier ohne Namen. In diesem
Fall sollten Sie damit beginnen, den Menüpunkt @code{Neues Turnier}
aufzurufen.

@item MAKEICONS
veranlasst das Programm, erzeugte Turnierdateien mit Workbench-Icons zu
versehen. Wenn das Programm vom CLI gestartet wird, so werden normalerweise
keine Icons erzeugt.

@item DEFICON
ist der Name eines Icons, das fuer die Turnierdateien kopiert wird. Vorgabe
ist @file{s/Chaos_Project}. Bitte beachten Sie, daß die @code{icon.library}
automatisch die Endung @file{.info} anhängt! Wird das angegebene Icon nicht
gefunden, so wird außerdem versucht, @file{s:Chaos_Project} zu laden. Wird
auch dies nicht gefunden, so wird das übliche Project-Icon von der
Kickstart übernommen.

@item MENUFILE
ist der Name einer Datei, die zu lesen ist, um eigene Menüpunkte in das
Menü @code{Spezielles} einzubauen. (Vorgabe ist @file{s/Chaos_Menu}.)
@xref{Eigene Menuepunkte, Eigene Menüpunkte, Eigene Menüpunkte}.

@item LANGUAGE
ist der Name der zu verwendenden Sprache. Diese Option ist ausschließlich
für Benutzer der Workbench 2.0 gedacht. Benutzen Sie sie nicht unter 2.1
oder höher! Vorgegeben ist Englisch. Natürlich müssen bei Verwendung einer
anderen Sprache auch die entsprechenden Catalog-Dateien installiert sein.

@item NOWINDOW
gibt an, daß kein Fenster eröffnet werden soll. Dies ist nur dann sinnvoll,
wenn das Programm von ARexx aus gesteuert wird.

@item WINNERPOINTS
@itemx DRAWPOINTS
gibt die Zahl der Punkte an, die ein Spieler für einen Sieg bzw. ein Remis
erhät. Beachten Sie, daß diese Zahl durch 2 dividiert wird. Siehe auch
@ref{Turniereingabe}.
@end table

Die Workbench-Tooltypen entsprechen den CLI-Argumenten. Sie können sowohl
im Project-Icon der Turnierdatei als auch im Tool-Icon des Programms
gesetzt werden. (Tooltypen des Projekticons haben Vorrang.) Allerdings
werden beim Start von der Workbench normalerweise Icons erzeugt. Deshalb
entfällt der Tooltyp @code{MAKEICONS} und es gibt stattdessen einen
Tooltyp @code{NOICONS}. Ferner entfällt hier der Tooltyp @code{NOWINDOW}.
(Ich sehe keinen Sinn darin, das Programm von der Workbench aufzurufen, ohne
ein Fenster zu eröffnen.)

@node Dateneingabe
@chapter Dateneingabe
@cindex Eingabemasken
@cindex Abbruch
Die Dateneingabe arbeitet mit den Standard-Intuition-Gadgets. Sie sollten
also sofort damit zurechtkommen. Einige Prinzipien gelten aber generell:

@itemize @bullet
@item
Sie haben überall die Möglichkeit, ihre Aktionen wieder abzubrechen. Zu
diesem Zweck sind alle Windows mit @key{Close}- und @key{Cancel}-Gadgets
versehen. Ferner können Sie alle Fenster durch Drücken der @key{Esc}-Taste
beenden.

@item
Alle Eingabemasken haben ein @key{Ok}-Gadget und werden erst durch Anklicken
dieses Gadgets beendet. Dem Anklicken des @key{Ok}-Gadgets entspricht das
Drücken der Taste @key{Ctrl-Return}. Allerdings ist es möglich, daß Sie in
diesem Fall zunächst ein Stringgadget deaktivieren müssen. Die beste Methode
ist, im MUI-Preferences-Programm diese Taste für @code{Gadget Off}
einzustellen. Dann kann man mit zweimaligem @key{Ctrl-Return} jedes Fenster
beenden.

@item
Bei Eingabemasken mit String-Gadgets ist zu Anfang eines dieser Gadgets
aktiviert. Eingegebener Text erscheint in diesem Gadget. Durch die
Return-Taste wird jeweils das nächste String-Gadget aktiviert.

@item
MUI macht es möglich, völlig ohne Maus zu arbeiten. Bitte lesen Sie näheres
in der MUI-Dokumentation. Es sei lediglich erwähnt, daß Sie mit Tab bzw.
Shift-Tab das jeweils nächste bzw. letzte Gadget aktivieren, Listview-Gadgets
mit den Cursortasten steuern und Buttons (z.B. das Ok-Gadget) mit der
Return-Taste betätigen können. Außerdem können Sie in den MUI-Preferences
auf Wunsch auch die Tastaturbelegung umstellen.
@end itemize

@menu
* Turniereingabe::   Eingabe globaler Turnierdaten
* Teilnehmerauswahl:: Auswahl eines Teilnehmers
* Teilnehmereingabe::   Eingabe von neuen Teilnehmern
* Spieleingabe::  Setzen von Spielen im Schweizer System
* Ergebniseingabe::   Eingabe von Ergebnissen
@end menu

@node Turniereingabe
@section Das Turniereingabefenster
@cindex Turniereingabefenster
@cindex Turniername (Gadget)
Das Turniereingabefenster erscheint bei der Wahl des Menüpunktes
@code{Neues Turnier}. Siehe dazu @ref{Turnier, ,Neues Turnier}. Es enthält
ein Stringgadget, in das der Turniername einzugeben ist.
Dieser Name erscheint auf dem Hauptfenster und bei den auf den Drucker
ausgegebenen Daten. Falls Sie mehrere Gruppen in einem
Turnier haben, dann sollten Sie den Gruppennamen hier mit aufnehmen,
z.B. ``1. Metzinger Weinbergturnier (A-Jugend)''

Unter dem Turniernamen kann man (wie mit den Argumenten @code{WINNERPOINTS}
und @code{DRAWPOINTS} beim Programmstart die Zahl der Punkte eingeben, die
ein Spieler für ein gewonnenes Spiel bzw. ein Remis erhält. Diese Zahlen
werden durch 2 dividiert: Für die üblichen 1 bzw. 0.5 Punkte sind also
2 bzw. 1 einzugeben. (Dies ist auch die Vorgabe.) Möchte man stattdessen
etwa einen Punkt für Remis und 3 Punkte für einen Sieg vergeben, so sind
stattdessen 6 und 2 einzugeben.
@xref{Programmstart}.


@node Teilnehmerauswahl
@section Das Teilnehmerauswahlfenster
@cindex Teilnehmerauswahlfenster
Das Teilnehmerauswahlfenster erscheint bei den Menüpunkten @code{Teilnehmer
ändern} und @code{Teilnehmer löschen}. @xref{Teilnehmer}. Es präsentiert
eine Liste aller Spieler, die mit den üblichen Gadgets auf- und
abwärtsgescrollt werden kann. Sie können wahlweise einen einzigen Teilnehmer
durch einfaches Anklicken oder wie in der Workbench die Icons können Sie
auch mehrere Teilnehmer durch Anklicken mit gedrückter Shift-Taste
aktivieren. Der Button @code{Invertieren} erlaubt es Ihnen, Ihre Auswal
gerade umzudrehen: Alle aktivierten Teilnehmer werden deaktiviert und
umgekehrt. Der links unten stehende Button (z.B. @code{Modifizieren})
beendet die Teilnehmerauswahl.


@node Teilnehmereingabe
@section Das Teilnehmereingabefenster
@cindex Teilnehmereingabefenster
Das Teilnehmereingabefenster erscheint bei der Wahl der Menüpunkte
@code{Neuer Teilnehmer} und @code{Teilnehmer ändern}. @xref{Teilnehmer}.
Es besitzt folgende Gadgets:

@table @strong
@item Name
@cindex Name (Gadget)
Der Name der Teilnehmer wird zum Teil bei der Auslosung verwendet. Es ist
deshalb nötig, daß die Teilnehmer alphabetisch korrekt sortiert sind. Dazu
müssen alle Namen einheitlich eingegeben sein. Vorgeschlagen wird:
Nachname, Komma, Leerzeichen, Vorname, also z.B. Wiedmann, Jochen.
@xref{Schweizer System}.

Jeder Teilnehmer muß einen eigenen Namen haben! Das Programm akzeptiert keine
Teilnehmer mit leerem Namensfeld und keine doppelten Namen. Notfalls müssen
Sie z.B. @samp{Schmid, Eugen (2)} eingeben!

@item Straße
@itemx Wohnort
@itemx Telefonnummer
@cindex Straße (Gadget)
@cindex Wohnort (Gadget)
@cindex Telefonnummer (Gadget)
Die Adressen der Teilnehmer werden im Normalfall nur bei Turnieren benötigt,
die längere Zeit dauern. Dann sollten Sie diese aber bereithalten, schon
allein um Kontakte der Teilnehmer untereinander zu ermöglichen.

@item Schachclub
@cindex Schachclub (Gadget)
Den Schachclub eines Teilnehmers benötigt man im allgemeinen kaum. Es kann
aber erwünscht sein, daß er z.B. auf der Teilnehmerliste auftaucht.

@item Geburtsdatum
@cindex Geburtsdatum (Gadget)
Das Geburtsdatum eines Teilnehmers wird nur für die DWZ-Wertung benötigt,
da aber unbedingt. Derzeit muß es unbedingt in der Form dd.mm.yy oder
dd.mm.yyyy eingegeben werden! (Ich hätte gerne die exzellente DOS-Funktion
StrToDate verwendet. Diese hat aber einen kleinen Nachteil: Sie akzeptiert
nur Daten vor dem 1.1.1978, d.h. nicht einmal meinen eigenen
Geburtstag@dots{})

Wird ein Geburtsdatum eingegeben, so überprüft das Programm, ob dieses
plausibel ist. Nicht plausible Daten oder Daten in unkorrektem Format
werden nicht akzeptiert.

@item DWZ
@cindex DWZ (Gadget)
Die DWZ wird für die Auslosung der ersten Runde beim Schweizer System
benötigt, falls diese nach FIDE-System ablaufen soll. (Bei Blitz- oder
Schnellturnieren wird das nicht der Fall sein.) Selbstverständlich wird
die DWZ auch für die DWZ-Wertung benötigt. In anderen Ländern können Sie
für die Auslosung eine andere nationale Wertungszahl (z.B. USCF) eingeben,
vorausgesetzt, diese ist ebenfalls absteigend sortiert (bessere Spieler
haben höhere Zahlen). Natürlich sollten Sie keine verschiedenen Wertungen
mixen, sondern im Zweifelsfall umrechnen.

Bitte beachten Sie, daß die offizielle Form der DWZ etwa so aussieht, wie
1834-23, was eine DWZ von 1834 aus 23 gewerteten Turnieren bedeutet. Chaos
akzeptiert beide Formen.

@item ELO
@cindex ELO (Gadget)
Bei Teilnehmern mit ELO-Zahl wird diese zur Bestimmung der Rangliste
verwendet. (Dies scheint mir so sinnvoll, aber könnte auch anders
gehandhabt werden.) Wenn Sie eine andere Wertung als DWZ verwenden, dann
sollten Sie ELO-Zahlen nur dann eingeben, wenn diese vergleichbar sind,
d.h. Spieler mit gleicher DWZ bzw. ELO-Zahl etwa gleichstark sein dürften.
@end table

@noindent
Zu allen diesen Stringgadgets siehe auch @ref{Dateneingabe}.

@table @strong
@item Senioren
@itemx Junioren
@itemx Damen
@itemx A-Jugend
@itemx B-Jugend
@itemx C-Jugend
@itemx D-Jugend
@itemx E-Jugend
@cindex Senioren (Gadget)
@cindex Junioren (Gadget)
@cindex Damen (Gadget)
@cindex A-Jugend (Gadget)
@cindex B-Jugend (Gadget)
@cindex C-Jugend (Gadget)
@cindex D-Jugend (Gadget)
@cindex E-Jugend (Gadget)
Wenn Sonderwertungen ausgeführt werden sollen, aber alle Teilnehmer in
einer Gruppe spielen (z.B. ein Sonderpreis für die beste Frau), dann kann
man mit diesen Gadgets die entsprechenden SpielerInnen markieren. Dies hat
auf das Turnier keinen Effekt. Es ist lediglich möglich, für die markierten
Teilnehmer gesonderte Tabellen auszugeben. Siehe auch @ref{Ausgabe}.
@end table

@node Spieleingabe
@section Setzen von Spielen im Schweizer System
@cindex Setzen von Spielen
Im Schweizer System kann es unter Umständen sinnvoll (oder zumindest
wünschenswert) sein, bestimmte Paarungen zu erzwingen. Dazu erscheint dieses
Fenster, bevor eine Runde nach Schweizer System gelost wird. Da das im
Normalfall wohl nicht gewollt ist, kann das Fenster durch den Menüpunkt
@code{Spiele setzen} unterdrückt werden. @xref{Voreinstellungen,
Spiele setzen, Spiele setzen}.

Im Fenster finden Sie auf der linken Seite eine Liste aller aktiven Spieler
(d.h. der Spieler, die nicht ausgeschieden sind). Ein Spieler wird durch
Doppelklick auf seinen Namen gesetzt und erscheint dann auf der rechten
Seite in der Liste der Spiele. Ein Spiel wird also gesetzt, indem man
die beiden Kontrahenten nacheinander anklickt. Dabei erlaubt das Programm
natürlich keine Paarungen, die bereits stattgefunden haben. Falls eine
Paarung gewählt wird, die aufgrund der Farbverteilung eigentlich verboten
wäre, so wird dies nur nach Rückfrage erlaubt. Mit dem @code{Delete}-Button
können Sie ein gesetztes Spiel wieder löschen.

Die Farbverteilung sollte normalerweise durch Chaos vorgenommen werden, um
für spätere Runden die Auslosung möglichst zu erleichtern. Falls dies
jedoch aus irgendwelchen Gründen doch anders erwünscht ist, so kann dies mit
einem Cycle-Gadget unterhalb der Spielerliste eingestellt werden. In diesem
Fall erhält der jeweils zuerst gesetzte Spieler Weiß. (Andernfalls ist die
Reihenfolge beliebig.) Spiele mit festgesetzten Farben erkennt man daran,
daß hinter den Namen der beiden Spieler das Kürzel @samp{(Fg)} (Farben
gesetzt) auftaucht.

Auch die Vergabe eines Freiloses ist möglich: Dazu wird als letzter Spieler
der Spieler angeklickt, der das Freilos erhalten soll, d.h. es wird eine
ungerade Zahl von Spielern gesetzt. Natürlich wird dies nur erlaubt, wenn
die Zahl der aktiven Spieler ungerade ist und wenn der betreffende Spieler
noch kein Freilos hatte.


@node Ergebniseingabe
@section Das Ergebniseingabefenster
@cindex Ergebniseingabefenster
Das Ergebniseingabefenster wird durch den Menüpunkt @code{Ergebnisse
eingeben} aufgerufen (@pxref{Runde}) und präsentiert Ihnen eine Liste von
Spielen einer Runde. Diese Liste können Sie mit den üblichen Gadgets auf- und
abwärtsscrollen. Stets ist ein Spiel aktiviert.  Dieses wird unter
Kickstart 3.x durch invertierte Anzeige hervorgehoben, unter Kickstart 2.x
erscheint es in einem Textgadget unter der Liste. Sie können durch Anklicken
ein anderes Spiel aktivieren.

Unter der Liste finden Sie einige weitere Gadgets. Rechts (mit den Gadgets
@code{ausgetragen} bzw. @code{kampflos}) können Sie durch Anklicken angeben,
daß das Ergebnis kampflos entstand. Vorgabe ist stets, daß das Spiel
ausgetragen wurde. Links (mit den Gadgets @code{Weiß gewinnt}, @code{Remis},
@code{Schwarz gewinnt} und @code{Ergebnis fehlt}) können Sie das Ergebnis
angeben. Vorgabe ist natürlich, daß das Ergebnis fehlt. Außerdem können Sie
die Ergebnisse auch mit der Tastatur eingeben: Die Tasten @key{w} (Weiß
gewinnt), @key{r} (Remis), @key{s} (Schwarz gewinnt), @key{f} (Ergebnis
fehlt), @key{u} (Spiel ausgetragen) und @key{k} (kampflos) entsprechen den
jeweiligen Gadgets.

Wird ein Ergebnis eingegeben, so wird automatisch das jeweilige nächste Spiel
aktiviert. (Unter älteren MUI-Versionen kann dies evtl. zu Problemen führen.)
Dies erlaubt eine besonders angenehme Eingabe.

@node Menüs
@chapter Menüs
@cindex Menüs
Das Programm hat ein Hauptfenster, in dem verschiedene
Angaben über das Turnier (Name, Dateiname, Teilnehmer- und
Rundenzahl sowie Turniermodus) ausgegeben werden. Dieses Hauptfenster ist
immer dann mit einem Menü versehen, wenn gerade kein Eingabe- oder
Ausgabefenster erscheint. Die Menüs sind:

@menu
* Turnier::             Entspricht dem ``Project'' Menü
* Teilnehmer::          Zur Eingabe von Teilnehmerdaten
* Runde::               Zur Auslosung und Ergebniseingabe
* Ausgabe::             Zur Datenausgabe
* Voreinstellungen::    Anpassungsmöglichkeiten des Programmes
* Spezielles::          Individuelle Menüpunkte
@end menu

@node Turnier
@section Das Turnier-Menü
@cindex Turnier (Menü)
Das Turniermenü entspricht dem ``Project''-Menü, das die meisten Programme
mit GUI haben. Die einzelnen Punkte des Menüs sind:

@table @strong
@item Neues Turnier
@cindex Neues Turnier (Menüpunkt)
Dieser Menüpunkt läßt das Turniereingabefenster erscheinen. Es wird der
Name des Turniers eingegeben sowie durch Anklicken eines Cycle-Gadgets
festgelegt, ob es sich um ein
Turnier nach Schweizer System oder um ein Rundenturnier handelt. Falls
beim alten Turnier Daten verändert wurden, so wird zunächst gefragt, ob
dieses abgespeichert werden soll und gegebenenfalls automatisch der
Menüpunkt @code{Speichern Als} aufgerufen.

@item Turnier laden
@cindex Turnier laden (Menüpunkt)
Mit diesem Menüpunkt kann man ein anderes Turnier aufrufen von der Diskette
oder Festplatte abrufen. Auch hier
kommt gegebenenfalls die Abfrage, ob zunächst das alte abgespeichert werden
soll. Zur Auswahl des Turniers erscheint der übliche Filerequester der
asl.library.

@item Turnier speichern
@cindex Turnier speichern (Menüpunkt)
Hier kann man das aktuelle Turnier abspeichern.
Voraussetzung ist, daß der Name der Turnierdatei bekannt ist. Falls nicht,
so wird automatisch der Menüpunkt

@item Turnier speichern als
@cindex Turnier speichern als (Menüpunkt)
aufgerufen, der zunächst mit Hilfe des asl-Requesters
die Auswahl einer Datei erlaubt und dann ebenfalls die Turnierdaten
abspeichert. Ich rate dringend dazu, nach jeder Auslosung und in einer
verschiedenen Datei abzuspeichern. (@pxref{Vorsichtsmassnahmen,
,Vorsichtsmaßnahmen}) Das Programm unterstützt dies dadurch, daß automatisch
ein Name wie z.B. @file{chaos.5.cdat} vorgegeben wird, wobei 5 die Anzahl
der Runden ist.

@item Informationen
@cindex Informationen (Menüpunkt)
Dieser Menüpunkt gibt einiges über das Programm und mich
(den Autor) aus. Ich pflege selbst bei jedem Programm wenigstens einmal
den Menüpunkt @code{About} auszuwählen in der Hoffnung, etwas interessantes
zu erfahren. Leider werde ich fast immer enttäuscht. Jetzt will ich endlich
auch mal selber entäuschen ;-)

@item Programmende
@cindex Programmende (Menüpunkt)
Mit diesem Menüpunkt kann man das Programm verlassen.
Wie bei @code{Neues Turnier} und @code{Turnier laden} geht auch dies
nicht versehentlich, sondern es erscheint bei Bedarf die Abfrage, ob man
zunächst nicht abspeichern möchte.
@end table

@node Teilnehmer
@section Das Teilnehmer-Menü
@cindex Teilnehmer (Menü)

Die Menüpunkte dieses Menüs verwenden das @code{Teilnehmereingabefenster}
sowie das @code{Teilnehmerauswahlfenster}. Diese wurden schon ausführlich
beschrieben. @xref{Teilnehmereingabe}. Dies sind die Menüpunkte:

@table @strong
@item Neuer Teilnehmer
@cindex Neuer Teilnehmer (Menüpunkt)
Mit diesem Menüpunkt können Sie vor dem Beginn des Turniers die Teilnehmer
eingeben. Beim Schweizer System ist es auch noch nach Auslosung der ersten
Runde möglich, neue Teilnehmer einzugeben. Das ist natürlich keine
offizielle und korrekte Möglichkeit, aber mancher Veranstalter wird
darüber froh sein. Die neuen Spieler erhalten dann ein Freilos
(bei bisher gerader Teilnehmerzahl) bzw. müssen gegen den Spieler spielen,
der bisher ein Freilos hatte. In der Rangliste werden die Spieler ganz
unten eingeordnet. Bitte beachten Sie, daß Sie durch die Reihenfolge der
Eingabe festlegen, wer gegen wen spielt! Es empfiehlt sich also, bei der
Eingabe nach den unten beschriebenen Prinzipien vorzugehen.
@xref{Spaetzuender, ,Spätzünder}.

@item Teilnehmer importieren (Menüpunkt)
@cindex Teilnehmer importieren (Menüpunkt)
@cindex Spielerdatenbank
Hat man ein Turnier durchgeführt und bei einem neuen Turnier nehmen
wenigstens teilweise dieselben Spieler teil, dann ist es natürlich
wünschenswert, die Spielerdaten nicht neu eingeben zu müssen, sondern direkt
übernehmen zu können. Das erlaubt dieser Menüpunkt: Beim Aufruf können Sie
mit Hilfe des Asl-Filerequesters eine vorhandene Turnierdatei aufrufen und
dann mit dem Teilnehmerauswahlfenster Spieler von dort übernehmen.

Dies macht es möglich, eine regelrechte Spielerdatenbank zu führen: Erzeugen
Sie einfach ein neues Turnier, dem Sie z.B. den Namen Ihres Vereins geben und
geben Sie dort die Spieler ein. @xref{UpdateRatings}.

@item Teilnehmer ändern
@cindex Teilnehmer ändern (Menüpunkt)
Dieser Menüpunkt erlaubt es, Spielerdaten zu ändern. Dies geht
jederzeit. Nach der Auslosung der ersten Runde erscheint hier allerdings
zur Vorsicht ein Requester, der Sie fragt, ob Sie wirklich Spielerdaten
ändern wollen.

@item Teilnehmer löschen
@cindex Teilnehmer löschen (Menüpunkt)
können Sie mit diesem Menüpunkt. Dies geht allerdings nur vor der
Auslosung. Beim Schweizer System können Sie den Menüpunkt auch später noch
aufrufen. Hier werden Spieler damit lediglich als ausgeschieden markiert,
d.h. sie werden zu einem Freilos (bei bisher gerader Teilnehmerzahl) bzw.
dienen dazu, ein Freilos zu eliminieren.

In jedem Fall erscheint bei der Anwahl des Menüpunktes ein Requester, der
fragt, ob Sie wirklich Teilnehmer löschen. Zusätzlich erscheint bei jedem
ausgewählten Teilnehmer ein weiterer Requester, der fragt, ob Sie wirklich
@emph{diesen} Spieler löschen wollen. Beachten Sie bitte, daß @strong{kein}
Spieler gelöscht wird, wenn Sie @strong{irgendwo} abbrechen.
@end table

@node Runde
@section Das Runde-Menü
@cindex Runde (Menü)
Mit dem Runde-Menü verwalten Sie das Turnier nach der Eingabe der
Teilnehmer. Es besitzt folgende Menüpunkte:

@table @strong
@item Runde auslosen
@cindex Runde auslosen (Menüpunkt)
@cindex Auslosung
Dieser Menüpunkt enthält 3 Untermenüpunkte. Durch Auswahl eines dieser
Untermenüpunkte wird das Turnier gestartet und die erste Auslosung im
entsprechenden Modus, d.h. nach @code{Schweizer System} (@pxref{Schweizer
System}) oder als @code{Rundenturnier} mit @code{FIDE-System}
(@pxref{FIDE-System}) bzw. @code{Rutschsystem} (@pxref{Rutschsystem})
durchgeführt. Bitte beachten Sie, daß es nicht möglich ist, den Modus später
zu ändern!

Beim Rundenturnier wird dieser Menüpunkt anschließend nicht mehr benötigt.
Beim Schweizer System dagegen kann der Menüpunkt später erneut aufgerufen
werden, um
die jeweils nächste Runde auszulosen. Dies erlaubt das Programm allerdings
erst dann, wenn alle Ergebnisse aus der Vorrunde eingegeben sind. Falls noch
Spiele fehlen, müssen diese zunächst als Remis eingegeben werden und dann
später korrigiert werden. Wenn Sie die Spiele einer Runde öffentlich
aushängen wollen, dann empfiehlt es sich deshalb, erst die Ausgabe zu machen,
dann die fehlenden Spiele als Remis einzutragen und dann erst die Auslosung
zu veranlassen.

Wurde eine Auslosung erfolgreich durchgeführt, so ruft das Programm
automatisch den Menüpunkt @code{Speichern als} auf. Ich empfehle dringend,
dies auszunutzen und tatsächlich nach jeder Runde und in verschiedenen
Dateien abzuspeichern! @xref{Vorsichtsmassnahmen, Vorsichtsmaßnahmen}.

@item Ergebnisse eingeben
@cindex Ergebnisse eingeben (Menüpunkt)
Mit diesem Menüpunkt können Sie die Ergebnisse einer Runde eingeben. Zur
Auswahl der Runde erscheint ein Requester, in dem Sie die Rundennummer
festsetzen können. Siehe auch @ref{Ergebniseingabe}.
@end table

@node Ausgabe
@section Das Ausgabe-Menü
@cindex Ausgabe-Menü
Alle Ausgaben können wahlweise auf den Bildschirm oder auf den Drucker
(LQ oder Draft) oder in eine Datei erfolgen. Diese Auswahl erfolgt im
Voreinstellungen-Menü. @xref{Voreinstellungen, Ausgabe auf, Ausgabe auf}.

Haben Sie den Bildschirm als Ausgabemedium gewählt, so erscheint ein eigenes
Fenster mit dem auszugebenden Text. Diesen können Sie bei Bedarf mit den
üblichen Gadgets auf- und abwärtsscrollen. Beim Drucker ist zu beachten,
daß die Preferences richtig gesetzt sein müssen. Siehe auch
@ref{Vorbereitungen}.

Ausgegeben werden können (mit den entsprechenden Menüpunkten):

@table @strong
@item Teilnehmerliste
@cindex Teilnehmerliste (Menüpunkt)
Sie haben hier die Wahl zwischen einer ausführlichen Teilnehmerliste mit
allen Spielerdaten (Untermenüpunkt @code{lang}) oder nur mit Nummer,
Namen, Schachclub, DWZ- und ELO-Zahl (Untermenüpunkt @code{kurz}).

@item Tabelle
@cindex Tabelle (Menüpunkt)
Bei der Tabelle haben Sie die Wahl zwischen verschiedenen Wertungen, nach
denen die Tabelle sortiert wird. Siehe dazu @ref{Voreinstellungen}.
Ferner können Sie neben der allgemeinen Tabelle noch die Extra-Tabelle
der Senioren, der Junioren usw. ausgeben lassen. Diese Auswahl erfolgt
über die Untermenüpunkte.

@item Runde
@cindex Runde ausgeben (Menüpunkt)
Die Liste der Spiele einer Runde; die Auswahl der Runde erfolgt mittels
eines Requesters wie bei der Ergebniseingabe. @xref{Runde, Ergebnisse
eingeben, Ergebnisse eingeben}.

@item Rangliste
@cindex Rangliste (Menüpunkt)
Die Rangliste der letzten Auslosung. Diese Rangliste ist nur dann
nötig,
falls Sie die interne Auslosung nachvollziehen wollen. Wie das Programm
vorgeht, ist im Abschnitt Algorithmen beschrieben. Da die Rangliste
nur beim Schweizer System verwendet wird, ist ihre Ausgabe auch nur bei
diesen Turnieren erlaubt. @xref{Schweizer System}.

@item Fortschrittstabelle
@cindex Fortschrittstabelle (Menüpunkt)
Die Fortschrittstabelle enthält eine Liste aller Spieler, ihrer
Spiele
und Ergebnisse. Da sie nur beim Schweizer System sinnvoll ist, ist sie
auch nur dort erlaubt.

@item Kreuztabelle
@cindex Kreuztabelle (Menüpunkt)
@cindex Ascii (Untermenüpunkt)
@cindex TeX (Untermenüpunkt)
Beim Rundenturnier ist dagegen die Kreuztabelle sinnvoll, die wiederum
beim Schweizer System relativ nutzlos ist. Deshalb ist ihre Ausgabe nur
beim Rundenturnier erlaubt. Es ist hier Ausgabe als @TeX{}-Quelltext möglich
und meines Erachtens auch sinnvoll. Deshalb gibt es hier die Untermenüpunkte
@code{Ascii} für normale Ausgabe und @code{TeX}. Letzteres erfolgt stets auf
eine Datei, d.h. es erscheint der asl-Filerequester, mit dem der Name einer
@TeX{}-Quelltext-Datei bestimmt wird. Diese muß anschließend von Hand
mit @TeX{}-bearbeitet und ausgedruckt werden.

@item Spielerkarten
@cindex Spielerkarten (Menüpunkt)
Die Ausgabe der Spielerkarten funktioniert genauso wie die Ausgabe der
Kreuztabelle, d.h. es gibt ebenfalls die Untermenüpunkte @code{Ascii} und
@TeX{}.

@item DWZ-Wertung
@cindex DWZ-Wertung (Menüpunkt)
Die Ausgabe der DWZ-Wertung ist in einem eigenen Kapitel ausgiebig
beschrieben. @xref{DWZ-Wertung}.
@end table

@node Voreinstellungen
@section Das Voreinstellungen-Menü
@cindex Voreinstellungen (Menü)
Das Voreinstellungen-Menü umfaßt nur drei Menüpunkte. Bitte beachten Sie,
daß sich diese unterschiedlich verhalten, was die Dauer der Einstellung
angeht.

@table @strong
@item Tabellenwertung (Menüpunkt)
Mit diesem Menüpunkt kann eingestellt werden, wonach die
Tabellen sortiert werden. Dabei gibt es folgende Möglichkeiten:
@enumerate
@item
@cindex Einfache Wertung (Untermenüpunkt)
Mit der @code{einfachen Wertung} wird die Tabelle nur nach den Punkten der
Teilnehmer sortiert.

@item
@cindex Buchholz-Wertung (Untermenüpunkt)
Bei der @code{Buchholz-Wertung} wird die Tabelle nach Punkten und
Buchholz-Punkten sortiert. Die Buchholz-Punkte eines Spielers sind die
addierten Punktzahlen seiner Gegner.

@item
@cindex Buchholz-Wertung, verfeinerte (Untermenüpunkt)
Bei der @code{verfeinerten Buchholz-Wertung} wird die Tabelle nach Punkten,
Buchholz-Punkten und verfeinerten Buchholz-Punkten sortiert. Die
verfeinerten eines Spielers Buchholz-Punkte sind die addierten
Buchholz-Punkte seiner Gegner.

@item
@cindex Sonneborn-Berger-Wertung (Untermenüpunkt)
Bei der @code{Sonneborn-Berger-Wertung} wird die Tabelle nach Punkten und
Sonneborn-Berger-Punkten sortiert. Die Sonneborn-Berger-Punkte eines
Spielers sind die mit einer vom jeweiligen Ergebnis abhängigen Konstanten
multiplizierten seiner Gegner: Hat der Spieler das Spiel verloren, so
werden die Punkte des Gegners mit 0, bei Remis mit 0.5 und bei Gewinn mit 1
multipliziert.
@end enumerate
Die Einstellung der Tabellenwertung wird mit den anderen Turnierdaten
abgespeichert. Voreingestellt ist stets die einfache Wertung.

@item Ausgabe auf
@cindex Ausgabe auf (Menüpunkt)
@cindex Bildschirm, Ausgabe auf (Untermenüpunkt)
@cindex Drucker, Ausgabe auf (Untermenüpunkt)
@cindex Letter Quality (Untermenüpunkt)
@cindex Datei (Untermenüpunkt)
Mit diesem Menüpunkt kann das Ausgabemedium (Bildschirm,
Drucker ohne LQ, Drucker mit LQ oder Datei) eingestellt werden. Beim
Programmstart ist hier stets der Bildschirm voreingestellt. Ist Datei
eingestellt und es wird ein Menüpunkt aus dem Ausgabemenü gewählt, so
erscheint der übliche Filerequester, der die Auswahl eines Dateinamens
erlaubt.

@item Spiele setzen
@cindex Spiele setzen (Menüpunkt)
Ist diese Option gesetzt (was sie beim Programmstart @emph{nicht} ist), dann
erscheint beim Anwählen des Menüpunktes @code{Runde auslosen} das
Spieleingabefenster, das das Setzen von Spielen erlaubt.
@xref{Spieleingabe}.

@item Icons erzeugen
@cindex Icons erzeugen (Menüpunkt)
Mit diesem Menüpunkt können Sie das Programm dazu bewegen, Icons zu erzeugen
oder dies zu unterlassen. Siehe auch @ref{Programmstart}.
@end table


@node Spezielles
@section Das Spezielles-Menü
@cindex Spezielles (Menü)
Dieses Menü enthält ausschließlich von Ihnen selbst definierte Menüpunkte
und ist nur dann vorhanden, wenn Sie diese in einer dafür bestimmten Datei
angeben. @xref{Eigene Menuepunkte, Eigene Menüpunkte, Eigene Menüpunkte}.


@node DWZ-Wertung
@chapter Die DWZ-Wertung
@cindex DWZ-Wertung
Die DWZ-Wertung umfaßt alle Spieler, die
gegen mindestens einen Spieler mit vorhandener DWZ gespielt haben.
Das Vorgehen entspricht dem in: Peter Zöfel, Karl-Heinz Glenz,
@cite{Das ELO-System}.

Zur Berechnung der DWZ wird das Alter und für eine offizielle DWZ-Meldung
das Geburtsdatum des Spielers benötigt. Falls dieses bei einem Spieler fehlt,
erscheint deshalb ein Requester, der folgende Auswahl anbietet:
@enumerate
@item Eines der Gadgets @code{Bis 20}, @code{21-25}, @code{Ab 26}
veranlaßt das Programm anzunehmen, der Spieler gehöre zur
entsprechenden Altersstufe. Die DWZ wird ganz normal
ausgewertet, allerdings fehlt natürlich im Ausdruck das
Geburtsdatum, das ein Teil der DWZ-Meldung ist.

@item Das Gadget @code{Ändern} erlaubt es, die Daten des betreffenden
Teilnehmers zu ändern und dann mit der DWZ-Wertung fortzufahren.

@item Das Gadget @code{Auslassen} veranlaßt das Programm den betreffenden
Teilnehmer bei der Auswertung auszulassen.

@item Mit dem Gadget @code{Abbruch} kann man die DWZ-Wertung abbrechen.
@end enumerate

Dies ist die Bedeutung der verschiedenen Werte:
@table @strong
@item Ro
ist die alte DWZ. Sie besteht normalerweise aus zwei Zahlen, z.B.
1834-23. Dies bedeutet, daß der Teilnehmer bisher eine DWZ von 1834 hatte,
die aus 23 Turnieren berechnet wurde.

@item W
ist die Zahl der Punkte, die der Teilnehmer in gewerteten Spielen erzielt
hat. Gewertet werden alle Spiele gegen Teilnehmer mit DWZ, die nicht
kampflos ausgetragen wurde.

@item n
ist die Anzahl der gewerteten Spiele.

@item We
ist der Erwartungswert, der vom Teilnehmer erwartet wird, um die alte DWZ
zu halten.

@item RH
ist die sogenannte Turnier-H-Zahl, die ungefähr beschreibt, wie gut der
Teilnehmer in diesem Turnier abgeschnitten hat.

@item Rn
ist schließlich die neue DWZ. Sie hat die gleiche Darstellung wie Ro. Bei
Spielern, die bislang keine DWZ haben und für die weniger als 9 Spiele
gewertet werden, wird eine vorläufige DWZ ausgegeben, z.B. 1457-(5). Diese
kann bei zukünftigen Turnieren verwendet werden, um dort auf die Zahl von
9 Spielen zu kommen und dann endgültig eine DWZ zu erlangen.
@end table


@node ARexx
@chapter Der ARexx-Port: Chaos als Batchprogramm
@cindex ARexx
@cindex Batchprogramm
Unter dem Portnamen @code{CHAOS.1} kann man das Programm mit Hilfe von
@code{ARexx} auch von anderen Programmen aus steuern. Mehr noch: Die
Benutzeroberfläche von Chaos ist eigentlich gar nicht mehr nötig, deshalb
auch die NOWINDOW-Option. @xref{Programmstart}.

@menu
* Befehle::             Mögliche ARexx-Kommandos
* Eigene Menüpunkte:Eigene Menuepunkte. Einbau von ARexx-Skripts in die Menüleiste
@end menu


@node Befehle
@section Mögliche ARexx-Kommandos
@cindex ARexx-Kommandos
Die ARexx-Befehle entsprechen weitgehend verschiedenen Menüpunkten, ihr
Sinn sollte deswegen unmittelbar klar sein. Anzumerken ist, daß die
ARexx-Kommandos natürlich nur dann erlaubt sind, wenn dies auch für die
entsprechenden Menüpunkte gilt. Sie können also nicht in einem Rundenturnier
die Tabelle nach Buchholz sortieren oder die Auslosung einer Runde
veranlassen, wenn der Benutzer gerade Spiele eingibt.

Dies sind die Befehle:

@deffn {} NewTournament NAME/A, FORCE/S
@cindex NewTournament, ARexx-Kommando
Erzeugt ein neues Turnier mit dem angegebenen Namen. Falls das aktuelle
Turnier nicht abgespeichert wurde, wird der Benutzer um Zustimmung gefragt.
Dies kann mit dem Schlüsselwort FORCE unterdrückt werden.
@xref{Turnier, Neues Turnier, Neues Turnier}.
@end deffn

@deffn {} LoadTournament FILE/A, FORCE/S
@cindex LoadTournament, ARexx-Kommando
Lädt das angegebene Turnier. Auch hier wird evtl. der Benutzer um Zustimmung
gefragt, falls FORCE nicht angegeben ist. @xref{Turnier, Turnier laden,
Turnier laden}.
@end deffn

@deffn {} SaveTournament FILE/A, ICON/S
@cindex SaveTournament, ARexx-Kommando
Speichert das aktuelle Turnier in der angegebenen Datei. Wird ICON angegeben,
so erhält die Datei zusätzlich ein Project-Icon. @xref{Installation}.
@xref{Turnier, Turnier speichern, Turnier speichern}.
@end deffn

@deffn {} AddPlayer NAME/A, STREET/K, VILLAGE/K, CHESSCLUB/K, BIRTHDAY/K, PHONE/K, RATING/K, ELO/K, FLAGS/K, NOUSER/S
@cindex AddPlayer, ARexx-Kommando
Gibt die Daten eines neuen Teilnehmers an. Der Name ist verbindlich. Die
Flags sind ein String, der eine Kombination der Buchstaben s (Senior),
j (Junior), w (Dame) und a-e (A-Junior bis E-Junior) enthält. RATING ist
die DWZ. @xref{Teilnehmereingabe}. @xref{Teilnehmer, Neuer Teilnehmer,
Neuer Teilnehmer}. Die Option NOUSER unterdrückt evtl. Fehlermeldungen an
den Benutzer.
@end deffn

@deffn {} ModifyPlayer PLAYER/A, NAME/K, STREET/K, VILLAGE/K, CHESSCLUB/K, BIRTHDAY/K, PHONE/K, RATING/K, ELO/K, FLAGS/K, NOUSER/S
@cindex ModifyPlayer, ARexx-Kommando
Modifiziert die Daten des Teilnehmers mit Namen PLAYER. Nur die angegebenen
Felder werden modifiziert, d.h. z.B.

@samp{ModifyPlayer "Widmann, Jochen" NAME "Wiedmann, Jochen"}

ändert nur den Namen. @xref{Teilnehmer, Teilnehmer ändern, Teilnehmer
ändern}. Auch hier kann man mit NOUSER Fehlermeldungen an den Benutzer
verbieten.
@end deffn

@deffn {} DeletePlayer PLAYER/A, FORCE/S
@cindex DeletePlayer, ARexx-Kommando
löscht den angegebenen Teilnehmer, bzw. markiert ihn als ausgeschieden.
Ohne das Schlüsselwort FORCE wird der Benutzer um Zustimmung gefragt.
@xref{Teilnehmer, Teilnehmer löschen, Teilnehmer löschen}.
@end deffn

@deffn {} SetPlayer PLAYER/A, INIT/S, FORCE/S, SETCOLORS/S
@cindex SetPlayer, ARexx-Kommando
Setzt den angegebenen Spieler. Sollen etwa die Spieler 3 gegen 5 und 2 gegen
4 gesetzt werden und Spieler 17 ein Freilos erhalten, so ist das Kommando
SetPlayer nacheinander für die Spieler 3, 5, 2, 4 und 17 und anschließend
das Kommando DoPairings auszuführen. Die Vorgehensweise entspricht also der
interaktiven. @xref{Spieleingabe}.

Sollen die gesetzten Spiele wieder gelöscht werden, so ist das Schlüsselwort
INIT anzugeben. (Natürlich funktioniert das nur @strong{vor} der Ausführung
von DoPairings möglich.) Es kann gleichzeitig der erste neu zu setzende
Spieler angegeben werden oder auch nicht.

Wie im interaktiven Modus lehnt es das Programm ab, Spieler ein zweites Mal
gegeneinander zu setzen oder einem Spieler ein Freilos zu geben, der bereits
eines hatte. Sollen zwei Spieler gegeneinander gesetzt werden, bei denen
das aufgrund der Farbverteilung eigentlich nicht erlaubt wäre, so fragt
das Programm nach der Zustimmung des Benutzers, außer das Schlüsselwort
FORCE wurde angegeben. Die Farbverteilung wird normalerweise durch Chaos
vorgenommen, dies kann aber durch das Schlüsselwort SETCOLORS geändert
werden. SETCOLORS @strong{muß} beim Setzen des zweiten, die schwarzen Steine
erhaltenden Spielers angegeben werden! Beim ersten Spieler wird es ignoriert.
@xref{Runde, Runde auslosen, Runde auslosen}.
@end deffn

@deffn {} DoPairings SWISSPAIRING/S, ROUNDROBIN/S, ROUNDROBINSHIFT/S, NOUSER/S
@cindex DoPairings, ARexx-Kommando
Die Auslosung einer neuen Runde wird mit diesem Kommando veranlaßt. Für die
erste Runde ist eines der Schlüsselworte SWISSPAIRING (Schweizer System),
ROUNDROBIN (Rundenturnier, FIDE-System) oder ROUNDROBINSHIFT (Rundenturnier,
Rutschsystem) anzugeben. Ohne das Schlüsselwort NOUSER wird das
Spieleingabefenster eröffnet, um dem Benutzer das Setzen von Spielen zu
erlauben.

Wurde mit dem SetPlayer-Kommando einem Spieler ein Freilos zugeteilt, obwohl
die Anzahl der aktiven Spieler gerade ist, so führt dies zu einer
Fehlermeldung. @xref{Runde, Runde auslosen, Runde auslosen}.
@end deffn

@deffn {} EnterResult WHITE/A, BLACK/A, RESULT/A/N, NOTPLAYED/S
@cindex EnterResult, ARexx-Kommando
Das Ergebnis (2 = Weiß gewinnt, 1 = Remis, 0 = Schwarz gewinnt, -1 = Ergebnis
fehlt) des Spieles zwischen den angegebenen Teilnehmern wird gesetzt. Das
Schlüsselwort NOTPLAYED ist anzugeben, wenn das Spiel kampflos entschieden
wurde. Chaos bestimmt selbständig die Runde, in der das Spiel stattfand.
@xref{Runde, Ergebnisse eingeben, Ergebnisse eingeben}.
@end deffn

Bei den folgenden Ausgabekommandos ist jeweils ein Dateiname anzugeben. Die
auszugebenden Listen werden im Ascii-Format in die angegebene Datei
geschrieben. Soll die Ausgabe auf den Drucker erfolgen, so ist es möglich,
die Dateinamen @file{prt:} (Draft) oder @file{prt:LQ} (Letter-Quality)
anzugeben.

@deffn {} PlayerList FILE/A, SHORT/S
@cindex PlayerList, ARexx-Kommando
Gibt die Teilnehmerliste (SHORT für kurzes Format) auf die angegebene Datei
aus. @xref{Ausgabe, Teilnehmerliste, Teilnehmerliste}.
@end deffn

@deffn {} InternalRatings FILE/A
@cindex InternalRatings, ARexx-Kommando
Gibt die interne Rangliste aus. @xref{Ausgabe, Rangliste, Rangliste}.
@end deffn

@deffn {} Table FILE/A, TABMODE/K/N, PLRMODE/K/N
@cindex Table, ARexx-Kommando
Gibt die aktuelle Tabelle aus. Mit TABMODE kann der Sortiermodus gesetzt
werden (0 = einfach, 1 = Buchholz, 2 = verfeinerter Buchholz, 3 =
Sonneborn-Berger; Vorgabe ist einfach) und mit PLRMODE kann bestimmt werden,
welche Tabelle auszugeben ist. (0 = Alle, 1 = Senioren, 2 = Junioren,
3 = Damen, 4 bis 8 = A-Junioren bis E-Junioren; Vorgabe ist alle)
@xref{Ausgabe, Tabelle, Tabelle}.
@end deffn

@deffn {} Round FILE/A, NUMBER/N
@cindex Round, ARexx-Kommando
Gibt die angegebene Runde (Vorgabe ist die letzte Runde) aus. @xref{Ausgabe,
Runde, Runde}.
@end deffn

@deffn {} TableOfProgress FILE/A, TABMODE/K/N
@cindex TableOfProgress, ARexx-Kommando
Gibt die Fortschrittstabelle aus. Mit TABMODE wird wie beim Table-Kommando
der Sortiermodus der Tabelle angegeben. @xref{Ausgabe, Fortschrittstabelle,
Fortschrittstabelle}.
@end deffn

@deffn {} CrossTable FILE/A, TEX/S
@cindex CrossTable, ARexx-Kommando
Gibt die Kreuztabelle aus. Bei Angabe des TEX-Schlüsselwortes wird
@TeX{}-Quelltext erzeugt. (Es ist prinzipiell möglich, das TEX-Schlüsselwort
mit dem Dateinamen @file{prt:} zu kombinieren. Allerdings wird dabei eben
der Quelltext ausgegeben.) @xref{Ausgabe, Kreuztabelle, Kreuztabelle}.
@end deffn

@deffn {} PlayerCards FILE/A, TEX/S
@cindex PlayerCards, ARexx-Kommando
Gibt die Spielerkarten aus. Für das TEX-Schlüsselwort gilt das beim Kommando
CrossTable gesagte. @xref{Ausgabe, Spielerkarten, Spielerkarten}.
@end deffn

@deffn {} DWZReport FILE/A
@cindex DWZReport, ARexx-Kommando
Gibt die DWZ-Wertung aus. Es ist nicht möglich, den Requester zu
unterdrücken, der bei der DWZ-Wertung auftaucht, falls ein Spieler kein
Geburtsdatum gesetzt hat. @xref{DWZ-Wertung}.
@end deffn

@deffn {} Window ON/S, OFF/S
@cindex Window, ARexx-Kommando
Schaltet das Hauptfenster ein bzw. aus. @xref{Programmstart}.
@end deffn


@node Eigene Menuepunkte
@section Eigene Menüpunkte
@cindex Menüpunkte, eigene
Hat man sich erst einmal ein eigenes ARexx-Skript erstellt, so entsteht
rasch der Wunsch, dieses auch vom Programm aus selbst zu verwenden. Dies
ist möglich, indem man sich einen entsprechenden eigenen Menüpunkt definiert.

Zu diesem Zweck sucht Chaos beim Programmstart nach einer Datei namens
@file{s/Chaos_Menu}. (Der Name kann mit der Option @code{MENUFILE}
geändert werden. @xref{Programmstart}.) Ist diese nicht vorhanden, so wird
außerdem nach @file{s:Chaos_Menu} gesucht.

Wird eine dieser Dateien gefunden, so erzeugt das Programm ein weiteres
Menü namens @code{Spezielles}. In dieses Menü werden die in der Datei
definierten Menüpunkte eingetragen. Die Definition ist einfach: Je zwei
Zeilen entsprechen einem Menüpunkt. Die erste gibt den Titel an und die
zweite einen Shell-Befehl, der beim Aufruf des Menüpunktes auszuführen ist.
(Für ein Beispiel sehen Sie bitte die mitgelieferte Datei
@file{s/Chaos_Menu}.)

Beachten Sie bitte unbedingt das Folgende:
@enumerate
@item
Chaos kann keine weiteren Befehle ausführen, bis Ihr Shell-Kommando beendet
ist. Insbesondere ist es nicht möglich, Chaos über den ARexx-Port aufzurufen,
während das Shell-Kommando läuft. Es kann deshalb nötig sein, Ihren
Shell-Befehl mit Hilfe von @code{Run} aufzurufen!
@item
Bedingt durch Intuition-Eigenheiten sind maximal 31 Menüpunkte möglich.
@end enumerate

Zwei ARexx-Skripte sind bereits vorhanden. Diese sollen als Beispiel dienen,
können aber vielleicht auch so nützlich sein. Ihre Benutzung wird in den
Skripten selbst erläutert.
@menu
* PrintTable::      Ausgabe von Tabellen in einem eigenen Format
* UpdateRatings::   Export der neuen DWZ in eine Datenbank
@end menu


@node PrintTable
@subsection PrintTable: Ausgabe von Tabellen in einem eigenen Format
@cindex PrintTable.rexx
Eine Schweizer Benutzergruppe äußerte den Wunsch, ihre Tabellen in einem
eigenen Format ausgeben zu können: Sie wollten die Punkte ganz rechts haben
und außerdem auch den Schachclub des Teilnehmers integriert haben. Das macht
dieses Skript. Es läßt zunächst Chaos die aktuelle Tabelle sowie eine
Teilnehmerliste in Dateien ausgeben. Diese werden vom Skript gelesen und
anschließend die veränderte Tabelle ausgeben.

Das Skript sollte eigentlich recht anschaulich sein. Ein Problem hat es
allerdings: Alle diese Angaben passen bei langen Spieler- oder Vereinsnamen
(jeweils bis 30 Zeichen sind möglich) nicht auf eine Zeile. Das Skript löst
dies dadurch, daß unter Umständen Teile des Spielernamens und des
Vereinsnamens abgeschnitten werden.


@node UpdateRatings
@subsection UpdateRatings: Export der neuen DWZ in eine Datenbank
@cindex UpdateRatings.rexx
@cindex Spielerdatenbank
Wie schon erwähnt, erlaubt es der Menüpunkt @code{Teilnehmer importieren},
eine Art Spielerdatenbank zu führen. (@pxref{Teilnehmer}) Nach
Durchführung eines Turniers entsteht natürlich der Wunsch, die DWZ's der
Spieler in der Datenbank auf den neuesten Stand zu bringen. Dies ist mit
diesem Skript möglich. Dazu muß der Name der Datenbank angegeben werden,
entweder indem das Skript mit @samp{UpdateRatings.rexx Datenbankname}
aufgerufen
wird (dann muß der der entsprechende Name in die Datei @file{s/Chaos_Menu}
eingetragen werden) oder indem das Skript ohne Datenbanknamen aufgerufen
wird: Dann erlaubt der Asl-Filerequester die Auswahl einer Datei. (Dies setzt
allerdings die Existenz des Programmes @file{c:RequestFile} voraus.)

Das Skript speichert dann zunächst das aktuelle Turnier als
@file{t:CurrentTournament} ab und läßt dann die DWZ-Wertung in eine
Datei ausgeben. Dann wird die angegebene Datei von Chaos geladen und das
Skript verwendet nun das ARexx-Kommando @code{ModifyPlr} dazu, die neuen
DWZ's aus der abgespeicherten Datei in die Datenbank einzutragen. Diese wird
anschließend wieder gespeichert und das aktuelle Turnier geladen.


@node Algorithmen
@chapter Algorithmen
@cindex Algorithmen
Die Algorithmen entsprechen den Abschnitten 2.1 (Rundenturnier) und
2.2 (Schweizer System) im @cite{Turnierleiterhandbuch des Deutschen
Schachbundes}.

@menu
* Rundenturnier::      Jeder spielt gegen jeden
* Schweizer System::   Weniger Teilnehmer als Runden
* Spätzünder:Spaetzuender.         Neue Spieler nach der 1. Runde
@end menu

@node Rundenturnier
@section Das Rundenturnier
@cindex Rundenturnier
Beim Rundenturnier spielt jeder Spieler gegen jeden anderen. Um die
Reihenfolge der Spieler zu bestimmen, erhält zunächst jeder Spieler eine
zufällige Nummer. Ich spreche deshalb im Folgenden nur von den Spielern
1,2,...,n.

Falls n eine ungerade Zahl ist, so wird ein scheinbarer Spieler mit der
höchsten Nummer angehängt. In jeder Runde hat dann der Teilnehmer spielfrei,
der gegen diesen Spieler spielen müßte. Im Folgenden gehe ich deshalb
davon aus, daß n eine gerade Zahl ist und k=n/2. (In der Mathematik sagt man
o.B.d.A. und meint: Ohne Bedenken des Autors ;-)

Es gibt nun zwei verschiedene Systeme, um die Paarungen zu bestimmen: Das
FIDE-System und das Rutschsystem.

@menu
* FIDE-System::     Offizielles System der FIDE
* Rutschsystem::    Einfach anzuwendendes System
@end menu

@node FIDE-System
@subsection Das FIDE-System
@cindex Rundenturnier (FIDE-System)
Das FIDE-System ist das offiziell von der FIDE vorgegebene System. Es wird
meist durch die bekannten Paarungstabellen verwirklicht, weil es etwas
komplizierter ist. Sein Nachteil besteht darin, daß schwer durchschaubar ist, welcher
Spieler in welcher Runde und an welchem Platz spielt.

In der ersten Runde finden folgende Spiele statt: 1 gegen n, 2 gegen (n-1),
3 gegen (n-2) usw.

In allen folgenden Runden wird zunächst der Gegner des Spielers n
festgelegt: Dies ist der Spieler k+1 in Runde 2,
der Spieler 2 in Runde 3, der Spieler k+2 in Runde 4, der Spieler 3 in
Runde 5 usw. Dabei haben die Spieler 2,3,@dots{},k Weiß und die anderen
Spieler Schwarz.

Alle anderen Spieler spielen jeweils gegen den Spieler, dessen Nummer
eins höher ist, als die ihres Gegners aus der vorigen Runde. Der Spieler
n wird dabei ausgelassen und nach n-1 kommt der Spieler 1. In den Runden,
in denen sie gegen sich selbst kämen, spielen sie stattdessen gegen n.
Weiß hat jeweils der Spieler mit der niedrigeren Nummer, falls die Summe
der beiden Nummern ungerade ist und sonst umgekehrt.

@node Rutschsystem
@subsection Das Rutschsystem
@cindex Rutschsystem
Das Rutschsystem hat gegenüber dem FIDE-System einen entscheidenden Vorteil:
Jedem Spieler ist klar, wann er wo in der nächsten Runde gegen wen spielen
wird. Das macht den organisatorischen Aufwand wesentlich geringer. (Lediglich
in der ersten Runde muß den Spielern bekannt gegeben werden, wo sie Platz
nehmen müssen.)

In der ersten Runde finden folgende Spiele statt: An Brett 1 spielt 1 gegen
k+1, an Brett 2 spielt k+2 gegen 2, an Brett 3 spielt 3 gegen k+3,
an Brett 4 spielt k+4 gegen 4 usw. Dabei werden die Spieler so plaziert, daß
die Spieler mit den niedrigen Nummern auf einer und die mit den höheren
Nummern auf der anderen Seite eines langen Tisches sitzen, Spieler 2 rechts
von Spieler 1.

Nach jeder Runde wechseln dann alle Spieler im Uhrzeigersinn die Plätze. Die
Bretter bleiben unverändert stehen. Eine Ausnahme gibt es allerdings bei
gerader Teilnehmerzahl: Spieler n (in der ersten Runde ist das bei gerader
Zahl von Brettern der weiße und sonst der schwarze Spieler am letzten Brett)
bleibt sitzen und dreht nach jeder Runde sein Brett um. Bei ungerader
Teilnehmerzahl ist immer der Gegner des virtuellen Spielers n spielfrei.

Wer das Rutschsystem noch nicht kennt, für den mag ein Beispiel hilfreich
sein. In der ersten Runde sitzen die Spieler so:

@ifinfo
@example
				4  5  6
				1  2  3
@end example
@end ifinfo
@iftex
@par
@tex
$$@vbox{@halign{@hfil#@hfil&@qquad@hfil#@hfil&@qquad@hfil#@hfil@cr
	4 & 5 & 6 @cr
	1 & 2 & 3 @cr
}}$$
@end tex
@end iftex

@noindent
(Man könnte bei nur 5 Spielern den spielfreien Spieler 3 alleine
hinschreiben.)
Danach tauschen die Spieler 1-5 im Uhrzeigersinn die Plätze, Spieler 6 bleibt
sitzen und dreht sein Brett. Das sieht dann also so aus:

@ifinfo
@example
				1  4  6
				2  3  5
@end example
@end ifinfo
@iftex
@par
@tex
$$@vbox{@halign{@hfil#@hfil&@qquad@hfil#@hfil&@qquad@hfil#@hfil@cr
	1 & 4 & 6 @cr
	2 & 3 & 5 @cr
}}$$
@end tex
@end iftex

@noindent
Dieses Vertauschen der Plätze wird nun einfach nach jeder Runde wiederholt.

@node Schweizer System
@section Das Schweizer System
@cindex Schweizer System
Das Schweizer System kommt dann zum Einsatz, wenn es mehr Spieler gibt,
als Runden gespielt werden können. Die Idee des Systems ist es, daß gleich
starke Spieler gleich starke Gegner haben sollen, andererseits aber am
Schluß trotzdem der beste Spieler vorne sein soll.

Vor jeder Runde wird zunächst eine Rangliste gebildet. In der ersten
Runde wird diese nach der DWZ (bei Spielern mit ELO-Zahl nach der
ELO-Zahl) sortiert. Spieler ohne Zahl kommen ans Tabellenende. Gleich
starke Spieler werden alphabetisch sortiert.

@cindex Freilos
Falls n die Zahl der Teilnehmer ist und n ungerade, dann wird per Los
einem der Spieler ohne DWZ ein Freilos zugeteilt. Dieser erhält einen
kampflosen Punkt. Falls es weniger als 5 Spieler ohne DWZ gibt, dann
werden solange noch die jeweils schwächsten Spieler dazugenommen, bis
unter mindestens 5 Spielern gelost wird. Im Folgenden gehe ich deshalb
wieder davon aus, daß n gerade ist und k = n/2.

In der ersten Runde wird nun gelost, ob der Spieler mit der Nummer 1 Weiß
oder Schwarz hat. Falls der Spieler 1 Weiß hat, dann finden folgende
Spiele statt:
1 gegen k+1, k+2 gegen 2, 3 gegen k+3, k+4 gegen 4 usw. Falls 1 Schwarz
hat, dann sind dabei jeweils die Farben vertauscht.

In den folgenden Runden werden jeweils die Spieler nach Punkten sortiert.
Innerhalb einer Gruppe punktgleicher Spieler wird nach der jeweils
letzten Runde sortiert. (Das heißt, daß im Laufe des Turniers die DWZ
auf die Rangliste immer weniger Einfluß hat und nur noch der Turniererfolg
entscheidet.) Diese Einteilung bestimmt die neue Rangliste.

Nun wird beginnend mit der Gruppe der punktbesten Spieler nach und nach
versucht, die Spieler der einzelnen Gruppen zu paaren. Innerhalb einer
Gruppe werden dazu die Spieler in vier Untergruppen geteilt, je nachdem,
welche Farbe sie in der letzten Runde hatten und ob sie in der oberen
oder unteren Hälfte der Gruppe stehen. Machen wir ein Beispiel:

@ifinfo
@example
    Obere Hälfte, Weiss     Obere Hälfte, Schwarz
       1                            2
       3                            5
       4                            6
				    7

    Untere Hälfte, Weiß     Untere Hälfte, Schwarz
       8                            11
       9                            12
       10                           13
				    14
@end example
@end ifinfo

@iftex
@par
@tex
$$@vbox{@halign{@hfil@rm#@hfil&@qquad@hfil@rm#@hfil@cr
    Obere Hälfte, Weiss &   Obere Hälfte, Schwarz      @cr
       1      &       2             @cr
       3      &       5             @cr
       4      &       6             @cr
	 &       7             @cr
	 &                @cr
    Untere Hälfte, Weiß &   Untere Hälfte, Schwarz     @cr
       8      &       11             @cr
       9      &       12             @cr
       10      &       13             @cr
		&       14@cr
}}$$
@end tex
@end iftex

Es sollen (wie in der 1. Runde) möglichst Spieler aus der oberen Hälfte
gegen Spieler aus der unteren Hälfte spielen.
Um in Zukunft mehr Spiele möglich zu machen, wird versucht, Spieler
aus der linken Hälfte gegen Spieler aus der rechten Hälfte zu paaren.
Das ist in diesem Fall aber nicht durchgehend möglich: Wenigstens zwei
Spieler aus der rechten Hälfte müssen gegeneinander spielen.

Nun wird zunächst ein Gegner für den Spieler 1 gesucht. Nach den obigen
Prinzipien ist dies der Spieler 11. Dann bekommt 2 den Spieler 8 als
Gegner, dann 3 gegen 12, 4 gegen 14, 5 gegen 9, 6 gegen 10 und schließlich
7 gegen 14.

Das setzt aber voraus, daß alle diese Spiele stattfinden dürfen. Ein Spiel
darf stattfinden, wenn
@enumerate
@item
dieselben Spieler noch nicht gegeneinander gespielt haben,

@item
nicht beide Spieler in den letzten beiden Runden dieselbe Farbe hatten.
Dies macht es unmöglich, daß ein Spieler in drei aufeinanderfolgenden Runden
weiß (oder schwarz) bekommt.

@item
und es möglich ist, die verbleibenden Spieler unter Beachtung der ersten
beiden Punkte gegeneinander zu paaren.
@end enumerate
Dagegen ist es beispielsweise ausdrücklich erlaubt, daß ein Spieler in
5 Runden viermal Schwarz hat. (Ich persönlich würde das anders vorziehen,
aber ich richte mich nach dem @cite{Turnierleiterhandbuch des Deutschen
Schachbundes}.)

Bei ungerader Zahl von Teilnehmern in der Gruppe bleibt ein Spieler übrig.
Dieser wird dann in die nächste Gruppe geschoben. Bei ungerader Zahl von
Teilnehmern erhält dann der am Schluß übrigbleibende Spieler ein Freilos.
Dabei gilt natürlich die Regel, daß kein Spieler zweimal ein Freilos haben
darf.

Falls es nicht möglich ist, die Spieler einer Gruppe gegeneinander zu
paaren, wird der rangniedrigste Spieler in die nächste Gruppe geschoben.
Dies muß natürlich unter Umständen wiederholt werden.

@node Spaetzuender
@section Spätzünder
@cindex Spätzünder
Im Schweizer System haben Sie nach der ersten Runde noch die Möglichkeit,
neue Spieler hinzuzunehmen. Wenn dies nur ein Spieler ist, dann geben Sie
dessen Daten einfach ein. Sind es aber mehrere Spieler, dann beeinflussen
Sie durch die Reihenfolge der Eingabe die Paarung der Spieler. In diesem
Fall sollten Sie das Folgende beachten:

@enumerate
@item
Falls die Teilnehmerzahl bisher ungerade war, dann nehmen Sie den Spieler
mit Freilos zu den neuen Spielern dazu.

@item
Bilden Sie unter diesen Spielern eine Rangliste gemäß den bereits
beschriebenen Regeln und bilden Sie dann gemäß denselben Regeln die Spiele.
@xref{Schweizer System}. (Falls Ihnen das zu umständlich ist: Losen Sie's
aus! :-)

@item
Falls Sie bisher ein Freilos hatten, dann ändern Sie die Daten des Spielers
mit Freilos um in die Daten des ersten neuen Spielers.

@item
Geben Sie die restlichen Spieler ein. Zuletzt evtl. den Spieler, der jetzt
ein Freilos erhält.
@end enumerate

@node Historie
@chapter Entwicklung des Programms
@cindex Geschichte
@cindex Historie
@table @asis
@item V1.0
Die Urversion des Programms wurde auf einem Exidy Sorcerer (ein CP/M-Rechner
mit Z80-CPU) in --- Basic geschrieben. Alle Daten standen auf der Diskette,
das Programm war dadurch sehr langsam. Der Algorithmus des Schweizer Systems
war recht simpel und blieb bei den Versionen 2 bis 4 unverändert.

@item V2.0
Auf meinem ersten eigenen Computer (einem C64) in Assembler geschrieben.

@item V3.0
Auf meinem ersten Amiga (ein A1000) in AmigaBasic geschrieben. Erste
Version, die auch Rundenturniere beherrschte.

@item V4.0
Mit dem ersten eigenen C-Compiler (Aztec-C V3.4a) geschrieben.

@item V4.2
Auf Anregung von Frank-Thomas Elpelt mit einigen Ergänzungen versehen:
Aufnahme von Spielern im Schweizer System nach der ersten Runde, Löschen
von ausgeschiedenen Spielern. Durch die inzwischen gestiegenen Ansprüche
der Schachspieler an den Auslosungsalgorithmus gab es mehrfach bei Turnieren
Ärger, vor allem weil die Behandlung des Farbwechsels (wohl zurecht) als
unbefriedigend empfunden wurde.

@item V5.0
Auf Anregung von Kai Bolay mit einem zeitgemäßen GUI unter Kickstart 2.x
versehen. Algorithmen jetzt gemäß Turnierleiterhandbuchs. DWZ-Wertung
eingeführt.

@item V5.1
Internationale Version mit Verwendung der locale.library.

@item V5.1a
Unbedeutende Fehlerkorrekturen, Lokalisierung für Workbench 2.0

@item V5.2
Benutzeroberfläche jetzt mit MUI, ARexx-Port, Setzen von Spielen,
Ausgabe von Kreuztabellen und Spielerkarten im Ascii-Format

@item V5.3
Einige Fehlerkorrekturen, nutzt einige Vorteile von MUI 2.0,
Gewinn- und Remispunktzahlen frei wählbar.

@item V5.4
Auslosungsalgorithmus des Schweizer Systems neu geschrieben
@end table

@node Zukunft
@chapter Zukunft des Programms
@cindex Zukunft
@cindex Setzen
Verschiedenes ist vorstellbar. Internationale Wertungen wie ELO- oder
USCF- könnten die DWZ-Wertung ergänzen. Es könnte doppelrundige
Rundenturniere geben. Zur Steigerung der Geschwindigkeit könnte
man die Auslosung in Assembler schreiben.

Alle diese Änderungen sind für @emph{mich} auf jeden Fall nicht nötig.
Ich werde sie nur dann einbauen (und überhaupt nur dann weitere Arbeit in
das Programm stecken), wenn (wie ich hoffe) ein gewisses Echo von den
Benutzern zurückkommt. (Bei den internationalen Wertungen wäre ich mangels
Dokumentation sogar auf Hilfe angewiesen.) Es liegt also an @emph{Ihnen}.

@node Danksagungen
@unnumbered Danksagungen
@cindex Danksagungen
Danken möchte ich:

@table @strong
@item Stefan Stuntz
für die Erstellung von MUI. Wer jetzt nicht mit der Benutzeroberfläche
zufrieden ist, dem ist nicht zu helfen.

@item Reinhard Spisser und Sebastiano Vigna
für die Amiga-Version von texinfo, mit der diese Dokumentation geschrieben
ist.

@item Der Free Software Foundation
für die Urversion von texinfo und für viele andere hervorragende Programme.

@item Matt Dillon
für DICE und besonders für DME.

@item Den Betatestern
Kai Bolay (kaib), Frank Geider, Franz Hemmer, Jürgen Lang (Quarvon),
Christian Soltenborn sowie Volker Zink (Der Zinker).

@item Meinem Freund Mathias Mörsch
für seine Hilfe bei der englischen Übersetzung der Dokumentation: Hat es
wenigstens ein Gutes, daß er seit 5 Jahren in den USA steckt.

@item Christian Bauernfeind (Baffy)
für verschiedene Fehlermeldungen und Betatesten.

@item Den Leuten von #AmigaGer
für die Beantwortung vieler dummer
Fragen und für viele Augenblicke erfreulich
ungezügelten Schwachsinns :-), z.B. PowerStat (Kai Hoffmann),
ZZA (Bernhard Möllemann), Stargazer (Petra Zeidler), stefanb
(Stefan Becker), Tron (Mathias Scheler), ill (Markus Illenseer) und jow
(Jürgen Weinelt).

@item Commodore
für den Amiga und für die Kickstart 2.0 :-) Macht weiter mit der Kiste, dann
bin ich vielleicht auch die nächsten 8 Jahre Amiga-Benutzer!

@item Douglas Adams und Tom Sharpe
für das Erdenken von Arthur Dent und Henry Wilt, meinen
Lieblings(anti)helden.

@item und meinen Eltern für ihre Badewanne.
Nirgends kann man besser nachdenken. ;-)
@end table

@node Literatur
@unnumbered Literatur
@table @emph
@item Das ELO-System
von Peter-Zöfel, Friedrich-Fröbel-Str. 5, 35041 Marburg und Karl-Heinz-Glenz,
Friedenau 22, 46284 Dorsten 21, von den Autoren selbst verlegt.

@item Turnierleiterhandbuch des Deutschen Schachbundes
von Ernst Schubart und Helmut Nöttger, de Gruyter Verlag, Berlin, New York,
1987
@end table

Alle Algorithmen und Richtlinien folgen den in diesen Büchern vorgegebenen.

@page
@headings off
@node Index
@unnumbered Index
@printindex cp

@contents

@bye
