@DATABASE WW2.guide
@TAB 3

@NODE MAIN "WW2"
 @{b}WW2 Release 3.4@{ub}

 @{"Copyright and Disclaimer" LINK Copyright}
 @{"Credits" LINK Credits}
 @{"Introduction" LINK Introduction}
 @{"Requirements" LINK Requirements}
 @{"Rules" LINK Rules}
 @{"Game Server" LINK Server}
 @{"GUI Client" LINK GUI}
 @{"Lua Client" LINK Lua}
 @{"Known Defects" LINK Defects}
 @{"Author" LINK Author}
 @{"History" LINK History}
 @{"Future" LINK Future}
 @{"Question & Answer" LINK FAQ}
@ENDNODE


@NODE Copyright "Copyright and Disclaimer"
WW2
Copyright  2000-2008 Steven Solie. All Rights Reserved.

Based on the original "Axis & Allies" board game.
Copyright  1987 Milton Bradley Co.

You are hereby granted the right to copy and distribute verbatim copies of
the program archive unaltered and in its entirety.
All other rights are reserved.

There is no guarantee or warranty of any kind. Use at your own risk.


Anti-Grain Geometry - Version 2.4 
Copyright (C) 2002-2005 Maxim Shemanarev (McSeem) 

Permission to copy, use, modify, sell and distribute this software 
is granted provided this copyright notice appears in all copies. 
This software is provided "as is" without express or implied
warranty, and with no claim as to its suitability for any purpose.
@ENDNODE


@NODE Introduction "Introduction"
@PROPORTIONAL
@SMARTWRAP
I became addicted to the "Axis & Allies" board game while taking classes at
the University of Regina, Saskatchewan, Canada. My friends and I played
almost every weekend until the wee hours of the morning. Since those days
ended some time ago, I've been itching to play a game or two but lacked the
necessary players and time to do so.
@{PAR}

I first started a computer version of this board game way back in 1993
written entirely in C on my unexpanded Amiga 3000D system. After several
failed attempts in both C and C++ over the years, I was pretty much ready
to give up on the project when I discovered the Personal Software Process
(PSP) by Watts Humphrey. I credit the PSP with giving me the structure and
discipline to get as far as I did this time around.
@{PAR}
@ENDNODE


@NODE Requirements "Requirements"
Minimum requirements:
 AmigaOS 4.0 Final + July Update (V52)
 800 x 600 with ARGB colour mode

Recommended:
 AmigaOne compatible computer system
 1024 x 768 in ARGB mode
 Internet connection for playing head-to-head against a buddy
@ENDNODE


@NODE Rules "Rules"
@SMARTWRAP
If you are a war gamer the rules for WW2 will seem pretty simple. If you
are not a war gamer (yet) the rules are quite complex at first but will
become second nature after a couple of games.
@{PAR}

This game implementation is based on the official Axis & Allies 2nd edition
rules. I do plan to add 3rd edition rules and various rule options in later
releases. I'm also looking at making the jump to the revised edition.
@{PAR}

Generally speaking, if you are not allowed to do something, the game just
won't let you do it. You won't see little message boxes popping up telling
you what you are doing wrong. That kind of feature is difficult to implement
and becomes really annoying for experienced players so I haven't added it
yet. Let @{"me" LINK Author} know how you feel about this.
@{PAR}

You can obtain an electronic copy of the game rules from
http://www.wizards.com/default.asp?x=ah/downloads
but you should already have a copy of the board game itself.
@{PAR}
@ENDNODE


@NODE Server "Game Server"
@SMARTWRAP
The game server is named WW2-Server and must be running in order to play.
The server is multi-player enabled and is planned to have multi-observer
capabilities in a future release. For now, it just quietly runs in the
background doing its thing.
@{PAR}

The server can be launched from either Workbench or the Shell. There are
currently no options. The server will automatically shutdown if you quit the
game or send it a CTRL-C signal. You can play as many games as you wish
on a server but only one game at a time can be played.
@{PAR}

The server's ARexx host port is named @{B}WW2SERVER@{UB} and it is used to
change server options while the server is running. It currently supports the
following commands:
@{PAR}

@{B}STARTLOG SERVER/S,VIEW/S@{UB}
@{PAR}
Start logging XML messaging to the default shell window. The SERVER option
will log server messages while the VIEW option will log client messages.
@{PAR}

@{B}STOPLOG SERVER/S,VIEW/S@{UB}
@{PAR}
Stop logging XML messaging to the default shell window. The SERVER option
will stop logging server messages while the VIEW option will stop logging
client messages.
@{PAR}
@ENDNODE


@NODE GUI "GUI Client"
@SMARTWRAP
The GUI client is named WW2-GUI. When first launched, the GUI will prompt
the player to play in single player mode, host a network game or connect
to an existing network game.
@{PAR}

In single player mode you have the option of using Lua scripts to play
some of the nations. There is one Lua script per team.
@{PAR}

A game may also be hosted. When hosting a game you choose which team to
play. You can choose either the Axis or the Allies and the server will wait
until another WW2 client joins the game to play the other team. Only the
player hosting the game has the capability to start and stop the game as
well as load games and save games. The socket server port is currently fixed
at 6642 and uses TCP exclusively. Configuration options may be added in
later versions.
@{PAR}

Connecting to a network game will require the IP address of the server.
The remote player has more limited options with game administration
controlled by the host.
@{PAR}

The GUI client is currently rather simple and enables a player to scroll
and zoom the game map to any size. The GUI client can be launched from
either Worbench or the Shell.
@{PAR}


If launched from the shell it has the following command template:
@{PAR}
@{B}LANGUAGE/K@{UB}
@{PAR}

Where LANGUAGE is the current language catalog to use. Only English is
available. If you'd like to volunteer to transate it to your language
please feel free to contact @{"me" LINK Author}.
@{PAR}


If launched from Workbench, it has the following tool types:
@{PAR}
@{B}LANGUAGE@{UB}
@{PAR}

Where LANGUAGE has the same functionality as the shell option.
@{PAR}


I haven't fully documented the GUI yet because it is always changing.
In any case, here are some not-so-obvious features:
@{PAR}

 Hold down the left mouse button and move the mouse to scroll the map.
@{PAR}

 Zoom the map by holding down a shift key while scrolling or use the
scroll wheel.
@{PAR}

 Click the left mouse button on an arrowhead to cancel a move.
@{PAR}

 The screen mode can only be changed when a game is not in progress.
@{PAR}

 Unit markers have the size of the unit displayed in the bottom centre
and the unit range in the top left corner (if applicable).
@{PAR}

 All units are moved one at a time.
@{PAR}


I tried to design the GUI to be a powerful interface for the experienced game
player and true to the original board game. This means the GUI may not be as
intuitive as it could be for a beginner. Another consequence is the fact that
the game map does not wrap around while scrolling. This decision was based
on the fact that players are prone to make mistakes at the edges of the game
board and I wanted that error opportunity to carry over into the computer
version.
@{PAR}
@ENDNODE


@NODE Lua "Lua Client"
@SMARTWRAP
The Lua client is meant to serve a dual purpose. For me, it means the
capability to automate functional testing which should help increase the
quality of the software. For you, it means you have the capability to
program the game yourself. Imagine creating your own robot opponents and
making them as smart or dumb as you want.
@{PAR}

See http://www.lua.org for complete information about the Lua programming
language itself.
@{PAR}

The Lua client can only be launched from the Shell currently.
@{PAR}

The Lua client has the following command template:
@{PAR}
@{B}SCRIPT/A@{UB}
@{PAR}

 @{"Lua Functions" LINK LuaFunctions}@{PAR}
 @{"Lua Callbacks" LINK LuaCallbacks}@{PAR}
@ENDNODE


@NODE LuaFunctions "Lua Functions"
@SMARTWRAP
The following extended library functions are currently available:
@{PAR}

@{B}abortMove (moveid)@{UB}
@{PAR}
Aborts the move specified by the moveid number. Returns true if successful or
false on error. This command can only be used during the Combat and
Non-Combat Movement actions.
@{PAR}

@{B}beginMove (unitid)@{UB}
@{PAR}
Begins to move the unit identified by the unitid number. Returns a unique
moveid number if successful or nil on error. This command can only be used
during the Combat and Non-Combat Movement actions.
@{PAR}

@{B}buyUnit (unittype)@{UB}
@{PAR}
Buy one specific type of unit. This command can only be used during the
Purchase Units action.
@{PAR}

@{B}changeMoveSize (moveid, delta)@{UB}
@{PAR}
Changes the size of the move specified by the moveid number by the delta
amount. The delta can be a positive or negative integer number. Returns true
if successful or false on error. This command can only be used during the
Combat and Non-Combat Movement actions.
@{PAR}

@{B}deployUnit (unittype, gamespace)@{UB}
@{PAR}
Deploys one unit of the specified type to the game space.
This command can only be used during the Place New Units action.
@{PAR}

@{B}endAction ()@{UB}
@{PAR}
End the current action. Returns true if successful or false on error.
@{PAR}

@{B}endMove (moveid)@{UB}
@{PAR}
Ends the move identified by the moveid number. Returns true if successful or
false on error. This command can only be used during the Combat and
Non-Combat Movement actions.
@{PAR}

@{B}getGameMap ()@{UB}
@{PAR}
Returns the current game map as a table of gamespaces. All the gamespaces
including what units are in each gamespace are returned.
@{PAR}

Each entry in the returned table has the following entries:
@{PAR}
@{TAB}id - unique gamespace identifier number@{PAR}
@{TAB}type - gamespace type string@{PAR}
@{TAB}owner - gamespace owner string@{PAR}
@{TAB}income - income value number@{PAR}
@{TAB}neighbors - table of neighboring territories@{PAR}
@{TAB}units - table of units in this territoriy@{PAR}

Each element in the neighbors table has the following entries:
@{PAR}
@{TAB}id - unique gamespace identifier number@{PAR}

Each element in the units table has the following entries:
@{PAR}
@{TAB}id - unique unit identifier number@{PAR}
@{TAB}type - unit type string@{PAR}
@{TAB}owner - unit owner string@{PAR}
@{TAB}size - unit size number@{PAR}
@{TAB}cargo - table of unit cargo@{PAR}

Each element in the cargo table has the following entries:
@{PAR}
@{TAB}id - unique unit identifier number@{PAR}
@{TAB}type - unit type string@{PAR}
@{TAB}owner - unit owner string@{PAR}
@{TAB}size - unit size number@{PAR}

@{B}getMoveableUnits ()@{UB}
@{PAR}
Returns the moveable units in two tables. The first table contains
all the moveable combat units. The second table contains all the
moveable cargo units. Each table element has the following fields:
@{PAR}
@{TAB}id - unique unit identifier number@{PAR}
@{TAB}type - unit type string@{PAR}
@{TAB}size - unit size number@{PAR}
@{TAB}range - unit range number@{PAR}
@{TAB}where - gamespace identifier string@{PAR}

@{B}getUnitCost (unittype)@{UB}
@{PAR}
Returns the cost of the unit as a number.
@{PAR}

@{B}joinGame (nation, ...)@{UB}
@{PAR}
Join the current game as one or more nations. Returns true if successful
or false on error.
@{PAR}

@{B}killAttacker (gamespace, id, size)@{UB}
@{PAR}
Kills the specified unit. Returns true if successful or false on error.
@{PAR}
@{TAB}gamespace - gamespace identifier string@{PAR}
@{TAB}id - unique unit identifier number@{PAR}
@{TAB}size - size to kill@{PAR}

@{B}killDefender (gamespace, id, size)@{UB}
@{PAR}
Kills the specified unit. Returns true if successful or false on error.
@{PAR}
@{TAB}gamespace - gamespace identifier string@{PAR}
@{TAB}id - unique unit identifier number@{PAR}
@{TAB}size - size to kill@{PAR}

@{B}leaveGame ()@{UB}
@{PAR}
Leave the current game. Returns true if successful or false on error.
@{PAR}

@{B}moveTo (moveid, gamespace)@{UB}
@{PAR}
Specifies the next game space to move to for the given moveid. Returns true
if successful or false on error. This command can only be used during the
Combat and Non-Combat Movement actions.
@{PAR}

@{B}newGame ()@{UB}
@{PAR}
Starts a new game. Implicitly ends the current game in progress. Returns
true if successful or false on error.
@{PAR}

@{B}printDebug (string)@{UB}
@{PAR}
Outputs the string to the current debug console stream.
Utilizes the exec.library/DebugPrintF() function to do so.
@{PAR}

@{B}quitGame ()@{UB}
@{PAR}
Quit the game and exit. Implicitly ends the current game in progress. Returns
true if successful or false on error.
@{PAR}

@{B}recallUnit (unittype, gamespace)@{UB}
@{PAR}
Recalls one deployed unit of the specified type from the game space. Returns
true if successful or false on error. This command can only be used during
the Place New Units action.
@{PAR}

@{B}sellUnit (unittype)@{UB}
@{PAR}
Sell one specific type of unit. Returns true if successful or false on error.
This command can only be used during the Purchase Units action.
@{PAR}

@{B}sleep (seconds)@{UB}
@{PAR}
Sleeps for the specified number of seconds.
Returns true if successful or false if interrupted.
@{PAR}

@{B}withdrawUnit (gamespace, unitid)@{UB}
@{PAR}
Withdraws one unit from the specified game space. Returns true if successful
or false on error. This command can only be used when withdrawing units
from battle.
@{PAR}

@{CODE}
The "gamespace type" string can be any of the following:
 LAND - Land
 SEA  - Sea Zone

The "owner" and "nation" string can be any of the following:
 DE - Germany
 JP - Japan
 UK - United Kingdom
 US - United States of America
 SU - Union of Soviet Socialist Republics

The "unittype" string can be any of the following:
 INF - Infantry
 ARM - Armor
 FTR - Fighter
 BMB - Bomber
 BB  - Battleship
 AC  - Aircraft Carrier
 TRN - Transport
 SUB - Submarine
 AA  - Antiaircraft Gun
 IC  - Industrial Complex

Type "gamespace" string can be any of the following:
 AFG - Afghanistan
 ALA - Alaska
 ALG - Algeria
 ANG - Angola
 ARG - Argentina Chile
 ASC -
 AUS - Australia
 AZO -
 BAL - Baltic Sea Zone
 BAR -
 BEN - India Ocean Sea Zone
 BER - Alaska Sea Zone
 BLA - Black Sea Zone
 BOL - Peru
 BOR - Borneo Celebes
 BRA - Brazil
 BUR - French Indo-China Burma
 CAN -
 CAR - West Indies Sea Zone
 CAS - Caspian Sea Zone
 CAU - Caucasus
 CEL - Borneo Celebes Sea Zone
 CGH -
 CHI - China
 CMD - Central Mediterranean Sea Zone
 CNG - Belgian Congo
 COL - Venezuela Colombia
 COR - Coral Sea Zone
 CRI - Caroline Islands
 CUB - West Indies
 EAF - Italian East Africa
 ECA - Eastern Canada
 ECH - Kwangtung Sea Zone
 ECO - Eastern USA Sea Zone
 EEU - Eastern Europe
 EGY - Anglo-Egypt Sudan
 EIO - Eastern India Ocean Sea Zone
 EMD - Eastern Mediterranean Sea Zone
 EPO - Hawaii Sea Zone
 EUS - Eastern U.S.A.
 EVE - Evenki Nat'l Okrug
 FAR - Soviet Far East
 FDN -
 FEQ - French Equatorial Africa
 FIN - Finland Norway
 GAB - Great Australian Bight Sea Zone
 GBR - United Kingdom
 GER - Germany
 GIB - Gibraltar
 GLP - West Panama Sea Zone
 GOA - Gulf of Alaska Sea Zone
 GOC - West Mexico Sea Zone
 GOM - Gulf of Mexico Sea Zone
 GSJ - East Chile Sea Zone
 HAW - Hawaiian Islands
 IND - India
 IRE - Eire
 JAV - East Indies Sea Zone
 JFI - Peru Sea Zone
 JPN - Japan
 KAZ - Kazakh S.S.R.
 KEN - Kenya Rhodesia
 KWA - Kwangtung
 LAB - Eastern Canada Sea Zone
 LEN - Karelia S.S.R.
 LIB - Libya
 MAD - French Madagascar
 MAN - Manchuria
 MCH -
 MEL - New Guinea Sea Zone
 MEX - Mexico
 MIC - Caroline Islands Sea Zone
 MID - Midway Island
 MNG - Mongolia
 MOS - Russia
 MOZ - Mozambique
 NAO - North Atlantic Sea Zone
 NGU - New Guinea
 NOR - North Sea Zone
 NOV - Novosibirsk
 NPO -
 NZE - New Zealand
 OKI - Okinawa
 PAN - Panama
 PEI -
 PER - Persia
 PHI - Philippine Islands
 POL - South Pacific Sea Zone
 RDJ -
 RED - Red Sea Zone
 RIO - Rio De Oro
 RYU - Okinawa Sea Zone
 SAF - Union of South Africa
 SAO -
 SAR - Saudi Arabia
 SCH -
 SCO - South Chile Sea Zone
 SEI -
 SEU - Southern Europe
 SIN - Sinkiang
 SJA - Japan Sea Zone
 SOK - Soviet Far East Sea Zone
 SOL - Solomon Islands
 SOS - Solomon Islands Sea Zone
 SPA - Spain
 SPO - Easter Island Sea Zone
 SUL - Philippine Islands Sea Zone
 SUM - East Indies
 SWE - Sweden
 SWI -
 SWZ - Switzerland
 SYR - Syria Iraq
 TAS - New Zealand Sea Zone
 TDC -
 TIM - Timor Sea Zone
 TOC - Midway Island Sea Zone
 TUR - Turkey
 UKR - Ukraine S.S.R.
 WAF - French West Africa
 WAK - Wake Island
 WCA - Western Canada
 WCO -
 WEU - Western Europe
 WIO - Western India Ocean Sea Zone
 WMD - Western Mediterranean Sea Zone
 WPO - Wake Island Sea Zone
 WUS - Western U.S.A.
 YAK - Yakut S.S.R.
@ENDNODE

@NODE LuaCallbacks "Lua Callbacks"
@SMARTWRAP
The following callbacks must be defined in your Lua scripts. The Lua
client will invoke these callbacks at the appropriate times during the
game.
@{PAR}

@{B}doChooseAAGunCasualties (gamespace, hits, units)@{UB}
@{PAR}
This function is called when one or more aircraft has been hit by defending
anti-aircraft gun fire. The function selects which units to kill with the
killAttacker() function. Each entry in the units table has the following fields:
@{PAR}
@{TAB}id - unique unit identifier number@{PAR}
@{TAB}type - unit type string@{PAR}
@{TAB}owner - unit owner string@{PAR}
@{TAB}size - unit size number@{PAR}

@{B}doChooseBattle (nation, gamespaces)@{UB}
@{PAR}
This function is called when a nation must choose a battle to resolve. The
gamespaces table contains an array of game space identifiers to pick from.
This function must return one game space from the given array.
@{PAR}

@{B}doChooseLandBattleAttackerCasualties (gamespace, hits, units)@{UB}
@{PAR}
This function is called when one or more land battle attacker casualties
must be chosen after the defender has fired. The function selects which
units to kill with the killAttacker() function. Each entry in the units
table has the following fields:
@{PAR}
@{TAB}id - unique unit identifier number@{PAR}
@{TAB}type - unit type string@{PAR}
@{TAB}owner - unit owner string@{PAR}
@{TAB}size - unit size number@{PAR}

@{B}doChooseLandBattleDefenderCasualties (gamespace, hits, units)@{UB}
@{PAR}
This function is called when one or more land battle casualties must be
chosen after the attacker has fired. The function selects which units to
kill with the killDefender() function. Each entry in the units table has
the following fields:
@{PAR}
@{TAB}id - unique unit identifier number@{PAR}
@{TAB}type - unit type string@{PAR}
@{TAB}owner - unit owner string@{PAR}
@{TAB}size - unit size number@{PAR}

@{B}doChooseSeaBattleDefenderCasualties (gamespace, hits, units)@{UB}
@{PAR}
This function is called when one or more sea battle casualties must be
chosen after the attacker has fired. The function selects which units to
kill with the killDefender() function. Each entry in the units table has
the following fields:
@{PAR}
@{TAB}id - unique unit identifier number@{PAR}
@{TAB}type - unit type string@{PAR}
@{TAB}owner - unit owner string@{PAR}
@{TAB}size - unit size number@{PAR}

@{B}doChooseSeaBattleDefenderNavalCasualties (gamespace, hits, units)@{UB}
@{PAR}
This function is called when one or more sea battle naval casualties must be
chosen after attacking submarines have fired. The function selects which
naval units to kill with the killDefender() function. Only naval units can
be chosen because submarines cannot fire at aircraft. Each entry in the units
table has the following fields:
@{PAR}
@{TAB}id - unique unit identifier number@{PAR}
@{TAB}type - unit type string@{PAR}
@{TAB}owner - unit owner string@{PAR}
@{TAB}size - unit size number@{PAR}

@{B}doChooseSeaBattleDefenderWithdrawals (gamespace, units)@{UB}
@{PAR}
This function is called when the defender may optionally withdraw submarines
from a naval battle. Withdrawals are chosen with the withdrawUnit() function.
The game space to withdraw to must be returned or nil if none. Each entry in
the units table has the following fields:
@{PAR}
@{TAB}id - unique unit identifier number@{PAR}
@{TAB}type - unit type string@{PAR}
@{TAB}owner - unit owner string@{PAR}
@{TAB}size - unit size number@{PAR}

@{B}doCollectIncome (nation)@{UB}
@{PAR}
This function is called with the current nation string when the nation is
collecting its income and marks the end of the nation's turn.
@{PAR}

@{B}doCombatMovement (nation)@{UB}
@{PAR}
This function is called with the current nation string when the nation should
be performing any combat movements.
@{PAR}

@{B}doNonCombatMovement (nation)@{UB}
@{PAR}
This function is called with the current nation string when the nation should
be performing any non-combat movements.
@{PAR}

@{B}doPlaceNewUnits (nation)@{UB}
@{PAR}
This function is called with the current nation string when the nation should
be deploying any purchased units.
@{PAR}

@{B}doPurchaseUnits (nation)@{UB}
@{PAR}
This function is called with the current nation string when the nation should
be purchasing units.
@{PAR}

@{B}doResearch (nation)@{UB}
@{PAR}
This function is called with the current nation string when the nation should
be doing research.
@{PAR}

@{B}doShutdown ()@{UB}
@{PAR}
This function is called when the game server has indicated the game has been
shut down. Not much more can be done after the game has been shut down.
@{PAR}

@{B}doStartup ()@{UB}
@{PAR}
This function is always called first when a script is first executed. The
script is expected to joinGame() at this point. This function must return
a boolean value indicating whether the game should continue or not.
@{PAR}

@ENDNODE

@NODE Defects "Known Defects"
@SMARTWRAP
The following defects are known to exist:
@{PAR}

- Saving and loading games over a network file system is very slow due
to lack of buffering.

- Redrawing of units takes a lot of time and causes the mouse pointer
to stutter.

- When the Lua client is playing the GUI may "freeze" due to a problem
with Intuition locking. Be careful not to change the GUI while the Lua
client is playing for now.
@{PAR}
@ENDNODE


@NODE Author "Author Information"
Please feel free to contact me if you have any comments or questions:

Steven Solie

Email: ssolie@telus.net, ssolie@ieee.org
  WWW: http://www3.telus.net/ssolie/
@ENDNODE


@NODE History "Release History"
@{B}Release  Date        Comments@{UB}
-----------------------------
3.4      2008-05-06  - Added many Lua functions and callbacks which makes it
                       possible to play against the computer now
                     - GUI changes to improve the look including alpha support
                     - Fixed some more rule violations
                     - GUI now displays marker overflows using a heavy line
                       extending from the last unit placed
                     - Many files converted to XML-based formats for future
                       game expansion capabilities

3.3      2007-05-06  - GUI now defaults to moving one unit at a time
                     - GUI introduced a new "move wheel" which is used to
                       change the size of a move
                     - Fixed several GUI rendering glitches
                     - Fixed several bridged move rule violations
                     - Changed to use Deja Vu typefaces
                     - Changed to GUI to display overflow units differently
                     - Removed algorithmic placement of units on gamespaces
                     - Exported several data sets from internal to XML-based
                       files
                     - Changed GUI prefs file from IFF to XML
                     - Replaced most bitmapped graphics with new graphics by
                       Kenneth Lester

3.2      2007-02-04  - Added choice of human or robot players
                     - Added many new Lua function calls
                     - Added network chatting capability
                     - Robot player status is displayed in the chat browser
                     - Game map is now rendered faster and more efficiently
                     - Territory outlines are shown when scrolling and zooming
                     - Remote players can join or leave a game at any time now
                     - Now requires AmigaOS 4.0 final

3.1      2006-02-25  - Completed entire 2nd Edition rule set.
                     - Replaced ARexx client with a Lua client.
                     - GUI should now be a bit more user friendly and stable.
                     - Improved look of GUI a bit.

3.0      2005-07-02  Implemented basic head-to-head internet play.
                     GUI now runs in either host or remote mode at startup.
                     Windows can now be dragged offscreen.
                     Greatly improved robustness in error situations.
                     Added entropy seed to the random number generator.
                     Fixed bugs reported by John Chandler.
                     Fixed various obscure rule violations.
                     Improved file requesters.

2.1      2005-02-12  Improved graphics with the Anti-Grain Geometry package.
                     Continent contours are displayed while panning & zooming.
                     Added battleship support attacks.
                     Added Panama and Suez canal rules.
                     Now requires ARGB or BGRA colour modes.
                     Completed transport rules with allies.

2.0      2004-10-11  Ported to AmigaOS 4.0 and enhanced.
                     Implemented full transport rules except with allies.
                     Implemented full amphibious assult rules except
                     battleship support attacks.
                     Transport bridge moves are fully supported.

1.5      2004-01-23  Implemented full fighter/carrier interaction rules.
                     Renamed to simply "WW2".

1.4      2003-01-27  Added strategic bombing raids & completed antiaircraft
                     gun rules.

1.3      2002-06-12  Added transports and aircraft carriers.

1.2      2002-06-02  Added battleships and submarines.

1.1      2002-04-05  Added fighters and bombers.

1.0      2002-02-07  First public release.


@ENDNODE


@NODE Future "Future Features"
@SMARTWRAP
The 2nd edition rules are now complete. Configuration options and other
nice-to-have extras are still missing.
@{PAR}

My top priority now is to complete the Lua client so robot players can be
built. I'm also open to suggestions from anyone on what to implement next
and all input will be seriously considered.
@{PAR}

The game is designed so that it will be possible to write lightweight
clients for it in any programming language and play it over the internet.
It is also possible to make the game compatible with play-by-email systems.
@{PAR}

The Lua client opens up a myriad of possibilities including a command
line interface, user programmable robot opponents and remote control to name
just a few. I hope to expand the game with Lua to enable just about anything
a clever WW2 hacker could imagine.
@{PAR}

Please don't hesitate to contact @{"me" LINK Author} with your ideas and comments.
@{PAR}
@ENDNODE


@NODE FAQ "Question & Answer"
@SMARTWRAP
@{B}Q: Why are the executables so large?@{UB}
@{PAR}

My choice of C++ can take most of the credit. The underlying static link
libraries add about 700 KB to the total size. Hopefully, a shared C++
standard library will be made available which should bring the executable
sizes down to a more reasonable level.
@{PAR}


@{B}Q: Why create a computer version of the board game?@{UB}
@{PAR}

The primary motivation for this project was a desire to play against other
players via the internet. A secondary motivation was to learn how to develop
a large application in C++ using various software development techniques
and advanced language features.
@{PAR}


@{B}Q: Are you aware there is already a PC version of this game?@{UB}
@{PAR}

Yes. I've seen various reviews of the game and the hard core gamers have
basically concluded that it is an unusable buggy mess. They suffer with it
only because it is the only game in town. I also believe I'm targetting a
completely different kind of player. I'm trying to create a game for
experienced and expert players. I won't be adding any fancy war footage
clips and such. I want to concentrate on correctness and reliability so you
can play this game for many, many hours if you want to.
@{PAR}


@{B}Q: Are you aware there a free Java version of this game?@{UB}
@{PAR}

Yes. However, it uses Java and the Java platform is not really all that
free because it only works on platforms which have a JVM. Unfortunately,
AmigaOS is still waiting for a JVM and I don't feel much like waiting.
@{PAR}


@{B}Q: Will the game always be free?@{UB}
@{PAR}

Yes. I have no desire to make any money with this game. Why else would I
have developed it for AmigaOS? If you like this game, I suggest you buy a
copy of the board game and play it as well. Nothing beats a night of
wargaming with some buds.
@{PAR}


@{B}Q: What version of the official rules are supported?@{UB}
@{PAR}

The game follows the second edition rules quite strictly. Any exceptions
to the second edition rules are explained in this Q&A.
@{PAR}


@{B}Q: How are the rules enforced?@{UB}
@{PAR}

A majority of the rules are enforced silently. In other words, if the
computer isn't letting you do something, it very likely isn't legal.
@{PAR}


@{B}Q: What AA gun rules are assumed?@{UB}
@{PAR}

When an antiaircraft gun is captured, control of the gun reverts to the
gamespace owner in all situations. This was not made clear in any of the
official rule sets or FAQs.
@{PAR}


@{B}Q: How does the game choose aircraft casualties?@{UB}
@{PAR}

Aircraft with the shortest range remaining are taken as casualties first.
@{PAR}


@{B}Q: How does the game choose which industrial complex a naval unit is deployed from?@{UB}
@{PAR}

This situation may occur when there are two or more industrial complexes
bordering a single sea zone. The game will always try to choose the
industrial complex with the highest capacity first.  Once a unit is deployed
by an industrial complex, it remains associated with that complex until it is
recalled. Deployed units are always recalled in the reverse order in which
they were placed.
@{PAR}


@{B}Q: How does the game choose defending fighter casualties?@{UB}
@{PAR}

Defending fighters on carriers in sea zones are automatically launched.
Casualties are removed from friendly carriers first followed by carriers
with the least amount of fighters. The game tries to simplify and combine
units as much as possible for the player.
@{PAR}


@{B}Q: What happens to any defending fighters that are stranded?@{UB}
@{PAR}

When a defending carrier is sunk, any fighters it was carrying are considered
stranded at the end of the battle. Stranded fighters will automatically land
on any remaining friendly carriers. After that, stranded fighters will land
on any friendly islands which are defined to be totally enclosed by a sea
zone according to the rules. The game will try to ensure fighters defend
their own carriers first followed by any friendly carriers.
@{PAR}


@{B}Q: How are unlanded aircraft handled?@{UB}
@{PAR}

Notice that aircraft that require landing are highlighted during the
non-combat movement action. If you do not land these aircraft, they are
removed and you lose them forever.
@{PAR}


@{B}Q: How are multiple AA guns handled?@{UB}
@{PAR}

A gamespace may contain any number of antiaircraft guns. However, only one
of the AA guns may fire at enemy aircraft.
@{PAR}


@{B}Q: How are unit stacking rules enforced?@{UB}
@{PAR}

Unit stacking rules are not enforced which means you can have as many units
as you wish split into as many groups as you wish. I personally think this
was a rather silly rule and it has long since been abandoned by serious
players anyway.
@{PAR}

@ENDNODE


@NODE Credits "Credits"
@SMARTWRAP

Design and coding by Steven Solie.
@{PAR}
New and updated high colour graphics by Kenneth Lester.
Original low colour graphics by Lon Niedermayer.
@{PAR}

Extra special thanks to:
@{PAR}
Stephan Rupprecht - for help with that nasty layout.gadget bug
@{PAR}
Olaf Barthel - for the extra CygnusED and clib2 help
@{PAR}
John Chandler - for his Total Amiga Magazine review and bug reports
@{PAR}

Huge thanks to Hyperion Entertainment and the entire Amiga OS 4.0 team for making
AmigaOS 4.0 a reality!
@{PAR}

@ENDNODE
