<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<TITLE>Inutilis Inga Anleitung</TITLE>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<DIV ALIGN="RIGHT">
<A HREF="07-entwicklerprogramme.html">letztes Kapitel<IMG SRC="bilder/zurück.png" BORDER="0"></A>
<A HREF="inhalt.html">Inhalt</A>
<A HREF="09-sequenzen.html"><IMG SRC="bilder/weiter.png" BORDER="0">nächstes Kapitel</A>
</DIV>
<H1>IngaSkript</H1>

<A NAME="A"><H2>1. Einleitung</H2></A>

<P>IngaSkript ist die Programmiersprache, in der der gesamte Spielablauf eines Inga-Adventures geschrieben wird. Sie beinhaltet Befehle zum Einrichten eines Ortes, zur Abfrage von Aktionen ("Objekt sowieso wurde angeklickt"), zur Steuerung von Personen und Objekten, zur Verwaltung des Inventars, usw.</P>
<P>Die Inga-Engine versteht diese Skriptsprache aber nicht direkt, sondern nur einen speziellen Bytecode. Dieser wird beim Kompilieren mit der SkriptShell erzeugt. Dabei entstehen zwei Dateien: "story.inga" enthält alle Befehle des Skripts in kompilierter Form, und "story.itxt" enthält alle Zeichenketten (Texte). Beide Dateien müssen sich im "Dats/"-Verzeichnis des Spiels befinden.</P>
<P>In der SkriptShell kann man ein Skript in mehrere Dateien aufteilen, doch diese Unterteilung geht im Bytecode verloren. Alle Skriptdateien werden hintereinander in eine Binärdatei geschrieben, weshalb z.B. Sprungmarken übergreifend in allen Skriptdateien gelten, als wäre es ein einziges großes Skript.</P>
<P>Im Folgenden sollen nun die grundlegenden Prinzipien der Skriptprogrammierung erläutert werden. Eine Übersicht aller existierenden Befehle befindet sich in der Datei "Kompendium.guide".</P>

<A NAME="B"><H2>2. Regeln beim Skriptschreiben</H2></A>

<P>In jeder Zeile eines Skripts kann nur immer ein Befehl stehen. Mehrere Befehle hintereinanderzuschreiben, wie es in vielen anderen Sprachen möglich ist, funktioniert bei IngaSkript nicht.</P>
<P>Zur Übersichtlichkeit können beliebig viele Zeilen an jeder Stelle freigelassen werden. Kommentare, welche vom Compiler nicht beachtet werden, müssen in einer eigenen Zeile stehen (also nicht z.B. hinter einem Befehl) und mit einem Semikolon beginnen. Um die Struktur eines Skripts hervorzuheben, können Zeilen eingerückt werden, d.h. mit Leerzeichen oder Tabulatoren begonnen werden. Beispiel:</P>

<CODE>
WennAngesehen 1<BR>
&nbsp;&nbsp;&nbsp;Rede 0, 3, "Doof", ""<BR>
&nbsp;&nbsp;&nbsp;; dummer Kommentar mit anschließender Leerzeile<BR>
<BR>
&nbsp;&nbsp;&nbsp;WennGleich #10, 5<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rede 0, 3, "Blöd", ""<BR>
&nbsp;&nbsp;&nbsp;Abschluss<BR>
Abschluss<BR>
</CODE>

<P>Alle Befehle sind nach dem selben Schema aufgebaut. Erst kommt die Bezeichnung des Befehls, welche immer zusammenhängend (also ohne Leerzeichen) ist, und dann folgen die Parameter, jeweils getrennt durch ein Komma. Beispiel:</P>

<CODE>
NichtExistierenderBefehl "Parameter Nummer 1 (eine Zeichenkette sogar)", 2, 3, 4, 5<BR>
</CODE>

<P>Sowohl bei der Befehlsbezeichnung, als auch bei allen anderen Wörtern (z.B. Sprungmarken) gilt: Groß- und Kleinschreibung wird unterschieden! Schreibt man also einen Befehl komplett klein, so brauch man sich nicht zu wundern, wenn er dem Compiler unbekannt ist.</P>
<P>Zeichenketten (Texte) und Dateinamen müssen immer in Anführungszeichen stehen. Sprungmarken werden jedoch ohne solche geschrieben. Wichtig ist noch, dass bei Dateinamen weder Pfad noch Endung dazugeschrieben werden dürfen, da diese von der Engine immer selbst hinzugefügt werden (also anstatt "BitMaps/Haus.ibm" nur "Haus"!).</P>

<A NAME="C"><H2>3. Sprünge</H2></A>

<H3>3.1. Allgemeines</H3>
<P>Sprünge sind notwendig, um den Ablauf des Skripts zu steuern, also z.B. um zu einem anderen Ort im Spiel zu kommen. Dazu bedarf es einer Sprungmarke, die das Sprungziel angibt. Sie beginnt mit einem Doppelpunkt, dem eine beliebige Bezeichnung folgt (ohne Leerzeichen!). Beispiel:</P>

<CODE>
:AltesHaus<BR>
</CODE>

<P>Denke daran, dass "AltesHaus" etwas anderes ist als "alteshaus", da zwischen Groß- und Kleinschreibung unterschieden wird.</P>
<P>Um zu einer Sprungmarke zu gelangen, benutzt man den Befehl "Springe", gefolgt von der Sprungmarkenbezeichnung (hier aber ohne Doppelpunkt!). Beispiel:</P>

<CODE>
Springe AltesHaus<BR>
</CODE>

<P>Es gibt noch die Variante "SpringeOrt", welche im Befehlskompendium beschrieben wird.</P>

<H3>3.2. Die ":Start"-Sprungmarke</H3>
<P>In einem der Skripte eines Projektes muss die Sprungmarke ":Start" stehen. Sie gibt an, wo die Engine mit dem Skript beginnen soll, wenn das Spiel gestartet wird.</P>

<A NAME="D"><H2>4. Subs (Prozeduren)</H2></A>

<P>Es gibt in IngaSkript nur eine sehr einfache Form von Prozeduren, da diese für das System nicht sehr wichtig sind. Sie sind fast identisch zu normalen Sprüngen, nur mit dem Unterschied, dass das Programm wieder zurückkehren kann. Eine Subroute beginnt mit einer gewöhnlichen Sprungmarke und endet mit dem Befehl "Zurück". Anstelle von "Springe" benutzt man dann "SpringeSub". Beispiel:</P>

<CODE>
Rede 0, 3, "Hallo!", ""<BR>
SpringeSub RedeDazwischen<BR>
Rede 0, 3, "Und weiter geht's!", ""<BR>
Stopp<BR>
<BR>
:RedeDazwischen<BR>
Rede 0, 3, "Eine Subroute!", ""<BR>
Zurück<BR>
</CODE>

<P>Es ist nicht möglich, innerhalb einer Subroute wiederum "SpringeSub" zu benutzen! Auch darf aus einer Subroute nicht herausgesprungen werden, da dies Folgefehler verursacht. Normale Sprünge innerhalb einer Route sind jedoch möglich.</P>

<A NAME="E"><H2>5. Variablen</H2></A>

<P>Sämtliche nummerischen Werte in einem Befehl können durch Variablen ersetzt werden (Textvariablen gibt es dagegen nicht). Variablen werden mit einer Nummer bezeichnet, die durch ein Doppelkreuz (#) von konstanten Werten unterschieden werden. Beispiel:</P>

<CODE>
CDNummer #10<BR>
</CODE>

<P>Dies würde also nicht heißen: Spiele Lied Nummer 10, sondern: Spiele das Lied, das in Variable Nummer 10 angegeben ist. Die größt mögliche Variablennummer ist ca. 32000.</P>
<P>Wenn bei einem Befehl eine Variablennummer explizit als Parameter gefragt ist, so darf das Doppelkreuz nicht hingeschrieben werden. Beispiel:</P>

<CODE>
SetzeVariable 10, 5<BR>
</CODE>

<P>Dabei würde die Variable Nummer 10 auf fünf gesetzt werden. Es ist natürlich möglich, dass die gewünschte Variablennummer wiederum in einer Variable steht. In diesem Fall müsste natürlich das Doppelkreuz doch angegeben werden. Beispiel:</P>

<CODE>
SetzeVariable 10, 11<BR>
SetzeVariable #10, 5<BR>
</CODE>

<P>Dies würde die Variable Nummer 11 auf fünf setzen.</P>
<P>Die benutzten Variablen gelten übrigens global im gesamten Skript (also auch in allen einzelnen Skriptdateien eines Projekts). Auch in Subrouten werden keine internen Variablen benutzt, sondern immer die globalen. Mit Variablen kann auch gerechnet werden. Mehr dazu steht im Befehlskompendium ("AddVariable" usw.)</P>

<A NAME="F"><H2>6. ID-Nummern</H2></A>

<P>ID-Nummern sind im Inga-System sehr relevant und ziehen sich durch viele Bereiche. Es wird zwischen Orts-, Elements- und Inventar-IDs unterschieden.</P>
<P>Jeder Ort hat eine exklusive ID-Nummer. Es dürfen also nicht mehrere Orte die gleiche Nummer haben. Das Durchnummerieren beginnt mit eins. Die Orts-IDs sind völlig unabhängig von Elements- und Universal-IDs, also dürfen auch Nummer benutzt werden, die schon für Elemente vergeben sind.</P>
<P>Jedes Element auf einem Ort hat eine ID-Nummer, welche nur an diesem Ort gilt (also nicht global). Es kann somit in jedem Ort eine ID-Nummer eins (usw.) geben. Die IDs werden zur Kontrolle und Verwaltung der Elemente benötigt, also um abzufragen, ob ein bestimmtes Element angeklickt wurde, um es zu entfernen, usw.</P>
<P>WICHTIG: Die Elements-ID-Nummer 0 ist für die Hauptperson reserviert, weshalb man bei der Nummerierung der anderen Elemente erst mit 1 beginnen darf.</P>
<P>Inventar-IDs sind mit den Elements-IDs nahe verwandt, aber sie gelten global auf allen Orten und werden ab 256 nummeriert. Wie der Name schon sagt, werden damit die Gegenstände im Inventar gekennzeichnet. Genau wie bei Elements-IDs kann abgefragt werden, ob ein Gegenstand angeklickt wurde. Weitere Informationen stehen im Befehlskompendium (z.B. unter "WennBenutztMit").</P>

<A NAME="G"><H2>7. Der allgemeine Skriptaufbau</H2></A>

<H3>7.1. Orte</H3>
<P>Der grobe Aufbau der Skripte ist für jeden Ort identisch. Erst kommt eine Sprungmarke, gefolgt von der Einrichtungsbeschreibung, und dann die Aktionsliste mit ihren Abfragen. Dies sieht dann etwa so aus:</P>

<CODE>
:Ort<BR>
Einrichtung 1, "Bild", 0<BR>
&nbsp;&nbsp;&nbsp;Feld ...<BR>
&nbsp;&nbsp;&nbsp;Objekt ...<BR>
&nbsp;&nbsp;&nbsp;Person ...<BR>
&nbsp;&nbsp;&nbsp;<I>(*1)</I><BR>
EinrichtungEnde<BR>
<I>(*2)</I><BR>
Liste<BR>
WennBenutzt 1<BR>
&nbsp;&nbsp;&nbsp;...<BR>
Abschluss<BR>
Stopp<BR>
</CODE>

<P>Wenn die Engine dann zu "Ort" springt, dann wird erst einmal mit dem Befehl "Einrichtung" das aktuelle Bild ausgeblendet und ein neues geladen. Dann werden alle Elemente der Einrichtung definiert und eventuell (bei *1) Voreinstellungen gemacht (z.B. die Hauptperson wird auf unsichtbar gestellt usw.), bis "EinrichtungEnde" erreicht wird.
Dort wird der Bildschirm mit allen Elementen grafisch aufgebaut und schließlich wieder eingeblendet.</P>
<P>Bei Bedarf können bei *2 noch Befehle aufgelistet werden, die bei jedem Betreten des Ortes ausgeführt werden sollen (z.B. die Hauptperson läuft immer zu einer bestimmten Stelle).</P>
<P>Der Befehl "Liste" veranlasst das Stoppen des Skripts. Nun kann der Spieler herumlaufen und Quatsch machen. Wenn jedoch etwas angeklickt wird, so startet das Skript wieder nach der Zeile "Liste" und alle Abfragen mit eventuellen Aktionen werden gemacht.</P>
<P>Das "Stopp" stoppt das Skript wieder (erstaunlich!), so dass der Spieler erneut gefragt ist. Zu diesem "Stopp" gibt es aber noch eine sinnvolle Alternative: In Adventures ist es üblich, dass man zwei Gegenstände aus dem Inventar miteinander benutzen kann, und zwar überall! Nun wäre es ja doof, bei jedem Ort ständig alle diese Abfragen zu machen, also nutzen wir Sprünge! Dafür ist eine extra Skriptdatei empfehlenswert, die z.B. so aussehen könnte:</P>

<CODE>
:Global<BR>
WennBenutztMit 256, 300<BR>
&nbsp;&nbsp;&nbsp;...<BR>
Abschluss<BR>
...<BR>
Stopp<BR>
</CODE>

<P>Anstelle des "Stopp" am Ende eines Ortskripts kommt nun "Springe Global". Nachdem dann alle lokalen Abfragen gemacht werden, folgen die globalen, die man somit nur einmal schreiben muss.</P>

<H3>7.2. Multiple-Choice-Dialoge</H3>
<P>Es gibt (hauptsächlich für Dialoge) die Möglichkeit, dass verschiedene (Antwort-) Möglichkeiten zur Verfügung stehen, die als Text dargestellt werden. Von diesen Antworten kann sich der Spieler eine auswählen und so den weiteren (Gesprächs-) Verlauf beeinflussen. Sobald etwas angeklickt wird, verschwinden die Auswahltexte.</P>
<P>Der Skriptaufbau dazu ist ähnlich dem eines Ortes: Jede Antwortmöglichkeit entspricht einem Element und anstelle des "Liste"-Befehls existiert "Dialogliste". Der Abfragebefehl heißt "WennGesagt". Beispiel:</P>

<CODE>
:Anfang<BR>
Antwort 1, "Tschüss!", 0, 0<BR>
Antwort 2, "Wie geht's?", 0, 0<BR>
Dialogliste<BR>
WennGesagt 1<BR>
&nbsp;&nbsp;&nbsp;Rede 0, 3, "Tschüss!", ""<BR>
&nbsp;&nbsp;&nbsp;Stopp<BR>
Abschluss<BR>
WennGesagt 2<BR>
&nbsp;&nbsp;&nbsp;Rede 0, 3, "Wie geht's?", ""<BR>
&nbsp;&nbsp;&nbsp;Rede 1, 3, "Ganz gut!", ""<BR>
&nbsp;&nbsp;&nbsp;Springe Anfang<BR>
Abschluss<BR>
</CODE>

<P>Die genauen Beschreibungen der Befehle stehen im Kompendium-Guide auf Diskette.</P>

<A NAME="H"><H2>8. Das Pseudo-Multitasking</H2></A>

<P>Inga besitzt die Fähigkeit, dass jede Person auf einem Ort ein eigenes Skript besitzen kann, welches sozusagen im Multitasking läuft. Man kann also eine Person ständig hin- und herlaufen lassen, ohne dass der restliche Spielfluss gestört wird (siehe Befehl "PersonProg" im Kompendium).</P>
<P>Das zweite Multitasking-ähnliche ist, dass parallel jede Person seinen eigenen aktuellen Befehl (z.B. zu einem Punkt laufen) befolgt. Das bedeutet, dass man aus dem Hauptskript mehreren Personen einen Befehl geben kann, wobei diese dann gleichzeitig ausgeführt werden. Es kann sich dabei jedoch immer nur um einen einzigen Befehl handeln. Sobald ein Befehl an eine Person geht, die noch etwas macht, wartet das Skript bis die Person wieder untätig ist. Beispiel:</P>

<CODE>
Laufe 0, 100, 100, 2<BR>
Laufe 1, 100, 100, 2<BR>
Laufe 2, 100, 100, 2<BR>
Laufe 0, 50,100, 2<BR>
Laufe 3, 100, 100, 2<BR>
</CODE>

<P>Als Erstes bekommt nun die Hauptperson (Nummer 0) den Befehl, nach (100,100) zu laufen. Während die Person noch läuft, wird auch schon Person Nummer 1 und 2 losgeschickt, so dass alle drei gleichzeitig laufen. Dann bekommt die Hauptperson (Nummer 0) einen neuen Befehl. Da sie aber vermutlich noch unterwegs ist, wird hier das Skript erst einmal gestoppt. Erst wenn die Hauptperson bei (100,100) angelangt ist, geht es mit dem neuen Befehl weiter. Erst jetzt wird auch die Nummer 3 losgeschickt. Das Multitasking ist also hier nicht ganz perfekt, aber dennoch nützlich.</P>
<P>Beim Reden gibt es noch eine absichtliche Einschränkung: Es kann immer nur eine Person gleichzeitig reden. Wenn eine Person redet, und gleichzeitig z.B. die Hauptperson etwas sagen soll, so wartet die Hauptperson so lange, bis die aktuelle Textzeile der anderen Person verschwunden ist. Andersherum funktioniert es natürlich genauso (jenachdem, wer zuerst reden will). Der Vorteil dieser Einschränkung ist, dass man Dialoge wesentlich unkomplizierter programmieren kann. Würden mehrere Texte gleichzeitig darstellbar sein, so müsste man ja zwischen jedem Rednerwechsel einen Wartebefehl einbauen, damit nicht alle gleichzeitig sprechen.</P>
</BODY>
</HTML>
