@DATABASE
@$VER: AmberCheat_Guide 1.1 (02.01.1998)

@REM @WORDWRAP

///"main"
@NODE main "Willkommen zu AmberCheat"
***************************************************************************
*                                                                         *
*                                 @{b}@{fg shine}AmberCheat@{ub}@{fg text}                              *
*                                                                         *
*                                  V1.1 MUI                               *
*                                                                         *
*                       Programmiert von Wanja Pernath                    *
*                                                                         *
*                 Letzte Änderung am Dokument: @{fg fill}02.01.1998@{fg text}                 *
***************************************************************************

@{u}@{b}@{fg shine}I. Einleitung@{ub}@{fg text}@{uu}

  1.1 @{"Entstehung            " link NODE_INTRO }
  1.2 @{"Überblick             " link NODE_OVERVIEW}
  1.3 @{"Systemvoraussetzungen " link NODE_SYSTEM}
  1.4 @{"Installation          " link NODE_INSTALL}
  1.5 @{"Rechtliches           " link NODE_RIGHTS}
  1.6 @{"MUI                   " link NODE_MUI}
  1.7 @{"Author                " link NODE_AUTOR}


@{u}@{b}@{fg shine}II. Programmbeschreibung@{ub}@{fg text}@{uu}

  2.1 @{"Das Programmkonzept   " link NODE_CONCEPT}
  2.2 @{"Die Bedienung         " link NODE_MAIN}
  2.3 @{"Das Menü              " link NODE_MENU}


@{u}@{b}@{fg shine}III. Über die Charaktere@{ub}@{fg text}@{uu}

  3.1 @{"Die Attribute         " link NODE_ATTRS}
  3.2 @{"Die Fähigkeiten       " link NODE_FAEH}
  3.3 @{"Andere Eigenheiten    " link NODE_OTHERS}
  3.4 @{"Die eingebauten Helden" link NODE_HEROS}


@{u}@{b}@{fg shine}IV. Sonstiges@{ub}@{fg text}@{uu}

  4.1 @{"Ambermoon und -star   " link NODE_AM&AS}
  4.2 @{"Warnungen             " link NODE_WARNINGS}
  4.3 @{"Ausblick              " link NODE_FUTURE}
  4.4 @{"Dank                  " link NODE_CREDITS}
  4.5 @{"Hilfäääh              " link NODE_HELP}
  4.6 @{"Über den Source-Code  " link NODE_SOURCE}

@ENDNODE
///
///"I. Einleitung"
@NODE NODE_INTRO "1.1 Entstehung"

AmberCheat   entstand   nach   einer   frustrierten   Neuinstallation   des
Rollenspielhammers  "Ambermoon"  von  Thalion.  Denn gerade am Anfang eines
neuen Abenteuers, sind die eingebauten Charaktere mehr als schwach.

So machte ich mich dann auf die Suche, in dem Datendschungel die Werte  der
einzelnen Charaktere zu finden.

Es  dauerte sehr lange. Doch in einer stürmischen Nacht entdeckte ich durch
Zufall, das alle Werte doppelt gesichert werden. Einmal kodiert und  einmal
dekodiert.  - Ein ganzes Sonnensystem ging in diesem Augenblick am Horizont
auf.

Nach einer Weile hatte ich das System geschnallt und AmberCheat entstand.

@ENDNODE



@NODE NODE_OVERVIEW "1.2 Überblick"

AmberCheat ist ein Programm, mit dem man in der Lage ist,  die  bestehenden
Charaktere  von  Ambermoon  nach  Belieben zu verändern und das Ergebnis zu
speichern.

Dadurch kann der Benutzer sich viel Zeit und Ärger gerade am  Anfang  eines
neuen Ambermoon Abenteuers sparen. Ist die knifflige oder nervige Situation
erledigt, so setzt man die Werte einfach wieder auf  ihren  Originalzustand
zurück.

AmberCheat hält sich auch nicht lange mit komplizierten  Suchsystemen  oder
einer  komplizierten  Oberfläche  auf.  Mit ein bis zwei Mausklicks hat man
das, was man will: Entweder einen  stärkeren  oder  gar  einen  schwächeren
Charakter.

@ENDNODE


@NODE NODE_SYSTEM "1.3 Systemvoraussetzungen"

Für die alte GadTools-Version:
------------------------------
Da ich die Oberfläche von AmberCheat mit einem (!^="§) GUICreator  erstellt
habe, sind (noch) folgende Dinge erforderlich:

  * AmigaOS 3.0
  * 1MB freier Speicher
  * MC68020 oder höher.
  * Ambermoon installiert auf einer Festplatte!

Ferner  sollte  man  noch  einen  MultiSync  Monitor  wie  den  M1438S  von
AmigaTechnologies  sein  eigen  nennen  und  eine  Auflösung von mindestens
640*400 bei acht Farben gewählt haben. Die Farben können zum  Beispiel  von
MagicWB kommen.


Für die neue MUI-Version:
-------------------------
  * AmigaOS 2.04 oder besser
  * MUI Version 11 oder besser
  * Alles, was MUI so benötigt (Schnelle CPU/100MB RAM/1GB HD/...)
  * Ambermoon auf Festplatte

Da ich jedoch der Meinung bin, daß jeder, der mit dem  Amiga  noch  spielen
will,  eine  Festplatte  besitzt, werde ich auf eine Diskettenunterstützung
verzichten. Die zahlreichen Mails, die  mich  erreichten,  bestätigen  auch
meine Vermutung.

Nun ist es wirklich soweit: Jeder,  der  einen  blanken  A1200  sein  eigen
nennt,  kann  AmberCheat  benutzen. Auch ein hochgezüchteter A500 tut's zur
Not, wenn man OS2.04 oder besser installiert hat.

@ENDNODE


@NODE NODE_INSTALL "1.4 Installation"

Die Installation ist eigentlich einfach:

Nachdem man Ambermoon installiert hat, verschiebt man den kompletten Ordner
"AmberCheat" in dasselbe Verzeichnis.

Folgendes @{"Bild" system "sys:utilities/multiview brs/install.brs"} zeigt wie es aussehen soll.

Danach sollte man Ambermoon starten, sich  einen  Charakter  aussuchen  und
gleich am Anfang beim Opa irgendwo abspeichern.

@ENDNODE

@NODE NODE_RIGHTS "1.5 Rechtliches"

  @{b}Ambermoon@{ub} is copyrighted 1993 by Thalion.
  @{b}MagicWB@{ub} is copyrighted 1995-97 by Martin Huttenloher.
  @{b}MUI@{ub} is copyrighted 1992-97 by Stefan Stuntz
  @{b}MUIBuilder@{ub} is copyrighted 1995 by Eric Totel
  @{b}NoAGA@{ub} is copyrighted 1994 by Uwe Schilling
  @{b}AmberCheat@{ub} is copyrighted 1996/97 by Wanja Pernath.

AmberCheat  ist  FreeWare.  Alle  Rechte  liegen  weiterhin  beim   Author.
AmberCheat  darf  über die bestehenden Netze und über sogenannte CoverDisks
frei verteilt werden, solange  das  gesamte  Paket  mit  Dokumentation  und
Source mitgeliefert wird.

Der mitgelieferte Source zu AmberCheat (AC) dient zur Demonstration und  zu
Lernzwecken.  Ich  möchte  nicht,  daß  irgendjemand auf die Idee kommt, AC
aufgrund  meiner  Arbeit  zu  verändern  und   als   ShareWare   oder   als
kommerzielles Paket zu verkaufen.

Wenn jemand AC verbessern will, so steht es ihm frei, es zu tun,  doch  muß
der  FreeWare-Status erhalten bleiben und der Source weiterhin mitgeliefert
werden.

@ENDNODE

@NODE NODE_MUI "1.6 Über MUI"

                          This application uses


                        MUI - MagicUserInterface

                (c) Copyright 1992-97 by Stefan Stuntz


MUI is a system to generate and maintain graphical user interfaces. With
the  aid  of  a  preferences program, the user of an application has the
ability to customize the outfit according to his personal taste.

MUI is distributed as shareware. To obtain a complete package containing
lots of examples and more information about registration please look for
a  file  called  "muiXXusr.lha"  (XX means the latest version number) on
your local bulletin boards or on public domain disks.

          If you want to register directly, feel free to send


                         DM 30.-  or  US$ 20.-

                                  to

                             Stefan Stuntz
                        Eduard-Spranger-Straße 7
                             80935 München
                                GERMANY



             Support and online registration is available at

                          http://www.sasg.com/

@ENDNODE

@NODE NODE_AUTOR "1.7 Der Author"

                  Geschrieben wurde dieses Programm von:
                                   @{b}
                               Wanja Pernath
                               Joergstr. 74
                              D-80689 München

                            Tel.: 089/54662171

                                  email:
                    pernathw@stud.fak11.uni-muenchen.de
                      pernathw@cip.ub.uni-muenchen.de
                                   @{ub}

                  Mein Amiga 1200 besteht aus folgendem:

                            Tower von Micronik
          Blizzard A1230IV 50MHz MC68030, 4MB FastRam von Phase 5
          640MB Festplatte am internen IDE-Controller von Conner
                   4-Fach CD-Rom Laufwerk mit CacheCDFS

                             Aufgerüstet mit:
         Blizzard A1240/TEC 40MHz MC68040, 8MB FastRam von Phase 5
                   12-Fach CD_Rom Laufwerk mit CacheCDFS
                 20MB VMM-Speicher auf eigener Partition.

@ENDNODE
///
///"II. Programmbeschreibung"
@NODE NODE_CONCEPT "2.1 Das Programmkonzept"

Nach  erfolgreicher   Installation   und   einmaligem   Abspeichern   eines
Spielstands aus Ambermoon, kann man AmberCheat starten.

Folgende @{"Oberfläche" system "sys:utilities/multiview brs/gui.brs"} bietet sich einem.

Die MUI-Version sieht etwas aufgeräumter aus @{" " system "sys:utilities/multiview brs/mui.brs"}

Die Zahlen in dem Bild bedeuten Gruppierungen, die hier  genauer  erläutert
werden.

  1) Mit diesem Schalter werden die einzelnen Charaktere @{"gewählt" link NODE_ACTCHAR}.
  2) Hier stehen die @{"Attribute" link NODE_ATTRS}, die @{"Fähigkeiten" link NODE_FAEH} und @{"andere Interessante" link NODE_OTHERS}
     Dinge über den Charakter.
  3) Mit den zwei Schaltern kann man a) Veränderungen @{"rückgängig machen" link NODE_ORIGINAL}
     und b) alle Werte per @{"Zufall" link NODE_RANDOM} generieren lassen.
  4) Mit den zwei Schaltern kann man a) alle Veränderungen @{"speichern" link NODE_SAVE} und
     b) das Programm @{"verlassen" link NODE_QUIT}.

@ENDNODE

@NODE NODE_MAIN "2.2 Die Bedienung"

AmberCheat kann nahezu vollständig über die Maus gesteuert werden,  da  die
Oberfläche sich nur aus Schaltern und Eingabefeldern zusammensetzt.

Im folgenden werden die einzelnen Bedienungselemente erläutert:

  2.2.1 @{"Die Charakterauswahl" link NODE_ACTCHAR}
  2.2.2 @{"Eingeben und Verändern von Werten" link NODE_INPUT}
  2.2.3 @{"Schalter für den gesamten Bogen" link NODE_ALLCHAR}
  2.2.4 @{"Sichern und Beenden" link NODE_SAVEQUIT}

@ENDNODE

@NODE NODE_ACTCHAR "2.2.1 Die Charakterauswahl"

Mit diesem Schalter kann man einen der insgesamt 15 zur  @{"Auswahl" link NODE_HEROS}  stehenden
Charaktere  auswählen.  Alle  Veränderungen  beziehen  sich  nur auf diesen
Charakter.

Klickt man mit der  Maus  auf  den  Schalter,  so  wird  der  nächste  Held
hervorgebracht, hält man währenddessen noch eine SHIFT-Taste gedrückt, wird
der vorherige ausgewählt.

@ENDNODE

@NODE NODE_INPUT "2.2.2 Eingeben und Verändern von Werten"

Will man gezielt einen oder mehrere Werte aus den Kapiteln @{"Attribute" link NODE_ATTRS},
@{"Fähigkeiten" link NODE_FAEH} oder @{"Andere" link NODE_OTHERS} ändern, so klickt man mit der Maus auf das
gewünschte Feld und nimmt die Veränderungen vor.

Stehen neben dem Attributsnamen zwei Eingabefelder, so ist das erste stehts
der  vorhandene  Wert  und  das  zweite  der  maximale  Wert.  Beide können
verändert werden.

@{i}Beispiel: Man will die Stärke des Charakters ändern.@{ui}

In der Gruppe @{"Attribute" link NODE_ATTRS} findet man den Wert "STÄ" gefolgt von zwei Eingabe-
feldern, die den vorhandenen und den maximalen Wert angeben (z.B.:  25/50).
Nun  klickt man mit der Maus auf das erste Feld (mit der "25") und gibt den
gewünschten Neuen ein. Anschließend drückt man auf  die  Eingabetaste.  Der
Wert wird aufgenommen.

@{b}@{u}@{fg filltext}Achtung!@{ub}@{fg fill}@{uu}@{i}
Es wird nicht geprüft, ob der aktuelle Wert kleiner oder gleich dem maximal
Wert  ist.  Das  sollte  vom  Nutzer  beachtet  werden,  da sonst Ambermoon
verwirrt werden könnte!
@{fg text}@{ui}

Sobald man die Eingabe bestätigt hat, wird der Schalter @{"Originale Werte" link NODE_ORIGINAL}
aktiviert, mit dem man die Eingaben rückgängig machen kann.

@ENDNODE

@NODE NODE_ALLCHAR "2.2.3 Schalter für den gesamten Bogen"

Diese Schalter beziehen sich auf den gesamten Charakterbogen des  aktuellen
Helden.

Mit @{"Originale Werte" link NODE_ORIGINAL} kann man, falls man schon Werte verändert hat, diese
rückgängig machen und mit @{"Zufall" link NODE_RANDOM} werden die Werte aus @{"Attribute" link NODE_ATTRS} und
@{"Fähigkeiten" link NODE_FAEH} per Zufall gewählt.

@ENDNODE

@NODE NODE_ORIGINAL "2.2.3.1 Der Schalter Originale Werte"

Sobald man irgendein Wert geändert hat, wird dieser Schalter aktiviert. Man
kann nun alle Eingaben rückgängig machen.

@{b}@{u}@{fg filltext}Achtung!@{ub}@{fg fill}@{uu}@{i}
Das geht nur solange, wie dieser Charakter angezeigt wird. Wählt man  einen
neuen  Charakter,  so  sind die Einstellungen intern gespeichert und werden
beim Verlassen von AmberCheat mit "Sichern" auch für  Ambermoon  zugänglich
gemacht.  Man  sollte  also  immer  nur  einen Charakter ändern. Ist dieser
Verändert, so kann man sich den nächsten vornehmen.
@{fg text}@{ui}

@ENDNODE

@NODE NODE_RANDOM "2.2.3.2 Der Schalter Zufall"

Will man sich einen gänzlich neuen Charakter entwerfen, so klickt  man  auf
diesen Schalter.

Es   werden  alle  Attribute  und  Fähigkeiten  nach  einem  Zufallsprinzip
ausgewürfelt. Als maximaler Wert gilt jeweils der zweite Wert.

@ENDNODE

@NODE NODE_SAVEQUIT "2.2.4 Sichern und Beenden"

Mit  diesen  Schaltern  kann  man  sich  entscheiden,  wie  man  AmberCheat
verlassen will.
Entweder @{"sichert" link NODE_SAVE} man alle Veränderungen oder man @{"bricht einfach ab" link NODE_QUIT}.

@ENDNODE

@NODE NODE_SAVE "2.2.4.1 Sichern der Änderungen"

Hat man erst mal alle Veränderungen nach seinen Wünschen gemacht, so sollte
man sein Werk verewigen.

AmberCheat  findet  selbstständig  heraus,  welcher  Spielstand vom Spieler
benutzt wurde und sichert dort die neuen Einstellungen.

AmberCheat beendet sich daraufhin.

Nun kann man Ambermoon starten und im Auswahlmenü einfach auf Weiterspielen
klicken. Die neuen Einstellungen werden übernommen.

@ENDNODE

@NODE NODE_QUIT "2.2.4.2 Abbrechen von AmberCheat"

Mit  diesem  Schalter  beendet  sich  AmberCheat  und  alle  Eingaben  sind
verloren. Zu diesem Zweck erscheint eine Sicherheitsabfrage, die man zuerst
mit "JA" beantworten muß.

@ENDNODE

@NODE NODE_MENU "2.3 Das Menü von AmberCheat"

Ab Version 1.1 (also NUR in der MUI-Version) gibt es funktionierende  Menüs
in  AC,  die  die Bedienung und auch die Generierung vereinfachen. Folgende
Menüs sind vorhanden:

  2.3.1 @{"Über MUI" link NODE_MUI }
  2.3.2 @{"Über AmberCheat" link NODE_ABOUT }
  2.3.3 @{"Informationen" link node_inforeq}

@ENDNODE
  2.3.1 @{"Lade Original" link node_orig}
  2.3.2 @{"Undo ungültig" link node_dropundo}
  2.3.4 @{"Sichere temporär" link node_savetmp}

@NODE node_orig "2.3.1 Menü: Lade Original"

Eine der wesentlichen Neuerungen in der MUI-Version von AC ist, daß AC nach
dem Erststart eine Backup der originalen Datei anlegt, so daß man ruhig mal
übertreiben kann, beim Erstellen der Charaktere.  Der  Menüpunkt  lädt  nun
diese originale Datei.

@{b}@{u}@{fg filltext}Achtung!@{ub}@{fg fill}@{uu}@{i}
Dadurch daß diese Datei beim Erststart von AC  kreiert  wird,  sollte  man,
nachdem   man   wesentlich  weiter  gekommen  ist  (also  Charaktere  einen
Stufenanstieg hatten etc.), darauf achten, daß man diese Datei für ungültig
erklärt.  Vergißt  man  es,  so  kann  es  durchaus  vorkommen,  daß einige
neuerworbene Dinge fehlen.
@{fg text}@{ui}

@ENDNODE

@NODE node_dropundo "2.3.2 Menü: Undo ungültig"

Wie schon  unter  @{"2.3.1" link node_orig}  erwähnt, sollte  irgendwann  einmal  der  globale
Undo-Puffer  für  ungültig  erklärt  werden.  Dieser Menüpunkt erledigt die
Arbeit, indem es die Datei bpt/backup.bpt  löscht  und  mit  der  aktuellen
Spielstandsdatei überschreibt.


@ENDNODE

@NODE node_savetmp "2.3.4 Menü: Sichere temporär"

Dieser Menüpunkt sollte es in einer späteren Version von AC möglich machen,
einzelne  Charakterbögen zu sichern und im Verlauf der Charaktergenerierung
anzuhängen.

Im Klartext verstehe ich darunter, daß man jeden einzelnen Charakter  unter
seinem Namen sichern, verändern und später wieder laden kann. Damit soll es
in Zukunft möglich sein, seine ganz eigenen, ganz  privaten  Charaktere  zu
erzeugen, mit denen man Ambermoon lösen kann.

Klingt gut, nicht wahr? - Hat  aber  leider  den  Nachteil,  daß  ich  noch
nirgendwo  den  Vermerk  über  die  Art des angezeigten Charakters gefunden
habe.  Dadurch  ist  es  leider  nicht  möglich,  z.B.  aus  NETSRAK  einen
Abenteurer zu machen.

Wie auch immer, dieser Menüpunkt ist noch nicht aktivierbar.

Schreibt mir doch einfach, was ihr von dieser Idee haltet.

@ENDNODE

@NODE node_inforeq "2.3.5 Menü: Informationen"

Wählt man diesen Menüpunkt an, so werden folgende  Informationen  in  einem
Requester ausgegeben:

  + Speicherslot des aktuellen Spielstands
  + Name des aktuellen Spielstands
  + Name des Charakter-Slots
  + Nummer des Slots
  + Neuer Name des Charakters.
  + Die Klasse des Charakters (Abenteurer/Magier/...)
  + Die Stufe des Charakters

Im Moment überlege ich gerade, wie man  die  Stufe  im  Register  <Anderes>
sichtbar  machen  und  vielleicht sogar über EP editierbar machen kann. Das
ist jedoch nicht ganz so einfach, wie es klingt,  da  die  Erfahrungspunkte
eines Charakters schön versteckt sind...

@ENDNODE

///
///"III. Über die Charaktere"

@NODE NODE_ATTRS "3.1 Die Attribute eines Charakters"

  @{fg shine}Folgende Attribute gehören zu jedem Charakter:@{fg text}

@{b}Stärke@{ub}:           Beeinflußt das Höchstgewicht des Gepäcks
@{b}Intelligenz@{ub}:      Beeinflußt die Lernfähigkeit
@{b}Geschicklichkeit@{ub}: Beeinflußt das Öffnen von Schlössern und das
                           Finden von Fallen.
@{b}Schnelligkeit@{ub}:    Wann kommt dieser Charakter im Kampf zum Zug?
@{b}Konstitution@{ub}:     Was kann ein Charakter an Schädigung aushalten?
@{b}Charisma@{ub}:         Beeinflußt das Verhalten von Händlern
@{b}Glück@{ub}:            Mit was für einer Wahrscheinlichkeit kommt man
                           heile aus einer Falle?
@{b}Anti-Magie@{ub}:       Widerstandskraft gegen magische Angriffe.

@ENDNODE

@NODE NODE_FAEH "3.2 Die Fähigkeiten eines Charakters"

  @{fg shine}Folgende Fähigkeiten beschreiben den Charakter:@{fg text}

@{b}Attacke@{ub}:            Treffer im Kampf
@{b}Parade@{ub}:             Erfolgreiche Abwehr im Kampf
@{b}Schwimmen@{ub}:          Welcher Schaden entsteht beim Schwimmen
@{b}Kritische Treffer@{ub}:  Wahrscheinlichkeit eines tödlichen Treffers
@{b}Fallen finden@{ub}:      Finden von Fallen
@{b}Fallen entschäfen@{ub}:  Entschäfen von Fallen
@{b}Schlösser knacken@{ub}:  Schlösser ohne Dietrich öffnen
@{b}Suchen@{ub}:             Versteckte Schätze finden
@{b}Spruchrollen lesen@{ub}: Erlernen von magischen Sprüchen
@{b}Magie benutzen@{ub}:     Anwendung eines magischen Spruchs

@ENDNODE

@NODE NODE_OTHERS "3.3 Andere Besonderheiten eines Charakters"

  @{fg shine}Folgende andere Dinge machen den Helden aus:@{fg text}

@{b}Lebenspunkte@{ub}:     Wie gesund ist der Charakter
@{b}Spruchpunkte@{ub}:     Wieviel magische Energie hat der Charakter noch
@{b}Trainingspunkte@{ub}:  Wieoft kann man diesen Charakter noch trainieren
@{b}Spruchlernpunkte@{ub}: Wieviele Sprüche kann dieser Charakter noch lernen
@{b}Erfahrungspunkte@{ub}: Wie groß ist die Erfahrung des Charakters
@{b}Gold@{ub}:             Wieviel Gold trägt dieser Charakter mit sich.

@{b}@{u}@{fg filltext}Achtung!@{ub}@{fg fill}@{uu}@{i}
Für Gold darf man keinen zu  großen  Wert  wählen,  da  Gold  ja  auch  ein
gewisses  Gewicht  hat.  Ansonsten kann man sich nicht mehr bewegen und man
muß das Gold wieder wegwerfen.
@{fg text}@{ui}

Bei der neuen MUI-Version habe ich auch gleich  noch  eine  kleine  Verbesserung
eingeführt: Man kann die Namen eines jeden Charakters ändern!

@ENDNODE

@NODE NODE_HEROS "3.4 Die eingebauten Helden und wo man sie findet"

Im Folgenden  findet  man  eine  Liste  der  Helden,  die  man  als  aktive
Charaktere benutzen kann.

  3.4.1  @{"NETSRAK       " link NETSRAK}
  3.4.2  @{"MANDO         " link MANDO}
  3.4.3  @{"ERIK          " link ERIK}
  3.4.4  @{"CHRIS         " link CHRIS}
  3.4.5  @{"MONIKA        " link MONIKA}
  3.4.6  @{"TAR DER DUNKLE" link TAR}
  3.4.7  @{"EGIL          " link EGIL}
  3.4.8  @{"SELENA        " link SELENA}
  3.4.9  @{"NELVIN        " link NELVIN}
  3.4.10 @{"SABINE        " link SABINE}
  3.4.11 @{"VALDYN        " link VALDYN}
  3.4.12 @{"TARGOR        " link TARGOR}
  3.4.13 @{"LEONARIA      " link LEONARIA}
  3.4.14 @{"GRYBAN        " link GRYBAN}

@ENDNODE

@NODE NETSRAK "3.4.1 NETSRAK"

NETSRAK ist ein Schwarzmagier der 50sten Stufe mit 300 LP und  800  SP.  Er
ist  nahezu  unfehlbar,  was daran liegt, das er von den Programmierern zum
Testen eingesetzt wurde.

Man findet ihn zusammen mit MANDO, ERIK, CHRIS und MONIKA in  dem  geheimen
Raum in Spannenberg.

Um dorthin zu gelangen, braucht man NETSRAK´s Zauberstab aus dem Geheimraum
in Großvater´s Haus (linker Kamin im Wohnzimmer).

Den benutzt man an der  Stelle  in  Spannenberg,  wo  ein  Schild  mit  der
Aufschrift @{u}"Karsten war hier"@{uu} zu lesen ist. (Im Nordosten der Stadt.)

@ENDNODE
@NODE MANDO "3.4.2 MANDO"

MANDO ist ein Dieb der  50sten  Stufe  mit  400  LP.  Auch  er  ist  nahezu
unfehlbar. Zu finden ist er wie NETSRAK.
@ENDNODE
@NODE ERIK "3.4.3 ERIK"

ERIK ist ein Krieger der 50sten Stufe mit 800 LP. Zu finden wie NETSRAK.
@ENDNODE
@NODE CHRIS "3.4.4 CHRIS"

CHRIS ist ein Alchemist der 50sten Stufe mit 300 LP und 800 SP.  Zu  finden
wie NETSRAK.
@ENDNODE
@NODE MONIKA "3.4.5 MONIKA"

MONIKA ist die Heilerin der 50sten Stufe mit 300 LP und 800 SP.  Zu  finden
wie NETSRAK.
@ENDNODE
@NODE TAR "3.4.6 TAR DER DUNKLE"

TAR DER DUNKLE ist ein Schwarzmagier der 35sten Stufe mit 210  LP  und  560
SP. Wo man ihn findet weiß ich noch nicht.
@ENDNODE

@NODE EGIL "3.4.7 EGIL"

EGIL ist der Krieger den man in seine Party mit aufnehmen muß.  Man  findet
ihn beim Trainer in Spannenberg.
@ENDNODE

@NODE SELENA "3.4.8 SELENA"

SELENA ist eine Diebin, die man nicht unbedingt aufnehmen sollte, da sie zu
schwach ist. Man findet sie, nachdem man die Orkhöle ausgeräuchert hat.
@ENDNODE

@NODE NELVIN "3.4.9 NELVIN"

NELVIN ist der Magier, den man in seine Party  mit  aufnehmen  sollte.  Man
findet ihn zusammen mit der Spähre der Öffnung im Turm des Alchimisten.
@ENDNODE

@NODE SABINE "3.4.10 SABINE"

SABINE ist die Heilerin, die man in seine Party mit aufnehmen  sollte.  Man
findet  sie  auf  dem  Weg  durch  LUMINOR´s  Turm  bei  den Gefangenen aus
Burnville.
@ENDNODE

@NODE VALDYN "3.4.11 VALDYN"

Auch VALDYN, den Ranger, findet man in LUMINOR´s  Turm  im  vierten  Stock,
nachdem man ein Licht berührt hat.
@ENDNODE

@NODE TARGOR "3.4.12 TARGOR"

Auch wo man TARGOR finden kann, habe ich leider noch nicht herausgefunden.

@ENDNODE

@NODE LEONARIA "3.4.13 LEONARIA"

LEONARIA ist eine Mystikerin der 25sten Stufe mit 150 LP und  440  SP.  Man
sollte sie unbedingt in seine Party mit aufnehmen, da sie sehr mächtig ist.
Zu finden ist sie in ILLIEN, der Stadt der Elfen und zwar in  der  dortigen
Taverne.
@ENDNODE

@NODE GRYBAN "3.4.14 GRYBAN"

GRYBAN ist ein Paladin der 35sten Stufe mit 490 LP und 210 SP. Wenn man ihn
gefunden  hat,  unbedingt aufnehmen. Man findet ihn irgendwo in der Festung
Godsbane, wo er auf Euch wartet.
@ENDNODE

///
///"IV. Sonstiges"

@NODE NODE_AM&AS "4.1 Starten von Ambermoon und -star auf neuen Systemen"

Nachdem ich die Mails gelesen  habe,  stellte  ich  fest,  daß  viele  User
Probleme   mit   dem  Starten  von  Ambermoon  und  Amberstar  auf  neueren
AGA-Systemen hatten und mich fragten, wie ich darauf  käme,  Amberstar  zum
Laufen zu bewegen. Nun, so ganz einfach ist es leider nicht. Es geht aber.

Die folgenden  Tips  beziehen  sich  allerdings  nur  auf  die  angegebenen
Versionen.   Ich   habe   keine  Ahnung,  ob  es  auf  kleineren  Versionen
funktioniert.

@{"4.1.1 Amberstar V1.43" link strt_as}
@{"4.1.2 Ambermoon V1.05 vom 06.12.93" link strt_am}

Ich konnte es selber gar nicht glauben, aber beide  Teile  laufen  bei  mir
sogar  mit  einer  040-CPU  UND mit virtuellem Speicher (den man allerdings
abschalten sollte, nicht daß irgendetwas unvorhergesehenes passiert).

@ENDNODE

@NODE strt_as "4.1.1 Starten von AmberStar V1.43"

Für Amberstar ist es "lebensnotwendig" auf dem alten ChipSet zu laufen, und
keinerlei "Cache" zu haben. Also werden wir ihm vorgaukeln, es handelt sich
hierbei um eine (ur-)alte Maschine.

Generell sollte man den Amiga ohne startup-sequence hochfahren  lassen.  Im
Boot-Menü  muß  außerdem  unter  <DISPLAY>  das Orignal Chip-Set ausgewählt
werden.

Wenn man dann auf Commandozeilen-Ebene angelangt ist, wechselt man in das
Verzeichnis, in dem Amberstar verweilt und tippt daraufhin folgendes ein:

 <execute Amberstar>

Und Amberstar sollte laufen.

Da <Amberstar> ein Skript ist, das ungefähr wie @{"hier" link bat/as.bat/main} gezeigt wird,
aufgebaut ist, kann man allerdings auch anders verfahren:

Man hole sich aus dem Aminet oder aus dem Tools-Verzeichnis einer Aminet-CD
das Programm <NoAGA> von Uwe Schilling und verändere das Skript so:

  Assigns
  ....
  CPU nocache noburst nocopyback  <-- Diese Zeilen sind die entscheidenden,
  noaga -d Amberstart             <-- da hier Caches und aga-set ausgeschaltet
                                      werden.
  ....

Danach kann man Amberstar sogar von der Workbench  aus  starten  und  spart
sich somit das hochfahren ohne Startup-Sequence.

@ENDNODE

@NODE strt_am "4.1.2 Starten von AmberMoon V1.05"

Auch für Ambermoon ist es wichtig, unter  dem  alten  Chip-Set  zu  laufen.
Jedoch kann man hierbei auf das Ausschalten der CPU-Caches verzichten.

Also entweder im CLI

  <noaga -c -d Ambermoon>

eingeben, oder ohne Startup-Sequence hochfahren  und  vorher  im  Boot-Menü
unter <DISPLAY> das ECS Chip-Set einstellen.

Danach sollte alles klappen.

@ENDNODE

@NODE NODE_WARNINGS "4.2 Warnungen"

@{b}@{u}@{fg filltext}Achtung! Achtung! Achtung! Achtung! Achtung! Achtung! Achtung! Achtung! Ach@{ub}@{fg fill}@{uu}@{i}

AmberCheat ist ein Programm mit dem man sich jeden Spielspaß  an  Ambermoon
nehmen kann. Dadurch, daß man hartnäckige Situationen dadurch umgehen kann,
daß  man  seine  Helden  kurzzeitig  verbessert,  kann  schnell  Langeweile
aufkommen.
Dennoch finde ich, hat AmberCheat seine Berechtigung. Denn wer möchte schon
immer  dieselben  Charaktere  verwenden?  Wer  hat  nicht  schon  von einem
Charaktergenerator für Ambermoon geträumt und  immer  wieder  auf  Ambersun
gehofft, wo man das vielleicht eingebaut hätte?

Seid gewarnt und benutzt AmberCheat weise...

@{ui}@{b}@{u}@{fg filltext}tung! Achtung! Achtung! Achtung! Achtung! Achtung! Achtung! Achtung! Achtun@{ub}@{uu}
@{fg text}

@ENDNODE

@NODE NODE_FUTURE "4.3 Ausblick"

Aufgrund eines kleinen und  ziemlich  unsympathischen  Stromausfalls,  der
meinen Amiga lahm gelegt hatte und die Festplatte zum Platzen brachte, war
ich leider nicht mehr in der Lage, den alten Source von AC zu retten.  Und
nachdem  ich  jetzt  zum ersten Mal eine GUI über MUI entworfen habe, habe
ich eigentlich auch keine allzu große Lust,  eine  überarbeitete  GadTools
Oberfläche zu entwerfen...

Wenn allerdings da  draußen  irgendwo  ein  jemand  ist,  der  meint,  ohne
GadTools  nicht mehr leben zu können, dann will ich mal nicht so sein. Denn
im Prinzip ist es nicht sooo schwer das ganze auf gadtools umzusetzen.

Aber wozu liefere ich denn den Source mit,  wenn  da  nicht  irgend  jemand
selbst Verbesserungen einbauen könnte?

An einer Version, die außerdem noch AmberStar unterstützt  wird  im  Moment
gerade  fieberhaft  gearbeitet...  Naja,  -  nun -, ich überlege mir gerade
fieberhaft, wie ich das bewerkstelligen könnte.  Denn  alle  Aufzeichnungen
sind  futsch!  Und es ist ja doch schon ein ganzes Jahr her, seitdem ich AC
erstellt habe.

Meldet Euch also wieder und schreibt mir all eure Wünsche, im Bezug auf AC.

Für das nächste release habe ich mir u.A. noch einiges einfallen lassen:

  o Charaktere einzeln abspeichern und später in Liste aufnehmen.

@ENDNODE

@NODE NODE_CREDITS "4.4 Dank"

Mein Dank gebührt vor allem der leider bankrotten Firma Thalion für  derart
geniale Spiele wie Amberstar oder Ambermoon.

Ich hoffe, daß es noch den dritten Teil der Saga geben wird (für den AMIGA).
Auch wenn es diese Firma nicht mehr gibt, der Dank gebührt ihnen.

Auf jeden Fall möchte ich mich bei allen  Leuten  bedanken,  die  mir  eine
email  geschickt  haben.  Ich  hatte  lange  keinen  so großen Spaß mehr im
Computerraum der UNI, wie an dem Abend vor vier  Tagen,  als  ich  all  die
ganzen  mails  gelesen  habe. Danke auch für die vielen Vorschläge, und wie
ihr sehen könnt, war ich in diesen vier Tagen ja auch ganz schön aktiv: Ich
habe AC auf MUI umgesetzt, habe mich mit MUIBuilder 'rumgeschlagen, bis ich
endlich herausgefunden habe, daß nicht das Programm der Dumme ist,  sondern
eher ich und habe MUI kennen und schätzen gelernt (als Programmierer).

Ansonsten bedanke ich mich noch bei: - Martin Huttenloher für MagicWB,
                                     - Stefan Stunz für MUI
                                     - Dietmar Eilert für GoldED
                                     - R. E. Spence für das Icon von AC
                                     - Nicola Salmoria für das NewIcon-Set
                                     - Eric Totel für seinen famosen MUIBuilder
                                     - Den Leuten, die das GNU/C-Projekt auf
                                       dem Amiga am Leben erhalten. Wenn man
                                       erst mal über genug Speicher und
                                       Schnelligkeit verfügt, ist es wirklich
                                       einer der besten compiler den es gibt.

@ENDNODE

@NODE NODE_HELP "4.5 Ich brauche Hilfe..."

I would do anything for HELP, but I won't do that... (M. Loaf - Bat out of Hell II)

Nachdem ich die Mails gelesen hatte, fiel mir urplötzlich auf, daß man über
das  Aminet  ja  recht  viele  Leute ereichen kann... Leute, die vielleicht
einige Probleme schon mal auf irgendeine Art und Weise gelöst haben. Leute,
die  auch  Lust  haben,  über  diese  Lösungen  zu  reden.  Leute,  die soo
wahnsinnig lieb sind, mir ihre Lösungen für die Probleme zu mailen.
Leute...

Lange Rede, kurzer Sinn: Gibt es eine Magier-Gilde in  Lyramion?  Und  wenn
                         ja, wo befindet sie sich?

Ich habe schon alles versucht. Alles. Doch nichts hat geklappt.

Also bittebittebittebittebittebitte  meldet  euch  und  sagt  es  mir!  Zur
Belohnung werde ich auch "irgendwelche Extra-Dinge" in Ambercheat einbauen.

@ENDNODE

@NODE NODE_SOURCE "4.6 Etwas über den mitgelieferten Quelltext"

Gleich erstmal vorweg: Der Sourcecode wurde mitgeliefert, um Euch als  User
und  angehende  Programmierer zu inspirieren. Ich habe selbst Programmieren
nur dadurch gelernt, daß ich alle  Quelltexte,  denen  ich  habhaft  werden
konnte,  auf  Herz  und  Nieren  durchleuchtete.  Ich  finde  es blöd, wenn
irgendwelche Autoren mit ihren Quelltexten zu  irgendwelchen  PD-Programmen
nicht  rausrücken  wollen,  da  ich  meine,  daß  jeder  Programmierer  auf
irgendeine  Art  und  Weise  genial  ist,  und   seine   Genialität   nicht
geheimhalten  sollte  wie irgend ein Top-Secret-Agent, sondern Andere daran
teilhaben lassen  sollte.  (Das  bedeutet  nicht,  daß  man  damit  angeben
sollte...)

Jedenfalls liefere ich diesen  Quelltext  mit,  um  zu  demonstrieren,  daß
MUI-Applikationen  relativ einfach zu erstellen sind. Ich selbst habe lange
Zeit gebraucht, das herauszufinden (um genau zu  sein,  brauchte  ich  fünf
lange Jahre dazu...)

Dieser Source zeigt also, wie es einfacher funktioniert.  Und  seitdem  ich
diese  Einfachheit  kenne,  wundere  ich  mich,  warum ich nicht schon viel
früher auf diese Idee gekommen bin...

Der  Quelltext  müßte  eigentlich  mit  jedem  handelsüblichen   C-Compiler
übersetzt  werden  können.  Ein  paar  Kleinigkeiten  hier  und  da sollten
eigentlich ausreichen...

hookfunk.s  und  das  Makefile  sind  jedoch  GNU/C-speziell.  Die   müssen
ausgetauscht werden.

Nun, lange Rede,  kurzer  Sinn,  hier  also  eine  kurze  Beschreibung  des
Quelltexts:

  4.6.1 @{"..._main.c" link ac_main }  Die Funktion, die alles weitere erledigt.
  4.6.2 @{"..._req.c " link ac_req  }  Kurzversionen eines MUI-Requesters
  4.6.3 @{"..._gui.c " link ac_gui  }  Die graphische Benutzeroberfläche (GUI)
  4.6.4 @{"..._proc.c" link ac_proc }  Interaktive Proceduren zur GUI
  4.6.5 @{"..._ac.c  " link ac_ac   }  AmberCheat-Relevante Funktionen
  4.6.6 @{"hookfunk.s" link ac_hooks}  Zwei sog. Hook-Stubs für GNU/C
  4.6.7 @{"Makefile  " link ac_make }  Sog. Makefile für GNU/C, das alles erledigt
  4.6.8 @{"GNU/C     " link ac_gnu  }  Von einigen verteufelt, von anderen geliebt.

@ENDNODE

@node ac_main "4.6.1 AmberCheat_main.c"

Hier findet eigentlich alles statt, was für den Start einer MUI-Applikation
notwendig ist.

  - Definition aller öffentlichen Variablen
  - Öffnen der MUI-Library (muimaster.library)
  - Öffnen des Ambermoon-Spielstands
  - Aufbauen der GUI
  - Warten auf ein Ereignis, das zum beenden von AmberCheat führt
  - und anschließendes Freigeben aller angeforderten Resourcen (Fenster/...)

@{"Anschauen..." link source/mui/AmberCheat_main.c/main }
@endnode
@node ac_req "4.6.2 AmberCheat_req.c"

Hier werden einige Funktionen definiert, die im Umgang mit MUIApplikationen
sinnvoll  sind.  Im Prinzip sind diese nur zum leicheren Erreichen von sog.
Requestern notwendig.

  - int request() Aufforderung an den User mit zwei Wahlmöglichkeiten
  - void requestNA() Aufforderung mit keiner Wahlmöglichkeit
  - int Requester() Aufforderung mit variabler Wahlmöglichkeit

@{"Anschauen..." link source/mui/AmberCheat_req.c/main }
@endnode
@node ac_gui "4.6.3 AmberCheat_gui.c"

Hier werden genau zwei Proceduren definiert:

  - CreateApp() zum Aufbauen der MUI-Applikation
  - DisposeApp() zum Freigeben aller MUI-Resourcen

@{"Anschauen..." link source/mui/AmberCheat_gui.c/main }
@endnode
@node ac_proc "4.6.4 AmberCheat_proc.c"

Die Funktionen, die hier  definiert  werden,  sind  nötig,  um  die  vielen
Schalter  von  AC mit dem Inhalt des Save-Files zu füllen. Auch werden hier
die sog. Hook-Funktionen definiert.

Wenn zum Beispiel der User einen neuen  Charakter  auswählt,  so  wird  die
Funktion  <ChangeCharacter()> aufgerufen, die den Inhalt der Gadgets in das
Save-File zurückschreibt und umgekehrt die  neuen  Werte  in  die  Schalter
einträgt.

  - CopyContents2Var() kopiert den Inhalt der Gadgets in den Charakterbogen
  - CopyVarContents()  kopiert den Charakterbogen in globale Variablen
  - UpdateGadgets()    kopiert die globalen Variablen in die Gadgets
  - DoUndo()           Macht zuletzt eingegebene Werte rückgängig
  - CreateCharacter()  Würfelt Attribute und Eigenschaften aus.
  - SaveCharacters()   Bereitet das Hauptprogramm vor, die Daten zu sichern
  - InfoReq()          Gibt viele Informationen über die Charaktere aus
  - ChangeCharakter()  Nachdem ein neuer Held ausgewählt worden ist.

@{"Anschauen..." link source/mui/AmberCheat_proc.c/main }
@endnode
@node ac_ac "4.6.5 AmberCheat_ac.c"

Dieses Modul ist wohl das interessanteste von allen, da hier alle möglichen
und  unmöglichen  Dinge definiert werden, um AC mit Ambermoon kommunizieren
zu lassen.

  - GetPartyLen()     Gibt die größe des Charakterbogens zurück
  - CloseAmberSaves() Schließt AC und sichert die Änderungen wenn gewünscht
  - OpenAmberSaves()  Öffnet die richtige Spielstandsdatei und liest Daten aus
  - GetActiveChar()   Macht den aktiven Charakter aktiv...
  - SetCYNames()      Kopiert die gesicherten Namen in die Liste der anwählbaren
  - CreateAmberCheat() Funktion, die vom Hauptprogramm aufgerufen wird und sich um
                       alles kümmert.
  - DisposeAC()       Dasselbe wie CloseAmberSaves( FALSE )
  - UpdateContents()  Wenn AC gestartet wird und alle Daten gelesen werden konnten,
                      dann müssen diese sichtbar gemacht werden.

@{"Anschauen..." link source/mui/AmberCheat_ac.c/main }
@endnode
@node ac_hooks "4.6.6 hookfunk.s"

Die sog. Hooks sind kleine Funktionen, die automatisch  von  den  Schaltern
aufgerufen  werden,  wenn  diese  betätigt  wurden.  Eine  schöne Sache für
Programmierer, da sie sich viel Zeit und Aufwand sparen. Nur leider gibt es
einen  Nachteil:  Dieser  Funktion  werden  Parameter  in den CPU-Registern
übergeben, die nicht jede (eigentlich keine) Hochsprache verarbeiten  kann.
Um  das  zu  ändern, wurden sog. Hook-Stubs eingeführt, die der Hochsprache
die Parameter vorkaut.

Hook-Stubs sind in Assembler geschrieben, damit sie möglichst  schnell  und
universell einsetzbar sind. Doch gibt es auch hierbei einen Nachteil: Diese
Routine ist GNU/C speziell.

GNU/C möchte  auf  jedem  Rechner  einsatzbereit  sein.  Und  um  sich  den
Programmieraufwand   für   verschiedene  Assembler  zu  sparen,  wurde  für
MC68000-Maschinen ein universeller  entworfen,  der  die  Assembler-Befehle
anders erwartet, als es beim Amiga üblich ist.

Wenn ihr also  AC  mit  irgendeinem  Amiga-Üblichen  C-Compiler  übersetzen
wollt, dann müßt ihr diese Datei mit Folgendem ersetzen:

            XDEF _hookEntry

_hookEntry: move.l  a2,-(sp)
            move.l  12(a0),a0
            jsr     (a0)
            addq.w  #4,sp
            rts

@{"Anschauen..." link source/mui/hookfunk.s/main }

Seht ihr den Unterschied in der Notation?
@endnode
@node ac_make "4.6.7 Makefile"

Ein Makefile erleichtert dem Programmirer viel  Arbeit,  denn  diese  Datei
übersetzt  automatisch  das  dazugehörige  Programm.  Um  also  nicht jedes
einzelne Modul mit einem kryptischen, fingerverenkenden Compiler-Aufruf  zu
erzeugen,  gibt  man  im  CLI  einfach <make> ein und nach einigen Sekunden
(Minuten oder gar Stunden...) ist das  Programm  fertig  und  man  kann  es
ausprobieren. Gut, nicht?

Wenn ihr aber nicht den GNU/C Compiler benutzt, ist  diese  Datei  wertlos!
Toll, nicht? ;-)

@{"Anschauen..." link source/mui/Makefile/main }
@endnode

@node ac_gnu "4.6.8 Verwendung mit dem GNU/C Compiler"

Es gibt wohl kaum soviele Gerüchte und  Märchen  und  Schreckensgeschichten
über  einen  C-Compiler,  wie  über  den  GNU/C  in der Amiga-Welt. Das hat
allerdings auch mehrere Gründe:

GNU/C wurde ursprünglich für UNiX entwickelt, einem Betriebssystem, das vor
allem  in  der  Forschung  und  in  UNI-Nähe  eingesetzt wird. Es hat wenig
gemeinsam  mit  der  Amiga-Welt,  da  dort  solche  Dinge  wie  Festplatte,
virtueller    Speicher,   genug   Hauptspeicher,   super-schnelle-super-CPU
alltäglicher sind als bei uns. So braucht GNU/C zum Beispiel sehr (und  ich
meine SEHR) viel Speicher, um überhaupt zu arbeiten.

Ich habe vor langer Zeit mal einen kleinen  Testlauf  mit  DICE  und  GNU/C
gemacht,  und  GNU/C benötigte fünfmal soviel Speicher wie DICE und dreimal
so lange, um dasselbe Programm zu übersetzen. Doch war  der  erzeugte  Code
viel  kürzer  und  das  eigentliche  Programm  viel  (oh, ja) kompakter und
schneller. Das überzeugte mich und seitdem verwende ich GNU/C nur noch.

Eine weitere Sache, die nicht verschwiegen werden  sollte  ist,  daß  GNU/C
einige  auf  dem Amiga alltägliche und oft genutzte Dinge nicht beherrscht,
andere (auf dem Amiga eigentlich unnötige) dafür um so besser...

Es gibt allerdings von den Entwicklern (Fred Fisch ist einer davon) Pakete,
die   solch  fehlende  Notwendigkeiten  auf  dem  Amiga  durch  geschicktes
Austricksen des GNU/C Compilers verdecken.

Um zum Beispiel MUI-Applikationen zu entwerfen, sollte  man  sich  aus  dem
Aminet aus dem Verzeichnis dev/gnu die neuen "inline-header" FD2Inline V1.1
besorgen, und im Source-Code den Schalter NO_INLINE_STDARGS definieren. Das
bewirkt, daß man den Code von MUIBuilder V2.2b ohne Fehler übersetzen kann.

Doch  selbst  dann  ist  der  Code-Generator  von  MUIBuilder  V2.2b  nicht
fehlerfrei:  Man  muß  noch  die  Hooks  verändern, die sog. Header-Dateien
berichtigen und zu guter Letzt die mui.lib mit -lmui in  das  Programm  mit
einbinden.

Klingt kompliziert, nicht wahr? Ich habe mich  auch  lange  Zeit  geweigert
sowas  zu  versuchen.  Doch  es lohnt sich. Und bei Fragen zu GNU/C und MUI
kann man mich gerne ein wenig löchern...

@endnode
///

