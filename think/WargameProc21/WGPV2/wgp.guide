@database WGP.guide
@master dh1:t/WGP.GUIde
@index Index
@remark Created with Heddley v1.1 (c) Edd Dumbill 1994

@node "MAIN" "The WarGame Processor"

                         The WarGame Processor
                                     
                              Version 2.0

The WarGame Processor consists of two main programs, the @{"WarGame Processor" link "WGP" 0}
and the @{"WarGame Processor Editor" link "WGPEDIT" 0}.  There's another specialized program that
might be useful for some games called @{"Chits" link "CHITS" 0}.  The whole WarGame Processor
System is designed to make it as easy as possible to play popular board
wargames by mail or e-mail.  It's not necessary for your opponent to have a
copy of the WarGame Processor, as the program will still make life easier
on your end.  The WarGame Processor concept is a dynamic one.  The program
provides the means for users to design their own modules, so the usefulness
and utility of the system will always be growing. WGP owners (and
non-owners) can stay up to date on revisions, modules, and be able to
contact opponents on the @{"WGP WWW page" link "SUPPORT" 0}.

                        ... Table of Contents ...    

 @{"System Requirements " link "REQUIRE" 0} 
 @{"Legal stuff         " link "LEGAL" 0}

 @{"Registration        " link "REGISTER" 0}

A. @{"WarGame Processor  " link "WGP" 0}
   @{"Loading            " link "WGPLOAD" 0}
   @{"Menus              " link "WGPMENU" 0}
   @{"Buttons            " link "WGPBUTTON" 0}
   @{"Information fields " link "INFO" 0}
   @{"Movement           " link "MODE" 0}
   @{"Combat             " link "COMBAT" 0}
   @{"Playback           " link "REPLAY" 0}

B. @{"WarGame Processor Editor " link "WGPEDIT" 0}
   @{"Preparation              " link "EDITPREP" 0}
   @{"Map Editor               " link "MAP" 0}
   @{"Hex Editor               " link "HEX" 0}
   @{"Order of Battle Editor   " link "OB" 0}
   @{"Unit Image Editor        " link "UNIT" 0}
   @{"Final Touches            " link "FINISH" 0}

C. @{"Chits   " link "CHITS" 0}

D. @{"Support " link "SUPPORT" 0}
@endnode

@node "REQUIRE" "System Requirements"
The WarGame Processor requires WB 2.x or above and at least 1 MB of chip
RAM to run. A hard drive is recommended.  The size of the module that the
program can handle may be limited by available RAM.  Because of the heavy
video memory overhead required, the program might not run if you have many
other programs running in the background.  WGP also requires iff.library
version 2.38 (included).

@endnode

@node "REGISTER" "Shareware Registration"
The WarGame Processor is shareware.  The Demo version of this program found
on the internet is crippled.  I hate doing this, but I know how bad I am
about procrastinating on shareware fees with the best of intentions if I
don't have anything to motivate me.

In the crippled version the playback options are limited to 30 actions per
playback, and players may not save a game in progress more than five times.
By the time you encounter this limit, I hope you will agree that this is
well worth the $25 registration fee.  To get a registered version, fill out
the enclosed registration form and send it with your fee to the address
shown.

The registered version which will be sent to you will most likely be an
earlier version of the one you downloaded, so don't erase any of your
existing files!  To uncripple your software, simply copy the file named
"keyfile" from your registered disks to the same directory your WGP
programs reside in.  Please don't distribute this keyfile, but feel free to
distribute the rest of the program as far and wide as you like.
@endnode

@node "WGP" "The WarGame Processor"
The main WarGame Processor program is the player.  This is where you will
actually play your games.  It's been designed to be as friendly as possible
to the players.  The main map window shows a 20x20 area of your mapboard,
which may be scrolled around.  Units are arranged in stacks. The contents
of stacks may be displayed on the column of buttons to the right of the
map. There is a miniature map showing where the current viewing area is,
and an area for off-map forcepools.  @{"Menus" link "WGPMENU" 0}, @{"buttons" link "WGPBUTTON" 0} and @{"information fields" link "INFO" 0}
are arranged around the play area help coordinate the game interface.

To move around the map, you can use the arrow keys.  These will move the
visible map area by one or two hexes in the direction you press.  If you
want a faster scroll, use the numeric keypad's 2-4-6-8 keys.  These will
move the visible map area 15 hexes at a time.  You may also click on the
miniature map in the upper right corner.  The red box indicates where the
visible area is.  Place the box where you want to view and click again.
@endnode

@node "WGPLOAD" "Starting the WarGame Processor"
Upon starting the WarGame Processor, you will be presented with a title
screen.  The WarGame Processor is a shell from which you will play your
game.  To give this shell a form, you must load a game module.  Game
Processor Files are located in your "Modules" directory, with a ".GPF"
extension.  Each WGP module file has an accompanying graphics file
containing the image libraries, with a ".GPD" extension.

The game module will define the map and the units.  Each game modeled with
WGP will require a different module.  It's not possible to run more than
one module at a time.  To load a different module, you must exit WGP and
restart it. 

@endnode

@node "WGPMENU" "Menu Functions"
There are three main menu categories in the WarGame Processor.  Click on
the items below to see a detailed description of each function:

The Project menu: 
   @{"Load          " link "PLOAD" 0} 
   @{"Save          " link "PSAVE" 0} 
   @{"Encode Save   " link "NSAVE" 0} 
   @{"Save as ASCII " link "ASCII" 0} 
   @{"Replay Turn   " link "REPLAY" 0}

The Interface Menu: 
   @{"Show Terrain/Units " link "TERRAIN" 0}
   @{"Define Dice        " link "DICE" 0}
   @{"Value Computation  " link "VALUECOMP" 0}

The Flow Control Menu:
   @{"Show Held Units                 " link "SHOWHELD" 0}
   @{"Clear Movement Flags            " link "MFLAG" 0}
   @{"Clear Combat Flags              " link "CFLAG" 0}
   @{"Turn All Units Face-Up/Down     " link "ALLFACE" 0}
   @{"Turn Carried Units Face-Up/Down " link "CARFACE" 0}
   @{"Reset Playback                  " link "RESET" 0}

@endnode

@node "PLOAD" "Load Saved Game"
When a module is first loaded up by the WarGame Processor, all the units
are in a stack on the hex on the upper left corner of the mapboard. By
loading a saved game file, you can recall any previously saved positions.
Saved game files may also have any number of replays attached to them,
which will also be loaded available for @{"replay" link "REPLAY" 0}.

Selecting "Load" from the Project menu allows you to load a saved game from
disk. The default directory is the "SavedGames" directory. Using a standard
directory utility such as DiskMaster or DirOpus, you may wish to create
sub-directories in this if you usually use more than one module at a time.
No pattern matching is performed on the load option.

If you receive an encoded file through the internet as e-mail, simply save the
mail as a separate file to your savedgames directory.  Then select the file
from the "Load Game" requester.  You do not have to edit any preceeding text
that might accompany the file.  WGP will parse the file looking for the header
to tell it where to start loading.  If you receive a file as two or more
separate pieces, use any text editor to join them together before you load it
into WGP (Be sure you join them in order).
@endnode

@node "PSAVE" "Save Game"
Selecting "Save" from the project menu allows you to save the current game
position -- and if you are a @{"registered" link "REGISTER" 0} user, the
playback for the turn --
to a saved game file. This file may then be sent to your opponent, if he's
also a WGP user.  If your opponent is not a WGP owner, you may still send
your move using the @{"save as ASCII" link "ASCII" 0} functions.

The save game event will be recorded in the playback history.  When the
file is @{"replayed" link "REPLAY" 0}, the viewer will be notified at the point
where the game
was saved during play.  This is to discourage the practice of saving a game
right before a critical die roll, then reloading and re-throwing the die
until a desirable result is attained.

I've found it's helpful to agree on a naming system with your opponent that
will help keep saved game files in order.  For instance, you may wish to
name the first move of the first turn of a Third Reich game as "39.03.01",
which would translate as 1939, third season (fall), first file exchange.
This will result in all your turns being kept in order in your directory
listings. You may also wish to keep your games separate in your directory
listings by making subdirectories for each game in your savedgames
directory.
@endnode

@node "NSAVE" "Encode Save"
This function is identical to the "Save Game" selection, except that the 
file will be encoded in standard ASCII characters suitable to be sent as 
attached e-mail over the internet.  

Many internet servers such as Juno or Genie will not support a binary transfer as
e-mail.  Others, such as Compuserve, will allow you to attach a file to e-mail,
but only if that file is strictly ASCII characters.  This Feature of WGP allows
you to save the game in a format compatible with any e-mail handler.  To use it,
save the file using the "Encode Save" menu option.  Once the file is saved, you
may load it into any text or e-mail editor.  

This sort of saved game file is normally twice as large as a standard saved game
file. It consists of a WGP file header identifier, the savedgame body, and the
WGP file trailer.  You should be careful not to add or change any text in any
part of this file if you add it as E-mail.  The saved game body consists of a
block of encoded characters, 60 spaces wide.  You will notice that the characters
are alternating numbers and letters.  WGP will be able to decode these during the
load back into a normal saved game file format. 

You may add text before or after the WGP file in your e-mail.  The load function
will ignore any text before the WGP file header.  It will also ignore whatever
line feed sequence your particular program uses, so if you use a PC or Mac to
transfer your files, WGP should still be able to decode them.

Some e-mail servers impose a size limit on email text.  You may have to break up
your savedgame files into two or more parts.  Be sure to label them so that the
other player can reassemble the parts into one file.
@endnode

@node "ASCII" "Save as ASCII functions"
Selecting any of the "Save -- ASCII" options will generate an ASCII text
file with details about your move.  You may record the entire move since
the last @{"reset" link "RESET" 0}, with all the details about the exact
movements of each unit
and all your @{"comments" link "COMMENT" 0}, or you may record only the current positions of each
unit.  You may also record only the comments made since the last reset, for
the purposes of quoting them in other correspondence. These files may be
saved and later printed to be sent to an opponent who isn't privileged
enough to have a copy of the WarGame Processor.  Each line recorded will
have a leading space, so that E-mail editors won't reformat the lines.

Note that the save as ASCII function will ignore @{"encrypted" link "COMMENT" 4} comments.
@endnode

@node "REPLAY" "Replay Turn"
Pressing the replay button or selecting "Replay Turn" menu will reset the
units to their positions when the playback recorder was last @{"reset" link "RESET" 0}, and
allow the player to watch as play unfolds.  Pressing any key will allow you
to step through the playback move by move.  This function is crippled to
the first 30 movement actions for unregistered copies of the program, and
can be uncrippled by @{"registering" link "REGISTER" 0}. The replay can be terminated any time by
pressing the Escape key.

During playback, units are moved in the same order that they were moved
during play.  Every hex they touched will be shown.  While a stack of units
are moving, the right side of the screen will show the contents of the
stack.  When combat occurs, all units not involved in a specific combat
will be removed from the board, after which a comment box detailing the
combat declaration and any results will appear. 

If the moving player encrypted a @{"comment" link "COMMENT" 0}, the program will prompt you for
the correct password when the encrypted comment is to be read.  If you do
not know the password, press enter and the file will deny you access to
read the comment and press on.  Passwords are not case-sensitive.
@endnode

@node "TERRAIN" "View Terrain and Units"
The "Show Terrain/Units" option of the interface menu allows you to turn
the units on and off on the map, allowing you to examine the terrain
underneath them. Select this option again to turn the units back on. This
may also be accomplished by pressing "T" on your keyboard.
@endnode

@node "DICE" "Define Dice"
The "Define Dice" function of the interface menu allows you to dictate how
many dice are to be thrown, and how many sides the dice should have. The
default is 2 6-sided dice. These parameters will be used in all subsequent
@{"dice throw" link "DIETHROW" 0} and @{"combat" link "COMBAT" 0} actions.
@endnode

@node "VALUECOMP" "Unit Value Computation"
The six items at the bottom of the interface menu list the unit variable
names for the 6 user defined variables for each unit.  If no name was
assigned to a variable in the editor, it will not be listed on the menu.
Beside each name will be either "Total" or "Lowest." This will control how
the program displays these values from a stack of units. "Total" will tally
all the values in the stack in question and display the result. "Lowest"
will display the lowest value in the stack for that value.  The default
option for each value is set in the @{"Order of Battle" link "OB" 0} section of the
@{"Module Editor" link "WGPEDIT" 0}. The method of computation may be changed during play by
selecting the desired menu option.
@endnode

@node "SHOWHELD" "Show Held Units"
The "Show Held Units" menu option will allow you to examine the contents of
the stack you're currently carrying, as if it was a stack sitting on the
board. This may also be done by pressing the "H" key.
@endnode

@node "MFLAG" "Clear Movement Flags"
Whenever a unit is moved, the program will mark it with an "M" beside the
unit name in the @{"information" link "INFO" 0} display.  This allows players to  keep track
of what units may have moved in a particular phase.  The "Clear Movement
Flags" menu function will clear this symbol from all units, and may be
invoked at any time.  This is simply a player aid, for you to use as you
see best.
@endnode

@node "CFLAG" "Clear Combat Flags"
Whenever a unit participates in @{"combat," link "COMBAT" 0} the program will mark it with an
"C" beside the unit name in the @{"information" link "INFO" 0} display. This allows players to
keep track of what units have been in combat.  The "Clear Combat Flags"
menu function will clear this symbol from all units, and may be invoked at
any time.  This is simply a player aid, for you to use as you see best.
@endnode

@node "ALLFACE" "Flip units face up/face down"
Each unit has a front image and a back image, and the WarGame Processor
treats it just like a real cardboard counter.  You can turn units face up
or face down.  The "Flip All units Face-up" and "Flip All units Face-down"
functions will turn over all units in the game.  This may not be desirable
in every game situation, as there might be units off-map that you don't
want to turn over, so should used with discretion.

@endnode

@node "CARFACE" "Flip units face up/face down"
Each unit has a front image and a back image, and the WarGame Processor
treats it just like a real cardboard counter.  You can turn units face up
or face down.  The "Flip Carried units Face-up" and "Flip Carried units
Face-down" functions will turn over all units currently being carried, if
they aren't already.  This may also be done from the keyboard, using the
"F" (front) and "B" (back) keys.

@endnode

@node "RESET" "Reset Playback"
As the player @{"moves" link "MOVEMENT" 0}, writes @{"comments" link "COMMENT" 0} or performs @{"combat" link "COMBAT" 0}, the details of his
action are stored in a temporary file in the WGP root directory called
"pb.temp".  This file will be appended to a saved game file during a @{"save" link "PSAVE" 0}.
The "Reset Playback" Menu function will erase all previous moves from the
playback record.  If the turn is @{"replayed" link "REPLAY" 0}, only moves made after the reset
will be shown. It is very important to reset this at the point you wish to
begin recording. This function will also reset the unit start positions,
which is used when the @{"Undo" link "UNDO" 0} button is selected from movement mode.

It might be suggested that the reset playback function would also reset the
@{"movement" link "MFLAG" 0} and @{"combat" link "CFLAG" 0} flags, instead of having to do that as a separate step.
This would, however, limit the versatility of WGP, since it might not
always be desirable to clear a movement flag with a reset, especially in a
game with multiple phases which may require several game save and playback
resets per turn.

@endnode

@node "WGPBUTTON" "Button Functions"
Along the bottom and to the right of the play area are a number of buttons
and text fields to allow the player to interact with different functions
provided by the WarGame Processor.

BUTTONS 
   @{"Replay Turn " link "REPLAY" 0} 
   @{"Comment     " link "COMMENT" 0} 
   @{"Throw Dice  " link "DIETHROW" 0}
   @{"Movement    " link "MODE" 0}
   @{"Information " link "INFO" 0}

@endnode

@node "COMMENT" "Comment"
Pressing the "Comment" button will allow you to enter a comment at any
point in the game.  Comments will also be required whenver combat is
declared or resolved, or a die is thrown.  Pressing "Save" at the bottom of
the comment box will save the comment as part of the @{"replay" link "REPLAY" 0} function. 

Pressing "Encrypt" will do the same as saving your comment, except you will
be asked for a password. Passwords may be up to 8 letters long, and are not
case-sensitive.  You should be careful to record what a password for a
comment was, and what the comment pertained to.  If you decide you don't
want to encode the comment after you press this button, simply don't enter
a password.  Once you enter your password, this comment will not be able to
be read during playback unless the correct password is entered. The text
will be encrypted in the saved game file to prevent prying eyes armed with
sector editors from finding out your comment.  Pressing the "Cancel" button
will return to play without recording the comment.

The encryption option is useful for exchanging secret option selections.
For instance, a game might allow you to secretly deploy a number of
submarines to sea without your opponent knowing how many there are until
they attack. You would make that choice, record it as a comment and then
encrypt it and send it to your opponent.  When the time comes to reveal
your secret, you can give him your password, and he can verify that you
aren't cheating, since he would have been in possession of your choice all
along, even though he couldn't read it.  Because someone might go back to
review a turn and read a comment that he just acquired the password for, it
might be considered a good practice to preface an encrypted comment with an
unencrypted explanation of what you're hiding -- "The following comment is
my submarine deployment."

The encryption logic uses a random tearoff pad method, which encodes
differently every time you save something.  It's reasonably secure and
should withstand a casual effort to break it.  Of course it could not
withstand a dedicated effort to break it, but the effort to do so would
hardly be worthwhile.
@endnode

@node "DIETHROW" "Throw Dice Button."
Pressing the "Throw Dice" button will open a comment box and record the
result of the die roll. The number and sides of the dice are dependent on
what was set from the @{"Define Dice" link "DICE" 0} menu. This button is for any die rolls
not specifically related to @{"combat" link "COMBAT" 0}.  It's generally considered good manners
to use a comment to declare what the die roll represents before doing it.
After the result is displayed, the user has the option to enter a @{"comment" link "COMMENT" 0}
before closing the dialog box.  To prevent selective cheating, the lines
containing the die results cannot be edited (this was a potential problem
in WGP 1.x). Likewise, the die roll comment itself cannot be canceled, and
will be part of the @{"replay" link "REPLAY" 0}.
@endnode

@node "MODE" "Movement"
There are two modes of action in the WarGame Processor: Movement and
Combat. Movement is the main mode used for 90% of what goes on in WGP.
Combat is a special mode designed to make it as easy as possible for a
player to designate units participating in combat and still let the program
do as much of the work as possible.  Because of the way WGP tracks unit
positions, the Combat mode is very restrictive.

The two different modes are selected by pressing the rotating option button
labeled "Movement".  This button will change to "Combat", to show the new
mode, and the button beside it will be enabled to allow the user to select
one of three different modes available in Combat.

  @{"Moving Units  " link "MOVEMENT" 0}
  @{"Undoing moves " link "UNDO" 0}
  @{"Combat        " link "COMBAT" 0}
@endnode

@node "MOVEMENT" "Moving Units."
Any time a hex containing units is clicked on, a wealth of @{"information" link "INFO" 0}
about those units will appear in the text fields to the right of the play
area. To pick up a unit for movement, click on the button containing that
unit to the left of the map.  This unit will be added to the bottom of the
stack you are currently carrying.  You may pick up more than one unit in
this fashion, but you may not pick up units from more than one hex.  If you
click on any other hex or flip over any units you might be carrying, you
will not be able to pick up additional units until the stack you are
carrying is put down.  If you wish to pick up a whole stack at once, simply
double-click on that stack.

After you have picked up units, you may wish to see what you are
"carrying." You may do this using the pull-down menu option
@{"show held units" link "SHOWHELD" 0}.  This will show you the units you are carrying, as well as
the values summary in the information fields.

To move units normally the "Movement/Combat" button at the bottom of the
screen must say "Movement." If it says "Combat", units may only be moved to
combat boxes, or returned to their last position by pressing the @{"release" link "RELEASE" 0}
button.

When the "Movement/Combat" button says "Movement", the replay recorder will
record every hex a unit "touches" on its way to its final destination. To
"touch" a hex, the user would single click in the hex. For example, a unit
is picked up, then each hex along its path of movement may be clicked on
once, indicating the unit passed through that hex, then the unit is placed
in it's destination by double-clicking. During the replay, the entire path
of movement will be indicated. Note that the "touched" hexes don't
necessarily have to be contiguous.

@endnode

@node "UNDO" "Undo"
If you wish to return a unit to it's starting position in the @{"Movement" link "MOVEMENT" 0}
mode, you may do so by picking it up if you're not already carrying it, and
pressing the "Undo" button above the attack combat box.  The unit will be
returned to the position it was in when the last @{"reset replay" link "RESET" 0} option was
executed from the menu. Note that if a unit is moved more than once, it
will NOT return to the last hex it was in!  It will always return to the
position it was in when the last reset was accomplished. 

The undo may not replace a unit in the same position within a stack that it
started.  Units which are "undone" will be placed on the top of the stack
which occupies their starting position.  This is because the program has no
way of knowing what units might have been moved in or out of a hex, and
thus cannot accurately track the position in a stack.  For this reason, if
you are playing a game where the position within a stack is important, you
should be careful to check units which are undone to make sure they are in
the proper place in the stack to which they're returned.
@endnode

@node "COMBAT" "Combat"
There are three modes of combat operation, @{"1 by 1" link "1BY1" 0}, @{"Declare" link "DECLARE" 0} and @{"Resolve" link "RESOLVE" 0}.
These are selected by the rotation button to the right of the
"Movement/Combat" button.

While in any Combat mode, units may only be moved from the map into either
the attack or defend boxes.  Units may not be moved from hex to hex, or
even put down normally in their original hex.  To return a unit to the map,
or to put it down after picking it up, it must be picked up and the @{"release" link "RELEASE" 0}
button pressed.  This will return the unit to the hex it started this
combat sequence in.

Between individual combat actions, the player may move freely back to
@{"movement" link "MOVEMENT" 0} mode, and then re-enter the combat mode.  For instance, a combat
may be declared and resolved, and the player may need to move some
combatants to the dead pile or advance after combat.  Since units cannot be
moved around on the board in Combat mode, the player would return to
movement mode, make his movement, and then go back to combat mode if more
combat was necessary.  The program will remember if any combats are
pending, and the order in which they're to be accomplished.

There are two ways of declaring combat, depending on what the requirements
of a particular game are.  When the "Movement/Combat" button is in the
"Combat" mode, the button beside it will indicate which of the three combat
modes is active.

To declare a combat, the combat mode button should be either in @{"1 by 1" link "1BY1" 0} or
@{"Declare" link "DECLARE" 0}.  Attacking units are moved into the attack box, and the defending
units are moved into the defend box. This is a way of designating who is
involved in the combat and what their role is. It's up to the user to
determine the odds and terrain effects to be applied.

Resolving combat: 
   @{"1 by 1  " link "1BY1" 0} 
   @{"Resolve " link "RESOLVE" 0} declared
@endnode

@node "1BY1" "Individual Combat Actions"
The "1 by 1" Combat mode means that each combat is declared and resolved
before moving on.  Units are placed in the attack and defend boxes
according to their roll in combat.  If a mistake is made and the player
picked up a unit he doesn't wish to use in Combat, he must press the
@{"Release" link "RELEASE" 0} button above the Attack box.  This will place all the units
currently being held back on the hexes they were on at the start of the
combat mode.  Units may be picked up from either combat box, or anywhere
else, but may only be put down in a combat box or by using the release
button.

When all the units have been designated by placing them in the combat box,
the player may resolve the combat by pressing the "Resolve" button above
the Defend box.  This will generate a @{"comment" link "COMMENT" 0} requester with the details of
the combat and the subsequent die roll.  Players may not alter the die roll
text, nor may they cancel out of the comment.  The combat result may be
encrypted.
@endnode

@node "DECLARE" "Declaring Combat Actions"
The declare combat mode allows each combat to be declared first, before any
resolution takes place.  This allows you, for instance, to declare all
combats before any resolution die rolls.

If the combat is in Declare mode, once all the units involved in a
particular combat have been designated, press the "next"  button. Units in
the combat boxes will be returned to their hexes, and a comment box will
appear detailing the combat and clarifying that this is a combat
declaration to be @{"resolved" link "RESOLVE" 0} later.  Each unit assigned to a declared combat
will receive a "D" flag after its name to indicate that it's part of a
declared combat. A text field right below the hex names on the right of the
screen will remind the player how many combats have been declared and are
pending resolution.  A maximum of 120 combats may be declared this way.
After 120 (what kind of game are you playing anyway?), you MUST resolve
some before you can declare more. 

A unit may only be assigned to one declared combat at a time, although it
may be used in 1 by 1 combats while part of a pending declared combat.

One limitation to this method of declaring combat is that additional units
may NOT be added in to the list of  combatants after the declaration is
made.  If, for instance, a defender chooses to add air support later to a
combat, it would be noted in the comments manually, since  those air units
wouldn't be reflected in the unit list shown by the program.

@endnode

@node "RESOLVE" "Resolving Declared Combat Actions"
The resolve combat mode allows the player to resolve combats which were
declared in the @{"Declare" link "DECLARE" 0} mode.  While in this mode,  no units may be moved.

Attacks declared in Declare mode will be resolved in the order in which
they were declared. To initiate resolution, press the "Resolve" button. The
map will be redrawn with only the units actually involved in the combat
shown. To continue, the user must press a key or click the "Resolve" button
again, and a comment window will be opened.  This will contain the details
of the combat, who took part, and what the dice roll was. The user may
enter any additional comments, such as units which joined the combat after
it was declared, odds and results, before saving the comment. Canceling a
comment box or editing the die roll text after a combat is not possible.

The user may switch back and forth between the Combat and Movement modes
between combat resolutions to make post-combat movements.  The user may
also perform @{"1 by 1" link "1BY1" 0} combats in between declared combat resolutions, without
affecting the declarations.  

@endnode

@node "RELEASE" "Release"
In @{"combat mode" link "COMBAT" 0}, units may no be put down except in the combat boxes.  This
is to avoid confusing the position of the units, since a different method
of tracking position is used in combat mode.  To put a unit down anywhere
but in the combat box the user must press the "release" button.  This will
ensure that the unit to the place it was in when the combat mode was
entered.  Unlike the @{"undo" link "UNDO" 0} function, the program will restructure the
stacking order after every combat so that the stacks are preserved.
Stacking may become confused if units are "released", but this will resolve
itself when the combat boxes are cleared.
@endnode

@node "INFO" "Information Text fields "
To the right of the play area are several text fields to provide
information about specific parts of the game in play.

Just below the overview map, the name or coordinate of the current hex
under the mouse cursor is shown.  This is updated as the mouse is moved.
Names can be defined in the Module Editor.

Underneath the hex name field will be a status line showing how many
declared combats are pending resolution, if any.

When you click on a hex containing units, you will see the yellow hex
marker over that hex.  A list of units in that hex will be displayed in the
buttons to the right of the map.  If there are more than six units in the
hex, the bottom button will be down arrows. Pressing the top and bottom
buttons will allow you to scroll through the list.  If a unit has moved
already, it will be marked with a "M" flag beside its name. If a unit has
participated in combat, it will be marked with a "C" flag beside its name.
If a unit is part of a combat that has been declared, but not resolved, the
"C" flag will be replaced with a "D" flag.  The @{"movement" link "MFLAG" 0} and @{"combat" link "CFLAG" 0} flags
may be cleared from the "Flow Control" menu.  The "declared" flag can only
be cleared by resolving the combat.

Units may be picked up from a stack by clicking the button containing that
unit.  This capability is sometimes restricted by the current mode of play,
or units being held from another hex.

Just above the buttons will be a summary of the 6 module-specific values
for the units in that hex.  Module values may either be the sum of a
specific value or show the lowest value in the stack.  These values are
defined in the Module Editor.  The method of how they are tallied is set by
a pulldown menu.

Just above the unit values fields is a field showing the number of unit
counters in a hex.

@endnode

@node "WGPEDIT" "The WarGame Processor Editor "
The WarGame Processor Editor provides an intuitive interface with which you
can design your own modules, based on your favorite games. Many people find
designing modules almost as fun as playing the games! There are many
functions in the editor designed to make the design process as painless yet
flexible as possible.  You should read through the sections here on the
editor so that you are aware of all the features offered (I knew one fellow
who didn't take this advice and numbered all his hexes by hand because he
wasn't aware of the automatic coordinate numbering feature -- OUCH!)

 @{"Preparation               " link "EDITPREP" 0} 
 @{"Map Editor                " link "MAP" 0} 
 @{"Menus                     " link "EDMENUS" 0}
 @{"Order of Battle Editor    " link "OB" 0} 
 @{"Terrain Editor            " link "HEX" 0} 
 @{"Unit Editor               " link "UNIT" 0}
 @{"Coordinates and Hex Names " link "NAMES" 0}
 @{"Forcepools                " link "FPS" 0}
 @{"Packaging your module     " link "FINISH" 0}

You may notice that the Editor has no capability to place units on the map.
This can only be done from the @{"WarGame Processor player" link "WGP" 0}. All units will be
placed on the map in the upper left corner as an initial default. Designers
should include a @{"saved game" link "PSAVE" 0} file which distributes the units in some
fashion to expedite setup.
@endnode

@node "EDITPREP" "Planning your module"
After doing a couple of modules myself, and offering advice to others who
are doing modules, I've found some ways of doing things seem to work better
than others.  I'll try to pass some of these on here.

The quality of your module will depend on how well you orchestrate the
different steps and functions of @{"map design" link "HINT2" 0}, @{"force pools" link "FPS" 0} and
@{"order of battle" link "HINT4" 0} layout.  While the map design and implementation will
provide the greatest visual impact, the planning of the order of battle
will be the most significant contribution to how easy the module is to
play.  The @{"artwork" link "HINT6" 0} and how the @{"unit values" link "VALUES" 0} are displayed can make the
difference between a good module and one that is unplayable.  Once you have
the map and the order of battle together, you will have to
@{"tie it all  together" link "FINISH" 0} by preparing set-ups and documentation.

When you start designing a module, do a little preparation work first. How
many hexes high and wide will your module have to be? 

It's unwise to set the map limits to the exact number needed when you
initialize the module.  I've found that a two hex pad on the edges all the
way around may give you some room to make mistakes in. This can be visually
negated by filling the padded area with a grey hex image with no borders.

You should also decide how many units you need in the module, and how
you're going to portray them.  Which @{"unit data fields" link "VALUES" 0} will hold what data?
Will the data be summed together within a stack, or will the program only
show the lowest value of that field in a stack?  Some games have step
reductions for losses, and one "unit" might have two or more sets of game
values, depending on what step you're looking at.  Will these be portrayed
by one unit with two sides, or by two different units within the module?
The latter will allow for the values to be computed correctly, even with
reduce-stepped units, but will require more units than what came with the
game.
@endnode

@node "HINT2" "Map Design"
When you get to the @{"map editor" link "MAP" 0}, do a quick layout of your game map, but
avoid doing detail work at first.  If you need to put a @{"coordinate" link "COORDS" 0} system
on the map, you should do so early on, as redoing coordinates will erase
existing hex names.  The default coordinate system names the hexes after
their X and Y coordinates. If you are playing with an opponent who doesn't
have the Game processor, or you want 100% accuracy, you may want to rename
the coordinates based on whatever system the game actually uses. The "Do
Coordinates" button will allow you to select a coordinate system for your
game. If you don't see the system you need, @{"E-mail" link "SUPPORT" 0} me with details.

When initially laying out your map, you may find it necessary to blank out
the leftmost hex on all the odd rows so that your map edge will match the
game you are modeling. One of the games I used to proof much of this code
by installing was World in Flames, which uses off-map area movement out of
the hexagonal play area, and so the actual hexagon play area started two or
three hexes from the game processor edge to give room to draw these areas.

It's easy to lose track of what you've done on a large map, and you might
duplicate terrain features.  If you find that you've done this, you might
want to eliminate the duplication, but you want to be sure you get all the
hexes that are affected by the duplication updated. I found that if you use
the @{"terrain editor" link "HEX" 0} "Reverse F/B" function to change a prominent color to,
say red, it makes it real easy to spot all occurrences of the hex in
question. You might also find that you made some images that you ended up
not using. Use the @{"usage report" link "EDMENUS" 35} in the function menu to identify which
images are unused.
@endnode

@node "VALUES" "Unit Values"
Each unit may have up to 6 user definable values attached to it. The names
of each of these values may be edited by the user in the box in the upper
right of the @{"Order of Battle" link "OB" 0} screen. Click on the desired name to change,
and enter your changes. Value names are limited to four characters, and
will be displayed in the game processor information field  when units are
examined. To the right of each value is an indicator of how this value is
to be treated in a stack. If the indication is "Total", all the values are
added together and the total displayed. If the indicator is "Minimum", only
the lowest value will be displayed from a stack. The default may be changed
in the Editor by clicking on the appropriate indicator.  This default may
be @{"overridden" link "VALUECOMP" 0} by the user during play using a menu pulldown.

Before you start working on your units, you should determine what values
should be computed from the unit as it sits in a stack, and in what order
these values should be displayed.  The @{"WarGame Processor player" link "WGP" 0} will
display the values like this in the @{"information" link "INFO" 0} field above the hex
roster:

     Val1           Val4
     Val2           Val5
     Val3           Val6

Decide on a 4-letter name for each value.  You may want to delete value
names that are not used.  As a general rule, games that need more than six
values for each unit make poor PBM candidates.  Be sure your values are the
way you want them, because it's a painful process to go back rearranging
the data for every unit.
@endnode

@node "HINT6" " ArtWork"
Using color zero in your artwork allows you to have clear spots where you
can literally "see through" the artwork to what is below.  To understand
the way the map works, think of it as two layers. Layer 1 is the bottom
layer or underlay, and shouldn't have any color zero in it.  Layer 2 is
laid over layer 1, and should have some color zero in it somewhere if layer
1 is to be seen through layer 2. This allows you to lay features such as
cities, rivers, and coastlines over standard terrain types. Layer 2 images
are limited to image numbers 1 to 125. Layer 1 images are numbered from 126
to 400. Results may be less than desirable if color zero is used in layer 1
or not used in layer 2. Since only one image may be assigned to each layer
in a hex, some forward planning might be in order to best optimize your
image resources. For instance, would it be better to place your city images
in layer 1 or layer 2? If in layer 2, will any unique hex images be
required if a city is adjacent to a river? 

Images will initially be placed in layer one. Images may be placed in layer
two by selecting the "Overlay" mode. When this mode is selected, the image
will automatically be changed to the first default overlay image. 

To return to layer one, simply press this button until "Underlay" appears
again. If you wish to remove an overlay image, press this button until
"Clear Over" appears.

Rivers come in two flavors: hex edge and hex-to-hex. Some sample hex-to-hex
images have been provided in the default image library, and should cover
most requirements. These should be placed in layer one, but may be edited
to work in layer two by making everything but the river part of the image
color zero.

Hex edge river images provided with the default image library provide all
the standard combinations of rivers possible in a hex.  The way I worked
these to use as few image slots as possible was to only draw rivers along
the upper and left hex edges. If you need a river along a different edge,
just draw it in the next hex in that direction. Sometimes a hex may have
more than one hex edge symbol, for instance there are several hexes in
Third Reich which have border, river, and front boundaries. These must be
dealt with individually.

You may have to add to these images if additional hex-edge symbology is
required, such as borders, weather areas, etc. For best results, limit
hex-edge symbology to the left and top sides of a hex. Right side or bottom
edge symbols can then be done with the same symbols by using the left side
or top of adjacent hexes. If you have to draw borders along the hex edges,
for example, you may want to copy each of the river images in the terrain
editor and change the color to black, or whatever color you want your
border to be. Unique images may have to be created as needed if, say a
border and a river share the same hex edge. Hex edge rivers are also useful
to delineate sea areas against borderless light blue seas.

Be sure when designing terrain to avoid horizontal lines of only one pixel,
or lines with odd numbers of pixels in the horizontal. Also avoid dramatic
color contrasts. This will help minimize screen flicker on non-ECS machines
which can be quite distracting.
@endnode

@node "MAP" "The Map Editor"
The map editor is the core of the WarGame Processor editor. This is where
you will actually design the playing field using images designed in the
terrain @{"hex editor" link "HEX" 0}. The map editor is the only area from which the user can
access the pull down @{"menus" link "EDMENUS" 0} (including the save function), or exit the
program.

To the right of the map edit are are anumber of @{"buttons" link "EDBUTTONS" 0} and @{"information" link "EDINFO" 0}
fields to help you interface with the editor more effectively.

At the right of the screen, above the buttons, is the image of the current
active hex image. The number above the image indicates the image number the
program has assigned to it. This image is also attached to the mouse. To
place this image on the map, simply click in the desired hex. If you make a
mistake and wish to return to the original image you pasted over, simply
click again on the hex and it will return its original image.  You can
"paint" broad swaths of identical hexes by simply holding the mouse key
down while moving across the hexes.  Down worry if you make a mistake,
remember, you can bring back the poriginal image by simply clicking on a
hex again.

To select a new image from the library of images, use the buttons to the
right of the displayed image, +1/+10 or -1/-10. These will page through the
available images. Simply stop on the image you want. If the desired image
is not available from the default editor hexes, you may use the terrain
editor to draw the desired terrain in an unused hex image.

To scroll the map up down or sideways, use the arrow keys on the keyboard.
To scroll quickly, use the numeric keys, 2-4-6-8.  The visible area
relative to the map will be represented by the red box on the miniature map
in the upper right corner of the screen. Clicking in this area will also
allow you to move around the map. Just move the red box to the area you
want to view and click the mouse button.
@endnode

@node "EDMODES" "Map Editor User Modes"
There are four user modes available in the @{"map editor" link "MAP" 0}, which can be
selected using the rotation button underneath the @{"Name Hexes" link "NAMES" 0} button. These
help manage the layers and provide the ability to copy and paste names on
hexes.

The default mode is "Underlay". In this mode, the user will have image
numbers 126 to 400 available to place on the map.

The next mode is "Overlay".  In this mode, the user will have image numbers
1 to 125 available to place on the map.  These images will be placed over
the images drawn in "place Underlay" mode.  Many hexes will not have an
overlay image.  By mixing and matching overlays and underlays, the user can
portray far more than the simple 400 hex images provided by the WarGame
Processor.

The third mode is "Clear Over".  If you made a mistake and placed an
overlay where you don't want one, this mode allows you to clear it away.
Simply select this mode, then click on the hex from which you wish to
remove the overlay.

The fourth mode is "Copy Names".  In this mode, you can copy names from one
hex to another, allowing you to give whole areas the same name. Simply
click on the hex you want to copy to or paste from, then press the "C" or
"P" keys to execute the function you wish.  A text field at the bottom of
the screen reminds you how to perform the copy and paste.
@endnode

@node "EDBUTTONS" "buttons"
There are several buttons along the right side of the map editor that allow
you to control different modes of the Map editor or access additional
editing functions in the program.

@{"Name Hexes" link "NAMES" 0} allows you to manually give each unit a unique name.

The rotation gadget named "Underlay" allows you to select one of four
different user @{"modes" link "EDMODES" 0} in the map editor.

@{"Make Overview" link "OVERVIEW" 0} will redraw the miniature map in the upper right corner based
on the terrain from the map editor.

Edit Units will invoke the @{"Order of Battle editor" link "OB" 0}.

Edit Terrain will invoke the @{"Hex image editor" link "HEX" 0}.

@{"Force Pools" link "FPS" 0} will allow you to edit the force pool names.

@{"Coordinates" link "COORDS" 0} provides the capability to number your hexes from a variety of
different coordinate schemes.
@endnode

@node "EDINFO" "information"
To the right of the play area are several text fields to provide
information about specific parts of the game being edited.

Just below the overview map, the name or coordinate of the current hex
under the mouse cursor is shown.  This is updated as the mouse is moved.
Names can be defined by using the @{"Name Hex" link "NAMES" 0} or coordinate functions.

Underneath the hex name field will be a status line showing what the number
of the current hex being drawn to the map is.  Just below this is that
hex's image, along with buttons which can be used to select the desired
hex.

Below the interface buttons, there are two lines which tell the user what
hex images are being used for the overlay and underlay of the hex currently
under the mouse.
@endnode

@node "NAMES" "Naming Hexes"
The "Name Hexes" button will allow the user to rename a hex from the
default @{"coordinate" link "COORDS" 0} name.  When this function is enabled, a hex may be
marked by clicking on it, and the new name typed in. Pressing return ends
the text entry. No other functions will be possible while text entry is
active. You may copy hex names by selecting the "Copy Name" @{"mode" link "EDMODES" 0}. Sometimes
you may wish to clear the coordinates from an area of the map, such as the
edge.
@endnode

@node "COORDS" "Coordinates"
The hex name is located just below the overview map, and updates as you
move the mouse cursor around the screen.  This name may be a proper name, a
coordinate, or both.  You can edit the names of units by using the @{"name" link "NAMES" 0}
@{"hexes" link "NAMES" 0} function. 

The WarGame Processor uses a default numeric coordinate system.  This
probably will not match the coordinate system used by your game.  By
pressing the "Coordinate" button, you can automatically label your map from
one of eleven provided coordinate systems.  Each system is described in the
selection, along with any special limitations of the system.  Use the left
and right arrow keys to page through the selections.  When you are
satisfied that you have chosen the correct system, press enter.  You will
be instructed to indicate a particular hex so that the program knows where
to start numbering.

The provided coordinate systems should cover most of the commonly used
systems used today. If you can't find the system that you need, @{"email" link "SUPPORT" 0} me
with details of the system, and I will install it for you.
@endnode

@node "OVERVIEW" "Making the Overview Map"
The "Make Overview" button will draw a new overview map in the upper
right-hand corner which will reflect any changes made in the map. You
should always save your work before using this, as it hasn't been
thoroughly tested, particularly on very large maps, and may contain some
fatal bugs.

The @{"Edit Units" link "UNIT" 0} and @{"Edit Terrain" link "HEX" 0} buttons provide access to other editor
functions.
@endnode

@node "FPS" "Forcepools"
The "Force Pools" button allows the user to assign his own names to any of
the 18 Force pools.  Force pools are off-map holding areas for units and
can be designated whatever name the user desires.

Try not to give different pools the same name, even if they're not used,
because the user will only have the name to tell him where he is as he's
flipping through the pools.  Even if you label them "unused" you should
attach a number or some other unique identifier to each name.

You should also try to avoid names like "German" in your force pool.
Qualify the name to show that this is a forcepool, like "German FP."  That
this is the "German" forcepool is obvious when you're using WGP, but less
so if your module is used to play against a player who doesn't have WGP.
The player will be @{"saving his moves in ASCII" link "ASCII" 0}, and it doesn't make much
sense for "unit xyz moves from hex B38 to German."
@endnode

@node "EDMENUS" "Editor Menus"
The Project menu:   

Save allows the user to save his module to disk. The game will be saved
using the name you select. All images will be saved with the module files
in the "Modules" directory, located under the directory that the editor was
launched from. Two files are saved with each module, one *.GPD file which
contains all the graphic images unique to your module, and one *.GPF, which
contains the data for how to put the graphics together.

"Quit" allows you to exit the program. A verification message is provided
before final shutdown. 

The Images Menu:

"Make Unit Template" will create an IFF picture of all the unit images used
in the module. This picture can then be edited by a more powerful paint
program than the tools contained in the Game processor. Don't try to change
the palette of the picture, because the WGP program will force it back to
the default palette

"Make Hex Template" will create an IFF picture of all the hex images used
in the module.  This picture can then be edited by a more powerful paint
program than the tools contained in the Game processor. 

"Cut Unit Template" will load an IFF picture of a unit template, then
extract the unit images from the template and incorporate them as part of
the present module. This allows you to reload your edited templates.

"Cut Hex Template" will load an IFF picture of a hex template, then extract
the unit images from the template and incorporate them as part of the
present module. This allows you to reload your edited templates. 

"Clear Hex Names" will erase all the hex names.  This should be done
prepatory to installing a default @{"coordinate" link "COORDS" 0} system.

"Add Units" will allow the user to add more units to the module than were
originally specified.  Press return after entering how many more units you
wish to add.

"Report Hex Usage" provides a report of which hex images have been used and
how many times they have been used.  Images which are unused are
highlighted in red.  This is a valuable tool for managing very large image
libraries through the development process.
@endnode

@node "HEX" "The Hex Image Editor"
The hex editor is accessed by pressing the "Edit Terrain" button from the
@{"Map Editor" link "MAP" 0}.  The Hex Editor allows you to define the art work which you
will use to make up the individual hexes on the map. A default library of
images is loaded, with a wide variety of basic terrain types to choose
from. This is mainly to be used as an example, and may be edited as
desired.  The current hex loaded in the editor will be the same as the
selected hex image in the map editor.  

@{"See details about how WGP handles graphics. " link "HINT6" 0}

For terrain features that extend from hex to hex, the hex editor has
highlighted the center pixel on each edge in red to make it easy to line up
features from hex to hex.

At the bottom right of the screen is the color palette. Foreground colors
are selected with the left mouse button, and background colors with the
right mouse button. The selected colors are shown immediately to the left
of the palette. The left and right mouse buttons will then be able to place
their respective colors on the unit image. Color zero appears as grey, but
when this color is used, it will be invisible on the play field. This is
very useful for images which are to be used in the overlay layer.

The main hex image is shown as a blow up, and may be edited as desired.
Above and to the right of this image is the actual size of the hex being
edited, so a true perception of the artwork may be seen. 

The "Fill color" button will paint over the image completely in the
foreground color.

The "Border" button will draw a border around the edge of the hex in black.
If you want another color for a border, select black and your desired color
as foreground and background colors, then use the "Reverse F/B" button.

The "Checker" button will paint every other pixel the foreground  color.
This can be used to create shades of color beyond those of the basic
palette.

The "Reverse F/B" button will replace the foreground color with the
background color and vice-versa in the image. 

The "Copy" button copies the current image to the buffer. The buffer is
shown below and right of the magnified image. 

The "Paste" button copies the contents of the copy buffer over the current
image. 

The "Previous" and "Next" button groups allow the user to thumb through the
available images. 

The "Go To Map Editor" button will return the user to the Map Editor,
saving any image changes that have been made.
@endnode

@node "OB" "The Order of Battle Editor "
The order of battle editor allows the user to define the individual units
which will be used in the game. The maximum number of units which may be
defined is 10,000.   Before you jump in to the Order of Battle, it often
helps to do some preliminary @{"preparation" link "HINT4" 0}.

A list of units is shown in the main part of the screen. The order of
battle window is only capable of displaying 33 units at a time. To see
additional units, the scroll up and scroll down buttons allow you to view
the entire list of units.  The page up and page down buttons allow faster
scrolling. Units may be selected to be edited by clicking anywhere on that
unit's line. This unit will then be shown in the edit line and changes can
be entered.

Each unit has a unique ID number in the far left column, which cannot be
changed. The name column provides a space to enter a name for the unit.
This can be whatever the user wants, but is limited to 9 characters. To
enter a new name, simply click in the name field on the editor line to
activate the entry mode, then type in the name or make changes to an
existing name.

Each unit may have two images assigned to it (a front and back). These
images are shown as such on the editor line, and the numbers which
reference these images on the main unit list. To the right of the main list
is a graphic table of all the available unit images to choose from. Click
the left mouse button on the desired image to select the "front" of the
counter, and the right mouse button to select the image for the "back" of
the counter. The new images will be displayed on the edit window. If your
module has more than eighty different unit images, additional images may be
viewed by the up and down arrows at the bottom of the image display. There
are up to 600 unit images available.

The @{"values" link "VALUES" 0} to be assigned to each unit are entered in much the same way as
the name, but are limited to numeric values from 1 to 99.

The copy button at the top of the screen will memorize the unit currently
in the edit window.  This can also be done by pressing the "C" key. The
details of this unit can then be pasted onto any other unit by selecting
that unit to be edited and pressing the paste button. This can also be done
by pressing the "P" key.

The F9 will select the next unit in the list for editing, without having to
click on it.

The F10 button will select the next unit in the list and copy the current
unit to it.  This allows you to stamp a large number of identical units
very quickly.

The "Edit Image" button will take you to the unit @{"image editor" link "UNIT" 0}, where you
can define the art for the counters. The front image of the counter in the
editor will be the default image to be edited.

The "Map Editor" button will return you to the @{"map editor" link "MAP" 0}. 

Once units are defined, they will appear in the upper left hex of the map
when the player is run. The @{"WarGame Processor player" link "WGP" 0} must be used to move
the units from there and place them prior to play of the game.
@endnode

@node "HINT4" "Order of Battle"
The Order of Battle editor can be a lot of work if it's not approached in
an orderly fashion.  It's easiest to make one unit of a particular type and
copy it over and over as many times as necessary, then go back and change
the details.  It's a good idea to indicate the nationality of the unit in
the name, to make references clear in combat text.

The counters provided in the game don't necessarily have to be reproduced
exactly in the module.  Text on the counter can often be done as part of
the unit name, for one thing.  You should decide which factors are
necessary to be shown on the counters, and which would do the job just as
effectively as computable @{"values" link "VALUES" 0} to be shown to the right of the map. You
should avoid putting too much information on the counters, or cluttering
them so that they're unreadable.  Often different classes or nationalities
may be designated by different colored borders.
@endnode

@node "UNIT" "The Unit Image Editor "
The unit image editor allows you to define the art work which you will see
on your units when playing the game. A default library of unit images is
loaded, with basic colors and symbology. This may edited as desired.

@{"See details about how WGP handles graphics. " link "HINT6" 0}

At the bottom right of the screen is the color palette. Foreground colors
are selected with the left mouse button, and background colors with the
right mouse button. The selected colors are shown immediately below the
palette. The left and right mouse buttons will then be able to place their
respective colors on the unit image. Color zero appears as grey, but when
this color is used, it will be invisible on the play field.

The main unit image is shown as a blow up, and may be edited as desired.
Above and to the right of this image is the actual size of the unit being
edited, so a true perception of the artwork may be seen.

The "Fill color" button will paint over the image completely in the
selected foreground (left mouse button) color. 

The "Border" button will draw a border around the edge of the unit in the
selected background (right mouse button) color.

The "Reverse F/B" button will replace the foreground color with the
background color and vice-versa in the image. This is an easy way to do a
quick nationality change.

The "Copy" button copies the current image to the buffer. The buffer is
shown below and right of the magnified image.

The "Paste" button copies the contents of the copy buffer over the current
image.

The "Previous" and "Next" button groups allow the user to thumb through the
available images. 

The "Edit Units" button will return the user to the Order of Battle Editor,
saving any image changes that have been made. 

To the right of the magnified image are a series of common military
symbols. Clicking on these will paste that symbol in the upper left corner
of the current image.

Above the magnified image are a sequence of numbers. Clicking on a number
will allow you paste that number in the image.  The position of the number
can be set by moving the mouse around the blowup image.  Watch the actual
size image in the upper right corner to see where the number is being
situated.  The blowup will reflect the change once the number is pasted.
@endnode

@node "FINISH" "Preparing your module for distribution."
 Once you've made your @{"map" link "MAP" 0}, detailed the @{"order of battle" link "OB" 0}, named your @{"force" link "FPS" 0}
@{"pools" link "FPS" 0}, and are satisfied with the whole thing, you are ready to move to the
WarGame Processor @{"play program" link "WGP" 0}.  When you first load a module into the play
program, all the units appear in the upper left corner in one huge stack.
Large stacks like this may cause slowdowns when you're picking units up.
You should provide a setup @{"saved game" link "PSAVE" 0} file, with the units broken down into
smaller stacks, maybe by type, and possibly placed in the correct area of
the board.  Some games which have a fixed setup should have the units
placed in their startup positions.  Perhaps you might want to put some
units in the correct force pools at the setup.

You should keep notes on the game module and provide them with the module
as a README file.  Identify where you made a compromise between the board
game and the module, what the different @{"values" link "VALUES" 0} mean, and how you arranged
the @{"force pools" link "FPS" 0}.  You should also state who the original publisher of the
game is, provide their address and phone number, and tell how someone can
acquire a copy of the game, if it's not one of the more popular games.

When you are ready to distribute your module, you should provide the two
data files ( .GPF and .GPD) from the modules directory, the suggested setup
file from the savedgames directory, and the readme file detailing your
notes on the module.  If possible the files should be archived in place in
their proper directory.  If you upload to a network, you should have the
word "WGP" as one of your keywords, and clearly identify it as a WarGame
Processor module, and that ownership of the WarGame Processor and the
original game are required for play.  Please note that modules based on
commercial third-party games should not be released to a public forum for
@{"copyright" link "LEGAL" 23} reasons.
@endnode

@node "CHITS" "Chits"
Many wargames require players to pull option counters from a pool of
face-down counters.  These counters are often then secretly held or
released simultaneously.  This presents two difficulties to play-by-mail.
The first is obviously ensuring secrecy and honesty in the draw, and the
second is ensuring that players don't draw the same chit, which would be
impossible in front to front play.  The "Chits" program provides a means of
resolving these difficulties.

When the chits program is first started up, the player is offered a chance
to either start a new chit file or to load an old one.  The player should
select "new."  The player will then be asked how many chits are in the
pool.  There may be up to one hundred chits in the pool, but the player may
lower this number if required.  If your chits are not simply numbers, you
and your opponent should agree beforehand which chit each number
represents.

Then the player will be asked for a password.  Once a password is entered,
the player will be required to save the file and send it to his opponent so
that the other player's password may be entered.  The chit file should have
an extension of ".CHT" so the file requester can see it by default.

The second player will start the program, and this time when offered the
chance to start a new file or load an old one, he should load the file
which was started by player 1.  The program will recognize that no password
exists for player 2, and ask for a new password.  Once this is entered, the
program may be used to draw chits.

To prevent a person from examining the contents of the undrawn chits, a
chit may ONLY be drawn by asking the opponent to "release" it.  To release
a chit for your opponent to examine, press the button "release chits from
pool."  A requester will ask how many chits you want to release.  The
program will then randomly designate chits from the pool to be examined by
the other player.  The file should then be saved again, and sent to the
other player.

When you start the program and load a file, you will be asked for a
password.  The program will identify you as player 1 or player 2 based on
your password.  The program will then examine the chits to determine if any
of them have been released for your examination.  If so, it will notify you
of the fact.  You will then be told the number of the chit which you have
pulled, and offered three options of what you want to do with it.

If you "keep" the chit, it will be flagged as yours and not be available
for the pool from then on.

If you "replace" the chit, it will be returned to the pool.

If you "release" the chit, your opponent will be able to examine it the
next time he loads this chit file.

Note that the chits you draw are determined at the time the opponent
releases them to you.  Rerunning the program to try to improve your draw
will be pointless.

At some point in the game, you may wish to reveal the chits you are holding
to your opponent.  You may do this by pressing the "release held chits"
button.  A requester will ask you which chit you wish to reveal. You will
be warned if the chit number you enter is not currently being held by you.
Once you have done this you must save the file.  The next time your
opponent loads the file, your chit will be revealed to him.

One way of "cheating" the system is if your opponent requests to pull a
chit out of the pool for examination (intelligence to tell what chit you're
NOT holding).  It may occur to some to save a file with a released chit,
and then keep sending the same file on successive attempts, effectively
denying any useful information after the first examination. The program
will encrypt differently every time it's run, so it's easy to spot this
tactic by examining your files with a hex editor like the one in DirWork to
see if you receive two identical files. If they are identical, and you
picked the same chit, it's a good bet your opponent didn't release a new
chit, but sent you the same file twice.

I won't make the claim that the file encryption can't be broken, but it
would require a dedicated attack on the encryption system.  This is made
more difficult by the fact that a different encryption occurs every time
the program is run.  I'm confident that the file encryption is secure from
casual to moderate attempts to analyze it. 

This program can also be used for simultaneous exchanges, so that neither
player will be able to make a decision about his choice based on what the
other player revealed, like the combat tables in "War and Peace".  For
instance, two players each hold a number of "tactics" chits, and the game
requires them to each select a chit and reveal them simultaneously. Here's
how this can be done.

Each player will start their own chit file, with the number of chits that
they alone hold.  They save the file, then reload it and provide the player
2 password themselves.  Then as player 2, they authorize the release of all
the available chits to their Player 1 persona.  The file is saved, and then
reloaded using the player 1 password.  As Player 1, they would elect to
"keep" all the chits.  

At this time, both players each hold a file which they have both passwords
for.  Using their Player 1 passwords, they each select a chit to be
revealed to player 2.  They then exchange files --  BUT NOT PASSWORDS! Once
both players have the other's file, they then exchange the password to
unlock the player 2 side of the file, revealing the selected chits.  In
this way, neither side can change their decision based on what was revealed
by the other player.

Once prepared, the original file may be used repeatedly by changing the
player 2 password.
@endnode

@node "SUPPORT" "WarGame Processor Product Support."
If you have any comments, suggestions, or questions, or if you need help or
advice in designing a module, please feel free to contact me.  Please
report any bugs you find so I can get them fixed for the next release.

To report a bug, please be as specific as possible: what you were doing,
what the program did, any error numbers.  Please take the time to reporduce
the failure several times.  I can't fix it if I can't reproduce your
failure consistently.

Keep an eye on my WWW page for WGP updates, information about Module
availability and opponent listings:

http://ourworld.compuserve.com/homepages/S_Emerson/wgp.htm

Look for WGP modules such as Third Reich, Victory in the Pacific, D-Day,
and France '44!

If you have no E-mail capability or if you just want to send me $$$ to show
your appreciation for all the Dr. Pepper that was consumed and the
carpal-tunnel condition that was exacerbated in developing this software,
you can snail-mail me at

 S. Emerson 
 160 N. Fairview #D-179,
 Goleta, CA 93117

     /                        Sean Emerson                       \
  /\/_      S.Emerson@Genie.com   103731.347@Compuserve.com      _\/\
 / '__)    http://ourworld.compuserve.com/homepages/S_Emerson   (__` \
 \  \      Dark Unicorn Productions -- The WarGame Processor      /  /
 /__\\                                                           //__\
@endnode

@node "LEGAL" "Legal stuff"
 COPYRIGHTS
 ----------
 The WarGame Processor Version 2 Amiga
 Copyright - 1996, Sean Emerson, All rights reserved

All versions of the WarGame processor executable, documentation and support
files are protected by United States Copyright Law and related
international treaty provisions.  You are entitled to use the program in
original form only.  You may not reverse engineer, decompile, disassemble
or derive a work based on this work in whole or in part.  This restriction
does not apply to original works developed using the WarGame Processor
editing tools.

Portions of this distribution are copyrighted as follows.

 iff.library, Version 23.2, 24-May-93
 By Christian A. Weber
 Internet: weber@amiga.physik.unizh.ch
 USED WITH PERMISSION (Many Thanks)

 FAIR USE
 --------

The Nature of the WarGame Processor is such that it may be abused to
violate Copyright laws when developing modules based on existing board
wargames.  The user is obligated to avoid developing modules unless he or
she legally owns a copy of the board wargame in question.  The user is
additionally obligated to avoid distributing modules for use to third
parties who do not own a legal copy of the board wargame in question. Under
the concept of fair use, it is not a violation of Copyright law to
distribute modules for third party games, as long as the recipient and the
sender both legally posess a copy of the original board wargame.  You may
not charge a fee for such distribution beyond a reasonable amount for
materials, shipping, and handling.


 SHAREWARE
 ---------

This program is made available through the concept of "Shareware" which is
a form of distribution that gives you the opportunity to try a piece of
software before you buy it.  It is a copyrighted work that is not now, nor
will it ever be regarded as in the Public Domain or otherwise "free"
software.


 LICENSE
 -------

You are granted a limited license to evaluate this software on a private,
non-commercial basis only.  Registration is not only required for your
continued use, it is needed to keep the development of future enhancements
to WarGame Processor active.  Without your support the product cannot
continue to evolve.


 DISCLAIMER
 ----------

No warranties are implied or expressed with regard to the fitness or
merchantability of the WarGame Processor for any particular purpose.  All
risks and damages, incidental or otherwise, arising through the use or
misuse of the WarGame Processor are entirely at the responsibility of the
user.      

While considerable effort has been made to provide you with a reliable
product, there is no guarantee that this program is 100% "bug-free".
Additionally, this disclaimer does not guarantee future versions of this
product, but maintenance releases may be made available if and when
feasible.


 ACKNOWLEDGEMENTS
 ----------------

Third Reich, Advanced Third Reich, D-Day, Empire of the Rising Sun, Victory
in the Pacific and War and Peace are all Trademark names for board wargames
by the Avalon Hill Game Company:

 The Avalon Hill Game Company 
 4517 Harford Rd. 
 Baltimore MD 21214-9989


 The WarGame Processor was developed entirely with SAS/C 6.55.

Honorable mention for other programs without which I could not have
completed this project:

 DirWork1.62 by Chris Hames
 Dostrace 1.0 by Peter Stuer
@endnode

@index Index
@node Index

 1

 @{"1 by 1 Combat   " link "1BY1" 0}

 A

 @{"artwork         " link "HINT6" 0}

 B

 @{"Buttons, WGP    " link "EDBUTTONS" 0}
 @{"Buttons, Editor " link "WGPBUTTON" 0}

 C

 @{"Chits                     " link "CHITS" 0}
 @{"Clear Combat Flags        " link "CFLAG" 0}
 @{"Clear Movement Flags      " link "MFLAG" 0}
 @{"Combat                    " link "COMBAT" 0}
 @{"comments                  " link "COMMENT" 0}
 @{"Coordinates and Hex Names " link "NAMES" 0}
 @{"Coordinates               " link "COORDS" 0}
 @{"copyright                 " link "LEGAL" 23}

 D

 @{"Declare     " link "DECLARE" 0}
 @{"Define Dice " link "DICE" 0}
 @{"dice throw  " link "DIETHROW" 0}

 E

 @{"E-mail       " link "SUPPORT" 0}
 @{"Edit Terrain " link "HEX" 0}
 @{"Edit Units   " link "UNIT" 0}
 @{"encrypted    " link "COMMENT" 4}

 F

 @{"Final Touches " link "FINISH" 0}
 @{"force pools   " link "FPS" 0}

 H

 @{"Hex Editor " link "HEX" 0}

 I

 @{"Image Editor " link "UNIT" 0}
 @{"Information  " link "INFO" 0}
 @{"information  " link "EDINFO" 0}

 L

 @{"Legal stuff " link "LEGAL" 0}
 @{"Load        " link "PLOAD" 0}
 @{"Load        " link "WGPLOAD" 0}

 M

 @{"Make Overview  " link "OVERVIEW" 0}
 @{"map design     " link "HINT2" 0}
 @{"Map Editor     " link "MAP" 0}
 @{"Map            " link " MAP " 0}
 @{"Menus          " link "EDMENUS" 0}
 @{"Menus          " link "WGPMENU" 0}
 @{"Modes          " link "EDMODES" 0}
 @{"Module Editor  " link "WGPEDIT" 0}
 @{"Movement       " link "MODE" 0}
 @{"movement flag  " link "MFLAG" 0}
 @{"Moving Units   " link "MOVEMENT" 0}

 N

 @{"Name Hexes " link "NAMES" 0}

 O

 @{"Order of Battle Editor  " link "OB" 0}
 @{"Order of battle hints   " link "HINT4" 0}
 @{"Override default values " link "VALUECOMP" 0}

 P

 @{"Packaging your module " link "FINISH" 0}
 @{"play program          " link "WGP" 0}
 @{"Playback              " link "REPLAY" 0}
 @{"Preparation           " link "EDITPREP" 0}
 @{"Preparation hints     " link "HINT4" 0}

 R

 @{"Registration          " link "REGISTER" 0}
 @{"Release               " link "RELEASE" 0}
 @{"Replay Turn           " link "REPLAY" 0}
 @{"Reset Playback        " link "RESET" 0}
 @{"Resolve Combat        " link "RESOLVE" 0}

 S

 @{"Save                " link "PSAVE" 0}
 @{"Save as ASCII       " link "ASCII" 0}
 @{"save game           " link "PSAVE" 0}
 @{"Show Held Units     " link "SHOWHELD" 0}
 @{"Show Terrain/Units  " link "TERRAIN" 0}
 @{"Support             " link "SUPPORT" 0}
 @{"System Requirements " link "REQUIRE" 0}

 T

 @{"Terrain Editor                  " link "HEX" 0}
 @{"Throw Dice                      " link "DIETHROW" 0}
 @{"Turn All Units Face-Up/Down     " link "ALLFACE" 0}
 @{"Turn Carried Units Face-Up/Down " link "CARFACE" 0}

 U

 @{"Undo              " link "UNDO" 0}
 @{"unit data fields  " link "VALUES" 0}
 @{"Unit Image Editor " link "UNIT" 0}
 @{"unit values       " link "VALUES" 0}
 @{"usage report      " link "EDMENUS" 35}

 V

 @{"Value Computation " link "VALUECOMP" 0}
 @{"values            " link "VALUES" 0}

 W

 @{"WarGame Processor Editor " link "WGPEDIT" 0}
 @{"WarGame Processor player " link "WGP" 0}
 @{"WGP WWW page             " link "SUPPORT" 0}

@endnode
