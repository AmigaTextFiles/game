@database MasterMind
@master MasterMind.guide
@$VER: MasterMind Documentation 1.0 (24.04.97)
@author "Henning Thielemann"
@(c) "Copyright © 1997 Henning Thielemann"
@wordwrap
@NODE Main "MasterMind directory"

	Welcome to the
	@{b}unique MasterMind solvers collection@{ub}

	0.	@{" Motivation " link Motivation }

	1.	The programs in
	1.1.	@{" ZX Spectrum Basic " link ZXSpectrumBasic }
	1.2.	@{" Amiga Basic       " link AmigaBasic }
	1.3.	@{" GFA Basic         " link GFABasic }
	1.4.	@{" Blitz Basic II    " link BlitzBasic }
	1.5.	@{" Cluster           " link Cluster }

	2.	And now?
	2.1.	@{" My imagine of a MasterMind game " link Future }
	2.2.	@{" Disclaimer " link Disclaimer }

@ENDNODE
@NODE Motivation

@{b}What the hell can make someone programming lots of MasterMind solvers?@{ub}

 In former times I played MasterMind sometimes.  As you know that's often
the reason for porting a game to the computer.  But I didn't want to
program a game, where I have to guess myself.  That means realtime thinking
- not that what I feel as entertainment.  I wanted an algorithm which
solves the code I creates.  An algorithm I can derive my own solution's
strategy from.
 The first try I made on my ZX Spectrum in about 1988. It was very slow but
shows that the computer always finds a very short solution. Humans
sometimes insert save tries, e.g.  change only one color or one place, to
be sure that a color is needed or has the right place.
 All algorithms presented here are common in that point, that they only
show codes which don't contradict with the previous evaluations.  That
means for every code suggestion is checked, if the previous suggestions
would get the evaluations they really get assuming the new suggestion is
the searched code.  This enables the short solutions.  The difference
between the algorithms are the ways of finding valid codes.  They all
should be fast enough for simple codes with 4 of 8 colors or something in
this scale.  But rising dimensions separates the wheat from the chaff.
Think of a 5 of 26 letters code which has 1000 times possibilities of a 4 of
10 figures code.
 Later on the Amiga I re-wrote the first version in GFA-Basic, making it a
little more flexible. Some day I had a new idea which I implemented in
those days current BlitzBasicII. But the breakthrough I realized in
Cluster.
 I found out that a friend of mine (Daniel Beer) has programmed a
MasterMind solver too, and I decided to join it to this collection.
 All programs exists in several formats: The custom source code format of
the language, the source code as ASCII text and a compiled version. The
AmigaBasic and GFABasic examples could not be compiled because we haven't
such compilers. If there is someone who can compile the programs for us -
feel free to do it and send us the executable files.

@ENDNODE
@NODE ZXSpectrumBasic "MasterMind solver on ZX Spectrum"

@{b}How to use?@{ub}

 Probably you have never worked with a ZX Spectrum. So I tell you the
steps to run it. First you need a ZX Spectrum emulator. I use the ZX
Spectrum emulator of Peter Mc Gavin. If you have another emulator (ZX-AM)
which can load .snapshot-files this should work too.
 There are two versions: the BASIC source and the compiled program, every
both as .snapshot and as tape file image. For everyone who has never used
a ZX Spectrum the .snapshot versions should be the easiest:
 The snapshot files contains the whole RAM of the ZX Spectrum and the
CPU register contents. Since most of the memory is empty the snapshot files
are very efficiently to crunch.  For the snapshot I choosed a state direct
after loading and typing the command for starting the program. The only
thing you have to do is:
 1. Loading the snapshot file
 2. Hit <enter> to execute the currently visible command that runs the
program.
 ZX Spectrum experts may prefer the tape file images. Switch the menu to
load from disk. Now the LOAD commands from the Spectrum editor are
re-directed to Amiga disks.
 To load the Basic program type:
LOAD "" <ENTER>	(J, Alt-P, Alt-P, <RETURN>)
Select the
"MasterMindBASIC.header" file in the first file requestor and 
"MasterMindBASIC.bytes" in the second file requestor. Then type
RUN <ENTER>	(R, <RETURN>)

 To load the compiled Basic program type:
LOAD ""CODE <ENTER>	(J, Alt-P, Alt-P, Alt-Shift, I, <RETURN>)
Select the
"MasterMindMC.header" file in the first file requestor and 
"MasterMindMC.bytes" in the second file requestor. Then type
RANDOMIZE USR 50000 <ENTER>	(T, Alt-Shift, L, 5, 0, 0, 0, 0, <RETURN>)

 Some german words may confuse you. Sorry I was to lazy to translate them
now. If you know that "schwarz" means "black" and "weiß"/"weiss" means
"white" you shouldn't have any problems when the computer asks you for the
number of black and white stones.

@{b}How does it work?@{ub}

 The algorithm assumes that your code has no figures appearing more than
once. It is fixed to 4 of 9 figures as you can see in the four nested
FOR-loops. They run through all possibilities and check them with the
previous suggestions. The worst case happens if you give wrong evaluations.
Then the algorithm has no choice but scanning all possibilities and finding
that there is no one.
 To accelerate the scan I build in a two level check.  First it compares
the number of fitting figures (independent of the place) to every previous
suggestion. If it fits the figures are permutated to get a order that also
satisfies the place restrictions. Here occurs a little bug, which don't
influence the success of the search but the needed time. After requesting
the user for an evaluation it don't try the other permutations but skips to
the next number to check. E.g. if the suggested code always contains all
correct figures (what you confirm with your evaluation), the algorithm
could find in a short time the correct code by testing further
permutations. But due to this bug it doesn't and returns to the slow scan
mode. It will find your code later because the algorithm scans through all
possibilities. That also means that the worst case is not weaken by the
permutation test.

@ENDNODE
@NODE AmigaBasic "MasterMind solver in Amiga Basic"

This is the one algorithm written by Daniel Beer.

@{b}How to use?@{ub}

 First you need an AmigaBasic interpreter. If you don't have, ask Amiga 500
users for it. Start the AmigaBasic program, open the MasterMind.bas file
and run it from menu or by typing "run" in the output window. That's all
you have to do, and it's all you can do.
 The program creates the code, guess and evaluates automatically. You can
only check if it does everything correct.

@{b}How does it work?@{ub}

 As Daniel says, this algorithm was quick programmed.  Therefore it needs
more time to solve. It creates an array where every possible code has a
boolean value. This values reflect if a code is still possible regarding to
all evaluations made before. The algorithm works like an sieve. After
every evaluation it scans the boolean array for still possible codes and
eliminates all codes that was possible before but become impossible after
the new evaluation.
 You can easily see that the algorithm becomes faster with every step. But
the handicap is that the first scan already needs the time my Spectrum
algorithm needs in the worst case!

@ENDNODE
@NODE GFABasic "MasterMind solver in GFA Basic"

@{b}How to use?@{ub}

 You must have an GFA Basic 3.5 interpreter, run only interpreter or
compiler. In the last case you should send us a compiled version of this
program so we can distribute it in the next release.
 In the PROCEDURE preferences (unfold with HELP key) you can edit the
parameters:
 anzbuc	- number of available characters
 anzbr	- number of characters a code should be build of
 anzver	- number of tries the computer should do before giving up
 fbuc	- ASCII code of the first available character
 The algorithm assumes that you create codes of characters with ASCII codes
from fbuc to fbuc+anzbuc-1 without multiple appearance of one character. To
evaluate the computer suggestions type x for every character that's on the
right position (black stone) and o for every character that's in your code
but not at this position.

@{b}How does it work?@{ub}

 The algorithm is a direct port from the ZX Spectrum source. But it
prevents the permutation bug and therefore can be made a bit faster in
noticing wrong evaluations.  It only runs from e.g.  0123 to 6789 checking
only codes with characters in rising order. All other possibilities are
found via permutations.

@ENDNODE
@NODE BlitzBasic "MasterMind solver in Blitz Basic"

@{b}How to use?@{ub}

 If you have an BlitzBasicII compiler you can compile&run the program from
the editor. Otherwise you can use the compiled version. Note that the
compiled program is not breakable! (And you will need the break feature if
the program decides for its worst case :-)
 You may modify some constants:
 numascii	- number of available characters
 numdigits	- number of characters a code should be build of
 numtries	- number of tries the computer should do before giving up
 firstascii	- ASCII code of the first available character
 joywait	- confirm every step by pressing joystick fire
 showsearch	- display every code the program checks
 As in the GFA-Basic version your code must not contain multiple
characters. You have to type "x" for black stones and "o" for white stones.

@{b}How does it work?@{ub}

 First I thought this technique can shorten the search the GFA-Basic
version does. But it doesn't. It has even a worst case if you do all
evaluations correct.
 It begins at the first position, counting the character from the first
possible to the last possible. For every character in the first column all
possible characters in the next column are checked and so on. A character
in a column is compared with the characters of former suggestions. If this
leads to an overflow of black or white stones in any former suggestion the
next columns are not checked for this character.
 It's easy to recognize that an high character in the first column leads to
the worst case. Every character before this character have to be checked.
But if a character is in the first column when it is not possible to be
there, it is not noticed until a character in a following column causes an
overflow.

@ENDNODE
@NODE Cluster "MasterMind solver in Cluster"

@{b}How to use?@{ub}

 This version is made for shell usage. You can pass all parameters from
cli. From the Cluster editor you may edit the default args-RECORD.
 Shell paramters (displayed by "MasterMind ?"):
COLUMNS  - number of characters a code should be build of (defaults to 5)
ELEMENTS - number of available characters (26 letters by default)	
CHAR     - the first available character ("A" for capitals (default), "0" for numbers)
SELFTEST - pass a code and the program checks if it can solve it
QUIET    - only useful with SELFTEST: supress output
MULTIPLE - allows multiple elements in your code (z.B. "AMIGA")
SORTED   - the solver tries new characters in rising order
 E.g. the first suggestion is "ABCDE". If you evaluate that nothing is
correct the next try will be "FGHIJ", and so on. Without SORTED new
characters will be choosen randomly, so you have no chance to annoy the
program by choosing a code with high characters.
 Again Xs and Os have to be typed in any order according to the suggested
code.

@{b}How does it work?@{ub}

 Hey, I'm really proud that it works. I thought of many possibilities how
to increase the search speed of the previous algorithms.  For instance what
criterion could help finding probably right characters, which would be
checked before others.  But I was very blinkered because every change that
not improves the basic idea of these algorithms (the scan for all ever
possible codes) would have the worst case if you evaluate wrongly.
 The Cluster algorithm differs from all others.  It is more like humans play
MasterMind, so you may wonder why I hadn't this idea before.  But I think
it @{u}is@{uu} just the problem to find an algorithm which is both fast and
easy to unterstand.
 First let's have a look at the function of the algorithm if symbols must
not repeat.
 The algorithm builds every suggested code directly from the symbols of the
previous suggestions. The first suggestion consists completely of random
symbols. The solver tries to assign your evaluation to the symbols. For
example the suggestion is ABCDE and you evaluate XO (one symbol is on the
right place, another is in your code but not at this position) the computer
assumes that A is meant with the X and the C is meant with the O. Now a
code will be created which contains the A on the same place and the C at
another -> AC???. About the ? we only know that these may be all Symbols
except A,B,C,D,E. Let the ?s fill so that ACFGH results. The evaluation of
this maybe one O. The computer now duplicates this code and stores the
complete code with evaluation in a history list.  After this it removes the
before filled chars, we have again AC???.  When the algorithm compares this
with the ACFGH code it recognizes that the evaluation had to be XX not O.
The algorithm concluses that a code matching to AC???  is not possible and
skips back to the ABCDE step. It remain A considering as X and try to use D
for O. This results in AD???. This is now checked with the next available code
ACFGH which results in X. That means a code AD??? is not possible because
every AD??? causes at least one X but the right (currently unknown) code
causes exactly one O with ACFGH. The same reason for AE???. The next things
tested are A?B??, A?D??, A?E??, A??B? and so.
 If you can't imagine how the evaluation is involved in the progressing
search, try to imagine that you have already a complete list of suggestions
and evaluations that describe exactly one code (or exactly no code if
a evaluation is wrong). Parts of this description are not directly visible,
they have to be loaded from disk, for instance. When you try to build a
possible code you prefer data already in memory. After this you have a code
that may contain ?  but fits to all codes in memory.  Now you have to load
a new code from disk, but in reality you complete your suggestion and ask
the user for evaluation. You join this result to your memory pool but
further work is done with the uncompleted code (containing some ?). This
additional code has to be checked with your uncompleted code. In case it
doesn't fit you have to revise earlier decisions.
 Did you already think about the symbols used for ?-completion? You can
only use symbols that have never been used in former and in the current
suggestions.  That's because in the one hand all symbols that are assumed
to be meant in earlier evaluations takes already place in your new code and
multiple symbols aren't allowed.  In the other hand the symbols not meant
in earlier evaluations cannot be in the code because they are excluded by
being not evaluated. For instance ABCDE XO means not only that two symbols
are part of the searched code, but also that the other three symbols are
not in the target code!

 Allowing equal symbols (switch MULTIPLE) made me changing some things in
the algorithm. The most difficult is to keep track of the symbols already
assigned. The assignment of As below can occur if you don't make this
carefully:
G B A C D
   /|\\
E A A A F -> XOO instead of X
 Another problem is that the algorithm may lose its way when it replaces
the ?s with different symbols.  That's why the computer begins always with
an suggestion of equal symbols in MULTIPLE mode.  This seems not to be very
clever but should not need more cycles than a mixed completion because
codes with many equal symbols are possible, too.  The resulting strategy is
very obviously, so obviously that even humans can adapt this for own
purposes.  After I see how my Amiga works it was no problem for me to solve
MasterMind codes with multiple colors although I used to play MasterMind
without repeating colors.

@ENDNODE
@NODE Future

@{b}What shall we learn from it?@{ub}

 Never believe an algorithm you programmed is not able to be improved!
Never believe an algorithm works right! A program that seems to have no bugs
is not correctly used! I built in a scan procedure in the Cluster version
of MasterMindSolve that do a self-test on all possible codes.  It showed me
some difficult to find codes that didn't work.  Now I have runned the scan
with 4 of 10 figures (300s) and 3 of 10 figures (240s on my 14MHz A500)
both in multiple and in single mode and it seems to work.

@{b}Is there any fun in playing it?@{ub}

 You may consider this variant of MasterMind boring, because you haven't to do
anything but typing evaluations and being angry about mistakes. My imagine
of a final MasterMind would be a game with this features:
1. Graphic, sound and registering fee of the MasterMind version by Dan Saeden.
2. The usability of the CodeFinder by Derek Piper.
3. The code hiding animation of the MindMaster of Thomas Streichan.
4. The configurability of SuperMeisterMind by Holger Voss.
5. The size of WBMind by Sophocles Metsis :-)
6. And these options:
     (knowing that these lead to serious conflicts with a noble designed GUI)
	- number of columns and elements
	- colors or letters or figures as elements
	- single/multiple color mode
	- one/two player mode: player A and B creates their codes
		player A suggests a code,
		player B evaluates and makes a suggestion for A
		player A evaluates and makes a suggestion for B
		and so on.
	- one or both players maybe the Amiga

 Who want to do this best MasterMind of all good MasterMind's? Who want's
to use my algorithm to make the Amiga a strong opponent? (See
@{"Disclaimer" link Disclaimer} before deciding for it.)

Please contact me at
Henning Thielemann
Veilchenweg 34
06118 Halle
Germany

henning.thielemann@student.uni-halle.de

@ENDNODE
@NODE Disclaimer

Disclaimer
==========

 There is no warranty for the program, to the extent permitted by
applicable law. Except when otherwise stated in writing the copyright
holder and/or other parties provide the program "as is" without warranty
of any kind, either expressed or implied, including, but not limited to,
the implied warranties of merchantability and fitness for a particular
purpose. The entire risk as to the quality and performance of the
program is with you. Should the program prove defective, you assume the
cost of all necessary servicing, repair or correction.

 In no event unless required by applicable law or agreed to in writing
will any copyright holder, or any other party who may redistribute the
program as permitted above, be liable to you for damages, including any
general, special, incidental or consequential damages arising out of the
use or inability to use the program (including but not limited to loss
of data or data being rendered inaccurate or losses sustained by you or
third parties or a failure of the program to operate with any other
programs), even if such holder or other party has been advised of the
possibility of such damages.

 It is allowed to use the algorithms presented here in your own programs
only if you include a remark that I'm the author of these algorithms in your
program's manual or in your program itself and if your program is freely
distributable without expecting any fee (like Shareware). If you want to
distribute your software with my algorithms commercially or as Shareware
you have to ask me for permission.  Every modifications or usage of my
algorithms in your programs has to be announced to me!

@ENDNODE
