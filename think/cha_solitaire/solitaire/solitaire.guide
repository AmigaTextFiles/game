@database solitaire.guide
@$VER: solitaire.guide 1.1 (1999.09.02) Е Claude Heiland-Allen

4567

@node main "Solitaire.guide"

    Solution to the solitaire puzzle game.

    @{" Background     " link background    }
    @{" Usage          " link usage         }
    @{" The Solution   " link solution      }   <-- read this!
    @{" Implementation " link implementation}
    @{" Author         " link author        }

@endnode

@node background "Solitaire.guide/Background"

Solitaire is a simple game, played with 32 pieces on a cross shaped
board.  The aim is to jump pieces over each other, removing the jumped
piece, until only one piece is left in the centre square.  Diagonal
jumps are not allowed.

This program finds a @{"solution" link solution} to the puzzle, and as I already used it
to find a solution the program is a bit unneccessary now.

Start position:

      000
      000
    0000000
    000и000
    0000000
      000
      000

End position:

      иии
      иии
    иииииии
    иии0иии
    иииииии
      иии
      иии

Example move:

    00и  ->  ии0

@endnode



@node usage "Solitaire.guide/Usage"

CLI:
    solitaire

WB:
    (not tested - should work though)


The program outputs the best result so far (number of pieces left) to
show that it is doing something.

Then it prints the solution, starting with the final board and the
moves to get to it, listed IN REVERSE ORDER.

Finally the number of board positions considered is printed (should
be 1903390).

@endnode



@node solution "Solitaire.guide/The Solution"

Well, strictly speaking it is one of a number of solutions, but you
only need one.  This is just the output of the program edited to make
it more accessible.


Coordinates:

    7   иии
    6   иии
    5 иииииии
    4 иииииии
    3 иииииии
    2   иии
    1   иии
      1234567


Format:
    "move: from->to [remove]"


The moves:

01: (2,4)->(4,4) [(3,4)]
02: (3,2)->(3,4) [(3,3)]
03: (1,3)->(3,3) [(2,3)]
04: (1,5)->(1,3) [(1,4)]
05: (3,4)->(3,2) [(3,3)]
06: (3,1)->(3,3) [(3,2)]
07: (3,5)->(1,5) [(2,5)]
08: (3,7)->(3,5) [(3,6)]
09: (4,3)->(2,3) [(3,3)]
10: (1,3)->(3,3) [(2,3)]
11: (4,1)->(4,3) [(4,2)]
12: (4,3)->(2,3) [(3,3)]
13: (4,5)->(2,5) [(3,5)]
14: (1,5)->(3,5) [(2,5)]
15: (4,7)->(4,5) [(4,6)]
16: (4,5)->(2,5) [(3,5)]
17: (6,3)->(4,3) [(5,3)]
18: (5,1)->(5,3) [(5,2)]
19: (5,3)->(3,3) [(4,3)]
20: (2,3)->(4,3) [(3,3)]
21: (4,3)->(4,5) [(4,4)]
22: (5,5)->(3,5) [(4,5)]
23: (2,5)->(4,5) [(3,5)]
24: (5,7)->(5,5) [(5,6)]
25: (5,4)->(5,6) [(5,5)]
26: (7,5)->(5,5) [(6,5)]
27: (4,5)->(6,5) [(5,5)]
28: (7,3)->(7,5) [(7,4)]
29: (7,5)->(5,5) [(6,5)]
30: (5,6)->(5,4) [(5,5)]
31: (6,4)->(4,4) [(5,4)]

@endnode


@node implementation "Solitaire.guide/Implementation"

This section contains notes on how the program was written, starting
with general observations and moving to greater detail.

As each move removes a piece, the game is finite (unlike eg. chess).

A depth first search is used, to reach a solution more quickly (in
the best case scenario), and easier to implement.

All boards are stored, to allow repetition to be pruned from the
tree; rotations and reflections are also considered.
(Not implemented - too complex)

Board squares can be divided into types:

  bob       X >= 1 (key pieces)
  aXa
bobobob     ao and bX are pairs - need ao >= 1 until last move
aXaXaXa     (Not implemented - not useful (checks if legal moves))
bobobob
  aXa
  bob

Checking that there is at least one X left (to fill the center)
prunes the move-tree considerably, giving a *huge* speed-up.

Possible moves are stored in a table, precalculated by another program
(commented out, table directly in source with minor changes to layout
etc).

The main function checks which of the possible moves are legal, then
recurses to check them.

The board data is not stored optimally, but simply; this allows much
simpler (faster) code.  Stack requirements are small (about 5k -
32 deep * about 100-200 bytes per level).

Summary: the program isn't particularly elegant or well written, but
it works (in a few hours on a 7 MHz 68000 - the version without the
checks took over 16 hours to come up with the wrong solution (the last
piece wasn't in the centre - oops)).

@endnode



@node author "Solitaire.guide/Author"

Claude Heiland-Allen is about to start a BA in Mathematics and
Computation at Lincoln College, Oxford University, UK.

His hobbies include making strange music, strange programming, and
strange maths - usually in some kind of combination.

Mail me about anything you want.


cheilandallen@yahoo.co.uk

@endnode
