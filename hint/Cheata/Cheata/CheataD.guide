@DATABASE "Cheata"

@smartwrap

@node Main "Cheata Guide"
@{" Einführung              " link "INTRO"}


@{" Beispielhafte Anwendung " link "EXAMPLE"}


Hauptfenster

@{" Size                    " link "SIZE"}

@{" Alignment               " link "ALIGNMENT"}

@{" Search Value            " link "SEARCHVALUE"}

@{" Replacement             " link "REPLACEMENT"}

@{" Update                  " link "UPDATE"}

@{" Start Search            " link "STARTSEARCH"}

@{" Listview                " link "LISTVIEW"}


Makrofenster

@{" Comment                 " link "COMMENT"}

@{" Replacement             " link "MREPLACEMENT"}

@{" Delete                  " link "DELETE"}

@{" New                     " link "NEW"}

@{" Execute                 " link "EXECUTE"}

@{" Listview                " link "MLISTVIEW"}


@{" Menü                    " link "MENU"}


@{" SegTracker              " link "SEGTRACKER"}


@{" ----> Registrierung     " link "FEEDME"}


@{" Programmgeschichte      " link "HISTORY"}


@{" Technisches             " link "TEKKNO"}

@endnode


@node INTRO "Einführung"
Cheata ist ein Programm, mit dem sie Werte im RAM ihres Computers
gezielt verändern können. Diese Werte müssen positiv und
ganzzahlig sein.

Primäre Anwendung findet Cheata im Verändern von einzelnen Werten,
die in Unterhaltungssoftware eine zentrale Stelle einnehmen und
ansonsten oftmals nur über komplexe und diffizil zu bewältigende
Handlungsfolgen beinflußt werden könnten. Zu diesem Zwecke müssen
die Programme allerdings das Multitasking unangetastet lassen,
damit Cheata quasiparallel zu ihnen laufen kann.


Als sinnvoll hat sich in der Praxis die kombinierte Nutzung von Cheata
und SegTracker erwiesen. SegTracker ist neueren Versionen von Enforcer
beigefügt und beispielsweise auf den NDU3.1- oder den Fish-Disketten
(z.B. 912, 959, 1000) zu finden. Nötig ist SegTracker nicht, es ist
nur als Komfortbonus anzusehen.


Die Anleitung sollte möglichst komplett durchgelesen werden. Vorschnelle
Verwendung von Cheata kann zu unbefriedigender Arbeitsweise des Programms
führen. Auch ist es mit Cheata leicht möglich, ein anderes Programm oder
das gesamte System zum Absturz zu bringen.
@endnode


@node EXAMPLE "Anwendung im allgemeinen und beispielhaften Fall"
Im folgenden werden allgemeine Aussagen durch ein fortlaufendes
Beispiel verdeutlicht. Hierzu wird die Administrationssimulationssoftware
SomniaZity® benutzt, die als vorhanden vorausgesetzt wird. Der zentrale
Wert wäre hier nun also $. Dieser Wert kann zu Beginn recht einfach,
wenn auch nur in drei Varianten vorbestimmt werden. Danach ist man
der Willkür des Programms ausgeliefert. Hier schafft sich nun
Cheata seinen Nutzwert.


Zuerst starten sie SegTracker. Sie können SegTracker auch direkt in
die startup-sequence oder user-startup aufnehmen.


Nun starten sie das zu manipulierende Programm.
Lassen sie das Programm soweit ablaufen, bis sie einen klaren
Einblick auf den aktuellen Stand des zu verändernden Wertes (im
folgenden Suchwert genannt) haben. Versetzen sie das Programm danach in
einen statischen Zustand solcher Gestalt, in der der Suchwert konstanten
Wert beibehält.

Im Beispiel würden sie SomniaZity® starten, den Schwierigkeitsgrad
wählen und und die Spielgeschwindigkeit auf Paused stellen. Wir nehmen
an, daß der von ihnen gewählte Schwierigkeitsgrad ihnen $10000 zur
Verfügung stellt.


Starten sie Cheata und geben in das mit Search Value betitelte
Stringgadget den Suchwert ein, in das darunter liegende Stringgadget
geben sie den Ersatzwert ein.

Im Falle von SomniaZity® tragen sie also oben 10000 und darunter einen
anderen, ihnen angemessen erscheinenden Wert ein, z. B. 500000.


In den beiden oberen Blättersymbolen wählen sie die korrekten, möglicherweise
experimentell zu bestimmenden Einstellungen für Size und Alignement an.

Für SomniaZity® lauten diese Einstellungen beidemal Longword.


Betätigen sie danach das Start Search Buttongadget. Je nach Konfiguration
ihres Computers und den den oben festgelegten Suchparametern kann der
dadurch ausgelöste Vorgang einer sehr kurze, eine kurze, eine mittlekurze
oder eine langkurze Zeitspanne benötigen. Währenddessen betrachten sie
bitte den Farbbalken, der in der Zeitspanne von 0 auf 100% zu kommen
versucht. Nachdem der Farbbalken dies geschafft hat, kann es noch zu
weiteren Verzögerungen kommen, die durch die Zusammenarbeit mit SegTracker
bedingt sind.

Im SomniaZity®-Beispiel gilt es hierbei nichts besonderes zu beachten.


Alle im Speicher ihres Computers gefundenen Werte gleich dem Suchwert werden
nun im Listviewgadget angezeigt. Identifizieren sie die Adresse, an der der
zu verändernde Wert liegt. Wird nur einer dargestellt, dann sollte es dieser
auch sein. Ansonsten helfen ihnen vielleicht die über SegTracker ermittelten
Informationen. Sollte dies nicht der Fall sein, so lassen sie das zu
manipulierende Programm weiterlaufen, bis sich der zu manipulierende Wert
verändert. Versetzen sie das Programm wieder in einen statischen Zustand
und betätigen sie in Cheata das Updategadget. Wählen sie den Sort Mode
Highlight an und identifizieren sie nun die richtige Adresse.

Im SomniaZity® Beispiel werden nun alle Adressen angezeigt, die den Wert
10000 enthalten. Es interessieren nur die, die als Loadname in ihrem Eintrag
SomniaZity® stehen haben (wird nur bei Kooperation mit SegTracker angezeigt).
Sollten hierbei mehrere Adressen auftauchen, so lassen sie SomniaZity® etwas
weiterlaufen, bis sich der $-Wert in SomniaZity® von 10000 unterscheidet.
Nun versetzen sie SomniaZity® wieder in den Paused-Modus und betätigen in
Cheata das Update-Gadget. Stellen Sie den Sort Mode auf Highlight.
Identifizieren sie so den Eintrag, der den neuen $-Wert reflektiert.


Um nun einen Wert zu verändern, wählen sie dessen Eintrag im Listviewgadget
mittels eines Doppelklicks an. Der Wert wird nun zwischen dem vorherigen
Suchwert und dem aktuellen Ersatzwert wechseln.

Im Falle SomniaZitys® üben sie auf den vorher identifizierten Wert einen
Doppelklick aus und beobachten, wie der Eintrag von 10000 auf 500000
wechselt.


Sie können nun Cheata beenden oder auch für eine weitere Nutzung im
Hautpspeicher belassen und mit dem Hauptprogramm ihre Arbeit fortsetzen.
Sollten sie in gleicher Sitzung noch einmal den betreffenden Wert ändern
müssen, so können sie Cheata im Hauptspeicher belassen und bei Bedarf
einfach einen neuen Wert ins Replacementgadget eintragen und den vorher
identifizierten Eintrag doppelklicken. Für eine spätere Nutzung merken
sie sich ggf. Loadname, Hunknum und Offset, die im Eintrag den
identifizierten Wert begleiteten. So wird eine spätere Identifizierung
sehr leicht möglich, sofern das zu manipulierende Programm nicht
zwischendurch neu compiliert wurde (Indikator dafür ist eine neue
Programmversion), in diesem Fall sollten sie die komplette Suchstrategie
neu anwenden.

In SomniaZity® könnten sie jetzt eine Megalopolis aufbauen. Für weitere
Manipulationen schreiben sie sich den Loadname, die Hunknum und den
Offset auf. Diese sind bei jeder Sitzung gleich, es sei denn, sie
wechseln beispielsweise von SomniaZity I® auf SomniaZity II® oder etwa
SomniaZity 2001®; ein Wechsel der Segmentstruktur ist hier wahrscheinlich.


----------Anhang zur Version 1.1

Cheata verfügt ab V1.1 über eine Makrofunktion. Diese dient dazu, einmal
identifizierte Addressen dauerhaft abzuspeichern und bei Bedarf ohne
erneutes Suchen wieder zu manipulieren. SegTracker ist dazu zwingend nötig.
Als besonders zeitsparend erweist sich diese Funktion bei Manipulation
mehrerer Werte in einem Programm.


Zuerst identifizieren Sie den Wert wie oben angegeben. Sollte sich dieser
im statischen Speicherbereich befinden (Loadname etc. wird angezeigt), dann
können Sie das Makrofenster mittels des Macro-Symbols öffnen und den Eintrag
per Drag&Drop in das Makrofenster übernehmen. Sollten Sie im gleichen Programm
mehrere Werte zu manipulieren wünschen, so identifizieren Sie deren Adressen
sukzessive und übernehmen Sie sie einzeln ins Makrofenster. Geben Sie
einen möglichst aussagekräftigen, informationsreichen Kommentar in das
Comment-Symbol ein und speichern Sie das Makro ab. Als Endung sollten Sie
unbedingt ".cheat" verwenden.

Später können Sie das Makro wieder einladen und über Execute alle Werte
gleichzeitig im Hauptspeicher manipulieren. Auch dafür muß SegTracker aktiv
sein.

@endnode

@node SIZE "Size"
Mittels des Size Gadgets legen sie die maximale Größe fest, die der zu
suchende Wert haben darf. Wenn sie vermuten, daß der Wert nicht größer
als 255 werden kann, so wählen sie Byte an, entsprechendes gilt für
Werte kleiner oder gleich 65535, die eine Word Einstellung verlangen.
Alle Werte darüber verlangen die Longword Einstellung.

Tatsächlich werden auch Werte, die garantiert nicht größer als etwa
100 werden, oftmals im Longwordformat abgelegt. Diese würden dann
aber von Cheata nur gefunden, wenn sie auch im Alignmentgadget
Byte anwählten.

Die Suche nach Longwords kann auf Rechnern mit 16Bit RAM (z. B. ein
nicht aufgerüsteter Amiga 500, 500+, 1000, 2000) etwa länger dauern
als die Suche nach Bytes oder Words.


Im Zusammenhang mit 68000 und 68010 CPUs gibt es noch eine Besonderheit
zu beachten. Diese CPUs können keine Werte im Word- oder Longwordformat
von einer ungeraden Speicherstelle lesen. Im Alignmentgadget dürfen
sie also für diese Formate nicht Byte einstellen. Cheata wird
fehlerhafte Einstellungen deshalb korregieren. Auf CPUs >= 68020
sind diese Kombination zwar zulässig, bleiben aber extrem unwahrscheinlich
und sollten deshalb nicht verwendet werden.

@endnode

@node ALIGNMENT "Alignment"
Mittels des Alignment Gadgets legen sie die Speicherpositionen fest,
an denen gesucht wird. Bytealignment läßt Cheata an jeder Speicherzelle
suchen, Wordalignment an jeder glatt durch zwei teilbaren und
Longwordalignment an jeder glatt durch vier teilbaren.

Im allgemeinen kann man davon ausgehen, das Werte im Wordformat auch
mindestens Wordalignment haben. Werte im Longwordformat sind meist
auch longwordaligned.

Da Cheata beispielsweise bei einer Bytealignmenteinstellung viermal
soviele Speicherstellen inspizieren muß wie bei einer Longwordeinstellung,
wird also die Suchzeit nicht unwesentlich durch dieses Gadget beeinflußt.


Im Zusammenhang mit 68000 und 68010 CPUs gibt es noch eine Besonderheit
zu beachten. Diese CPUs können keine Werte im Word- oder Longwordformat
von einer ungeraden Speicherstelle lesen. Im Alignmentgadget dürfen
sie also für diese Formate nicht Byte einstellen. Cheata wird
fehlerhafte Einstellungen deshalb korregieren. Auf CPUs >= 68020
sind diese Kombination zwar zulässig, bleiben aber extrem unwahrscheinlich
und sollten deshalb nicht verwendet werden.


@endnode

@node SEARCHVALUE "Search Value"
In dieses Gadget tragen sie nun den Wert ein, nach dem Cheata im Speicher
ihres Computers suchen soll. Sie können hier aber nur ganze, positive
Zahlen eintragen. Außerdem richtet sich der maximale Wert auch nach der
Einstellung des Sizegadgets.

Die Zeit, die Cheata dann für einen Suchvorgang benötigt, richtet sich ganz
entschieden nach dem hier eingetragenen Wert. Kleine Werte (wie 0, 1, 3...)
werden sehr oft im Speicher vorkommen, große und "krumme" Zahlen
(z. B. 9481) dagegen nur selten. Jedesmal, wenn Cheata also einen passenden
Wert findet, muß die Speicherstelle gemerkt werden, muß SegTracker über
weiter Informationen bezüglich dieser Speicherstelle befragt werden, muß ein
Eintrag im Listviewgadget geschaffen werden. Dies dauert wesentlich länger
als das einfache Durchsuchen des Speichers. Etwa nach dem Wert 0 zu suchen,
ist deshalb nicht empfehlenswert.

Ein weiteres Problem besteht darin, daß für jeden gefunden Wert der Eintrag
ins Listviewgadget etwas Speicher kostet, bei vielen tausend aber kann
der zur Verfügung stehende Speicher schnell knapp werden. Sollte im Verlauf
der Suche der freie Speicher ausgehen, so werden keine weiteren
Einträge mehr ins Listviewgadget aufgenommen, die Liste der gefundenen
Werte wäre also unvollständig.

@endnode

@node REPLACEMENT "Replacement"
In diese Gadget tragen sie den Wert ein, der den an bestimmten Adressen
den Suchwert ersetzen soll. Seine maximale Größe richtet sicht nach der
Einstellung des Sizegadgets zum Zeitpunkt der Suche. Sollte das zu
manipulierende Programm selbsttätig den zu manipulierenden Wert
erhöhen können, dann sollten sie nicht den Maximalwert eintragen, da es in
der Praxis sonst oftmals zu unerwünschten Effekten kommt.

@endnode

@node SORTMODE  "Sortmode"
Mittels dieses Gadgets legen sie fest, in welcher Reihenfolge die
Einträge des Listviewgadgets dargestellt werden.

Address: Die Einträge werden entsprechend den Werten der Address-Spalte
angezeigt. Kleinste Adressen kommen zuerst.

Name: Die Einträge werden entprechend den Einträgen in der Loadname Spalte
alphabetisch sortiert. Bei gleichem Namen entscheidet der Wert der Hunknum
Spalte, dann der der Offset Spalte.

Highlight: Hier werden nun zuerst die Werte angezeigt, die highlighted
sind, innerhalb und außerhalb dieser Gruppe erfolgt die Sortierung dann
weiter wie bei Name.

@endnode

@node UPDATE "Update"
Die durch das Updategadget ausgelöste Funktion bekommt besonders dann
Bedeutung, wenn nach einem ersten Suchdurchlauf nicht mit Sicherheit
gesagt werden kann, welcher Eintrag im Listviewgadget den zu
verändernden Wert repräsentiert.

Alle Adressen, an denen der Suchwert gefunden wurde, werden durch die
Updatefunktion wieder überprüft und im Listviewgadget neu angezeigt.
Sollte sich ein Wert verändert haben, so wird der korrelierende
Eintrag gehighlighted. Sollte der Sortiermodus auf Highlight stehen, so
werden die Einträge auch automatisch neu sortiert.

@endnode

@node STARTSEARCH "Start Search"
Mit diesem Gadget wird der Suchvorgang eingeleitet. Erst zu diesem
Zeitpunkt wird der Suchwert auf Korrektheit bzgl. der Einstellung
des Sizegadgets überprüft, ggf. macht ein Requester auf die falsche
Eingabe aufmerksam, stoppt den Suchvorgang und gibt Möglichkeit zur
Korrektur.

Ist alles korrekt, öffnet sich ein zweites Window, in dem sich
eine Fortschrittsanzeige und ein Cancelgadget befinden, mit dem
man den Suchvorgang abbrechen kann. In diesem Fall werden nur die bis
dahin gefundenen Einträge angezeigt. Die Fortschrittsanzeige schreitet
nicht unbedingt proportional zu der Zeit fort, die im Verlauf des
Suchvorgangs benötigt wird. Da nur der belegte Speicher durchsucht
wird, kann es manchmal zu großen Sprüngen in der Anzeige kommen.

Die Suche ist beendet, sobald das Window sich schließt. Zu weiteren
Verzögerungen kann es aber dadurch kommen, das erst nach Abschluß des
Suchvorgangs die gefundenen Adressen von SegTracker überprüft werden.
Hierzu muß leider kurz das Multitasking abgeschaltet werden, sollte
also der Mauspointer sich nicht mehr bewegen lassen, so ist das System
nicht (unbedingt) abgestürzt. Bei sehr vielen Einträgen benötigt MUI
manchmal geraume Zeit, um die Namen im Listviewgadget anzuzeigen.

@endnode

@node LISTVIEW "Listview"
Im Listviewgadget wird das Suchergebnis dargestellt. Jedesmal, wenn der
Suchwert im Speicher gefunden wird, wird für ihn eine Ergebniszeile
im Listviewgadget eingerichtet.


Die ersten drei Spalten enthalten nur dann Einträge, wenn SegTracker
aktiv ist und die Adresse eines Suchwerts einem Segment zugeordnet werden
konnte.

@{B}Loadname:@{UB} Der Loadname gibt den Namen des Programms an, in
dessen Segment der Wert gefunden wurde. Dieser ist meist identisch
mit dem Namen, der dem Programm auf einem nichtflüchtigen Datenträger
zugeordnet ist. Manchmal enthält der Loadname auch noch die Pfadangabe.

@{B}Hunknum:@{UB} Ein Programm besteht meist aus mehreren Hunks. Die
Hunknum(ber) gibt an, in welchem Hunk der Wert gefunden wurde.

@{B}Offset:@{UB} Hier nun der Offset zum Hunkanfang, an dem
der Wert gefunden wurde. (Achtung: Sporadisch treten "unsinnige"
Offsets auf. Diese sind im Falle von Cheata aber genau so wie
"normale" zu behandeln.)


@{B}Address:@{UB} Die Address-Spalte gibt an, wo der Wert im Speicher
gefunden wurde.

@{B}Value:@{UB} Die Value-Spalte gibt direkt nach Beendigung eines
Suchvorgangs den Suchwert wieder, wenn dieser zur Zeit des Suchvorgangs
an einer bestimmten Addresse anlag. Da Cheata aber im Multitasking läuft,
kann nachfolgend auf den Suchvorgang der Wert an einer beliebigen
Adresse von einem anderen Programm geändert werden. Insofern ist diese
Spalte nur als Augenblicksaufnahme zu verstehen. Dies gilt analog, wenn
durch Cheata ein Wert verändert wird.


Ein Wert an einer bestimmten Adresse wird nun verändert, indem man die
entsprechende Eintragszeile doppelklickt. Sollte der Wert dieser Zeile
dem alten Suchwert gleichkommen, so wird als neuer Wert derjenige
eingetragen, der im Replacementgadget steht, ansonsten wird der alte
Suchwert zurückgeschrieben. Die maximale Größe des Ersatzwertes ist
wieder vom Sizegadget abhängig, so wie es zum Zeitpunkt der Suchoperation
eingestellt war. Man kann also nicht nach einem Wert im Byteformat suchen
lassen und anschließend einen Wert im Word- oder Longwordformat eintragen.

Achtung: Wenn man unüberlegt Speicherstellen durch Cheata mit neuen
Werten beschreibt, so kann es sofort oder später zu unkontrollierbaren
Reaktionen eines oder mehrere Programme oder des gesamten Systems kommen.
Im ungünstigsten, wenn auch sehr unwahrscheinlichen Fall (dieser tritt
theoretisch alle 27001 Jahre auf, eher verrechnet sich also der Pentium
ihres Nachbarn) kann dies beispielsweise zu unerwünschten
Schreibzugriffen auf ihre Festplatte/aktuelle Diskette führen.

@endnode


@node COMMENT "Comment"
Hier tragen Sie bitte eine möglichst informative Beschreibung des Makros
ein, also Namen des zugehörigen Programms, Version (inkl. Sprache, Demo)
und auch, was verändert wird.

Beispiel:

SomniaZity® 2001 V1.003 Egyptian version, $ cheat

@endnode


@node MREPLACEMENT "Replacement"
Austauschwert für den Wert des Listviews.

@endnode


@node DELETE "Delete"
Löscht den angewählten Eintrag aus dem Makro.

@endnode


@node NEW "New"
Löscht das Makro komplett.

@endnode


@node EXECUTE "Execute"
Überträgt alle Werte in den Speicher. SegTracker muß aktiv sein!

@endnode


@node MLISTVIEW "Listview"
Ein Doppelklick übertragt den Wert des Replacement-Symbols in das Listview.
Der Wert wird nicht in den Speicher geschrieben, dies passiert erst bei
Anwahl des Execute-Symbols.

@endnode


@node MENU "Menü"
@{B}New:@{UB} Das aktuelle Makro wird gelöscht.


@{B}Open:@{UB} Ein Makro kann geladen werden.


@{B}Save:@{UB} Das Makro wird unter seinem alten Namen gespeichert.


@{B}Save As:@{UB} Das Makro wird unter einem neuen Namen gespeichert.


@{B}About:@{UB} Information über Cheata.


@{B}About MUI:@{UB} Informationen über MUI.


@{B}Quit Program:@{UB} Cheata wird verlassen.

@endnode

@node SEGTRACKER "SegTracker aus der Perspektive von Cheata"
Ein Programm ist oftmals, obwohl auf Diskette in einem Stück
stehend, in mehrere Hunks unterteilt. Wird das Programm nun
geladen, so wird jedem Hunk ein Segment im Speicher des Computers
zugeteilt, wobei die einzelnen Segmente weit voneinander entfernt
liegen können. Diese Segmente werden nun von SegTracker registriert,
so können alle Adressen innerhalb dieser Segmente später den
entsprechenden Programmen zugeordnet werden.

Als Anwender von Cheata hilft ihnen das folgendermaßen. Erstmal können
sie alle Adressen aus ihren Überlegungen sicher ausschließen, die
einem anderen Programm, als dem von ihnen zu manipulieren gewünschten,
entsprechen.

Zweitens sind all die Adressen, denen keine Loadname
zugeordnet ist, wahrscheinlich ebensowenig in Betracht zu ziehen, da
die Werte, die Cheata im allgemeinen zu verändern hat, normalerweise
direkt in einem Segment stehen. Umgekehrt ist also wahrscheinlich eine
der Adressen, die als Loadname den Namen des zu manipulierenden
Programms enthalten, die gesuchte.

Drittens können sie so bei wiederholter Veränderung eines Wertes in
einem Programm, diesem nach dem ersten Mal leicht wieder identifizieren,
wenn sich die Hunknum und den Offset merken, an dem er steht. Diese
sind nämlich, im Gegensatz zur Adresse, auch dann noch konstant, wenn
sie das zu manipulierende Programm aus dem Speicher werfen und später
neu einladen.

@endnode

@node FEEDME "Registrierung"
Cheata ist in der aktuellen Version Shareware. Wenn Sie Cheata nach einer
kurzen (15 Kalendertage) Evaluierungzeit weiterhin nutzen möchten, dann
müssen Sie Sich registrieren lassen. Die Gebühr beträgt 10 DM.
Da Sie bereits die komplette Version zur Verfügung haben, bekommen Sie
keine neue Version zugeschickt (die Gebühr hätte dann deutlich höher
ausfallen müssen). Stattdessen wird eine neue Version immer die
relevanten Vertriebswege für Sharware benutzen und auf diesem Wege auch zu
Ihnen gelangen.


Füllen Sie bitte das beigelegte Registrierungsformular aus, falten Sie
es doppelt und legen Sie, bei Barzahlung, einen 10DM-Schein dazwischen.
Den verschlossenen Umschlag senden Sie an die AA-Kontakperson:


Stefan Tiemann

Heisstr. 20a

D-48145 Münster

Deutschland


oder sie überweisen Sie (nur innerhalb Deutschlands!) auf das Konto:


Stefan Tiemann

Stadtsparkasse Dortmund

BLZ 440 501 99

KNR: 822058078



E-Mail Kontakt:

tiemant@uni-muenster.de



                         @{U}Extra Chance@{UU}

Im Registrierungsformular können Sie eine persönliche obskure Zahl zwischen
0 und 1.000.000 eintragen. Sollte diese obskure Zahl mit der bereits unter
notabeler Aufsicht gezogenen Gewinnzahl übereinstimmen, dann haben Sie
automatisch einen süßen, kleinen Esel gewonnen, der Ihnen frei per
GPA (German Pet Service) zugestellt wird. Zusätzlich bekommen Sie eine
Verpflegungsration für die ersten 3 Wochen zur Verfügung gestellt.

Ihr Esel hört auf den Namen Calvin Klein, ist stubenrein und ein sehr guter
Zuhörer, der auf all Ihre Fragen mit Ija antwortet. Er mag Kinder wie alte
Menschen gleich gern und gibt sich auch den Tag über mit Fernsehen zufrieden,
falls Sie Ihn einmal alleine lassen müssen (was Sie aber sicher nie tun
wollen!).

Als Wachtier ist er perfekt, da er nur wenig Schlaf benötigt und
sich auch in einem großen Garten leicht zurechtfindet. Kostenfrei richten wir
ihn gerne vor Zustellung auf SM-DOS- oder WonderWhy95-User ab.

Lassen Sie sich diese einmalige Chance nicht entgehen, registrieren Sie sich
jetzt! (Auch Mehrfachregistrierungen ein und derselben Person zur
Maximierung der Gewinnchancen werden akzeptiert)




Die Autoren weisen darauf hin, daß sie für keinerlei Probleme, die im
Zusammenhang mit Cheata auftreten, noch für korrekte
Funktionsweise von Cheata irgendeine Haftung oder Gewährleistung
übernehmen.



Die Autoren sind im Verband der AA (Anonyme Amigauser) und bilden
dessen Subgruppe SPK (System Programming Korporation). Das Ziel der
AA ist es, Menschen, die durch die Bill Of Gates an der
Wahrnehmung ihrer Rechte als freie, unprogrammierte Computeruser
gehindert werden, zusammenzuführen und eines Tages ohne Repressionen
seitens der Monopolmicroisten an die Öffentlichkeit treten zu lassen.
Die SPK bildet insofern den harten Kern der AA, als sie den
Amiga nicht nur nutzt, sondern ihm auch neue Software zuführen
möchte und den aktiven Kampf gegen das Imperium aufgenommen hat.

@{I}Wir rufen hiermit dazu auf, überall im Lande neue SPK-Speicherzellen
zu bilden, um sie am TAG_END in einer einmaligen, schlagartigen Aktion
zu vernetzen und den großen@{UI} @{B}RESET@{UB} @{I}zu initiieren.@{UI}

@endnode


@node HISTORY "Programmgeschichte"

V1.0

Erste öffentlich zugängliche Version


V1.1

- Bessere Behandlung von Speichermangel

- Makrofunktion

- Mui 3.x Blasenhilfe

@endnode


@node TEKKNO "Technisches"
Cheata benötigt AmigaOS 3.0+ und MUI 3.0+



Cheata wurde komplett in Modula-2 programmiert und unter dem M2Amiga
System erstellt.

Das GUI vom Cheta wurde mittels MUI realisiert, nachfolgender Hinweis
ist dehalb zu beachten:


----------
@{JCENTER}

This application uses



MUI - MagicUserInterface


(c) Copyright 1993/94 by Stefan Stuntz


@{JLEFT}
MUI is a system to generate and maintain graphical user interfaces. With
the aid of a preferences program, the user of an application has the
ability to customize the outfit according to his personal taste.

MUI is distributed as shareware. To obtain a complete package containing
lots of examples and more information about registration please look for
a file called "muiXXusr.lha" (XX means the latest version number) on
your local bulletin boards or on public domain disks.

@{JCENTER}


If you want to register directly, feel free to send


DM 30.-  or  US$ 20.-


to



Stefan Stuntz

Eduard-Spranger-Straße 7

80935 München

GERMANY

----------

@{JLEFT}





@endnode
