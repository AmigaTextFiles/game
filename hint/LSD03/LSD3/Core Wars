                                CORE WARS

Translated in English by: Dimension 2001. Edited by PARASITE.


CORE WARS:
 In this game 2 programs written in a low-level language (like Assembler
 but called RedCode) must fight in the memory of a simulate computer.
 The field of battle consists of 8000 cells of memory and in each of
 them can be stored an instruction.
 The program that will make the other to execute one illegal instruction,
 will be named the winner of the game.
 The programs must be written using a normal editor that uses ASCII-code
 like Tx-ED or ED that you'll find on this disk.
 Programs must be written in a particular way:
 first 8 characters of each line are dedicated to field of Labels, the
 second to field of Instructions (it consists of 3 characters) and the
 third is reserved at Operands.
 Eách line of program must end with a ";" and also it's possible to add
 remarks after ";" or to dedicate full lines to remarks but they must become
 with the ";".
 Each program must end with a line composed only of one "."
 Memory's cells are composed by 5 fields:

    1) Comand : Operative-code of the instruction

    2) A mode : Way to address the A operand

    3) A      : A operand

    4) B mode : Way to address the B operand

    5) B      : B operand

  When we speak about a value stored in one memory's cell we refer to the
  last field of the cell (B operand).

  Instructions in RedCode use various way of addressing:

        '#' : Immediate

        '$' : Direct

        '@' : Indirect

        '<' : Auto-Decremented

  All references to memory's locations are necessarily relative to make
  possible a correct re-location of programs: it's impossible to address
  in absolute way a memory's cell.
  The instructions in RedCode are the following:

   Instruction   Code      Description

      DAT         0        Don't executable, contains data.
                           A operand is ignored.

      MOV A,B     1        Move A operand to B location.

      ADD A,B     2        Add operands A and B and put the result in B
                           location

      SUB A,B     3        Subtract the operand A from B and put the result
                           in the B location

      JMP A       4        Jump to A location.
                           B operand is ignored.

      JMZ A,B     5        Jump to A location if the value of B is 0.

      JMN A,B     6        Jump to A location if the value of B isn't 0.

      DJN A,B     7        Decrement by one the value of the B location,
                           then jump to A location if the result isnt't
                           0.

      CMP A,B     8        Compare the value of A operand with the value of
                           B operand, jump one instruction if they are
                           equal.

      SPL B       10       Start a parallel task from B location.

  The instruction MOV transfers all 5 fields unless if it's followed
  by a immediate addressing and, in this last case, it's like all
  instructions because it value only the fifth field.

  On this disk, moreover, you'll find some testing programs.
  They are:

  -Bluff
  -Chang1
  -Mice
  -Warp
