Part 2


 A CPR initialization script can be used to change options automatically
 when you invoke the debugger. See "CodeProbe Initialization" earlier
 in this chapter for more information.


 Source Mode
 There are three source modes: C, assembly, and mixed. The current
 source mode can be determined by means of the opt command or by
 activating the Options menu. It can be changed by means of the opt
 source command or the Source selection in the Options menu. C
 source mode is the default.
The syntax of the opt source command is as follows:


op[t] so[urce] c | a[sm] | m[ixed] | n[ext]


 Repeatedly choosing opt source next cycles through the three
 possible source modes.

 C Mode

 In C mode, CodeProbe displays C source lines when the trace or
 proceed commands are executed or when a breakpoint is triggered.
 To change the current source mode to C mode, enter the following
 command:


> opt source c


While in C source mode, you cannot single step by assembly
 instruction.

 Assembly Mode

 In assembly mode, disassembled code is displayed in the Source
 window. Single trace or proceed commands will step by assembly
 instruction.
To change the current source mode to assembly mode, use the
 following command:

> opt source asm

 Mixed Mode
 In mixed mode, both assembly instructions and C source lines, if
 available, are displayed in the Source window. For each C source line
 displayed, the corresponding assembly instructions are displayed as
 well.84 Chapter 4




To change the current source mode to mixed mode, enter the
following command:


> opt source mixed


 In mixed mode, you can take advantage of the two different forms of
the trace and proceed commands in order to step by either C
source line or assembly instruction.


Echo Mode 

When echo mode is on, commands are echoed in the Dialog window
before being executed. This option is useful if you want to execute
debugger command files and see the command lines as they are
executed along with their output. Commands that are invoked by menu
selections or double-clicking the mouse are also displayed as they are
executed. By default, this option is set to of f . It is not needed while
entering commands in the Dialog window because command lines are
displayed as they are entered anyway. The syntax is as follows:


op[t] e[cho] [on | off]


Instruction Bytes

The ibytes option affects the display format of disassembled code in
the Source window and the output of the unassemble command. If
the option is set to on, the second field of the disassembly contains a
hex dump of the instruction. The following fields contain the op-code
and its operands. If the option is set to off, the hexadecimal dump is
suppressed. The syntax is as follows:

op[t] ib[ytes] [on | off]

Here is an example:

> opt ibytes on
> unassemble 7
main:
7{
0025F950 48E70130 MOVEM.L D7/A2-A3,-(A7)
0025F954 BFEC0004CMPA.L0004(A4),A7
0025F958 65001BD6 BCS 00261530
> opt ib off
> unassemble 785 Setting Up the Debugging Environment




 main:
 7 {
 0025F950MOVEM.L D7/A2-A3,-(A7)
 0025F954CMPA.L 0004(A4),A7
 0025F958BCS 00261530


 Ignore Path 

 If the ignorepath option is set to on, CodeProbe ignores the
 directory part of the source filename. In this case, CodeProbe looks in
 the current directory for the source file. By default, ignorepath is
 set to of f and CodeProbe uses the entire pathname when searching
 for the source file. The syntax is as follows:

 op[t] ig[norepath][ on | off ]

 This option is useful in conjunction with the opt search command
 to override the source filename specified in the object file. For more
 information, see the SOURCEIS option in Chapter 8, "Compiling and
 Linking Your Program," of the SAS/C Development System User's
 Guide, Volume I: Introduction, Compiler, Editor.

Case Sensitivity

 The case option controls case sensitivity for the search command.
 The search command is used to search for a string in the Source
 window. When case is set to on, a case-sensitive search is made
 whenever a search command is executed. The syntax for the case
 option is as follows:

 op[t] cas[e][ on | off ]

Context

 As you proceed through an application program by tracing and
 breakpointing, CodeProbe always keeps the current source line or
 assembler instruction displayed in the Source window. CodeProbe
 attempts to keep at least a minimum number of context lines of code
 displayed above and below the current line. The number of these
 context lines can be controlled by the context option. Note that, in
 mixed mode, it is not always possible to keep the right number of lines
 above or below, but the source code line will always be displayed and
 the assembler instruction will be displayed if possible. The default
 number of context lines is 2. The maximum number of context lines
 possible is limited by the number of lines in the Source window. The
 syntax is as follows:

 op[t] co[ntext] integer86 Chapter 4


List Default 

The list option determines the number of source lines displayed by
the list command. The list command is discussed in Chapter 9.
The default value for this option is 6. The syntax is as follows:

op[t] l[ist] integer

Unassemble Default

The unassemble option determines the number of instructions
displayed by the unassemble command. The default value for this
option is 4. The syntax is as follows:

op[t] U[nassemble] integer

 Note that the default value is only used when no source file is
available. When a source file is available for a section of code,
unassemble displays the disassembly for a single source line by
default.

Radix Default 

The radix option controls the default input type for constants. The
choices are decimal and hexadecimal. The default is decimal. When set
to hex, this option can be used to avoid having to type the initial 0x
on hexadecimal constants. The syntax is as follows:

op[t] rad[ix] [d[ecimal] | h[ex]]

String Length 

The strlen option controls the maximum number of bytes that are
displayed when a character string is displayed with the di spl ay or
dzero commands. If the string contains bad characters, fewer may be
displayed. The default is 128. The syntax of the strlen option is as
follows:

 op[t] st[rlen] integer

The integer parameter specifies the number of bytes.

Array Dimension 
The arrdim option specifies the maximum number of array elements
that will be displayed by the display command. The syntax for the
arrdim option is as follows:

op[t] ar[rdim] integer

The integer parameter specifies the maximum number of array
elements. The default value is 20. Arrays with integer or fewer87 Setting Up the Debugging Environment





elements are displayed in their entirety. Larger arrays will have their
first integer elements displayed followed by an ellipsis (. . .).



Range Length

The rangelen option controls the default size of memory dumps
when no other source of information is available, for example, when
dumping an absolute addresss. The rangelen option is used when
commands such as display, dump, or watch have only an address
parameter. The rangelen option specifies the number of elements
after the address to display, dump, or watch. The syntax for the
rangelen option is as follows:

op[t] ran[gelen] integer

The integer parameter specifies default range size in number of
elements of a type to be displayed. The default value is 64.

Maximum Bad Chars

The badchar option determines how many nonprintable characters
must be encountered before the dzero or display command stops
printing a string. The syntax of the badchar command is as follows:

op[t] b[adchar] integer

The integer parameter specifies the number of nonprintable characters
allowed. The default value is 3. A 0 indicates no limit.

Search Path: 

The search path is used to find the source modules used when
compiling the application. When a module is compiled with one of the
debug options, the full pathname of the source module is saved in the
debug information. CodeProbe always looks for the source module in
its original location first, then it looks in the current directory, and
finally, it walks through each of the directories specified in its search
path in order. If you have moved the source module to some other
location, use the opt search command to add the new location to
your search path.
 The opt search command takes four forms:

Op[t] se[arch]
op[t] se[arch] dir[, dir[...]]
op[t] se[arch] + dir[, dir[...]]
op[t] se[arch] - dir[, dir[...]]88 Chapter 4




 The first form lists the current paths in the search path list, which is
empty by default. The second form sets the search path to the list of
directories on the command line. The third form appends the list of
directories on the command line to the current search path. The last
form deletes the list of directories from the current search path. This
list is empty by default. Here are some examples:

> opt search c:, df0:, dh0:mysource
> opt search + df1:test
> opt search - df0:, c:

The search option cannot be set from the Options menu.

Autoswap Mode 

When in autoswap mode, the screen containing the application's output
is pushed to the front each time CodeProbe gives control to the
application. When a breakpoint is reached, the debugger screen is
again pushed to the front. If you are single stepping through source
code, the switching of screens will probably appear as a brief flash. If
the autoswap mode is set to of f, which is the default, the application
screen will not be pushed to the front. The autoswap feature can be set
to on or of f with the opt command. The syntax is as follows:

op[t] au[toswap] [ on | off ]

 Autoswap mode is particularly useful when debugging programs that
require input from the keyboard. The application's screen is displayed
whenever input is required.

 Catch New Devices

When a device is opened for the first time a new task may be created.
If the process that opened the device is under debugger control, then
CodeProbe will catch the new task provided the Catch New Devices
option is set to on. The default setting for this option is off . The
syntax for the devices option is as follows:

op[t] d[evices] [ on | off ]

Step Into ResLib

The Step Into ResLib option allows the user to decide whether to allow
CodeProbe to step into resident libraries while tracing or runrling an
application with watch breaks. This option should remain set to of f
(default) unless you want to debug your own resident libraries. Tracing
into systern libraries such as Exec or Intuition can lead to
problerns. If this option remains off, it is safe to run with watch breaks
on while stepping over system resident libraries. However, you should89 Setting Up the Debugging Environment




disable all watch breaks before stepping into a ROM-resident library
routine. The syntax for the reslib option is as follows:

op[t] res[lib] on | off

Current Task

The current task is displayed by entering the opt command with no
parameters. This information cannot be displayed through the Options
menu. The following line indicates that a program named sort is the
current task and that execution has stopped at address 0001DC20.

Current Task........sort at 0001DC20

The current task cannot be changed with the opt command; however,
you can use the jump command to change the execution point.

Catch New Tasks
 
Whenever a new task is started by a task under CodeProbe's control,
the new task is also under CodeProbe's control by default. This does
not apply to tasks started by a call to the OpenDevice function. The
catch option enables you to turn task catching on or off. The
syntax of the catch command is as follows:

cp[t] ca[tch] [ on | off ]

Customizing Dialog Window Commands

In order to provide CodeProbe with a more versatile command
interface, the alias and def ine commands can be used to customize
the Dialog window commands. Aliases enable you to redefine or
customize commands. This capability is similar to the aliasing
capabilities found in the Shell. Defines provide CodeProbe with a
macro facility modeled after the C language's preprocessor #def ine
facility.

The Alias Command
 
The alias command is used to create new aliases, display the
definition of an existing alias, or display a list of all currently existing
aliases. The syntax for the alias command is as follows:


a[lias] [name[definition]]


When entered with no parameters, the alias command displays
the list of all currently defined aliases, with the alias listed on the left90 Chapter 4




 and the associated command on the right. The following example
 shows the list of aliases already defined for you by CodeProbe:


> alias
da dump $* $ ascii1
db dump $* $ hex1 text
dc dump $* $ dec1
dd dump $* $ float8
df dump $* $ float4
dffpdump $* $ ffp4
di dump $* $ dec4
dl dump $* $ dec4
dp dump $* $ hex4
ds dump $* $ dec2
dw dump $* $ hex2


The definition for an existing alias is displayed if the alias
 command is entered with only the name argument. The following
 alias command causes the definition for the dffp alias to be
 displayed:


> alias dffp
dffpdump $* $ ffp4


Alias names are only expanded when they occur at the beginning of
 a command line. An alias definition can be a simple textual substitution
 or it can contain positional parameters to be expanded at execution
 time.
Positional parameters are specified as $1, $2, $3, and so on. $0
 represents the alias itself. $* represents all command-line parameters.
 If no positional parameter is specified in a definition, all parameters
 are placed after the expanded definition until it encounters a semicolon
 (;) or an end of line. To define an alias that expands into more than
 one command, enclose the definition in either double quotes ("") or
 curly braces ({ }). If the command string must contain double quotes,
 curly braces must be used or the quotes must be escaped. A backslash
 (\) can be used to continue the line.91 Setting Up the Debugging Environment




 The following are examples of the alias command:


> alias print display
> alias dw
dwdump $* S hex2
> alias look2 "g $1; where; g S2; where"
> alias printgo {print "vars: ", S*; gO}


After entering these alias commands you could enter the following
command lines:


> look2 sort swap
sort:\sort.c\sort 20
1* In routine sort:\sort.c\sort 20
2 Called from sort:\smain.c\main 13 (+0xC)
3 Called from 0xC3162E
sort:\swap.c\swap 5
1* in routine sort:\swap.c\swap 5
2 Called from sort:\sort.c\sort 26 (+0x12)
3 Called from sort:\smain.c\main 13 (+0xC)
4 Called from 0xC3162E
> print tmp
10 (0xA)
> dw x
0036c4a4: 0000 0001
> go sort
> printgo i, p[i]
vars:0 (0x0)0 (0x0)
Program exited with code 0.


The alias definitions in the previous example expand to the following
commands:


display tmp
dump *y hex 2
g sort; where; g swap; where
display "vars: ", i, p[i]; go


 If at least one parameter is specified in a definition, all unused
parameters are thrown away in the expansion. Any unspecified
parameter results in an empty expansion. For example, assume the92 Chapter 4




alias given previously for look2. You can enter the following
command lines:

> look2 func1 func2 func3
> look2 func1

These command lines are expanded as follows:

g func1; where; g func2; where
g func1; where; g ; where

 Aliases can be nested in the definitions of other aliases. If the
debugger detects a circular reference between aliases, it will expand
until it detects the cycle. If an alias references itself, the reference will
not be expanded. For example, alias where where args does
not cause an infinite loop.
 Aliases can be used to redefine any native CodeProbe command
except alias and unalias . To reference a command that has been
aliased, escape the command name with a back-tick character ( ` ). For
example, the following sequence defines aliases for the set and
enter commands so they function as they did in CodeProbe
Version 5.10:

> alias set opt
> alias enter `et

Note the back-tick character used to escape the set command.

The Unalias Command

 The unalias command removes entries from CodeProbe's list of
aliases. The syntax for the unalias command is as follows:

unal[ias] name
unal[ias]*

The name parameter should match the alias name to be removed. The
asterisk (*) is used to remove all aliases.

 The Define Command

 The define command provides a more general macro text
substitution facility than the alias command. Just as with the C
preprocessor's definitions, macros defined in CodeProbe are expanded
anywhere within a line of text unless hidden inside of double quotes.
CodeProbe will not expand macro definitions that have been escaped93 Setting Up the Debugging Environment




by a back-tick character. The syntax for the def ine command is as
follows:


[#]def[ine] name [ definition ]
[#]def[ine] name ( parm [, parm . . . ] ) [definition]


The name parameter specifies the text to be replaced, and the definition
parameter is the substitution text. In the second form, parameters are
specified exactly as in the C language. Using the de f i ne command
with no arguments displays all macro definitions currently recognized.
Some examples are as follows:


> define PI 3.14159
> display PI
3.14159
> define ISEQUAL(a,b) (a == b)
> display ISEQUAL(1,5)
0 (0x0)
> expand ISEQUAL(1,5)
(1 == 5)


To define a symbol to nothing, omit the def inition parameter as
shown in the following command:

> define FOO

 One difference between the C preprocessor #define capability and
CodeProbe's is that the debugger treats def ine as a command
statement, meaning that it will stop parsing the def ine when a
semicolon is reached. To have CodeProbe treat a semicolon as part of a
definition, precede it with an escape character as follows:

\;


 The define command is intended to be used to define expressions.
Although you can use the def ine command to create new commands,
you should use the alias command to create custom commands.94 Chapter 4




The Undefine Command

 The undef ine command removes a definition from CodeProbe's
definition list. Compiler generated symbols may not be undefined. The
syntax for the undef ine command is as follows:

und[efine] name
und[efine] *


 The first form removes the macro with the specified name from the
 definition list. The second form removes all definitions from the list.95





5Working in Cross-
Development Mode


95 Introductlon
95 Why Debug in Cross-Development Mode?
96 Using the Cross Debugger
 96 Preparing to Use the Cross Debugger
 96 Running the Cross Debugger




 Introduction

 Version 6.0 of the SAS/C Development System comes with a new
 debugging capability: cross-debugging. This means that you can have
 your program run on one Amiga system, and debug it from another
 Amiga system. This is extremely useful when debugging a program that
 shuts down WorkBench, partially takes over the machine, or makes
 heavy use of graphics.
 When running in cross-development mode, CodeProbe communicates
 with a small kernel that controls the application via a serial
 communications port or over a network.



 Why Debug in Cross-Development Mode?

 There are several reasons why you may want to debug in cross-
 development mode:

 It is easier sometimes to see and send input to both the application
and debugger if they have their own separate monitors and
keyboards.
 Some applications use low-level graphics control, which takes control
away from Intuition. Since CodeProbe's windowing system is built
on top of Intuition, you cannot communicate with it while such an
application is running.
 With very large applications in tight memory situations, there may
not be enough memory available for both CodeProbe and the
application. The CodeProbe cross-debugger kernel that runs on the
machine with the application is small (less than 30K). It allows the
application to use most of the available memory.
 Disk space limitations may make it difficult to have the debugger, all
the necessary source files, and a copy of the application with debug96 Chapter 5




information available on the same machine along with all the files
needed by the running application.
 If the program being debugged crashes, you can continue to work on
the machine with the source code while it is rebooting.

Using the Cross Debugger

 In the following discussion, the machine containing the source code
 and the cross debugger (CPRX) is referred to as the host machine.
 Your actual debugging session occurs on the host machine. The
 machine on which the application will run under the kernel's control
 is referred to as the target machine.
 The cross debugger and kernel communicate with each other over a
 serial link or via a named pipe. Using named pipes, you can debug
 your program from an Amiga system connected to the target machine
 via a network.

Preparing to Use the Cross Debugger

 To use the cross debugger, you will need two Amiga machines. You
 can use a NULL modem cable to connect the machines, or you can
 even debug over the phone, if both Amiga machines are connected to
 modems. If you use the serial port, use the serial icon in the
 Preferences menu to select the highest baud rate acceptable. With a
 NULL modem cable, 19200 works fine. Over the phone you probably
 will need to specify the maximum speed accepted by your modems.

Running the Cross Debugger

 Two files must be installed on the target machine: the kernel (CPRK),
 and the application program that is to be debugged, unless the -x
 option is used. CPRX can automatically strip the application program
 of debug information and install it on the target machine if the -x
 option is used.
 CPRK provides direct control of the application program on the
 target machine. It communicates with CPRX, which is running on the
 host machine, over a serial line or through a pipe across a network.
 CPRK displays its copyright information and diagnostic output in a CLI
 window. CPRX runs like CodeProbe, except that the program being
 debugged runs on another machine.
 On the host machine, you need the source to your project and the
 executable file for the program you want to debug. The executable file
 should have been built with debug information.
Debugging a program in cross development mode is a four-step
 process:

1. Start the kernel (CPRK) on the target machine.
2. Start the cross debugger (CPRX) on the host machine.97 Working in Cross-Development Mode




3. Debug your application program.
4. Enter the f ini sh command in CPRX to terminate CPRK and
CPRX.

 Note: When debugging over a serial port, you must start CPRK
before starting CPRX. When using named pipes, the order does not
matter.


Defining the Communications Parameters

CPRX and CPRK take the following command-line options that define
and set parameters for the communications medium:

-pipe [ name ]
specifies that a named pipe is to be used instead of the serial port.
If name is not specified, pipe: cpr is used. CPRX or CPRK will
open two pipes using name as a base, name_ d and name_ k.
 To communicate successfully over a network, either CPRX or
CPRK must be invoked with a pipe filename referring to a pipe on
the other machine. If your network allows you to refer to a pipe
device on an attached machine by specifying

net: pipe/<pipename>

you could invoke CPRK on the target machine with the option


-pipe net:pipe/cpr


and invoke CPRX on the host machine with the -pipe option and
no parameters. This method works with the popular freely
redistributable network parnet, written by the Software Distillery.

-device [name]
specifies that the named device should be opened for
communications if -pipe was not specified. The default is
serial.device.

-unit [number]
specifies the unit number of the communications device if -pipe
was not specified. The default is zero (O).

-speed [number]
specifies the baud rate of the communications device if -pipe was
not specified. The default is the value set in preferences.98 Chapter 5




 searting the Kernel (CPRK)
 Start the kernel on the target machine with the following Shell
 command:


 cprk [options]


 The only options CPRK accepts are the communications configuration
 options previously listed. CPRK cannot be invoked from the
 Workbench screen.
Once invoked, CPRK acts as a server, waiting for a request to start a
 debugging session from a CPRX invocation on another machine. Note
 that if you are using the serial device, CPRK must be invoked before
 CPRX is invoked on the host machine.

 Starting the Cross Debugger (CPRX)

 Start the cross debugger on the host machine with the following Shell
 command:

 cprx [options]target-executable-filename [program-options]

 CPRX cannot be invoked from the Workbench screen.
The target-executable-filename parameter is the name of the program
 to be debugged. By default, CPRX and CPRK look for the program in
 the current directory of both the host and the target machines. If the
 specified executable name is an absolute path, CPRX and CPRK look in
 that location on both machines. If the executable file is located in
 different places on the target and host, then use the -symf ile option
 on CPRX to specify where the executable file resides on the host
 machine. CPRK will still look in the location specified by
 target-executable-filename. Anything on the command line after the
 target-executable-filename is passed to the target program as command-
 line arguments.
CPRX can be invoked with any of the options available to the native
 debugger (CPR) or with any of the communications configuration
 options previously listed. In addition, CPRX accepts the following
 options:

 -symfile filename
 specifies the location of the executable file on the host machine. Use
 this option if the location is not the same on the host and target
 machines.

 -nok[check]
 turns off checksum checking. By default, CPRX and CPRK examine
 a checksum on the executable files on the host and target machines99 Working in Cross-Development Mode


 to verify that both sides are using the same executable file. If the
 checksum fails, CPRK does not load the program.

 -x

 strips all debugging information from the host's version of the
 executable file, copies the stripped version to the target machine,
 and tells CPRK to invoke the just-transmitted version. This allows
 CPRK to run constantly without changing disks or rebooting (as
 long as your program does not crash).


Example 1
Suppose you want to start a cross-debugging session to debug a
program named myprog using the serial port at 19200 baud. Assume
that the program to be debugged resides in the current directory on
the host machine, so use -x to copy it over. The following commands
can be entered on the target and host machines:

target machine
 cprk -speed 19200

host machine
 cprx -x -speed 19200 myprog

Example 2

Suppose you want to start a cross-debugging session to debug a
program named myprog using parnet and named pipes. Assume that
the program to be debugged resides in TEMP: on the target machine
and in work: test on the host machine. The following commands can
be entered on the target and host machines:

target machine
 cprk -pipe net:pipe/cpr

host machine
 cprx -pipe -symfile work:test/myprog temp:myprog

Debugging Your Application
Once started, the cross debugger behaves just like the normal
debugger, except entering CTRL-C in the CPRX Dialog window does
not always stop the program executing on the target machine. All
interaction with the debugger occurs on the host machine via CPRX;
all interaction with the program being debugged occurs on the target
machine in the normal fashion.


Terminating CPRX and CPRK
If communications have not yet been established, you can terminate
CPRX or CPRK by entering CTRL-C in the Shell window that you100 Chapter 5




 used to invoke the command. If CPRX does not open its windows after
 you invoke it, communications have not been successfully established.
 Once the program is loaded, you can choose to terminate debugging
 one of two ways:

Terminate both CPRX and CPRK by entering the finish command
in the CPRX Dialog window. The syntax is as follows:


fin[ish]


The program being debugged will automatically be terminated if it
has not yet completed.
Terminate only CPRX by using the normal CPR quit command.
CPRK will continue running for use with a future CPRX debugging
session. The program being debugged will automatically be
terminated if it has not yet completed.

 You should allow your program to run to completion if possible before
 entering finish or quit to ensure that it cleans up all resources.101





6Using AREXX Macros with
CodeProbe


101 The AREXX Interface
101 Macros Provided by CodeProbe
102 Invoking Macros
103 Values Returned from CodeProbe Commands
 103 Return Codes
 103 Command Output




 The AREXX Interface

 AREXX is a multitasking implementation of the REXX language, a
 high-level language designed for macro processing and general
 programming tasks. CodeProbe supports an AREXX interface for
 customization. This interface is provided through CodeProbe's REXX
 port, sc_cpr.



 Macros Provided by CodeProbe

 A number of macros are provided in the sc: rexx directory as
 examples. Some simulate commands supported by the Commodore
 debugger, wack, including the following:



 MacroDescription

 avail.cprdisplays the amount of available memory
 dbptr.cprdumps memory as bytes from a given BPTR
 dbstr.cprdumps memory as bytes for a given BSTR
 devices.cpr displays the devices in the system
 devs.cprdisplays the list of system devices
 execbase.cprdumps exec base information
 ints.cprdisplays the list of interrupt handlers


 (continued)102 Chapter 6




 MacroDescription
 libraries.cprdisplays the libraries in the system
 libs.cprdisplays the list of resident libraries
 makeaptr.cprconverts a BPTR to an APTR
 memory.cpr displays regions of memory
 mods.cprdisplays system resident modules
 ports.cprdisplays the list of public ports
 regions.cpr displays regions of memory
 resource.cprdisplays the list of system resources
 rsrcs.cprdisplays the resources in the system

 showcli dumps CLI structure for a given command,
 process address, or task

 showprocess.cpr takes a process address or name and displays
 all of its task and process fields

 status.cpr shows all CLI tasks

 whichis.cpr identifies the CLI process associated with a
 command, task number, or task address




 For more details on how to use these macros while debugging,
 examine the macros in the text editor. Each macro has comments at
 the beginning of the file explaining how to use it.



 Invoking Macros

 CodeProbe recognizes macros with a.cpr extension. To invoke a
 macro from CodeProbe, simply enter the name of the macro from the
 command line. (The . cpr extension is optional.) CodeProbe first looks
 for the macro in the current directory, then in sc: rexx, and finally
 in REXX:.
For example, the following macro, named avail.cpr, uses the
 storage function to display the amount of memory available.



/* */
'd "' || storage() 'bytes free"'
exit(0)103 Using AREXX Macros with CodeProbe




 To invoke this macro, enter avail from the command line. The
 display command in the avail.cpr macro displays the value
 returned by the storage function, 1953944, and the string "bytes
 free", as shown here.

 > avail
 1953944 bytes free


 Values Returned from CodeProbe Commands

 CodeProbe commands provide return codes that are available to
 AREXX macros. Output from the debugger commands also can be
 assigned to the AREXX variable results.


 Return Codes 

 CodeProbe commands return status codes to AREXX as follows:


 Return
 Code Explanation

 O The debugger command was successful.

 1 The command was syntactically correct, but the program
failed for some other reason.

 2 A syntax error occurred.

 3 The debugger could not allocate memory for the AREXX
message.

Command Output

 In addition to these return codes, an AREXX macro can receive the
 Output output of a debugger command as it would normally appear in the
 Dialog window by invoking the AREXX command options
 results. The output will then be accessible from the variable
 result, provided that the debugger returned a 0 return code.
 For example, to execute a debugger command from outside the
 debugger, you could execute the following REXX script:

 /* */
 address "SC_CPR" /* only if macro was not invoked from CodeProbe */
 options results
 'any CodeProbe Dialog window command'104 Chapter 6




 The output from the CodeProbe command is assigned to the AREXX
 variable result.105




 7 Debugging Resident
Libraries


105 Introduction
105 Setting Breakpoints
106 The symload Command
106 The libraries.cpr AREXX Macro
106 Cautions
106 Limitations
106 Example




 Introduction

 Debugging resident libraries has been simplified considerably with
 Version 6.0 of CodeProbe. When debugging a resident library you can

set breakpoints in the library
use the symload command to read symbol information from the
 library
use the libraries .cpr AREXX macro to display the libraries in
 the system.

 Setting Breakpoints

 You can set breakpoints in any resident library that your program may
 use. For example, the following command sets a breakpoint on the
 function myfunc in library mylib. library:


 break mylib.library:myfunc


 If your program has not yet called OpenLibrary( ) to open
 mylib.library, then CodeProbe waits to install the breakpoint until
 the library has been opened. When CodeProbe detects that the library
 has been opened, it loads the debug information for that library. If
 myfunc does not exist, or if debug information for that library cannot
 be found, CodeProbe will halt the program at that point. This allows
 you to specify a different function or use the symload command to
 load debug information from a different location.106 Chapter 7




 The symload Command

 The symload command can be used to load debugging information
 for a resident library. For example, the following command loads
 debugging information for the library named mylib. library in the
 current directory:


symload mylib.library


 Refer to Chapter 9, "Commands and Built-in Functions," for a
 complete description of the symload command.



 The libraries.cpr AREXX Macro

 The libraries.cpr AREXX macro can be used to display a list of
 the libraries that are currently loaded. To run this macro, enter
 libraries on the command line of the Dialog window. Refer to
 Chapter 6, "Using AREXX Macros with CodeProbe," for more
 information.



 Cautions

 Since there is only one code segment for a shared library, you must be
 careful in setting breakpoints. A breakpoint is just an illegal instruction
 that CodeProbe places in the code. When the child process encounters
 that instruction, CodeProbe handles the exception. However, if another
 process is also using the same library, it will cause a crash when the
 program encounters the illegal instruction. Therefore, do not set
 breakpoints in libraries that will be used by processes not under
 debugger control.


 Limitations

 When debugging a resident library, you cannot examine global
 variables declared in modules outside the library even if you specify
 the full pathname of the module.


 Example

 See the directory sc:examples/reslib for an example resident
 library with debugging instructions.107





8 Debugging Multitasking
 Programs


 107 Introduction
 108 Types of Tasks
 108 How CodeProbe Handles Tasks
 109 Commands Used to Control Tasks
109 tasks
110 opt task
111 activate and deactivate
111 detach
112 catch
112 symload
 113 Design Considerations for Debugger Compatibility



 Introduction

 CodeProbe can debug applications that spawn additional tasks. These
 applications are designed to take advantage of the Amiga system's
 multitasking capabilities. This chapter looks at the commands used to
 debug multitasking applications including the following:

 tasks
 displays all tasks under the debugger's control.

 opt task
 examines or modifies the state of some task besides the one
 currently at a breakpoint.

 deactivate
 prevents a task from running, even when a go command is
 executed from another current task.

 activate
 reactivates a task affected by the deactivate command.

 detach
 frees a task from debugger control.

 catch
 places a task under debugger control.

 symload
 changes the load module used for collecting debug information
 while the debugger is active.108 Chapter 8





The discussion concludes by focusing on how to design applications
 with debugger compatibility in mind.
CodeProbe is able to debug multitasking applications by intercepting
 every call to AddTask( ) and determining the identity of the calling
 task. If the calling task is under debugger control and the catch
 option is set to on, the new task will also be brought under debugger
 control. Any task under CodeProbe's control can be stopped by a set
 breakpoint or by single stepping. Also, if you enter Ctrl-C in the
 Dialog window while an application is running, all active tasks under
 debugger control will be stopped.



 Types of Tasks

 Two types of tasks can be spawned by an application. The first type,
 called a synchronous task, is created, runs to completion, and returns
 control to the parent process while the parent process waits. This type
 of task is not practical to debug with CodeProbe while running the
 parent process. You should debug the task as a separate program
 before debugging the parent process.
The second type of task is an asynchronous task. When a parent
 process spawns an asynchronous task, control is returned to the parent
 process immediately after creation. The two applications then run
 independently, but both are under debugger control. This type of task
 can be debugged with CodeProbe.
In this chapter, all references are to asynchronous tasks and their
 parent processes.



How CodeProbe Handles Tasks

 It is important to understand the way tasks are handled when a
 breakpoint is hit or when you are stepping through a task. If several
 tasks are running under the debugger's control when a breakpoint is
 reached, all other tasks on the debugger's list are stopped as well as
 the one that encountered the breakpoint. This guarantees that the state
 of the application remains consistent while the user examines the task.
 The debugger will set the environment to that of the breakpoint task.
 That is, the current module, current line, and the registers displayed
 will all belong to the breakpointed task. The name and address of the
 Task Control Block for the current task are always displayed in the
 Dialog window's title bar.109 Debugging Multitasking Programs


 Commands Used to Control Tasks

 CodeProbe provides a number of commands that are used to control
 tasks.

 tasks 

 The tasks command displays all tasks under the debugger's control:

 >tasks

 Address Type Pri StateSigWaitStackPtr Debug Name
 OOC513B8 130Waiting 80000000 OOCSSlCC actmulti

Note that there are eight fields (columns) displayed by this
 command:

 Address
 contains the address of the task control block.

 Type
 indicates the type of node that begins the task control block. The
 number 13 is used for processes, while 1 is used for simple tasks.
 For a complete list of the possible task types, see the header file
 exec/nodes.h.

 Pri
 contains the priority of the task.

 State
 indicates the process state.

 SigWait
 displays the SigWait field of the task control block. This field
 indicates which signal bits the task may be waiting on.

 StackPtr
 indicates the current position of the stack pointer. Note that this
 will be somewhat different from the value displayed in the sp
 register. The value displayed here includes any information placed
 on the stack by the trap handler or exception handler associated
 with this task.

 Debug
 indicates the task's status with the debugger: act denotes an active
 task, and inact denotes an inactive task. Tasks not under the
 control of the debugger will have no information in this field.

 Name
 refers to the name of the task as specified in the task's node
 structure.110 Chapter 8





For more information on tasks and any of the fields except the debug
 field just discussed, see the Amiga ROM Kernel Reference Manual:
 Libraries and Devices.
The tasks command accepts an option called all. This option
 causes all tasks in the system to be displayed. This is useful if you
 want to catch a task that is not currently under debugger control. For
 more details, see the discussion on the catch command later in this
 chapter.

opt task 

The opt task command makes a new task current. This command is
useful if several tasks are currently running under the debugger and
you want to examine or modify the state of some task besides the one
currently at a breakpoint.
When a new task is made current by this command, a new set of
 registers is displayed. Highlighting of changed registers in the Register
 window may be misleading since the debugger only keeps track of
 changes while stepping through a single task. The module displayed in
 the Source window may change, or more likely, if the task was in a
 resident or linked library, assembler lines will be displayed. It may be
 possible to get information as to the calling sequence of the task by
 using the where command, but since assembler routines, including
 the Amiga system's resident libraries, do not follow C language calling
 conventions, the information displayed by where is only an intelligent
 guess.
You can modify any registers, condition control register (CCR) flags,
 or stack variables, just as in the breakpointed task. You can even single
 step through the code. However, a word of caution is advised. A
 breakpoint is implemented by placing an illegal instruction at the
 desired location. All tasks under the debugger's control have a trap
 handler attached to catch the illegal instruction and report back to the
 debugger. A breakpoint in any shared code will insert an illegal
 instruction in any task that executes that code. If you must place a
 breakpoint in shared code, such as a resident library under test, be
 sure that any task that might open it is under debugger control. Never
 place breakpoints in libraries that you do not control. Improper use of
 breakpoints in these circumstances can crash your machine.
The opt task command, like all commands that manipulate tasks,
 takes task-ID as an argument:

 op[t] t[ask] task-ID


A task-ID can be either the name of the task or the address of the
 task control block. If the name is used, it should be unique (otherwise111 Debugging Multitasking Programs




the first task with that name in the debugger's task list will always be
selected). If the name contains a blank, the entire name must be
surrounded by double quotes.
 Task addresses are generally entered in hexadecimal with a 0x
prefix. Task names and addresses can be determined with the tasks
command. Some sample commands are

 >opt task Child
 >opt task 0xC85428
 >opt task "Child of multi"

 Note: task command names are case sensitive.

activate and deactivate

 While debugging a multiple task application, you may want to stop one
 or more tasks temporarily. The deactivate command allows you to
 prevent a task from running, even when the go command is
 performed from another current task. Later, the task can be
 reactivated by using the activate command. Both commands take
 task-ID as an argument.


 a[ctivate] task-ID
 dea[ctivate] task-ID


detach
 At times, you may want to allow one or more tasks spawned by a task
under the debugger to run freely and not under the control of
CodeProbe. For example, a task designed to respond to Intuition events
may cause the system to lock up if it does not respond to menu events
quickly. It may not be desirable to allow such a task to be stopped
when other tasks hit a breakpoint. Such a task can easily be freed from
debugger control by using the detach command.
 To use the detach command, first set a breakpoint at the entry point
to the task. When the breakpoint is reached, use the tasks command
to identify the address or name of the task (you may know this based
on your code). Then enter the detach command. The syntax is the
same as the other task manipulation commands previously discussed.

det[ach] task-ID


 A few cautionary words are in order regarding the use of the
detach command. Once the task is free from the debugger, it can no
longer handle breakpoints. Therefore, be sure that all breakpoints in
code reachable from a detached task have been removed. Second, the
task will not be removed automatically if you quit the debugger. The112 Chapter 8




detached task can continue running even after you exit CodeProbe.
Since CodeProbe frees all of the memory containing the code used by
the detached task, subsequent code segments can use part of this free
memory and a crash can occur.
 If you later want to re-attach a task to the debugger, this can be
achieved using the catch command, the subject of the following
discussion.

catch 

At times, you may find that a process or task not started under the
debugger is behaving in an unpredictable or undesired manner. For
instance, the task may be caught in an infinite loop. Another possibility
is that the task is waiting on some message port for a message that will
never come. The catch command is used to capture tasks that are
causing these types of problems. Its syntax is similar to those for other
task commands:

ca[tch] task-ID


 To debug a task that is stuck in an infinite loop, invoke CodeProbe
with no filename. Then, when the debugger is up, use the command
tasks all to find the name and address of the process in question.
The catch command can then be used to capture the desired task
and place it under debugger control. If the task is a process, this
command will locate the code segments associated with the debug
executable as available from the process structure. If the task is not a
process, you will have to determine the address of the seglist and
use the opt env command to tell the debugger how to map the
debug information with the actual executable file. The opt env
command takes as an argument the address of a seglist pointer, as
in this example:


opt env 0xC08418


 For more information on segment lists, see The AmigaDOS Manual,
3rd Edition.

symload 
 The symload command enables you to change the executable file
 used for collecting debug information while the debugger is active. This
 is useful when debugging several interacting applications that are
 invoked from separate executable files. Note that this command does
 not load any code into memory or spawn any new processes or tasks.113 Debugging Multitasking Programs



 The symload command can take several forms. The following
command will find the executable file and the loaded memory segments
associated with the specified process, if it has CLI structure:

 symload proc "process-name" executable

The process is specified by the process-name parameter, and the
executable file is specified by the executable parameter. Note that
symload and proc are required keywords in this example. If the
command has an executable filename as an additional argument, as in
this example, any debug information associated with that file will be
loaded instead of looking for the file associated with the process. The
address of a process task block can be specified in place of the process
name.
 This command also can be given a pointer to a segment list as an
argument:

 symload seg 0x123456 executable

 The keyword seg is followed by the hexadecimal address pointing
to the process seglist. The name of an executable file is also
required.


Design Considerations for Debugger Compatibility

CodeProbe makes every effort to allow an application to run as it
would while running outside of debugger control. However, in order to
establish breakpoints and catch new tasks generated in a multitasking
application, CodeProbe must manipulate certain resources in the
application's task structure. In particular, CodeProbe redefines a task's
exception handler, exception data, trap handler, and trap data fields. If
it is necessary for an application to redefine any of these fields for its
own purposes, it must do so in the way described in the Amiga ROM
Kernel Reference Manual: Libraries and Devices.
 Exception handlers must save the address of the original exception
handler and exception data fields and pass any unallocated exceptions
back to those routines. Before invoking the original exception handler,
be sure to restore the original exception data pointer in the task
structure.
 The same practice applies to trap handlers. In particular, all
exceptions besides allocated traps should be passed to the original trap114 Chapter 8




 handler. In order to control multitasking, CodeProbe performs a
 SetFunction on the AddTask, OpenLibrary, OpenDevice, and
 RemTask functions. These functions should not be redefined by an
 application.115





9 Commands and Built-in
 Functions


 115 Introduction
 115 CodeProbe Commands
 118 Special Parameters
118 address
119 array-slice
120 expression
120 location
121 number
121 range
122 register
123 string
123 subrange
124 type
125 variable
 126 Command Reference
 202 Built-in Functions
 203 Built-in Function Reference




 Introduction

 This chapter provides complete reference information for each of the
 CodeProbe commands and the built-in functions. This information is
 provided in the following order:

 [] list of CodeProbe commands that shows acceptable abbreviations and
provides a brief description of each command
 [] list of built-in functions with brief descriptions
 [] descriptions of special parameters, each of which is used with
several CodeProbe commands
 [] reference information for each of the commands and built-in
functions.



 CodeProbe Commands

 As explained in Chapter 1, "Introduction to CodeProbe," debugger
 commands can be entered four ways: from the Dialog window, from a
 pull-down menu, by function keys, or by menu-accelerator keys. This116 Chapter 9




 chapter describes each of the following debugger commands as they
 are entered from the Dialog window:

 a[ctivate]activates a task under debugger control
 al[ias]defines an alias for a debugger command
 ar[gs]displays the arguments to a function
 bc[lear] clears one or more breakpoints
 bd[isable]disables one or more breakpoints
 be[nable] enables one or more breakpoints
 bl[ist]lists all breakpoints
 b[reak]sets a breakpoint
 c[all]evaluates an expression and discards the result
 ca[tch]catches a task not currently under debugger
control
 dea[ctivate] deactivates a task under debugger control
 def[ine] defines a macro
 det[ach] detaches a task from debugger control
 d[isplay] displays the value of an expression
 du[mp]dumps memory contents
 dz[ero]displays memory as a null-terminated ASCII string
 ec[ho]displays a string
 envsets the environment
 ex[ecute] executes a debugger command file
 expandexpands and displays a command line
 fin[ish] terminates CPRK and CPRX
 fr[egister]displays or modifies floating-point registers
 g[o] continues execution until a breakpoint is
encountered or the program exits
 h[elp]displays help information
 hu[nks]lists the addresses and sizes of all hunks
 j[ump]changes the current execution point117 Commands and Built-in Functions




 l[ist]lists the lines in a source file
 lo[g] logs debugger commands to a file
 op[t] shows option values or changes the value of a
debugger option
 p[roceed] single-steps over function calls
 pssingle-steps over function calls by source line
 q[uit]terminates the debugger
 r[egister]displays or modifies registers
 res[tart] restarts the program being debugged
 ret[urn] returns immediately from the current function
 rf[lag]displays or modifies flags
 sea[rch] searches for a string in the current source file
 se[t] modifies the values of variables or memory
locations
 sle[ep]pauses for the time specified
 so[urce] displays the source file
 sta[rt]restarts the program being debugged
 symb[ol] finds the symbol nearest to the specified address
 sym[load] reads symbol information from an executable file
 ta[sks]displays system tasks
 t[race]single-steps into function calls
 tssingle-steps by source line into function calls
 unal[ias] deletes an alias
 u[nassemble] displays memory as assembler instructions
 und[efine]deletes a macro definition
 w[atch]sets a watch on a variable or memory
 wb[reak] sets a watch break
 wc[lear] clears one or more watches
 wd[isable]disables one or more watches
 we[nable] enables one or more watches118 Chapter 9




 wha[tis] determines the type of an object
 whe[re]shows the calling sequence
 wi[ndow] opens or closes a window
 wl[ist]lists all watches
 wmsg writes a message to the Message window.


 Special Parameters

The following special parameters are described in this section:

 [] address
 [] array-slice
 [] expression
 [] location
 [] number
 [] range
 [] register
 [] string
 [] subrange
 [] type
 [] variable.

Each of these parameters is used in several CodeProbe commands.


address 

 An address parameter is any expression that denotes an address. This
 may be a hexadecimal constant, a C pointer variable, a register, the
 result of prefixing & to a C identifier of the proper type, or the result
 of arithmetic calculations on other addresses. Note that the address
 operator & may not be applied to the identifier of a bitfield or a
 register.
 The following are examples of values of expressions that denote an
 address where p is a pointer, and i and x are integers:



 &i
 (&i + 8)
 &arrayl 3 1
 &mystruct - x


 0x00C85400
 a0
 (a0 + 0x22)119 Commands and Built in Functions




 There are some cases where a register name may be ambiguous. For
example, you may have defined a variable sp in your program. In the
following command it is not clear whether you mean to dump data
beginning at the variable sp, or at the address contained in the
register SP:


db sp


In such cases the debugger will assume that you mean to refer to the
variable sp. However, you can prefix the register name with a dollar
sign ($) or use the register command to examine the value of the
SP register even if you have declared a variable named sp.
 In certain commands, it is necessary to specify the type of an object
to be modified or displayed. If the object is referred to by means of an
address constant or register, the value is assumed to be a character
pointer (char *).


array-slice

An array-slice parameter is a contiguous section of a unidimensional
 array of scalar variables, an ordered selection of elements from a
 multidimensional array, or an ordered selection of members from an
 array of complex types. An array-slice is specified using the following
 form:

 variable [[n . . m ] | [*]]

 Note: The inner brackets in this syntax diagram are not optional
and do not denote optional parameters.
 The advantage of using an array-slice parameter over a range
parameter is that the array-slice can be used to select isolated
subcomponents, such as a particular structure member from an array
of structures. The array-slice parameter also can be nested for
multidimensional arrays or structure members that are arrays
themselves.
 The subrange parameter is described later in this chapter. If a
subrange is chosen as the index of an array-slice, those elements within
the subrange are selected. The asterisk (*) index specifies that all
elements of the array are to be contained in the array-slice.
 The following are examples of the array-slice parameter:

 a[3..7]
 matrix[i..j][1.3]
 b[*]
 a[3..6]->b120 Chapter 9




expression Any C expression is accepted as an expression parameter, except those
 that use one or more of the following operators:

 ++ or --
 ,
 ?:
 =
 &=
 |=
 >>=
 <<=
 +=
 -=
 *=
 /=
 %=
 ^=

location 

A location parameter specifies a place in the code at which a
breakpoint is to be set, code is to be unassembled, or a similar action
is to be performed. When debugging in source mode, you can think of
a location parameter as a line number in a source file or a function
entry point. When debugging in assembly mode, you may want to
place breakpoints at specific addresses. To do this, specify a
hexadecimal address as the location parameter.
The location parameter can be specified in one of two ways:

[] hex address
[] [[image:][\module\]function] line

In the first form, the hex-address variable can be any valid absolute
 address specified as a hexadecimal integer.
 In the second form the values for the variables image, module, and
 function can be specified explicitly as follows:

image
is the name of the executable image (the program, library, or
device) containing the location. It is usually specified in lowercase.
If omitted, the current image is the default. In a program with only
one image, it is never necessary to specify a value for image: Note
the required colon (:).

module
is the name of the C source file compiled to yield the specified
function. Note the backslash (\) postfix.121 Commands and Built in Functions




 function
 is the name of a function in the application.

 You can put spaces between the value specified for image and its colon
 postfix and the value specified for module and its backslash postfix. but
 they are not necessary. You must put a space before the line parameter.
 The line parameter can specify any of the following points in the
 source code:

 integer
 a line number, relative to the start of the C source file containing
 the function

 $
 the current location

 e[ntry]
 the entry to the function (prolog)

 r[eturn]
 the return from the function (epilog).

 If the function name is not specified with the line parameter, the
debugger defaults to the current function. If a function is specified
without a line, the debugger defaults to the first execution line.

number

A number parameter is a number in decimal, octal, or hexadecimal
 notation. An initial 0 digit causes the number to be interpreted as
 octal, an initial 0x (or 0x) causes the number to be interpreted as
 hexadecimal, and an initial 0n (or 0N) causes the number to be
 interpreted as decimal. The default is decimal.
 Examples of acceptable values for the number parameter include the
 following:

12345
0455
0x380
0X1849
0n12345

 range 
 A range parameter is a contiguous area of memory that can be
 specified in one of two ways:

 [] address..address
 [] address l number
 address L number122 Chapter 9




 In both forms, the first address variable is the start address, and the
range begins at this address.
 In the first form, the second value for address is the end address,
and the range includes the area of memory from the start address to
the end address.
 In the second form, the l or L indicates that the value for the
variable number is to be interpreted as a length. In this case, number
indicates the number of elements and the range is from the start
address through address+number-1. When the debugger sees a
solitary l or L in a command, it is considered part of a range
expression.
 The following examples fit the definition of the range parameter:

 0x123456 .. 0x123461
 0x123456 L 11

 a1..a2
 a7 l 20


 &P[O] .. &P[5]
 P[0] .. P[5]

 &P[0] l 6
 P[0] l 6

 The first pair of examples are equivalent. The next pair are variants
of the basic range expression. The remaining pairs are equivalent
ranges, given the addressing policy described earlier in this section.

register

A register parameter refers to the name of any of the following 680xO
registers:

A0 - A7 are address registers. Register A7 functions as the
 stack pointer and can be specified as either A7 or
 SP.
D0 - D7 are general-purpose registers.
PC is the program counter.
SP is the stack pointer.
SR is the status register. It contains the CCR register
 as well as the current processor status.
CCR is the condition code register. It resides in the
 lower byte of the status register, SR.123 Commands and Built-in Functions




 If a math coprocessor is present, the following registers also can be
 specified as the register parameter:

FP0 - FP7 are the floating-point registers.
FCR is the floating-point control register.
FSR is the floating-point status register. It contains the
 current floating-point condition codes.

Optionally, registers can be prefixed with a dollar sign ($) to
 distinguish them from variables with the same name. For example,
 register D1 can be specified as $D1 to distinguish it from a variable
 named d1.


string 

 A string parameter can be any standard C string in double quotes (").
 Standard C escape sequences starting with the backslash character are
 supported as follows:

 \n newline (0x0a)
 \t horizontal tab (0x09)
 \b backspace (0x08)
 \r carriage return (0x0d)
 \f form feed (0x0c)
 \v vertical tab (0x0b)
 \NNN octal constant, where NNN is a three-digit octal
number
 \xNN hex constant, where NN is a two-digit hexadecimal
number.

 A backslash followed by any character other than those shown
 previously in the escape sequences is interpreted as a plain character.
 For example, \ \ is a string consisting of a single backslash, and a \ " b
 is three characters long: an a, a double quote, and a b.
The Dialog window does not recognize any of these escape sequences
 when they are displayed. You cannot use the \t escape sequence to
 tab in the Dialog window. The escape sequences are useful in line
 mode and when setting a character string.
Like all debugger input, a string can be continued to the next line by
 ending the line with a backslash. The debugger does not support ANSI
 string concatenation.

subrange 

A subrange parameter is a series of contiguous integers, inclusive of its
bounds. The integers may be either integer constants or variables from124 Chapter 9




 the application being debugged. The form of the subrange parameter is
 as follows:

 [integer | variable]. . [integer | variable]

The following are examples of the subrange parameter:

 3..7
 i..j

type 

A type parameter can be any of the data types provided by the C
language including any of the following:


char
unsigned char
short
unsigned short
int
unsigned int
long
Unsigned long
unsigned
float
double
struct <name>
union <name>
enum <name>


A type also can be any of the C types previously listed followed by
 some number of asterisks indicating that the type is a pointer to the
 base object.
In addition, the type parameter can take any identifier defined by
 means of a typedef statement if the debugging information for the
 module supplies typedef information.125 Commands and Built-in Functions



variable

 A variable parameter is an expression in your program that designates
an object. It can be either a simple identifier or an expression
referring to an array element, structure member, or object pointed to
by a pointer. In addition, it can begin with a specification of the
following form:

[[image:][\module\]function]

See the location parameter earlier in this chapter for a description of
the image, module, and function variables.
 The following are objects that fit the definition of the variable
parameter:



i 
max
array[3]
array
io:readfile\length
mystruct->name[2]
mystruct
*cptr
main.c\opnf\count
opnf\i
mylib.library:LIBmyfunc\myvar126 Chapter 9




 Command Reference

 This section provides complete reference information for each of the
 CodeProbe commands. The commands are listed in alphabetical order.
 Most of the command descriptions include the following sections:

 Synopsisshows the format of the debugger command or
 built-in function

 Description describes the function of the debugger command or
 built-in function and contains all the information
 you need to use the command or function

 Example contains examples that illustrate how to use the
 command or function

 See Alsorefers you to the descriptions of other related
 commands or functions.127 Commands and Built-in Functions




activate Activates a task under debugger control


 Synopsisa[ctivate] [task-name | task-address | exe-name]


Description: The activate command activates a task that has been deactivated by
 the deactivate command. The task is activated when the next go or
 proceed command is executed.
The task-name, task-address, and exe-name parameters are the name
 of the task, the address of the task, and the executable name of the
 task as specified by the tasks command. Only one of these
 parameters can be specified.


 Examples activate Child
 activates the task named Child under debugger control.

activate 0xC08540
 activates the task with a task block starting 
 at address 0xC08540.

activate myprog
 activates the task executing the program myprog.


 See Also catch, deactivate, detach, tasks128 Chapter 9




aliasDefines an alias for a debugger command


Synopsisal[ias] [name[definition]]


Description: When entered with no arguments, the alias command displays the
 list of all currently defined aliases. If a value for name is provided as
 the only argument, the definition for that alias will be displayed. Any
 text following the name parameter is treated as a definition and is used
 to define the alias.
Alias names are expanded only when they occur at the beginning of
 a Dialog window command line. An alias definition can be a simple
 textual substitution or it can contain positional parameters to be
 expanded at execution time. Positional parameters are specified as $1,
 $2, $3, and so on. $0 represents the alias name itself. $* represents
 command line parameters $1 through $n. If no positional parameter is
 specified in a definition, all parameters are placed after the expanded
 definition text.
The alias command will parse a definition until it encounters a
 command delimiter character (;) or the end of the line. To define an
 alias that expands into more than one command, enclose the definition
 in either double quotes or curly braces. If the command string must
 contain double quotes, curly braces can be used or the quotes can be
 escaped. As in C and all other debugger commands, a backslash may
 be used to continue the line.


 Examplesalias
 displays a list of all alias definitions.

alias foo
 displays a definition of f oo.

alias next proceed
 defines next to be an alias for proceed.

alias pr display foo, bar, $*
 defines pr to be an alias that executes the display command
 printing the value of foo, bar, and any variables entered after
 the pr.

alias doit {go $1; d foo}
 defines doit to execute the go command using the first
 parameter, and displays the variable named foo.

alias doit {go $1;\
d foo}
 uses the backslash command to split a command across two lines.129 Commands and Built-in Functions




alias Defines an alias for a debugger command
(continued)


alias doit "go $1; d $2"
 uses positional parameters with multiple commands. The first
 parameter, $ 1, is passed to the go command, and the second
 parameter, $2, is passed to the display command.

 See Also define,unalias,undefine130 Chapter 9




argsDisplays the arguments to a function


Synopsisar[gs] [function-name]


Description: The args command displays all of the argument names and values to
 the current function or the function specified by the function-name
 parameter. If a function-name parameter is specified it must be in the
 calling sequence, as displayed by the where command.


Examplesargs
 displays the arguments to the current function.

args sort
 displays the arguments to the sort function.


 See Also display, env, where131 Commands and Built-in Functions




bclear Clears one or more breakpoints

Synopsisbc[lear] integer[integer...]
bc[lear]* | l[ast]
bc[lear] integer .. integer


Description: The bclear command clears one or more breakpoints. When a
 breakpoint is cleared, it ceases to exist and can be reinstated only by
 issuing the break command again. You should use the bdisable
 command to disable breakpoints temporarily.
The integer parameter specifies the breakpoint number as displayed
 by the blist command. Any number of values can be specified as
 integer parameters. An asterisk specifies that all breakpoints should
 be cleared and last causes the most recently set breakpoint to be
 cleared. A range of breakpoints can be specified by
 integer. . integer.


Examplesbclear 2 5 6
 clears the breakpoints numbered 2, 5, and 6.

bclear last
 clears the last breakpoint set.

bclear *
 clears all breakpoints.

bclear 4 .. 7
 clears breakpoints 4, 5, 6, and 7


 See Also bdisable, benable, blist, break, wclear132 Chapter 9



bdisableDisables one or more breakpoints


Synopsisbd[isable]integer[integer...]
bd[isable] * | l[ast]
bd[isable]integer .. integer


Description: The bdisable command disables the recognition of one or more
 breakpoints. When a breakpoint is disabled, it is not recognized by
 CodeProbe, but it does remain on the list of current breakpoints. A
 disabled breakpoint can be re-enabled by the benable command.
The integer parameter specifies the breakpoint number as displayed
 by the blist command. Any number of values can be specified as
 integer parameters. An asterisk specifies that all breakpoints should be
 disabled and last causes the most recently set breakpoint to be
 disabled. A range of breakpoints can be specified by integer . . integer.


Examplesbdisable 2 5 6
 disables the breakpoints numbered 2, 5, and 6.

bdisable last
 disables the last breakpoint set.

bdisable *
 disables all breakpoints.

bdisable 4 .. 7
 disables breakpoints 4, 5, 6, and 7.


See Also bclear, benable, blist, break, wdisable133 Commands and Built-in Functions



benable Enables one or more breakpoints


Synopsisbe[enable] integer [integer ...]
be[enable] * | l[ast]
be[enable] integer .. integer


Description: The benable command enables the recognition of one or more
 breakpoints that have been disabled by the bdisable command.
The integer parameter specifies the breakpoint number as displayed
 by the blist command. Any number of values can be specified as
 integer parameters. An asterisk specifies that all breakpoints should be
 enabled and last causes the most recently set breakpoint to be
 enabled. A range of breakpoints can be specified by integer . . integer.


Examplesbenable 2 5 6
 enables the breakpoints numbered 2, S, and 6.

benable last
 enables the last breakpoint set.

benable *
 enables all breakpoints.

benable 4 .. 7
 enables breakpoints 4, 5, 6, and 7.


 See Also bclear, bdisable, blist, break, wenable134 Chapter 9



blistLists all breakpoints


Synopsisbl[ist]


Description: The blist command displays a list of all breakpoints. Each entry has
 a form similar to the following example:


5 0x40054 loop:\loop.c\main 8 (2 hits)
after(4) when(i == 3) quiet {echo Hi}


 The number 5 in this example is the number used to refer to this
 breakpoint in bclear, bdisable, and benable commands. If an
 asterisk appears next to the number, that breakpoint has been disabled
 and will not be triggered. Following the breakpoint number is the
 hexadecimal address at which the breakpoint resides. If sufficient
 debug information is available, the address is followed by the location
 that it represents. The hit count, which represents a running count of
 the number of times the breakpoint has been triggered, is displayed
 after the location of the breakpoint. A breakpoint is triggered when all
 of the following conditions are true:

 [] execution has reached the address shown
 [] the when and after conditions are true, if specified
 [] the breakpoint is enabled.

 Breakpoints are triggered when the user steps to the address provided
 the last two conditions are met. The second line of output displayed by
 the blist command shows the options given when the break
 command was issued.


 See Also bclear, bdisable, benable, break, wlist135 Commands and Built-in Functions



breakSets a breakpoint


Synopsisb[reak] location[after(integer)][when(expression)]
[tr[ace]] [q[uiet]] [te[mp]] [{cmd-list}]


Description: The break command is used to set a breakpoint at a location
specified by the location parameter. You can use a dollar sign to specify the
 current location.
 The after option specifies the minimum number of times the
specified line must be executed before the breakpoint is triggered. This
is also known as specifying a pass count. For break commands that
do not contain an after clause, the pass count is set to 1.
 Each time the breakpoint is hit, the pass count is tested. If the pass
count equals 1, the breakpoint is triggered and execution stops. If the
pass count is greater than 1, the pass count is decremented by 1, and
execution continues. The blist command shows the current pass
count for each breakpoint.
 If the when option is present, the breakpoint is triggered only if the
specified expression evaluates to true (nonzero). The after and when
options can be specified in any order. If both options are specified, the
pass count is tested and decremented only when the when condition is
true.
 The trace option continues execution automatically after the
breakpoint is triggered, unless you reach the breakpoint by single-
stepping, then the the trace option has no effect.
 The quiet option suppresses the default message showing the
location when the breakpoint is triggered.
 The temp option causes the breakpoint to be deleted after it has
been triggered.
 If the cmd-list parameter is present, the commands listed are
performed each time the breakpoint is triggered. As in C commands
and all other debugger commands, a backslash may be used to
continue the line.
 Note: To avoid confusion, the break command does not use the
default radix setting. You must specify ox for an address; otherwise,
you will be specifying a line number. For example, even if the radix is
set to hex, the following command specifies a break command for
line 20 and not address 0x20:


b 20136 Chapter 9



breakSets a breakpoint
(continued)


Examplesbreak $
 sets a breakpoint at the current line.

b 14
 sets a breakpoint at line 14 of the current module.

b sort
 sets a breakpoint at the first line of the sort function.

break sort return
 sets a breakpoint at the return from the sort function.

break \myfile.c\sort 14
 sets a breakpoint at line 14 of sort in the module named
 myfile.c.

break mylib.library:myfunc
 sets a breakpoint at the first line of the myf unc function in
 the shared library mylib. library.

 b $ after(5)
 breaks the fifth time the current line is executed.

break 0x804A
 sets a breakpoint at the absolute address 0x804A.

break 14 when (i > 5) (di p L 16; b sort 26
when (i == 8); bl; go)
 sets a breakpoint on line 14 that performs the commands given
 inside the curly braces if i > 5 evaluates true.

b 8 trace quiet (d "i = ", i)
 prints a message of the form ~ i = value "every time line 8 is
 executed.

break 100 temp (d foo)
 stops at line 100, prints f oo, and deletes this breakpoint.


See Also bclear,bdisable,benable,blist,go137 Commands and Built-in Functions




callEvaluates an expression and discards the result


Synopsisc[all] expression


Description: The call command is used to evaluate an expression when you do not
 care about the value returned. It is equivalent to the following
 statement in C language:


expression;


The most common use of the call command is to call a function in
 the application program, though function calls also may appear in
 arbitrary expressions in other commands. If you want to see the value
 returned by the expression, use the display command.
The debugger looks at the types of the parameters specified and not
 at the definition of the function or any prototype. Thus, the debugger
 does not flag an error if the wrong number of parameters are
 specified, nor does it perform automatic casting of types or allow
 passing of char, short, or f loat types. For example, the following
 command passes two parameters, an int and a double, regardless of
 how the function is declared:


call f(2, 1.5)


CodeProbe supports standard C syntax for function calls. Either a
 function name or an expression evaluating to a function type may be
 specified before the opening parenthesis. Thus, the call command can
 be used only to call functions or evaluate expressions that point to a
 function. For example, if pf is a function pointer, and f unc is a
 function, the following commands are allowed:

call func()
call (*pf)()

 However, the following commands are not allowed:

call pf()
call 0xl34()
call register( )


You cannot use the call command to execute a function after a
 program has ended.138 Chapter 9




callEvaluates an expression and discards the result
(continued)

 If a breakpoint is hit, a signal is caught, or the program terminates
in the middle of a function call, the debugger aborts the expression
and leaves you at that location. A warning is printed if any parameters
are not cleaned off the stack. This may cause a return to an invalid
location later if execution is allowed to continue.


 Examples call status()
 calls the status function.

call print("Test", 300)
 calls the print function passing in a string and an integer
 parameter.

call (*fp)(&arr[5], j+10, 3.0)
 evaluates arbitrary expressions.


See Also display,env,where139 Commands and Built-in Functions




catchCatches a task not currently under debugger control


Synopsisca[tch] [task-name I address I exe-name]


Description: The catch command enables the debugger to gain control of tasks
 that were not started under the control of CPR. The task-name and
 address parameters can be found by issuing a t a s k s a 11 command.
The exe-name parameter can be used to specify the name of the
 executable associated with the task you want to catch.


 Examples catch Child
 catches the task named Child.

ca 0xC08540
 catches the task with a task block starting address 0xC08540.

 catch myprog
 catches the task running the program myprog.


 See Also activate, deactivate, detach, symload, tasks140 Chapter 9



deactivate Deactivates a task under debugger control


Synopsisdea[ctivate] [task-name | address | exe-name ]


Description: Normally all tasks under CPR's control are started when a go or
 proceed command is issued. The deactivate command can be
 used to deactivate a task. A task that is deactivated by this command is
 not started when the debugger allows the application to run unless it is
 the current task. The task can be reactivated with the activate
 command.
The task-name and address parameters can be found by issuing a
 tasks command. The exe-name parameter can be used to specify the
 name of the executable associated with the task you want to catch.


 Examplesdea Child
 deactivates the task named Child under CPR.

deactivate 0xC08540
 deactivates the task with a task block starting at address
 0xC08540.

deactivate myprog
 deactivates the task running the program named myprog.


 See Also activate, catch, detach, tasks141 Commands and Built-in Functions



define Defines a macro


Synopsis[#]def[ine] name [definition]
[#]def[ine] name(parm [,parm ... ]) [definition]


Description: The define command provides a general macro substitution facility
 that is nearly identical to the mechanism provided in C syntax. Macros
 defined in the debugger are expanded anywhere within a line of text
 except inside quotes or filenames. The debugger also will not expand
 macro definitions that are prefixed with a backtick character ( ` ). The
 ANSI # and ## operators are not supported.


 Examples define
 displays all the macro definitions.

define foo
 defines foo as a null definition.

def foo bar
 defines foo to be bar.

define func(a,b) (a+b)
 defines func with parameters.


See Also alias, unalias, undefine142 Chapter 9




detach Detaches a task from debugger control

Synopsisdet[ach] [task-name | address | exe-name ]


Description: The detach command detaches a task from debugger control. The
 task can be brought under CodeProbe's control with the catch
 command.
The task-name and address parameters can be found by issuing a
 tasks command. The exe-name parameter can be used to specify the
 name of the executable associated with the task you want to catch.
When using the detach command make sure that no breakpoints
 are placed inside code that is executable from a detached task. Also, do
 not specify the detach command to the original program if any of its
 child processes continue to run in the same code segment.


 Examplesdetach Child
detaches the task named Child from debugger control.

det 0xC08540
 detaches the task with a task block starting at 
 address 0xC08540.

det myprog
 detaches the task executing the program myprog.


 See Also activate, catch, deactivate, tasks143 Commands and Built-in Functions




display Displays the value of an expression


Synopsisd[isplay] (expression["format"] | string) [, ...]


Description: The display command evaluates the value of the expression
 parameter and displays the result. The expression parameter can be
 any C expression containing constants, variables, and function calls
 from the program being debugged. Any number of expressions and
 strings can be specified, separated by commas. All expressions are
 displayed on the same line.
The display command chooses the default format based on the
 type of the expression. Values of type char are displayed as
 characters as well as in decimal and hexadecimal format. If the
 character is unprintable it is displayed as an escape sequence, for
 example, \n or \xAC. Values of type int and long are displayed in
 decimal and hexadecimal format, and f loats and doubles are
 displayed in floating-point best format.
To override the default format, a printf style format can be
 specified optionally after each expression. No error checking is done on
 the format parameter, so strange results are possible. It may contain
 up to two conversion operators for short and long types but only
 one for all other types.
All members of structures, unions, and arrays are displayed using
 the default formats. Partial arrays may be displayed using two integers
 to indicate the first and last elements to display. For example, the
 following command displays array elements 3, 4, and 5:


display a[3..5]


 An asterisk may be used instead to indicate that all elements should be
 displayed.
The string parameter can be any standard C string in double quotes
 as described earlier in this chapter in the "Special Parameters" section.
To display a null-terminated string, use the dzero command. Use
 the dump command to dump an area of memory.

 Examples display
 displays the variable i.

 d a "a=%10.5e"
displays a using a printf style format specifier.

 d p->d[5] + f(3)
displays the value of an expression containing a function
call.144 Chapter 9




display Displays the value of an expression
 (continued)


display "X is", x, "J is", j
 displays the value of several argu ments including strings.

d x "X is %d", j "J is %d"
 displays the value of several arguments using printf style
 format specifiers.

d a[3]
 displays the value of an element of an array.

display a[3..5]
 displays the value of elements 3 through 5 in an array named
 a.

d a[*]
 displays the value of every element of an array.


See Also call,dump,dzero145 Commands and Built-in Functions 145




dumpDumps memory contents


Synopsisdu[mp] [variable | address | range] [S]
[format [itemsize] | text]


Description: The dump command is used to examine an area of memory. You select
 the format of the dump, the length of each item being dumped, and
 whether or not you want text to appear on the right side of the dump.
 A dump command with no parameters continues where the previous
 dump command ended using the same dump specifications.
The variable, address, or range parameter specifies the location to be
 dumped. The $ parameter can be used to specify the last dump address
 when the format or text parameters are used. The $ is ignored if a
 variable, address, or range parameter has already been specified
 making it useful for aliases where the dump address may be omitted.
The format parameter controls the format of the dump and its value
can be any of the following:

a[scii] FFP[float]IEEE[float]
b[inary]f[loat]o[ctal]
d[ecimal]h[ex] u[nsigned]


 The default format is hex.
If you specify a format parameter, you also can specify an itemsize
 parameter to control the length of each item dumped. The itemsize
 parameter can have a value of 1, 2, 4, or 8. The itemsize parameter is
 concatenated onto the end of the format parameter (for example, b4
 for a binary format of length 4). If you do not specify itemsize,
 CodeProbe uses a default. As shown in the following table, the
 allowable size and default values depend on the format specified.
The text parameter is used to specify that an ASCII representation
 of the memory dump should be displayed.146 Chapter 9




dumpDumps memory contents
(continued)


 The itemsize parameter has the following default values and
allowable sizes:


 Format Default Allowed Sizes

 ascii11
 binary 11, 2, 4
 decimal 41, 2, 4
 FFPfloat44
 float84, 8
 hex 41, 2, 4
 IEEEfloat84, 8
 octal41, 2, 4
 unsigned41, 2, 4




Compatibility Aliases
To provide backward compatibility with previous releases of
CodeProbe, the following aliases for the dump command are
supported:

da
dumps a range of memory as ASCII characters

db
dumps a range of memory in both hexadecimal and ASCII format

dc
dumps a range of memory in decimal format

dd
dumps a range of memory as 8-byte floating-point numbers in IEEE
format

df
dumps a range of memory as 4-byte floating-point numbers in IEEE
format

dffp
dumps a range of memory as 4-byte floating-point numbers in FFP
format147 Commands and Built-in Functions




dumpDumps memory contents
(continued)


di or dl
 dumps a range of memory in integer format using decimal
 representations of the integers

dw
 dumps a range of memory in short integer (16-bit) format using
 hexadecimal representations of the integers

dp
 dumps a range of memory in 4-byte hexadecimal format

ds
 dumps a range of memory in short integer (16-bit) format, using
 decimal representations of the integers.


Examplesdump var
 dumps memory contents of variable var.

dump var L 13 hex1
 dumps memory contents for 13 bytes using 1-byte hexadecimal
 format.

dump var1 .. var2 ascii
 dumps memory contents between var 1 . . var 2 in ASCII format.

dump 0xAF8100 L 8
 dumps memory contents for 8 longs (32 bytes) starting at
 absolute address 0xAF8100.


 See Also display,dzero148 Chapter 9




dzeroDisplays memory as a null-terminated ASCII string


Synopsisdz[ero] variable | address | array-slice


Description: The dzero command displays the contents of memory as a null-
 terminated (\0) string. If the location is the name of a nonpointer
 variable in the program being debugged, dzero displays the memory
 contents starting at the address of the variable and continuing until the
 null character is found. If the location is the name of a pointer
 variable, dzero uses the contents of the pointer and displays bytes
 starting at that address until a null character is encountered. If the
 address parameter is used to specify an absolute address, dzero
 displays the contents of that address until a null character is
 encountered. If the location is an array-slice, the address of each
 element in the array slice will be displayed until the null character is
 found.


 Examplesdzero string
 displays characters until the null character is reached.

dzero ptr
 displays data pointed to by ptr as a string.

dzero ptr[3..7]
 displays each element in the array slice ptr [3..7] until the
 null character is reached.


 See Also display, dump149 Commands and Built-in Functions



echoDisplays a string


Synopsisec[ho] [text]

Description: The echo command writes the value specified for the text parameter
 in the Dialog window. This is useful for documenting the actions being
 taken in a debugger command file, the cprinit file, or AREXX
 macros. If the text parameter contains semicolons, they must be
 escaped with a backslash (\;). Defines or aliases are not expanded.


 Exampleecho Starting program\; loading defines .
 displays the message following the echo command in the Display
 window.


 See Also display, execute150 Chapter 9




env Sets the environment

Synopsisenv[function | integer]
env[-c[aller] | -s[ubroutine] | -u[p] | -d[own] | -integer |
 +integer]

Description: The env command changes the environment for subsequent debugger
 commands. Environment is the state of the machine at a particular
 point in the calling sequence (that is, the contents of the stack and the
 contents of variables). Setting the environment to a previous point in
 the calling sequence, such as the point where the current function was
 called, returns the machine to the state it was in at that time.
 However, only the information that can be retrieved from the stack
 will have been restored. Scratch registers and other components, such
 as the values of externs, that are not dependent on the stack remain
 relative to the current execution point in the application and will not
 be changed. Nonscratch registers are restored to the correct values for
 the new environment.
The environment can be set to an absolute or relative position in the
 call chain. To set it to an absolute position, specify the function name
 using the function parameter, or a level number using the integer
 parameter. The where command or Calls window can be used to
 display the level number. The other forms to the env command set the
 environment relative to the current function.
To move the environment up one level to the caller of the current
 function, use the -caller, -up, or -1 flags. To move in the opposite
 direction, use the -subroutine, -down, or +1 flags. Use the
 +integer or -integer forms to move more than one level at a
 time.
Level 1 is defined to be the function in which you are currently
 stopped. The caller's level is 2, its caller is level 3, and so on. These
 level number designations change as the program steps into and
 returns from functions.
If you attempt to move the environment up or down more levels
 than there are in the call frame, a warning is displayed and the
 environment is moved as far as possible.
After using the env command, commands that refer to line numbers
 and variables act as if the function specified by the function parameter
 is the current function. Any command that causes the program being
 debugged to resume execution, such as the go or trace commands,
 automatically resets the user environment to the last point of
 execution. Issuing the env command is the same as double-clicking on
 a function call entry in the Calls window.151 Commands and Built-in Functions



env Sets the environment
(continued)


 Examplesenv
 sets the user environment to the last point of execution.

env main; d i
 sets the user environment to main and display i.

env -subroutine
 sets the environment to the called function (down 1 level).

env -caller
 sets the environment to the caller function (up 1 level).

env +5
 moves the environment down 5 levels.

env 7
 moves the environment to the level 7.


 See Also where152 Chapter 9



execute Executes a debugger command file


Synopsisex[ecute] filename


Description: The execute command reads and executes CodeProbe commands
 from the file specified by the filename parameter. If the file cannot be
 found, CodeProbe appends a . cpr extension to it and tries again.
 Thus, you can place a set of debugger commands in a file with a .cpr
 extension and simply use the root filename, minus the extension, in the
 execute command. CodeProbe searches for the specified file in your
 normal Shell path as defined with the AmigaDOS PATH command.
If the file cmds.cpr consists of the commands


break sort
blist
trace
trace


 then the execute command applied to this file would yield the
 following display:


> execute cmds.cpr
executing commands from cmds.cpr
1 0xC32D3E sort:\sort.c\sort 22
sort:\sort.c\init 5
sort:\sort.c\init 9

The debugger commands themselves are not echoed as part of the
 display unless echo mode is turned on.
If you are debugging a program frequently and want to set a number
 of breakpoints at the same places, you can place all of your breakpoint
 commands in a file and then use the execute command on this file.
 This way you can avoid re-entering the same commands each time you
 want to use the debugger.
If the execute command is used in a command list, it must be the
 last command in the list.


 Examplesexecute setvars
 executes the file named setvars or setvars .cpr.

execute test/cmds.cpr
 executes the file named cmds.cpr located in the test directory.153 Commands and Built-in Functions




expand Expands and displays a command line

Synopsisexpand [alias] command-line


Description: The expand command displays its arguments with all aliases or
 defines expanded. The command-line parameter specifies any valid
 command-line entry that includes aliases or defines. This command can
 be useful in trying to create more complex aliases and defines.
 If the alias keyword is not specified, aliases are not expanded, but
 defines will be expanded.


Examplesexpand alias dp
 expands the alias for named dp to display the following:


 dump$ hex4


expand ISEQUAL(1,5)
 expands the macro ISEQUAL using the arguments 1 and 5. For
 example, if ISEQUAL has been defined as ( a == b ), then it
 would be expanded to ( 1 = = 5 ) .


See Also alias, define154 Chapter 9




ffnish Terminates CPRK and CPRX


 Synopsisfin[ish]


 Description: The finish command is used in cross-development mode to terminate
the session. The cross debugger (CPRX) on the host machine instructs
the kernel (CPRK) on the target machine to terminate after cleaning up
and closing the communications link. The f i n i s h command must be
entered on the host machine. The host machine is the one that is being
used to display the CodeProbe user interface. The f i n i s h command
does not work from the native version of CodeProbe.


 Example finish
 causes CPRK to terminate after disconnecting from CPRX.


 See Also quit155 Commands and Built-in Functions




fregisterDisplays or modifies floating-point registers


Synopsisfr[egister] [register[[=] expression]]


Description: On machines that have a math coprocessor chip installed, the
 fregister command displays or modifies the contents of the
 floating-point registers. If no parameters are specified, the fregister
 command displays the current contents of all the machine's floating-
 point registers in hexadecimal and as floating-point numbers. If only a
 register name is supplied, the contents of the register are displayed;
 otherwise, the value of the expression parameter is stored in the
 register specified.
The display and set commands also can be used to display and
 modify the registers.


 Examples fr
 displays all floating-point registers and flags.

fregister fp0 30.14
 sets floating-point register fp0 to 30. 14.

fr fp2 = sales
 sets floating-point register p2 equal to the value of sales.

fregister fp1
 displays the value of floating-point register fp1.

See Also display,register,rflag,set156 Chapter 9




go Continues execution until a breakpoint is encountered or the program
exits


Synopsisg[o][location[after(integer)] [when(expression)]]


Description: The go command begins execution of the program at the current
 location, which is identified by the address stored in the program
 counter (pc) register. Execution continues until a breakpoint is reached
 or until the program terminates, either normally or with an error.
The location parameter specifies an optional location for a temporary
 breakpoint. The breakpoint specified in the go command exists only
 for the duration of the go command. The next time program execution
 stops, the breakpoint is cleared, even if the temporary breakpoint was
 not reached.
The after option specifies the minimum number of times the
 specified location must be reached before the temporary breakpoint is
 triggered. This is also known as specifying a pass count. For go
 commands that do not contain an after clause, the pass count is set
 to 1.
Each time the temporary breakpoint is hit, the pass count is tested.
 If the pass count equals 1, the temporary breakpoint is triggered and
 execution stops. If the pass count is greater than 1, the pass count is
 decremented by 1 and execution continues.
If the when option is present, the breakpoint is triggered only if the
 specified expression evaluates to true (nonzero). The after and when
 options can be specified in any order. If both are used, the pass count
 is only tested and decremented when the condition is true.
Note: To avoid confusion, the go command does not use the
 default radix setting. You must specify ox for an address; otherwise,
 you will be specifying a line number. For example, even if the radix is
 set to hex, the following command specifies a go command for line 20
 and not address 0x20:

 g 20

 Examplesgo
 continues program execution to the next breakpoint or the end
 of the program.

go 14
 continues program execution to line 14 of the current module. 
 Note that line numbers are relative to a module and not a
 function. This example assumes that code was generated at line
 14. You cannot use the go command to go to a line with no code
 generated.157 Commands and Built-in Functions




go Continues execution until a breakpoint is encountered or the program
(continued) exits


 go sort
 continues program execution to the first line of the sort function.

 go \myfile.c\sort 14
 continues program execution to line 14 of the sort function in
 module my file.c . This example also assumes that code was
 generated at line 14.

 go mylib.library: myfunc
 continues program execution to the myfunc function in the shared
 library mylib. library.

 go $ after(5)
 continues program execution until the fifth time the current line is
 executed.

 go 0x804A
 continues program execution until absolute address 0x804A is
 reached.


 See Also break, proceed, ps, trace, ts158 Chapter 9




helpDisplays help information


Synopsish[elp] [command]
? [command]


Description: The help command displays information about commands and
 operands. If the command parameter is omitted, the Help window
 opens and a list of commands and topics is displayed. Entering one of
 the items on this list as the value for the command parameter displays
 information about that item.
An alternate method of selecting an item is to double-click on the
 command or topic in the Help window. This method of selection can
 also be used from the help screens themselves. For example, at the
 bottom of the screen for the dump command there is a section that
 directs you to the display and dzero commands for additional
 information. You can access the help screen for either of these
 commands by double-clicking on the name of the command.


 Exampleshelp
 displays a list of commands and topics.

h break
 displays information about the break command.

? break
 displays information about the break command.159 Commands and Built-in Functions


hunksLists the addresses and sizes of all hunks


Synopsishu[nks]


Description: The hunks command displays the list of loaded hunks, their
 addresses, and their sizes for the current executable file.
The following example shows the output from the hunks command:


>hunks
Hunk Address Size
 000C32AE80xB54 (2900)
 100C285700x27C (636)


The size is displayed first in hexadecimal format followed by decimal
 format in parentheses.


Example hunk s
 lists all hunks for the current executable file.160 Chapter 9




jumpChanges the current execution point


Synopsisj[ump] location


Description: The jump command updates the program counter to point to a new
 location. The effect of using this command is that the code between the
 previous execution point and the new location is not executed. Any
 value for the location parameter that is valid for the break or go
 commands can be used. It is important to note that the stack is not
 modified in any way.
You should be very careful when using the j ump command because
 certain registers may not be set up the way the code that is jumped to
 expects. Using the j ump command is more likely to be safe if you
 always jump from one C source file line to another in the same
 function (not from assembly lines), and you have compiled with the
 debug=symbolflush or debug=fullflush options to make sure
 that registers are flushed to memory at C source line boundaries. If the
 jump command is used on optimized code, the registers are not likely
 to be set correctly.
Note: To avoid confusion, the jump command does not use the
 default radix setting. You must specify 0x for an address; otherwise,
 you will be specifying a line number. For example, even if the radix is
 set to hex, the following command specifies a jump command for line
 20 and not address 0x20:


 j 20


 Examplesjump 1 2
 jumps to line 12 in the current function.

jump 0x804E
 jumps to the address 0x804E.


 See Also env, go, return161 Commands and Built in Functions




listLists the lines in a source file

Synopsisl[ist]
l[ist] $
l[ist] + | - integer [L length]
l[ist] line-range
l[ist] [image:]\module [line-range]
l[ist] [[image:]\module\lfunction [line-range]


Description: The list command is used when debugging in line mode to list the
 lines in a source file. The current list line is set to the source line at
 which the program being debugged is stopped each time the user
 regains control.
 The list command with no arguments displays lines starting with
the current list line. The number of lines displayed is controlled by the
opt list command.
 The $ parameter is used to list a number of lines above and below
the current line at which the program is stopped. The number of lines
above and below is controlled by the opt context command.
 The module parameter specifies the name of a module in the
program. A range of lines is specified with the line-range parameter,
which can have either of the following forms:


line-1 [[..] Iine-2]
line-1 L length


In the first form the line-range parameter specifies a range of lines
starting at line-1 and ending at line-2. In the second form a range of
lines is specified as starting at line-1 and extending for length number
of lines.
 If the list command is given an environment (module or function),
then the source file for that environment is opened, if possible, and the
desired line range is displayed. If no line range is given, and no
function is given, the listing begins at line 1. If a function name is
given and no line range is given, lines are listed beginning with the
function declaration.
 Each time the list command is used, the current list line is set to
the line immediately following the last listed line. Remember that the
current list line is also updated each time the client program is allowed
to execute.

 Examples list
 lists the next group of lines. The number of lines listed is
 set by the opt list command.162 Chapter 9




listLists the lines in a source file
(continued)


list $
 lists lines around the line pointed to by the current program
 counter.

list module
 lists first lines of the specified module.

list \module 20 40
 lists lines 20 through 40 of the specified module.

list \module 20 L 10
 lists 10 lines of the specified module starting at line 20.

list +20
 starts listing lines 20 lines down from the current line.

list -20
 starts listing lines 20 lines up from the current line.

list -20 L 10
 lists 10 lines, starting 20 lines up from the current line.

list foo
 starts listing at the declaration of the function named foo.

list foo 10 20
 lists lines 10 through 20 of the function named foo.


 See Also opt, source, unassemble163 Commands and Built-in Functions



 log Logs debugger commands to a file

Synopsis lo[g] [log-command]

Description 

 The log command is used to save to a file a record of all activity in
 the Dialog window including commands and results. Menu selections
 are not saved by the log command. This information is stored in a log
 file. The name of the file is set with the log f ile command. The
 default filename is cpr. log.
When issued without the log-command parameter, the log command
 can be used to display the current log state, either on or o f f, and the
 filename of the log file. The log-command parameter can be any of the
 following:

 append
 appends log information to the end of the log file

file filename
 specifies the filename of the log file

off
 closes the log file

on
 opens a new log file

snap
 snapshots contents of the Dialog window to the log file.

 If a command that enables the logging of your session, such as log
on, log append, or log snap, is issued when logging is already
enabled, the results of the command are added to the current log file.
If the log filename is changed while logging is enabled, the current log
file is closed, and a new one is opened. The log file is automatically
closed when you exit CodeProbe.

 Examples

 log snap
 saves the dialog for the current session into the log file named
 cpr . log.

 log file foo.log
 sets the log file to the filename foo.log.

 log on
 enables the log file.164 Chapter 9



log Logs debugger commands to a file
(continued)


 log off
 disables the log file.

 log append
 enables the log file and appends new log information to the end of
 the log file.165 Commands and Built-in Functions




opt Shows option values or changes the value of a debugger option

Synopsis op[t]
op[t] aU[toswap] [on | off]
op[t] ar[rdim] integer
op[t] b[adchar] integer
op[t] ca[se] [on | off]
op[t] cat[ch][on | off]
op[t] co[ntext] integer
op[t] dev[ices][on | off]
op[t] e[cho] [on | off]
op[t] ib[ytes][on | off]
op[t] ig[norepath] [on | off]
op[t] l[ist] integer
op[t] rad[ix][d[ecimal] | h[ex]]
op[t] ran[gelen] integer
op[t] re[slib][on | off]
op[t] se[arch] [+ | -] director,v[, director,v [ . . . ]]
op[t] so[urce] c | a[sm] | m[ixed] | n[ext]
op[t] st[rlen] integer
op[t] t[ask] [task-ID]
op[t] u[nassemble] integer


Description
The opt command is used to show the value of debugger options or to
 change them. The opt command by itself shows the current settings of
 all options. The following are the options and their possible values:

 autoswap
 if set to on, pushes the screen containing the applications output to
 the front each time control is given to the application. If set to o f f,
 the application screen is not pushed to the front. The default is
 off.

 arrdim
 controls the maximum number of array elements that are displayed
 at one time with the display command. The default is 20.

 badchar
 controls the number of non-ASCII characters that a dzero or
 display command will accept when displaying a string referenced
 by a character pointer. The default is 3.

 case
 if set to on, causes the search command to perform case-sensitive
 string searches. The default is off.166 Chapter 9




opt Shows option values or changes the value of a debugger option
(continued)


 catch
 if set to on, catches any new task generated by a task under
 debugger control. The default is off.

 context
 controls the number of lines displayed in the Source window
 preceding the current line. The default is 2.

 devices
 if set to on, attaches to, or catches, any new device process or task
 generated by a task under debugger control. The default is off.

 echo
 if set to on, causes the debugger to echo all commands to the
 Dialog window. This is particularly useful when using the
 execute command to execute a file of debugger commands. The
 default is off.

 ibytes
 if set to on, causes the debugger to display the instruction bytes
 being disassembled. This affects the output of the unassemble
 command. In windowing mode, it also affects the Source window in
 mixed and asm source modes. The default is off.

 ignorepath
 if set to on, causes the debugger to ignore the pathname for the
 source file provided by the compiler. The default is off.

 list
 controls the default number of lines displayed by the list
 command in line mode. The default is 6.

 search
 defines a set of directories to search for the source code. If no + or
 -- is specified, the list of directories replaces the current list.
 Specifying a + at the beginning of the list appends the new list to
 the end of the current list. Specifying a -- at the beginning of the
 list removes the specified directories from the current list.

 source
 controls the display in the Source window in windowing mode.
 Repeatedly choosing the next values cycles through the possible
 display types in the order C, asm, and mixed. The source option
 controls the output when you execute a step or go. The default is
 C.167 Commands and Built-in Functions




 opt Shows option values or changes the value of a debugger option
(continued)


strlen
 controls the maximum number of bytes that are displayed when a
 character string is displayed with the dzero command. The default
 is 128.

task
 changes the current task to the task identified by the task-ID
 parameter. The task-ID parameter can be either the name of a task
 or the address of a task control block, as displayed by the tasks
 command.

radix
 sets the default input type for constants. It is used to avoid having
 to type the initial 0x on hexadecimal constants. The default is
 decimal.

rangelen
 controls the default size of ranges when no range size information
 is available. The default is 64.

reslib
 if set to on, steps into resident libraries while tracing or running an
 application with watch breaks. The default is off .

unassemble
 controls the default number of instructions that are disassembled by
 the unassemble command in line mode. It has no effect in C
 mode or windowing mode. The default is 4.

Examples

opt
 displays the settings of all options.

opt unassemble 10
 sets unassemble count to 10.

opt search /src,/test
 sets search directories.

opt search +test2
 appends a new search directory.


 See Also display,dzero,list,unassemble168 Chapter 9




proceed Single-steps over function calls

 Synopsis p[roceed] [integer]

Description 
 In C mode, the proceed command causes the debugger to step
 through the number of source statements specified by the integer
 parameter. In Mixed or Asm modes, it steps through integer number
 of machine instructions. If a function call is encountered, the function
 is executed as if it were a single statement. If the integer parameter is
 omitted, it defaults to 1.
A proceed command is performed when you press the Return key
 without entering any commands in the Dialog window. The F6 key can
 also be used to enter the proceed command.

 Examples 

 proceed
 steps 1 source statement in C mode or 1 machine instruction if in
 Mixed or Asm modes.

 proceed 5
steps 5 source statements in C mode or 5 machine instructions if in
Mixed or Asm modes.


 See Also go, ps, trace, ts169 Commands and Built-in Functions




 ps Single-steps over function calls by source line


 Synopsis ps [integer]


Description 
 The ps command causes the debugger to single-step through the
 number of C source statements specified by the integer parameter even
 if mode is set to Mixed or Asm. If a function call is encountered
 during stepping, the function is executed as if it were a single
 statement. If the integer parameter is omitted, it defaults to 1.


 Example

 ps2
 steps through two source lines regardless of the debugger mode.

 See Also go, proceed, trace, ts170 Chapter 9




 quit Terminates the debugger


 Synopsis q[uit]


Description 
The quit command terminates the debugging session and returns to
 the operating system prompt.
When running in cross-development mode, the quit command only
 terminates the cross debugger (CPRX) on the host machine, leaving the
 kernel (CPRK) waiting for a new debug session.
Normally, CodeProbe forces the application being debugged to call
 the exit function before terminating the application. The debugger
 then exits. If CodeProbe was started with the -startup option, the
 debugger exits without forcing the application to call exit.


 Example quit
 terminates the debugging session.171 Commands and Built-in functions



 register Displays or modifies registers


 Synopsis r[egister] [register [[=] expression]]


Description 
 If no arguments are given, the register command displays the
 current contents of all the machine integer registers. If a register name
 is specified by the register parameter, the contents of that register are
 displayed. If an expression parameter is specified in addition to the
 register parameter, the value of the expression is stored in the register.
The display and set commands can also be used to display and
 modify the contents of the registers.


 Examples
 register
 displays all registers and flags.

 register dS = 30
 sets register D5 to 30.

 r d3 = index
 sets register D3 to the value of index.

 register a0 &x
 sets register A0 to the value pointed to by x.

 r a1
 displays the value stored in register A1.


 See Also display, fregister, rflag, set172 Chapter 9




 restart Restarts the program being debugged


 Synopsis res[tart] [argument-list]


Description
 The restart command causes the program you are debugging to be
 reloaded and executed up to the entry point of main, just as when the
 debugger was first invoked. (If the -startup option was specified
 when you invoked the debugger, execution will stop before the startup
 code is executed and not at the first line of the main function.)
 Because the program is reloaded, all static data is reinitialized. All
 breakpoints will be retained and watch breaks on static and external
 variables will be retained and disabled.
The argument-list parameter provides the arguments for the program
 being debugged. These arguments are delimited by white space, just as
 would appear on the command line when invoking the program. The
 program will use these arguments as if it were invoked from the
 command line with them.
The restart command cannot be used with the -command
 command-line option or as one of a sequence of commands separated
 by semicolons. When used, the restart command must occur at the
 end of a command line.
The restart command potentially can cause your machine to crash
 if used improperly. When you enter the re s tart command, your
 application is immediately reloaded and re-executed with no cleanup of
 your currently running program other than calling the exit function
 to close files. This can leave the machine in an unacceptable state that
 can cause problems later. To avoid this problem, be sure to allow your
 application to run to completion if possible and do any necessary
 cleanup before issuing the restart command.
The start and restart commands are the same if the same
 arguments are provided by the argument-list parameter. The significant
 difference between the two commands is their behavior when they are
 specified with no arguments. The start command restarts the
 program without any arguments; however, the restart command
 with no arguments restarts the program with the original arguments
 used when the debugger was invoked.173 Commands and Built-in Functions




 restart Restarts the program being debugged
(continued)


Examples 

restart
 restarts the program using the same arguments with which it was
 initially invoked.

restart myfile.txt 5
 restarts the program passing it two arguments: myfile.txt and
 5

restart "sample string"
 restarts the program passing in a string as an argument.


 See Also start174 Chapter 9




 return Returns immediately from the current function


 Synopsis ret[urn] [expression]


Description 
 The return command causes the current function to return to its
 caller without executing the rest of the function.
The value of the expression parameter is used as the return value
 from the function. The value is converted to the appropriate type if
 necessary; however, it must be a scalar quantity (not a structure or
 union).
An attempt to return a value from a function declared void is
 treated as an error, and a suitable message is displayed. Similarly, an
 error message is displayed if you use a simple return command
 (without a parameter) from within a function declared as having a
 return value. In all other cases, the return value is cast (if necessary)
 to the correct type and returned to the calling function.
When a return command is given, the current function is returned
 immediately to the calling function. The return value, if any, is
 returned to the calling function, and execution is suspended as though
 a breakpoint were triggered in the calling function after the call was
 made. For instance, note the following code fragment:


i = 5;
j = func(i);
if (j < 2)
 j++ ;


Assume that the return command is issued during the execution of
 func in the form ret 7. Execution stops inside the line that did the
 call, just before the assignment to j. You can then single-step to the
 next statement.


 Examples

 return stringptr
 returns the value of stringptr.

 ret 5
returns an integer value of 5.

 return
returns from a void function.175 Commands and Built-in Functions




 rflag Displays or modifies flags


 Synopsis rf[lag] [flag ...]


Description 
 The rflag command can be used to display or modify the settings of
 the machine flags. If no parameters are specified, the current settings
 of the flags are displayed. With one or more arguments, the indicated
 flags are set or cleared according to the values given. The flag names
 are specific to the target machine.
A flag setting can be one of the terms in the following table. The Set
 column comprises the terms used to set flags, while the Clear column
 comprises the terms used to clear flags.



Flag NameSetClear

Overflow (yes/no)OV NV

Sign (negative/positive) NG PL

Zero (yes/no)ZR NZ

Auxiliary Carry (yes/no) AC NA

Carry (yes/no)CY NC




 Examples
 rflag
displays all registers and flags.

 rflag cy
 sets the carry flag to 1.


 See Also fregister, register176 Chapter 9




 search Searches for a string in the current source file


 Synopsis sea[rch] [string]


Description 
 The search command searches the current source file for the
 specified string. In windowing mode, the search begins from the top
 line of the current Source window. In line mode, the search begins at
 the first line that would be displayed if a list command were entered
 with no arguments.
In windowing mode, the cursor is positioned at the beginning of the
 matching string. The Source window is also repositioned so that the
 line containing the match is the number of lines specified by the
 context option from the top of the window. The context is set by
 the opt command.
In line mode, the line containing the match is displayed.
The search command with no arguments causes the debugger to
 search for the string specified in the last search argument, starting
 from the new current line. If no matches are found, a message is
 printed. If the user then enters search again, the search is resumed
 beginning at the top of the file. The case-sensitivity option, opt case,
 determines whether the search is case sensitive or not.


 Examples
 search foo
 finds the string "foo".

 search foo;
finds the string "foo". The semicolon used in this command is a
command delimiter and is not considered part of the search string.

 search foo\;
finds the string "foo;" . The escape character (\) causes the
semicolon to be part of the search string.

 search
repeats the last search.


 See Also opt, list177 Commands and Built in Functions


 set Modifies the values of variables or memory locations


 Synopsis se[t] (variable | register) = expression
se[t] address [=] string


Description 
 The set command is used to modify the values of variables, registers,
 or memory locations in the program being debugged.
You are most likely to use the first form of the set command in
 debugging C programs. It allows you to change the value of a variable
 in your program by referring to that variable by name. In this context,
 variable has a rather broad sense that includes references to array
 elements, structure members, and indirect references.
The variable parameter cannot refer to an aggregate such as a
 structure, union, or array.
The register parameter can be any valid register name, D0 through
 D7 and A0 through A7, and if a co-processor is present, FP0 through
 FP7. A $ prefix optionally may be used to distinguish the register from
 a variable of the same name.
The expression parameter is the same as used in the C assignment
 statement.
If necessary, the value for variable will be converted to the proper
 type in accordance with the normal C conversion rules; it is then
 entered into memory at the address of the first variable operand. This
 is similar to a C assignment statement for a scalar variable.
The second form shown in the synopsis is used to store a string into
 memory. The null terminator is not copied unless it is explicitly
 present in the string. The equal sign is optional. Support for this form
 of set command may be removed in future releases. The built-in
 strcpy and memcpy functions are preferred.

 Examples

 set i = 5
 sets the variable i equal to the integer value 5.

 set a = 3.1415
 sets the variable a equal to the floating-point value 3.1415.

 set $d0 = 300
 sets register D0 equal to 300. The $ is optional.

 set time->date = newtime
 sets the date member of the time structure equal to the value of
 the variable newtime.

 set stringptr "this string has no null byte"
 stores a string that is not null-terminated to the memory location
 pointed to by stringptr.178 Chapter 9




set Modifies the values of variables or memory locations
(continued)


 set stringptr "this string has a null byte\0"
 stores a null-terminated string to the memory location pointed to by
 stringptr.

 set stringptr "string one\0string two\0"
 stores two null-terminated strings to the memory location pointed to
 by stringptr.


See Also fregister,memcpy,strcpy,register179 Commands and Built-in Functions




sleep Pauses for the time specified


Synopsis sle[ep] number


Description 
 The sleep command pauses for the number of seconds specified by
 the number parameter.


Example sleep 10
 pauses for 10 seconds.180 Chapter 9



 source Displays the source file


 Synopsis so[urce] [filename]


Description 
 The source command overrides the C source file associated with the
 current module. The specified value for filename replaces the filename
 associated with the module for the rest of the current debugging
 session. The new file is displayed in the Source window immediately,
 and its name is echoed in the Dialog window.
If no filename parameter is specified, the name of the current source
 file is echoed in the Dialog window but the current source file is not
 changed.
If the filename you want to change to is the same as the default
 filename but the path is different, you can use the opt search
 command instead of the source command to change the locations that
 CodeProbe looks for source files.


 Examples
 source
displays the current filename.

 source test/test1.c
changes the filename for the current module to test1.c in the
test directory.


 See Also opt181 Commands and Built-in Functions




 start Restarts the program being debugged


 Synopsis sta[rt] [argument-list]


Description 
 The start command causes the program you are debugging to be
 reloaded and executed up to the entry point of main, just as when the
 debugger was first invoked. (If the -startup option was specified
 when you invoked the debugger, execution will stop before the startup
 code is executed and not at the first line of the main function.)
 Because the program is reloaded, all static data are reinitialized. All
 breakpoints are retained and watch breaks on static and external
 variables are retained and disabled.
 The argument-list parameter provides the arguments for the program
being debugged. These arguments are delimited by white space, just as
would appear on the command line when invoking the program. The
program will use these arguments as if it were invoked from the
command line with them.
 The start command cannot be used with the -command
command-line option or as one of a sequence of commands separated
by semicolons. When used, the start command must occur at the
end of a command line.
 The start command potentially can cause your machine to crash if
used improperly. When you enter the start command, your
application is immediately reloaded and re-executed, with no cleanup
of your currently running program other than calling the exit
function to close files. This can leave the machine in an unacceptable
state that can cause problems later. To avoid this problem, be sure to
allow your application to run to completion and do any necessary
cleanup before issuing the start command.
 The start and restart commands are the same if the same
arguments are provided by the argument-list parameter. The significant
difference between the two commands is their behavior when they are
specified with no arguments. The start command restarts the
program without any arguments; however, the restart command
with no arguments restarts the program with the original arguments
used when the debugger was invoked.182 Chapter 9




start Restarts the program being debugged
(continued)


 Examples
 start
 restartsthe program being debugged without passing it any
 arguments.

 start myfile.txt 5
 restarts the program being debugged passing in the arguments
 myfile.text and 5.


See Also restart183 Commands and Built-in Functions




 symbol Finds the symbol nearest to the specified address


 Synopsis symb[ol] address


Description 
 The symbol command causes the debugger to search the symbol
 information and display the name of the symbol whose location is
 closest to the address specified by the address parameter.


 Example symbol 0x8040
 displays the symbol whose address is nearest to 0x8040.


 See Also symload184 Chapter 9




symload Reads symbol information from an executable file


 Synopsis sym[load] executable file
 sym[load] proc process-id
 sym[load] seg address executable-file


Description
The symload command associates an executable file and any
 debugging information found in that file with a loaded image.
If given the filename of an executable-file, the symload command
 associates that file with the current hunk list.
If the proc keyword is used, followed by the name of a process that
 is identified by the process-id parameter, the symload command
 attempts to map the segment list for the process with its executable
 file.
If the seg keyword is specified along with an address and the
 filename of an executable file, the symload command treats the
 address as a pointer to a BCPL segment list and it maps the list to the
 executable file.


 Examples
 symload myapp
 reads the current segment list and symbols from the file named
 myapp.

 sym proc myapp
reads the segment list and executable file for process myapp.

 symload proc 0xC85428 myapp
reads the segment list and executable file for the process located at
0xc85428.

 symload seg 0xC84200 myapp
uses the segment list at address 0xC84200.


 See Also hunks185 Commands and Bui1t-in Functions



tasks Displays system tasks


 Synopsis ta[sks] [a[ll]]


Description 
 The tasks command displays information about tasks. By default, it
 displays the tasks currently under debugger control. If the all option
 is specified, all system tasks are displayed.
 The opt task command can be used to change to a new task.


 Examples 
 tasks
 displays a listing of all tasks under debugger control.

 ta all
 displays a listing of all tasks in the system.


 See Also activate, catch, deactivate, detach, opt186 Chapter 9




trace Single-steps into function calls


 Synopsis t[race] [integer]


Description 
 In c mode, the trace command steps the number of source
 statements specified by the integer parameter. In Mixed or Asm
 modes, it steps the number of machine instructions specified by the
 integer parameter. If a function call is encountered, stepping continues
 into that function. If the integer parameter is omitted, trace will step
 one line.


Examples 
trace
steps one source statement if in C mode, or one machine instruction
if in Mixed or Asm mode.

t 5
steps five source statements or machine instructions.


 See Also go, proceed, ps, ts187 Commands and Built-in Functions




 ts Single-steps by source line into function calls


 Synopsis ts [integer]


Description 
 The ts command is similar to the trace command in that it will step
 into functions encountered during execution. It is different in that ts
 will only step by C source line, even if the source mode is set to Asm
 or Mixed. The integer parameter specifies the number of C source
 lines to step. If no parameter is specified, ts will step one line at a
 time.


 Examples 
 ts
 steps one source line regardless of the mode the debugger is in.

 ts 2
 steps two source lines.


 See Also proceed,ps,trace188 Chapter 9



 unalias Deletes an alias


 Synopsis una[lias] name
 una[lias] *


Description
The unalias command removes entries from the debugger's list of
 aliases. The name parameter refers to any alias name. You can use the
 * parameter as a wildcard character to remove all aliases.


 Examples 

unalias foo
deletes the alias for foo.

una *
deletes all aliases.


 See Also alias, define, undefine189 Commands and Built-in Functions



unassemble Displays memory as assembler instructions

 Synopsis u[nassemble] [location-1 [location-2]]


Description 
 The unassemble command displays the range of memory from
 location-1 to location-2 in assembler format.
 By default, the command begins disassembling at the current
 program counter. If subsequent unassemble commands are
 performed before the application is given control by a trace,
 proceed, or go command, it will continue disassembling from the
 point at which it finished the last invocation.
 If source line number information is available for the range of
 memory being disassembled, unassemble will display the C source
 line before displaying the corresponding instructions. It will display the
 number of assembler instructions generated for one C source line.
 If no source information is available for the range of memory being
 displayed, unassemble will display the default number of
 instructions as specified by the unassemble default item in the
 Options menu. By default this number is 4 instructions.
 The output of the unassemble command is equivalent in format to
 assembler mode output displayed in the Source Window. It will consist
 of three or four columns depending on the setting of the instruction
 bytes option, which is controlled by the opt ibytes command. (See
 Chapter 4, "Setting Up the Debugging Environment," for more
 information about setting instruction bytes.) The following is an
 example of unassemble output with instruction bytes on and source
 unavailable:


> unassemble
0x25F950 48E70130MOVEM.L D7/A2-A3,-(A7)
0x25F954 BFEC0004CMPA.L 0004(A4),A7
0x25F958 65001BD6BCS 00261530


 The first field contains the hexadecimal address of the instruction
 being disassembled. The second field is a hexadecimal dump of the
 actual bytes composing the instruction. The third field consists of the
 M680X0 mnemonic for the given opcode. The fourth field consists of
 the operands to the instruction. If the instruction bytes option is
 turned off, the second field is not displayed.

 Examples
 unassemble \modl\func1 10
 unassembles line 10 of func1 in mod1.

 unassemble 13 14
 unassembles lines 13 to 14.190 Chapter 9



unassemble Displays memory as assembler instructions
(continued)


 unassemble func1
 unassembles the first line of func1.

 unassemble func1 func2
 unassembles from &func1 to &func2.

 unassemble
 continues unassembling at the last location.

 SeeAlso opt, list191 Commands and Built in Functions



undefine Deletes a macro definition


Synopsis [#]und[efine] name
[#]und[efine] *


Description 
 The undef ine command removes entries from the debugger's list of
 macro definitions. The name parameter specifies the name of the macro
 to removed. You can use the * as a wildcard character to remove all
 macro definitions. The # sign can be inserted before the undef ine
 command so that C header files (.hfiles) can be read by CodeProbe.


Examples 
 #undef foo
 deletes the macro named foo.

 undefine *
deletes all macros.


 See Also alias, define, execute, unalias192 Chapter 9




 watch Sets a watch on a variable or memory


 Synopsis w[atch] expression | range [s[tatic] | d[ynamic]]


 Description 
 The watch command is used to set a watch for the expression or
memory range specified. Whenever control is returned to the user, for
example by stepping or stopping at a breakpoint, the new value of the
watched object is displayed in the Watch window. The Watch window
can be opened with the View menu, the window command, or by
pressing F1.
In line mode, the object is not automatically displayed. You must use
 the w list command to display it.
The watch command does not cause the debugger to stop execution
 when the value being watched changes; it just displays the changed
 value. Use the wbreak command to cause the debugger to stop when
 a value is changed.
By default, watches are dynamic; that is, the expression being
 watched is re-evaluated whenever control returns to the debugger. The
 static option causes the watch expression to be evaluated once,
 when the watch is set. The result is treated as an address whose
 contents are displayed.


 Examples 
 watch text->len
sets a watch for the symbolic scalar text->len.

 w \mod\f1\a[0] L 20
sets a watch for a length of 20 bytes starting at the symbolic range
specified by \mod\f1\a[0].

 w &a[0] .. &a[5]
sets a watch for the range from &a[0] to &a[5].

 watch tmp[i] static
if i = 3, watches tmp [3] regardless of changes to i.


 See Also wbreak,wclear,wdisable,wenable,wlist193 Commands and Built-in Functions



 wbreak Sets a watch break

Synopsis wb[reak] expression | range [s[tatic] | d[ynamic]]


Description
The wbreak command sets a watch break for the expression or
 memory range specified. Whenever any byte in a specified range is
 modified, control is returned to you.
By default, watch breaks are static; that is, the expression is
 evaluated once when the watch break is set. The address result of the
 expression is then monitored by the watch break.
The dynamic option indicates that the watch break expression or
 range should be re-evaluated whenever control returns to the
 debugger.


 Examples
 
 wbreak text->len
 sets a watch break for the symbolic scalar text->len.

 wb \mod\f1\a[0] L 20
 sets a watch break for a length of 20 bytes starting at the symbolic
 range specified by \mod\f1\a[0].

 wbreak &a[0].. &a[5]
 sets a watch break for the range from &a[0] to &a[5].

 wb p->q dynamic
 sets a watch break for different locations depending on the value of
 p.


See Also watch, wclear, wdisable, wenable, wlist194 Chapter 9



 wclear Clears one or more watches


 Synopsis wc[lear] integer [integer . . . ]
 wc[lear] * | l[ast]
 wc[lear] integer .. integer


Description 
 The wclear command is used to clear one or more watches or watch
 breaks. When a watch is cleared it ceases to exist and can be
 reinstated only by issuing the watch or wbreak command again. You
 can use the wdisable command to temporarily disable a watch.
The integer parameter specifies the number of a watch as displayed
 by the wlist command. Any number of integer values can be
 specified as parameters to the wclear command.
The * parameter specifies that all watches and watch breaks should
 be cleared.
You can specify that all watches and watch breaks between two
 watch numbers be cleared by using the form integer . . integer.
The last parameter can be specified to clear the last watch or
 watch break that was set.


 Examples

 wclear 2 5 6
 clears watches or watch breaks numbered 2, 5, and 6.

 wclear last
clears the last watch or watch break set.

 wc *
 clears all watches or watch breaks.

 wc4..7
 clears watches 4, 5, 6, and 7.


See Also watch, wbreak, wclear, wdisable, wlist195 Commands and Built-in Functions



wdisable Disables one or more watches

Synopsis wd[isable] integer [integer ...]
wd[isable] * | l[ast]
wd[isable] integer .. integer


Description 
 The wdisable command is used to disable the recognition of one or
 more watches or watch breaks. When a watch or watch break is
 disabled, it is no longer recognized, but it remains on the current list
 of watches. A wenable command can be used to re-enable a watch or
 watch break that has been disabled with the wdisable command.
 The integer parameter specifies the number of a watch, as displayed
by the wlist command. Any number of integer values can be
specified as parameters to the wdisable command.
 The * parameter specifies that all watches and watch breaks should
be disabled.
 You can specify that all watches and watch breaks between two
watch numbers be disabled by using the form integer . . integer.
 The last parameter can be specified to disable the last watch or
watch break that was set.


 Examples
wdisable 2 5 6
 disables watches or watch breaks numbered 2, 5, and 6.

wdisable last
 disables the last watch or watch break set.

wdisable *
 disables all watches or watch breaks.

wdisable 4..7
 disables watches 4, 5, 6, and 7.


See Also watch, wbreak, wclear, wenable, wlist196 Chapter 9



wenable Enables one or more watches


 Synopsis we[nable] integer ...
 we[nable][*] | l[ast]
 we[nable]integer .. integer


Description 
 The wenable command is used to enable the recognition of one or
 more watches or watch breaks that have been disabled by the
 wdisable command.
The integer parameter specifies the number of a watch, as displayed
 by the wlist command. Any number of integer values can be
 specified as parameters to the wenable command.
The * parameter specifies that all watches and watch breaks should
 be enabled.
You can specify that all watches and watch breaks between two
 watch numbers be enabled by using the form integer . . integer.
The last parameter can be specified to enable the last watch or
 watch break that was set.


 Examples
 we 2 5 6
 enables watches or watch breaks numbered 2, 5, and 6.

 we last
enables the last watch or watch break set.

 wenable *
enables all watches or watch breaks.

 we 4..7
 enables watches 4, 5, 6, and 7.


See Also watch, wbreak, wclear, wdisable, wlist197 Commands and Built-in Functions




 whatis Determines the type of an object

 Synopsis wha[tis] expression
wha[tis] (type)

Description 
 The whatis command displays the type, location, and storage class of
 an object, or gives additional information about a data type.
If an expression is given, whatis displays the C data type of the
 expression. If the result of the expression is a simple variable or a
 member of an array, whatis displays the address of the object and
 identifies it as either static, extern, or automatic. If the result
 of the expression is a function, whatis displays the address of the
 function, its return type, and its location.
If a parenthesized type is given, including types that are defined by a
 typedef statement, whatis displays the full definition for the type.
 For struct, union, and enum types this means all members of the
 aggregate are displayed; for a type that has been defined by a
 typedef statement, this means the base type of the typedef is
 displayed. Using the whatis command on basic C data types such as
 int or long is allowed, but it is not very useful.

 Examples

 whatis i
 determines the type of a variable named i.

 wha main
 determines the type, address, and defining module for the main
 function.

 wha 3.5
 determines the type of a constant.

 whatis Red
 determines the type of an enumeration constant.

 wha *p->c[3]
 determines the type of the expression *p- >c [3].

 whatis (int) (1*3.4)
 determines the type of an expression with a type cast.

 whatis (node)
 determines the type of a typedef.

 whatis (struct X)
 displays the members of s truct X.198 Chapter 9

End Of Part 2

