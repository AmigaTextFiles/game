Part 3


 where Shows the calling sequence


 Synopsis whe[re] [a[rgs]] [integer]


Description 
 The where command displays a backtrace of the function calls in the
 call sequence. Calls are listed in reverse order beginning with the most
 deeply nested function.
The args option causes the where command to display the
 arguments to each function in a manner similar to the args
 command.
The integer parameter specifies the number of calls to be displayed.
 By default, only the 20 most recent calls are printed.
Here is an example of the output from the where command:


> 1  In routine fpreg.o:\fpreg.c\five 48
> 2* Called from fpreg.o:\fpreg.c\six 68 (+0xE)
> 3  Called from fpreg.o:\fpreg.c\seven 82
> 4  Called from fpreg.o:\fpreg.c\main 92
> ...


 The numbers on the left indicate a level number that can be passed to
 the env command. Level 1 is defined to be the function in which you
 are currently stopped or the run environment. The caller's level is 2,
 its caller is 3, and so on. These level number designations change over
 time as the program steps into and returns from functions. The
 asterisk indicates the current user environment as set by the env
 command.
The Calls window also displays this information.


 Examples

 whe
 displays a list of the last 20 function calls.

 where S
displays a list of the last 5 function calls.

 where a
displays the arguments to each function.

 See Also args, env199 Commands and Built-in Functions

 window Opens or closes a window

 Synopsis wi[ndow] window-name [on | off]


Description
The window command is used to open and close a specified window.
 Any of the following values can be specified as the window-name
 parameter:
 c[alls] mo[dules]w[atch]
 he[lp] ms[g]s[ource]
 me[mory]r[egister]

If the window command is invoked with only a window-name
 parameter, the command acts as a toggle for the specified window;
 thus, if the window is currently opened, the window command will
 close it, and if it is currently closed it will be opened.
 If on or off is specified, the window is forced into that state,
 regardless of its current state. If a window that is already open is set
 to on, it will pop to the top of the window hierarchy.
 The window command is ignored in line mode.


 Examples

 wi register
 toggles the Register window.

 window help on
 opens the Help window or pops it to the top.200 Chapter 9




wlist Lists all watches


 Synopsis wl[ist]


Description 
 The wlist command lists all watches and watch breaks. Disabled
 watches are marked with an asterisk. Watch breaks are distinguished
 from regular watches by an exclamation mark. The value associated
 with the watch is displayed if available.


 Example w list
lists all watches.


 See Also watch, wbreak, wclear, wdisable, wenable201 Commands and Built-in Functions




 wmsg Writes a message to the Message window

Synopsis wmsg integer message-text

Description 
 The wmsg command is used to write the text specified by the
 message-text parameter in the Message window. The integer parameter
 specifies the location in the window for the text. Line 0 is the top line.
 This command is used primarily with debugger or AREXX scripts.


 Examples wmsg 0 --- This is the Message window. ---
 displays the string --- This is the Message window. ---
 on the top line of the Message window.

wmsg 12 This goes on line 12.
 displays the string This goes on line 12. on line 12 of the
 Message window.202 Chapter 9

 Built-in Functions

 As described in Chapter 3, "Debugging Your Program", built-in
 functions are standard, commonly used functions recognized by the
 compiler and expanded inline for efflciency. The SAS/C Compiler
 defines several built-in functions that are described in Chapter 4,
 "Using the System Header Files to Access Libraries," of the SAS/C
 Development System Library Reference.
 CodeProbe also defines several built-in functions. These functions are
 related to the library built-in functions in that several of them share
 the same names and the same functionality. The CodeProbe built-in
 functions are provided for the following reasons:

[] for use with the call and display commands. Since the built-in
functions provided with the compiler generate in-line code, these
commands would not be able to access them.
[] to add convenience and functionality. CodeProbe's built-in functions
provide functionality not available through other debugger
commands.

The compiler's built-in functions perform in accordance with the
 ANSI C standards. This may be slightly different from what
 CodeProbe's built-in functions do. For example, passing NULL to a
 built-in function is an error in CodeProbe. Overlapping memory blocks
 may be handled differently. Also, the parameters to CodeProbe's
 built-in functions are a little more flexible than the parameters to the C
 versions:

 formal type actual parameter types allowed

 void * constant, register, any pointer scalar,
 array, function, address, string
 constant

 char * constant, register, character pointer,
 unsigned character pointer, character
 array, string constant

 int constant, register, any integral scalar,
 bitfield, enumerated constant

 Floating-point constants and registers are not allowed, and string
 constants can only be specified as the source operand.203 Commands and Built-in Functions

Built-in Function Reference

This section describes the following built-in functions:

 memcmpcompares two memory blocks
 memcpycopies a memory block (non-overlapping)
 memmovecopies a memory block (possibly overlapping)
 memsetsets memory to a specified value
 strcatconcatenates two strings
 strcmpcompares two strings
 strcpycopies a string
 strlenreturns the length of a string.204 Chapter 9

 memcmp Compares two memory blocks

 Synopsis i = memcmp ( a, b, n );
 int i; /* comparison results*/
 void *a, *b;/* blocks being compared */
 int n; /* block size in bytes*/


Description 
 The memcmp function compares two memory blocks and returns a
 value whose sign indicates the collating sequence of the blocks, as
 follows:



 Return Meaning

 NegativeFirst block below the second

 ZeroBlocks are equal

 PositiveFirst block above the second




CodeProbe has a built-in #define that causes all references to
 memcmp to be referenced to __builtin_memcmp, which is the
 actual name of the CodeProbe function. If you want to step into or call
 an actual function called memcmp in your code, you should use the
 undef ine command to clear the define or use the backtick character
 to escape the function's name.

 Example

 display memcmp(ptr1, ptr2, n)
displays the result of comparing ptr 1 and ptr2 for n bytes.

 b 27 when(memcmp(ptr1, ptr2, 10) < 0)
breaks at line 27 when the 10 bytes pointed to by ptr 1 evaluate to
a value less than the value of the 10 bytes pointed to by ptr2.


 See Also memcpy, memmove, memset205 Commands and Built-in Functions




memcpy Copies a memory block (non-overlapping)

Synopsis to = memcpy(to, from, n);
void *to; /* destination pointer */
void *from;/* source pointer*/
int n;/* block size in bytes */


Description 
 The memcpy function copies data from one memory block to another.
 The destination pointer is returned.
The memcpy function cannot be used to copy overlapping memory
 blocks. You should use the memmove function when copying
 overlapping blocks. Also note that you can crash your machine if there
 is not enough memory to hold the data at the destination memory
 location.
CodeProbe has a built-in #define that causes all references to
 memcpy to be referenced to __builtin_memcpy, which is the
 actual name of the CodeProbe function. If you want to step into or call
 an actual function called memcpy in your code, you should use the
 undef ine command to clear the define or use the backtick character
 to escape the function's name.


Example
 
 call memcpy(ptr1, &j, 10)
 copies 10 bytes from ptr2 to ptr1.

 call memcpy(0x804a, myptr, 50)
 copies 50 bytes from myptr to location 0x804a.

 b 27 (memcpy(a0, a1, 15)]
 sets a breakpoint at line 27 with an action to copy 15 bytes from
 the memory pointed to by register A1 to the memory pointed to by
 register A0.


See Also memcmp, memmove, memset206 Chapter 9




memmove Copies a memory block (possibly overlapping)

 Synopsisto = memmove(to, from, n);
void *to; /* destination pointer */
void *from;/* source pointer*/
int n;/* block size in bytes */


Description 
 The memmove function copies data from one memory block to another.
 Overlapping blocks are handled correctly. The destination pointer is
 returned.
Note that you can crash your machine if there is not enough
 memory to hold the data at the destination memory location.
CodeProbe has a built-in #define that causes all references to
 memmove to be referenced to __builtin_memmove, which is the
 actual name of the CodeProbe function. If you want to step into or call
 an actual function called memmove in your code, you should use the
 undef ine command to clear the define or use the backtick character
 to escape the function's name.

 Example

 call memmove(ptr1, &j, 10 )
copies 10 bytes from ptr2 to ptr 1.

 call memmove(0x804a, myptr, 50)
copies 50 bytes from myptr to location 0x804a.

 b 27 {memmove(a0, a1, 15)}
sets a breakpoint at line 27 with an action to copy 15 bytes from
the memory pointed to by register A1 to the memory pointed to by
register A0.


 See Also memcpy, memcmp, memset207 Commands and Built-in Functions 




memset Sets memory to a specified value

 Synopsisto = memset(to , c , n );
void *to/* base of memory to be initialized */
int c;/* initialization value*/
int n;/* number of bytes to be initialized */


Description 
 The memset function sets the specified number of bytes of memory to
 the specified value.
Note that you can crash your machine if there is not enough
 memory to hold the data at the destination memory location.
CodeProbe has a built-in #define that causes all references to
 memset to be referenced to __builtin_memset, which is the
 actual name of the CodeProbe function. If you want to step into or call
 an actual function called memset in your code, you should use the
 undef ine command to clear the define or use the backtick character
 to escape the function's name.


 Example 

 call memset(ptr, 0, 100)
sets 100 bytes to 0 starting at the address pointed to by ptr.

 call memset(a0, 'X', 50)
sets 50 bytes to the ASCII character X starting at the address
pointed to by register A0.


 See Also memcpy, memcmp, memmove208 Chapter 9



 strcat Concatenates two strings


 Synopsis to = strcat(to, from);
char *to; /* destination pointer */
char *from;/* source pointer*/


Description 
 The strcat function copies data from one string to the end of
 another string until a null character is found. Overlapping strings are
 not handled by the strcat function.
Note that you can crash your machine if there is not enough
 memory to hold the string at the destination memory location.
CodeProbe has a built-in #define that causes all references to
 strcat to be referenced to __builtin_strcat, which is the
 actual name of the CodeProbe function. If you want to step into or call
 an actual function called strcat in your code, you should use the
 undefine command to clear the define or use the backtick character
 to escape the function's name.


 Example call strcat(myptr, "foo")
concatenates the string "foo" after the string pointed to by the
variable myptr.


 See Also strlen, strcmp, strcpy209 Commands and Built-in Functions


 strcmp Compares two strings


 Synopsisi = strcmp(a, b);
 nt i; /* comparison result */
 char *a, *b; /* strings being compared */


Description 
 The strcmp function compares two strings and returns a value whose
 signs indicate the collating sequence of the blocks as follows:



 Return Meaning

 NegativeFirst string below the second

 ZeroStrings are equal

 PositiveFirst string above the second




CodeProbe has a built-in #define that causes all references to
 strcmp to be referenced to __builtin_strcmp, which is the
 actual name of the CodeProbe functioll. If you want to step into or call
 an actual function called strcmp in your code, you should use the
 undefine commalld to clear the define or use the backtick character
 to escape the functioll's name.


 Example 
 display strcmp("abc", ~def")
 tests the strings "abc" and "def" and displays the return value.
 The value indicates whether the strings are equal or which string is
 higher.

 break myfunc when(strcmp(arg, "foobar") == 0)
 breaks at the furlction myfunc when the variable arg points to the
 string "foobar".


 See Also strlen,strcpy,strcat210 Chapter 9



 strcpy Copies a string


 Synopsis to = strcpy(to, from);
char *to; /* destination pointer */
char *from;/* source pointer */


Description 
 The strcpy function copies data from one string to another until a
 null character is found. Overlapping strings are not handled by the
 strcpy function.
Note that you can crash your machine if there is not enough
 memory to hold the string at the destination memory location.
CodeProbe has a built-in #define that causes all references to
 strcpy to be referenced to __builtin_strcpy, which is the
 actual name of the CodeProbe function. If you want to step into or call
 an actual function called strcpyin your code, you should use the
 undefine command to clear the define or use the backtick character
 to escape the function's name.


 Example call strcpy(a, b)
copies the string pointed to by b to the memory location pointed to
by a.


 See Also strlen, strcmp, strcat211 Commands and Built-in Functions




strlen Returns the length of a string

 Synopsis len = strlen( s );
int len;/* length of string s */
char *s; /* string to scan for length */


Description 
 The strlen function returns the length of a string, as determined by
 the index of the first null character found.
CodeProbe has a built-in #define that causes all references to
 strlen to be referenced to __builtin_strlen, which is the
 actual name of the CodeProbe function. If you want to step into or call
 an actual function called strlen in your code, you should use the
 undefine command to clear the define or use the backtick character
 to escape the function's name.


Example

 display strlen( "hello" )
 displays the length of the string "hello", which is 5.

 display strlen(0x804a)
 displays the length of the string starting at address 0x804a.


See Also strcmp, strcpy, strcat212213

Part 2
Using the SAS/C
Utilities

Chapter 10 Utility Reference214215

10 Utility Reference

 This chapter describes the utilities included with the SAS/C
 Development System. The utilities are described in alphabetical order.
 The description of each utility includes each of the following sections,
 if applicable:

Synopsisshows the format of the command that invokes the
 utility

Descriptiondescribes what the utility does and contains all the
 information you need to use the utility

Examplecontains examples that illustrate how to use the
 utility

 Error Messagesdescribes the error messages, if any, produced by
 the utility and the action required to fix the error.216 Chapter 10




 cover Analyzes coverage data

 Synopsis cover [options] [datafile]. . .


Description
 The cover utility analyzes the coverage data produced when you
 compile your program with the coverage option, link with the object
 file covutil.o, and run your program. Using this data, you can
 determine which lines of code in your program were executed and
 which were not. This information can help you design test cases that
 exercise all paths through your program.
When you run your program, it writes coverage data to the file
 cover . dat in the current directory. If this file does not exist, your
 program creates it. If this file already exists, your program reads in
 the existing cover.dat, merges in the new coverage data, and writes
 the merged data back to cover.dat.
This utility analyzes the coverage data file, locates your C source
 files, and produces new output files containing a copy of your C source
 with arrows pointing to lines that generated code that was not
 executed. Ihe output file has the same basename as the C source file,
 but with the extension .cov instead of .c.
By default, cover looks for the coverage data file cover . dat in
 the current directory. If you choose to rename cover.dat, you must
 specify datafile when you run cover.
Your program must adhere to the following rules:

[] The main routine must be called main rather than _main because
covutil.o replaces _main with an enhanced version.
[] Your program must end by calling exit or by falling through the
end of main. (Do not call XCEXIT or abort, for example.)
[] Your prograrn must not be a resident library or device.

To use cover, follow these steps:

1. Compile your program with the coverage and debug=line
options. (You can use a higher debug level if you like.) I)o not
specify the nostdio option. Specifying coverage slows down
your program considerably, so do not specify coverage for
production software. You can choose to compile only certair
modules with coverage to reduce overhead.
2. Link your compiled program with covutil.o. This file is
located in sc:examples/cover. The covutil.o file replaces
the main and _exit functions in your program with enhallced
versions that can constrllct and write out the coverage data.
3. Run your program normally to create cover.dat.
4. Run the cover utility.217 Utility Reference




 cover Analyzes coverage data
(continued)

The cover utility supports the following options:

dir =directory-pathname
specifies the directory path or paths to search to locate the C source
files. The coverage data contains the name of the C source file, but
not its directory. If the C source file is not in the current directory,
specify the dir= option with the proper directory as its argument.
To specify multiple pathnames, separate each pathname with a plus
(+) sign or a comma (,). Also, you can specify dir= as many times
as necessary.

merge filename
tells cover to read the specified data files, merge the information
contained in them, and write the merged data to filename. If you
specify merge, cover does not look for C source files and does not
produce a report. This option allows you to combine the results of a
suite of tests to determine what code is exercised by the test suite as
a whole.

nosource
tells cover not to read in the C source files. Instead, it prints a
report to the Shell window listing the names of all source files and
the lines in each file that were not executed.

 Example 

 To analyze the coverage of the lines.c program, open a Shell and
use the cd command to change to the sc:examples/lines drawer.
Enter the following command:

sc lines.c sc:examples/cover/covutil.o coverage debug=line link

The compiler produces a program called lines. Run this program
with no command-line options:


lines


Watch the lines for a few seconds, then click on the close gadget to
terminate the program. The program produces a file called cover.
dat. Run the cover utility on this file:


cover218 Chapter 10

 cover Analyzes coverage data
(continued)


 The cover utility reads cover .dat and lines.c and writes the
 file lines.cov. Use your editor to examine lines.cov. Lines that
 were not executed are highlighted with an arrow (==>) in the left
 margin.
219 Utility Reference

diff Determines the differences between two files

Synopsis diff[>destination] loptions] file1 file2

Description 
 The diff utility determines the differences in contents between two
 files and describes the lines that you should delete from, add to, or
 change in file2 to make it look like file1. To help you find those lines,
 diff identifies the line numbers and gives the text of the lines.
If you enter the diff command without specifying filenames, diff
 displays the version that you are using and describes the options
 available.
Output from this utility is sent to the standard output device, unless
 you redirect it by specifying the -o option or by entering a greater
 than (>) sign followed by a destination.
diff supports the following options:

-bnnsets the size of the I/O buffer to the value specified by nn. The
default I/O buffer size is 4K, and the maximum size is limited
by the amount of available system memory. Increasing the size
of the I/O buffer makes diff run faster.

-c displays only those lines common to both files.

-Fnnsets the column number where you want diff to begin
comparing lines. For example, if you set nn to 25, diff
ignores the first 25 characters on each line.

-Lnnsets the column number where you want diff to stop
comparing lines. For example, if you set nn to 75, diff
ignores the characters beyond column 75 on each line.

-lnndefines the number of lines, nn, per file that can be handled
by diff. diff uses two tables (one for each file) to keep
track of the lines read in from each file. The default size of
each of these tables is 2000; the maximum number is limited
by memory availability. If diff is running out of memory
and your files are less than 2000 lines in length, you can use
this option to increase the amount of memory available, or
you can check to see if any other tasks are running
concurrently and shut down any unwanted tasks.

 -ofilesends the output to the specified file (or device). You can use
this option instead of the AmigaDOS redirection command.
You can send the output to a different device by specifying the
device name. For example, to send output to the printer,
specify -oprt: . To send output to a file on drive df0:,
specify -odf0:filename.220 Chapter 10


diff Determines the differences between two files
(continued)


 -p filters out unprintable characters from the input stream. You
can use this option to clean out an AmigaDOS binary file.

 -q suppresses any messages if there are no differences between
the specified files.

 -w ignores differences related solely to space or tab characters
and reduces sequences of these characters to a single space.
This option also removes trailing blanks. When you specify the
-w option, diff uses additional memory to create a third
table for each line in its compressed form.

Note: The appendix, "diff File-Matching Algorithm," discusses
 the theory of file matching and how it affects diff .
To compare the two files, newfile and oldfile, you enter the
 following command:


 diff newfile oldfile


 diff compares the two files and gives you a set of instructions to
 follow to change oldf ile into newf ile. The instructions begin with
 the following message:


 TO TRANSFORM oldfile INTO newfile ...


 The instructions are displayed in three types of blocks: a delete block,
 an append block, and a change block.
A delete block describes the lines that you should delete from
 oldfile, and it has the following form:


 *** DELETE [i,j] FROM oldfile ***
 <Text of line 1 in oldfile.
 <Text of line 2 in oldfile.
 <Text of line 3 in oldfile.


 The numbers i and j are the first and last line numbers in oldfile of
 the lines to be deleted. A less than (<) sign preceding a line of text
 indicates that you should delete the line.221 Utility Reference




 diff Determines the differences between two files
(continued)


An append block describes the lines that you should add to
 oldfile, and it has the following form:


 *** APPEND AFTER i IN oldfile ***
 >Text of first line that you should add.
 >Text of second line that you should add.
 >Text of third line that you should add.


 The number i is the line number in oldfile after which the lines
 should be added. A greater than (>) sign preceding a line of text
 indicates that you should add the line.
Note: The line number i will not be correct if you make other
 changes to the lines in oldfile before line number i.
A change block lists the lines in oldfile that you should change
 and shows how to change them. diff presents this information as a
 series of lines to delete and a series of lines to add in place of the
 deleted lines. A change block has the following form:


 *** CHANGE [i,j] IN oldfile TO [m,nl IN newfile ***
 <Line 1 in oldfile that you should change.
 <Line 2 in oldfile that you should change.
 <Line 3 in oldfile that you should change.

 ---------------

 >New text (from newfile) for line 1 in oldfile.
 >New text (from newfile) for line 2 in oldfile.
 >New text (from newfile) for line 3 in oldfile.


 The numbers i and j are the first and last line numbers in oldfile of
 the lines to be deleted. The numbers m and n are the first and last line
 numbers in newfile of the lines you need to add to oldfile.


 Examples Suppose you wanted to compare the contents of the files cow and
lamb. The file lamb contains the following lines:

 Mary had a little lamb.
 Its fleece was white as snow.
 Everywhere that Mary went,
 The lamb was sure to go.222 Chapter 10




diff Determines the differences between two files
(continued)

The file cow contains the following lines:


 Mary had a very large cow.
 Its fleece was white as snow,
 Mary had a what?
 Everywhere that Mary went,


If you entered the command


diff lamb cow


this utility would produce the following:

TO TRANSFORM cow INTO lamb ...

 *** CHANGE 1 IN cow TO 1 IN lamb ***
 <Mary had a very large cow.

 Mary had a little lamb.

 *** DELETE 3 FROM cow ***
 <Mary had a what?

 *** APPEND AFTER 4 IN cow ***
 >The lamb was sure to go.


Error Messages 

The diff utility may generate the following error messages:

Can't open file
 indicates that diff cannot open the named file. The file may not
 exist or it may be protected.

Diff I/O Error
 indicates an I/O problem.

Improper -1 specification: nn
 indicates that diff cannot interpret the nn value specified with the
 -1 option as a number.223 Utility Reference




 diff Determines the differences between two files
(continued)


Internal Error: ...
 indicates an internal error. Please contact the Technical Support
 Division at SAS Institute if you see this error message. The
 Technical Support representative will need the following
 information:

 [] the version of diff you are using
 [] the exact wording of the command line you used
 [] the exact wording of the message you received
 [] the size of the files you were trying to compare.

Line table overflow
 indicates that one of the two line tables, in which diff stores the
 lines from each file while they are being compared, is too small to
 hold the lines in one of the files. Try increasing the line table size
 with the -l option.

Not enough memory for nn lines per file
 indicates that you have used the -l option to increase the line table
 size, but you do not have enough memory to increase it by the
 amount you specified.

Out of memory
 indicates that diff is out of memory. Try decreasing the line table
 size with the -l option if possible. Do not use the -w option. You
 can also try decreasing the size of the I/O buffer by using the -b
 option; however, this action makes diff run slower because more
 disk accesses may be required. If you are using a hard disk, this
 factor may be negligible.

Too many file names: ...
 indicates that you have made an error on the command line in such
 a way that diff assumes you are attempting to operate on more
 than two files.

Unrecognized option
 indicates that you specified an option that diff does not recognize.224 Chapter 10




grep Searches for and prints regular expressions


 Synopsis grep [>destination] [options] pattern file . . .


Description 
 The grep utility searches the files you specify for all the lines that
 contain the specified pattern. For each file in which it finds the
 pattern, grep displays, on the screen, the filename, line number, and
 contents of the line that contains the matching string. The patterns that
 you can specify can be specific or general, and they are sometimes
 referred to as regular expressions. In this book, they are referred to as
 patterns.
For example, suppose you are working on a long document in a file
 named document . txt. You originally were going to call the
 document a user manual, but you have decided to call it a user's guide.
 You need to see where you have used the word manual to describe the
 document. You could enter the following command:


 grep manual document.txt


 grep displays all of the lines in the file that contain the word manual.
 These lines could include such phrases as the manual, insert the paper
 manually, or refer to your AmigaDOS manual.
By using special characters as described under "Specifying the
 Pattern" later in this discussion, you can tell grep exactly what to
 look for so that it does not display lines in which you are not
 interested.
To specify the files that you want grep to search, you can use the
 AmigaDOS wildcards (#?). For example, to search all files in the
 current directory that have an extension of .c, enter # ?.c as the
 filename. To search all files in the root level directory of drive df 0:
 that begin with the letter g and have the extension .c, enter
 df0:g#?.c. AmigaDOS ignores the case of filenames. It will find the
 files you specify whether you enter the name in uppercase, lowercase,
 or mixed case.
You can redirect the output from grep by specifying a greater than
 (>) sign followed by the destination where you want the output sent.
 You may want to redirect the output to a file and print that file.225 Utility Reference




 grep Searches for and prints regular expressions
(continued)


 grep supports the following options:

 -c prints the total number of matched lines.

 -f prints only the names of all files in which grep finds a string
that matches the pattern.

 -n tells grep not to display line numbers.

 -p displays only printable ASCII characters. Non-printable
characters are filtered out. This option is useful if you are
searching a binary file that may contain control characters.

 -q does not display filenames or line numbers.

 -s displays the names of all files that grep searches. Normally,
grep displays only those filenames in which it found a match
for the pattern.

 -v prints only the lines in which a match of the pattern is not
found.

 -v prints the version number of grep.

 -S tells grep not to distinguish between upper- and lowercase. For
example, if you use this option, the pattern int would match
int, INT, Int, and INt.


Specifying the Pattern
 By using characters that grep interprets in special ways, you can
specify some very complex patterns. Because grep is so flexible, you
must also be specific about the pattern for which you are searching.
The following list describes the special characters that you can use to
specify the pattern for which you are looking:

 . is the grep wildcard character. A period will match any single
character, including a space, tab, newline, or control character.
 A period followed by an asterisk(*) tells grep that any
number of any characters can be present. The .* sequence is
equivalent to the #? sequence for AmigaDOS commands.

 " " are used to enclose patterns that include space characters.226 Chapter 10




grep Searches for and prints regular expressions
(continued)


[] are used to search for any one character from a set of
 characters by enclosing that set of characters inside square
 brackets. A set of characters enclosed in square brackets is
 called a character class. A character class will match one single
 character. For example, to search for lines that contain vowels,
 you can enter [aeiou].

 - is used to specify a range. Inside a character class, you can
specify a range of characters by entering the first character
in the range and the last character in the range separated
by a hyphen. The first character must occur alphabetically
before the second. For example, to find any one of the
lowercase alphabetic characters, you enter [ a- z ] .

 ! is used as the negation character when included as the first
character in a character class. An exclamation point tells
grep to find any character that is not in the character
class. For example, to find any one character that is not a
lowercase alphabetic character, enter [!a-z] . To find any
one character that is not a lowercase alphabetic character
and is not the end-of-line character, enter [!a-z\N].

* tells grep that the preceding character does not have to be
 present in the pattern but can be present an unlimited number
 of times. In other words, an asterisk means "zero or more of."
 A period followed by an asterisk tells grep that any number
 of any characters can be present. The .* sequence is equivalent
 to the #? sequence for AmigaDOS commands.

+ tells grep that the preceding character must be present in the
 pattern at least one time but can be present an unlimited
 number of times. In other words, a plus sign means "one or
 more of." For example, to find all lines in your file that contain
 one or more of the lowercase letter t, enter t+.

^ tells grep that the pattern must begin in column 0. Enter the
 caret (^) at the beginning of the pattern. grep will look only for
 those lines in which the pattern occurs beginning in column 0.
 For example, to find all lines that begin with a left parenthesis,
 enter ^(.227 Utility Reference


grep Searches for and prints regular expressions
(continued)


$ tells grep that the pattern must occur at the end of a line.
 Enter the dollar sign at the end of the pattern. For example, to
 find all lines that end with a right parenthesis, enter ) $.

\ is the escape character. If you want to search for any of the
 special characters included in this list, you must enter a
 backslash before that character. For example, to find all lines
 that contain a caret, enter \~. Similarly, if you want to search
 for a backslash, enter two backslashes, \ \ .
You also need to use the backslash to identify certain
 additional characters. These characters are as follows:

\b backspace

\n newline

\r carriage return

\s space

\t tab

\xij control character identified by hexadecimal digits ij

For example, to locate all lines containing the Control-g
character, enter \x07.

You can combine these characters to specify any pattern you need.
 The way in which you specify the pattern to grep determines the
 response you will receive. grep does not convert tabs to spaces or
 change any combinations of spaces and tabs. If grep does not respond
 as you expect it to, try escaping any special characters with the
 backslash (\) character. Alternatively, try reducing the number of the
 special characters in your search pattern.

 Examples
 To search for one word, you need only specify the word and the file in
which you want to search. For example, the following command
searches the file document.txt for the word manual:

 grep manual document.txt

To search for a string of words that are separated by spaces you
 must enclose the entire string within double quotes, as follows:


 grep "this is the string to search for" document.txt228 Chapter 10




grep Searches for and prints regular expressions
(continued)


 Specifying Any Single Character
 You can tell grep that a character can be any character by using a
 period (.) to designate that character. For example, you can specify a
 four-character pattern, beginning with th and ending with n, in which
 the third character can be anything, by specifying the following
 command:


grep th.n document.txt


 This command will display all lines with patterns such as


thanthenthanksEthan


 The period will match any single character, including an alphabetic
 character, numberic character, space, tab, newline, or control
 character. For example, you can enter the following command:


grep 123.45 document.txt


 This command will display all lines containing any of the following
 strings:


123a45 123 45 123!45 123(45123.45


 Specifying Character Classes
 A character class is useful when you need to look for characters that
 do not follow a pattern or when you do not care about the case of a
 character. For example, the following command displays all lines
 containing the symbols %, &, or ~:

grep [%&~] document.txt

 If you want to display all lines containing either the or The, you can
 enter the following command:

grep [Tt]he document.txt229 Utility Reference



grep Searches for and prints regular expressions
(continued)


 Similarly, you can enter the following command:


grep [Tt][Hh][Ee] document.txt


 This command displays all lines containing any of the following strings:


 THETHeThethethEtHEtHeThE


 Using the -$ option produces the same results:


grep -$ the document.txt


Inside a character class, you can use a minus (--) sign to specify a
 range of characters. The first character must occur alphabetically
 before the second. For example, the following command displays all
 lines that contain a lowercase letter:


grep [a-z] document.txt


 Similarly, the following command displays all lines that contain any
 lowercase letter, any uppercase letter, or any decimal number:


grep [a-zA-ZO-9] document.txt


 A practical use of character classes arises when you need to display all
 the lines in your file in which you refer to a specific year. Since each
 character class matches one character, enter the following command:


grep [0-9][0-9][O-9][O-9l document.txt

 If you are concerned only with years in the nineteenth and twentieth
 centuries, then enter this command:


grep 1[89][0-9][0-9] document.txt230 Chapter 10




grep Searches for and prints regular expressions
(continued)


Also, the exclamation point (!) means not if it occurs as the first
 character in a character class. For example, the following command
 displays all lines that contain any character that is not a lowercase
 letter:


grep [!a-z] document.txt


 The following command displays all lines that contain any character
 that is not the number sign (#):


grep [!#] document.txt


 Specifying the Number of Times a Character Can Appear
 An asterisk (*) tells grep that the preceding character can be present
 zero or more times. For example, you may have a file in which you
 have referred to Gail and mentioned a year in which some event has
 occurred. To display those lines in which both Gail and a year occur,
 enter the following command:


grep "Gail.*[0-9][0-9][0-9][0-9]" document.txt


 The period (.) followed by an asterisk (*) tells grep that any character
 can be between Gail and the year and that you do not care how many
 of the characters appear. This command would display lines such as
 the following:


Call Gail Barbara Industries at 1-999-629-9310.
Gaillard de Marentonneau was a 1900s century botanist.
My eldest daughter Gail was born in 1969.


You can also use the asterisk (*) after a character class if you want
 to tell grep that you do not care how many of the characters in the
 character class occur in the pattern. For example, the following
 command displays any combination of zero or more lower- or
 uppercase letters t and the letters he:

grep [tT]*he document.txt231 Utility Reference




grep Searches for and prints regular expressions
(continued)


 This command displays lines containing strings such as the following:


 he tthe These hero penuche inherit mother


 Using the plus (+) sign instead of the asterisk (*) tells grep that you
 want the string to include at least one t. Using a plus sign displays the
 following strings:


tthe These mother


If you want to display only lines that contain the word the, you can
 use the following command:


grep "[tT]+he" document.txt


 Of the previously listed words, this command displays only tthe. If
 you enter an asterisk (*) instead of a plus (+) sign, this command
 displays he and tthe. If you include an exclamation point (!) as the
 first character in the character class, this command displays only the
 following strings:


he hero penuche inherit


 Specifying a Pattern at the Beginning or End of a Line
 As the first character in the pattern, a caret (^) tells grep to display
 only those lines that begin with the pattern. For example, to display
 only lines that begin with numerals, you can enter the following
 command:

grep ^[10-9] document.txt

 Similarly, you can tell grep to display only those lines that end with a
 pattern by entering a dollar sign ($) as the last character in the
 pattern. For example, the following command tells grep to display all
 lines that end with the word the:

grep "[tT]+he$" document.txt232 Chapter 10




grep Searches for and prints regular expressions

(continued)


 Specifying Patterns that Contain Special Characters

 Using a backslash (\), you can search for any of the special characters
 that grep recognizes. For example, if you want to search for a dollar
 sign ($), enter a backslash (\) in front of the dollar sign. grep

 assumes you are looking for a dollar sign and not for a pattern that
 occurs at the end of a line. Similarly, the following command displays
 all lines that contain left brackets ([):


 grep \[ document.txt

 You also can use the backslash (\) to tell grep that you want to
 display all lines that contain backslashes, as follows:


 grep \\ document.txt


 To locate all lines containing tab characters, enter the following
 command:

 grep \t document.txt

 You also can use the backslash (\) inside of a character class. For
 example, to find all lines that begin with a space or a tab character,
 you can enter the following command:

 grep "^[ \t]" document.txt

 Because the period (.) is the grep wildcard character, to search for
 the phrase and so on ..., use the following command:

 grep "and so on \.\.\." document.txt

You can use \xij to search for control characters. Control characters
 are generally used as printer format instructions in files produced by
 word processors. Identify the character by its hexadecimal number (ij).
 For example, to display all lines that contain Control-g, enter the
 following command:

 grep \x07 document.txt233 Utility Reference




grep Searches for and prints regular expressions
(continued)

To find lines that contain Control-z, enter the following command:


grep \xla document.txt


The dollar sign ($) special character works much like the carat (^)
 except that it forces the match to occur only at the end of a line. For
 example, to search for all occurrences of the C language comment
 terminator, */, at the end of a line, enter the following command:

grep \*/$ document.txt

 The backslash (\) tells grep not to interpret the asterisk (*) in its
 special sense as a closure operator.
Suppose you have a number of C language source files, each with
 filenames that end with .c, and you need to search these files to find
 all calls of either of the read or fread functions. Enter the following
 command:

grep "f*read *(" #?.c

This command prints every line in these files that contains either
 read or fread, followed by O or more spaces and a left parenthesis.
You also can search your files for all function definitions. Assume
 that each function definition begins with the function name and
 parameter list on a separate line. You can use the following command:

grep "^[a-zA-Z_ ]+[a-zA-Z0-9_ ]*(" #?.c


The pattern matches only expressions that begin a line. The
 expression must consist of one or more lowercase letters, uppercase
 letters, or the underscore (_), followed by 0 or more spaces, and then
 a left parenthesis. This command will print lines such as the following:


get1(s)/* get a line */
_read ()
my_read(fp){fread(fp,x);}


 However, this command will not select a line such as


char *get1(p) /* get a line */234 Chapter 10




grep Searches for and prints regular expressions
(continued)

 You can use grep to help locate mismatching left and right braces
 ({}). To print each line that contains a left or right brace, you can
 enter the following:

 grep [{}] #?.c

Error Messages 

grep may generate the following error messages:

Bad character class
 indicates that grep is unable to interpret a character class in the
 pattern you have asked it to find. Check to see if you have used any
 special symbols that you did not intend to use. This message also
 can be generated if, in specifying a character class and using the
 minus (--) character to indicate a range of characters, the first
 character in the range does not alphabetically precede the second
 (for example, [d-a]).

Bad pattern
 indicates that grep is unable to interpret the pattern you are
 asking it to find. You may have used a special character in the
 pattern that does not make sense in this context. Check to see if you
 have forgotten to escape a special character.

Can't find file(s) ...
 indicates that grep is unable to find one or more of the files you
 have asked it to search. The files may not exist, or you may have
 misspelled the filenames.

Can't open ...
 indicates that grep is unable to open the named file. The file may
 not exist or may be protected.

Closing ] not found
 indicates that grep believes that you have asked it to search for a
 pattern that contains a character class, but you have omitted the
 right bracket (]) that terminates the character class. If not, you may
 have included a left bracket ([) in the pattern but forgot to use a
 backslash (\) before it.

Empty character class
 indicates that a character class you have used in your pattern has
 no members, for example [].235 Utility Reference




grep Searches for and prints regular expressions
(continued)


Improper hex specification
 indicates that you have used the x escape sequence but have not
 followed it with two recognizable hexadecimal digits.

Incompatible combination of options
 indicates that the options with which you have invoked grep are
 contradictory.

Internal Error: . . .
 indicates an internal error. Please contact the Technical Support
 Division at SAS Institute if you see this message. The Technical
 Support representative will need the following information:

 [] the version number of grep you are using
 [] the exact wording of the command line you used
 [] the exact wording of the resulting error message.

Invalid option
 indicates that you have used a command line option that grep does
 not recognize. This message also can be generated if your pattern
 begins with a minus sign (--) but you have not escaped it or
 enclosed the pattern in double quote marks (").

No beginning double quote in pattern
 indicates that grep has detected double quote marks (") in a
 pattern that did not start with a double quote. You may need a
 backslash (\) before the double quote.

No file arguments provided
 indicates that grep believes you have specified a pattern but no
 filenames. This message also may be generated if you invoke grep
 with a filename but no pattern.

No pattern or file arguments given
 indicates that grep cannot find either a pattern or filename on its
 command line.

Out of space
 indicates that grep has run out of space in constructing its pattern
 representation. Please contact the Technical Support Division at
 SAS Institute if you see this message.

Pattern ill-formed: no terminating double quote
 indicates that you started the pattern with a double quote (") but
 failed to terminate it with one.236 Chapter 10




grep Searches for and prints regular expressions
(continued)


Too few arguments to GREP
indicates that grep demands at least two arguments on its
command line: a pattern and at least one filename.237 Utility Reference




 gst Manages global symbol tables


 Synopsis gst [gst-filename] [options] [symbol-name . . . ]


Description 
 A Global Symbol Table (GST) is a collection of all the information
 defined in a set of header files and stored in a format that the compiler
 can use easily and quickly. You can use GSTs to reduce significantly
 the processing time required for header files. However, GSTs require
 additional disk space and impose some restrictions on your header
 files. For information on creating and using GSTs, refer to Chapter 4,
 "Using the System Header Files to Access Libraries," in SAS/C
 Development System Library Reference.
 The gst utility helps you manage GSTs and extract information
from a GST. With the gst utility, you can

[] load a GST into memory
[] unload a GST
[] list all GSTs currently in memory
[] extract symbol information from a GST.

 GSTs must be loaded into memory before they can be used.
Normally, a GST is loaded automatically the first time you issue a
command that needs the GST. After a GST is loaded, it will remaill in
memory until either the system needs the memory, until you mallually
unload it using the gst utility, or until you tell sc to recreate the
GST. To load a GST into memory, specify the GST command as
follows:

gst gst-filename

The gst utility loads the GST into memory and then exits.
 Note: You should do this only if you plan to remove the disk
containing the GST from the drive.
 To display information about a symbol contained in a GS 1', specify
the gst command as follows:

gst gst-filename symbol-name

 Some symbols may occur more than once in the GST. For example,
a symbol may occur once as a structure tag and again as an identifier.
The gst utility prints all definitions of the same symbol.
 gst supports the following options:

list
 lists all GSTs currently in memory. You can use this option to
 determine which GSTs to unload if you need more memory.238 Chapter 10




gst Manages global symbol tables
(continued)


 [name=]filename
 specifies a GST file created using the makegst option in the sc
 command. You do not need to specify name= unless you want to
 load a GST that has the same name as a keyword (for example,
 name = symbol ).

 [symbol=]symbol-name
 displays the type of symbol name and the filename and line number
 where symbol-name is defined. The type may be one of the
 following:

 tagstruct, union, or enum name
 identifiervariable or function name
 typedeftypedef
 include#include filename
 preprocessor preprocessor macro or #define

 You do not need to specify symbol= unless you want information
 about a symbol that has the same name as a keyword (name,
 unload, and so on).

 unload
 forces a GST to be unloaded from memory. If you also specify
 symbol names on the command line, gst prints all definitions for
 those symbols before it unloads the GST.

 verbose
 prints the full definition of symbol-name.


 Examples 

 To load the GST named pro ject.gst, enter the following command:


 gst project.gst


 The gst utility loads the GST into memory and then exits.
If the header file intuition/intuition.h is included in
 pro ject.gst, you can display the definition of the Window
 structure as follows:


 gst project.gst Window239 Utility Reference




 gst Manages global symbol tables
 (continued)


 If project.gst is not already loaded into memory, gst loads
 project.gst. After project.gst is loaded into memory, gst
 queries the GST and displays the following information:


intuition/intuition.h 904 defines "Window" (struct)


 To display additional information, enter the following command:


gst verbose project.gst Window


 gst also displays the contents of the Window structure with offsets
 for each member.

Error Messages 

gst may generate the following error messages:

 No GST file specified
indicates that you did not specify a GST filename.

 Can't find GST file "filename"
indicates that gst cannot find the file specified.

 Symbol "symbol-name" not found
indicates that gst could not find the specified symbol.

 Not enough memory to load GST
indicates that the GST file could not be loaded due to insufficient
memory.
240 Chapter 10



hypergst Displays the contents of GSTs


 Synopsis hypergst [gst-filename]


Description 
 The hypergst utility enables you to browse the definitions of symbols
 and data structures in GSTs (Global Symbol Tables) that are loaded
 into memory. The hypergst utility works with the AmigaGuide
 hypertext system. For information on using AmigaGuide, see Chapter
 3, "Getting Help," in SAS/C Development System User's Guide,
 Volume I: Introduction, Editor, Compiler.
 To browse the definitions in a GST, the GST must be loaded in
 memory. You can invoke the hypergst utility and load a GST in one
 of the following two ways:

 [] You can enter the hypergst command followed by the name of the
GST file that you want to browse.
 [] From the Workbench you can click on the HyperGST icon, then
hold down the Shift key and double-click on the icon for the GST file
that you want to browse.

 If the GST that you want to browse is already loaded into memory,
 you can invoke hypergst in one of the following two ways:

 [] You can enter the hypergst command without specifying a GST
filename. The hypergst utility displays a screen listing the names
of all GSTs in memory. To select a specific GST, click on the name
of that GST file.
 [] You can double-click on the HyperGST icon. The hypergst utility
displays a screen listing the names of all GSTs in memory. To select
a specific GST, click on the name of that GST file.

After the GST is loaded, hypergst displays a screen containing
 buttons for the various kinds of symbols defined in the GST. These
 buttons are as follows:

 Data Items
displays external data items declared in header files in the GST
such as DOSBase.

 Prototypes
displays prototypes for functions including system functions and
functions declared in your OWII header files.

 Typedefs
displays custom data types defined with a typedef statement
either in system header files or in your own header files.241 Utility Reference



 hypergst Displays the contents of GSTs
(continued)


 Structs/Unions/Enums
displays structure, union, and enumerated type definitions.

 Preprocessor Symbols
displays preprocessor macros defined in any header file including
macros with arguments and simple substitution macros.

If you click on one of these buttons, hypergst displays an
 alphabetical list of all symbols of that type in the GST. If you click on
 the name of a symbol, hypergst displays a symbol information
 screen for that symbol. This screen may contain other buttons that
 reference header files, structure tags, type definitions, and so on. You
 can click on any of these buttons to display more information about the
 highlighted item.


Error Message 

 hypergst may generate the following error message:

 No GST files in memory
indicates that you have not loaded any GST files into memory. For
example, you see this message if you invoke hypergst
immediately following a reboot and do not specify any arguments.
242 Chapter 10




lprof Generates run-time statistics


 Synopsis lprof [-t=n] [>prog-output-dest] program [program-options]


Description 
 The lprof utility generates run-time statistics for a program. lprof
 records the amount of time spent in each routine that is called as your
 program runs. The lstat utility produces a report using the
 information compiled by lprof. This report will help you identify
 modules that run slowly or inefficiently.
To use lprof with your program, you must compile your program
 with the debug option.
lprof gathers statistics by determining, at regular intervals, what
 instruction your program is executing. The default interval is 33
 milliseconds. You can change this interval by specifying a new interval
 (n) in milliseconds with the -t option as follows:

 lprof -t=n program

You can redirect your program's output by specifying a greater than
 (>) sign followed by a destination. program is the name of the
 executable that you want to run. If program is not in the current
 directory, you must specify the full pathname. You can specify options
 for your program.
After lprof loads your program, it runs the program and gathers
 statistics by examining the current program counter at given intervals.
 lprof writes your program's statistics to the file named prof . out
 in the current directory. You can use the lstat utility to produce a
 report from those statistics.


 Examples 
 To gather statistics on a simple program named myprog that does not
take any arguments, enter the following command:

lprof myprog

For a program that normally takes command-line arguments, you
 can add them after the program name, as follows:

lprof myprog -opt 1 -flag

If you want to redirect the program's output to a file named
 outfile, enter the following command:

lprof >oUtfile myprog -opt 1 -flag243 Utility Reference




lprof Generates run-time statistics

(continued)


If the program is not in the current directory, you must give the full
 pathname, as follows:


 lprof >outfile C:myprog -opt 1 -flag244 Chapter 10




lstat Analyzes and prints run-time statistics


 Synopsis lstat [>destination] [options] program [profile]


Description 
 The lstat utility analyzes the profile statistics file created by lprof.
 lprof runs the program, gathers statistics by examining the current
 program counter at given intervals, and writes this information to the
 file named prof . out in your current directory. lstat analyzes the
 information in this file and displays a report on the screen.
You can redirect the output from lstat by specifying a greater
 than (>) sign followed by the destination where you want the output
 sent. You may want to redirect the output to a file and print that file.
The profile is the name of the output file created by lprof. lstat
 first looks in your current directory for the default file produced by
 lprof, prof.out. If this file is not in your current directory, or if
 you have changed its name, you must specify its full pathname as the
 value for profile.
You must specify the program name. lstat uses this name to get
 debugging and symbol information for its report.
Note: This utility assumes that you have compiled the program
 with the debug compiler option. The debug option allows lstat to
 associate code with a specific line. If you do not compile with the
 debug option, lstat reports statistics based on subroutines only.
lstat supports the following options:

 -z tells lstat to display statistics for all subroutines even if
they were not encountered in profiling. By default, lstat
does not report subroutines that it does not encounter.

 -f tells lstat to display full statistics for each subroutine,
indicating the line numbers within a module that it
encountered. By default, lstat displays only summary
information about the subroutine.

-t=n tells lstat to display only those routines that have at least n
hits. By default, lstat prints all subroutines that it
encountered even once.

If the report produced by lstat shows that a large percentage of
 time is spent in one program module, you may want to

 [] redesign the module
 [] incorporate the module into the calling routines, thus eliminating
 calling overhead
 [] rewrite the routine in assembly language
 [] restructure your program.245 Utility Reference




lstat Analyzes and prints run-time statistics
(continued)


You also may find that most of the work being done involves the
routine in question, and the percentage of time taken is reasonable.


Examples These examples assume that you have the file named pro f . out in
your current directory and that prof . out was produced with the
following command:

lprof testprog

 To display the basic statistics about your program, enter the
command lstat testprog as follows:


1> lstat testprog


header size 0x1c, ProfileHeader 0x1c
719 run + 158 ready + 77 wait = 954
 75.367% run, 16.562% ready,8.071% wait
 8.067% samples (58) oUt of profile range

counted = 660, RUN - NonTable 661

Routine %Total % Offset HitsLabel
 59.5455%59.5455% lc44c393 getrsc
 8.9394%68.4848% lc6fa59 frersc
 3.6364%72.1212% 10d3824 alcmem [lines 64-102 in mem.c]
Most hits-1.2121% (8) on line 80
 2.2727%74.3939% 1825215 instal [lines 117-146 in sym.cj
Most hits-1.2121% (8) on line 132


 0.l5l5% l00.0000% 1ca18 1 CXM22


 You can display information about subroutines that lprof did not
encounter by using the -z option. In this example, using this option
produces information about the strcat and strncpy routines.
These routines have O hits and account for 0% of the runtime, but IIOW
appear in the output, as in the following:


1> lstat -z testprog246 Chapter 10




lstat Analyzes and prints run-time statistics
(continued)


 header size 0xlc, ProfileHeader 0xlc
 719 run + 158 ready + 77 wait = 954
75.367% run, 16.562% ready,8.071% wait
8.067% samples (58) out of profile range

 counted = 660, RUN - NonTable 661

 Routine %Total % Offset HitsLabel
 59.5455% 59.5455% lc44c393 getrsc
8.9394% 68.4848% lc6fa59frersc
3.6364% 72.1212% 10d3824alcmem llines 64-102 in mem.cl
Most hits-1.2121% (8) on line 80
 2.2727%74.3939% 1825215instal llines 117-146 in sym.cl
Most hits-1.2121% (8) on line 132

...
0.0000% 100.0000%lca600strcat
0.0000% 100.0000%lca780strncpy


For each routine that has line number information, you can display
 more detailed line number information by specifying the - f option.
 The -f option tells lstat to display the percentage of total runtime
 and number of hits for each line that was executed in that routine, as
 in the following:


1> lstat -f testprog


header size 0xlc, ProfileHeader 0xlc
719 run + 158 ready + 77 wait = 954
 75.367% rUn, 16.562% ready,8.071% wait
 8.067% samples (58) oUt of profile range
counted = 660, RUN - NonTable 661247 Utility Reference




Istat Analyzes and prints run-time statistics
(continued)


Routine %Total % Offset HitsLabel
 59.5455% 59.5455% lc44c393 getrsc
 8.9394%68.4848% lc6fa59frersc
 3.6364%72.1212% lOd3824alcmem llines 64-102 in mem.~]
 0.3030% (2) on line 64
 1.0606% (7) on line 68
 0.7576% (5) on line 69
 1.2121% (8) on line 80
 0.3030% (2) on line 90
 
 2.2727%74.3939% 1825215instal [lines 117-146 in sym.c]
 0.1515% (1) on line 117
 0.1515% (1) on line 129
 0.4545% (3) on line 131
 1.2121% (8) on line 132
 0.1515% (1) on line 133
 0.1515% (1) on line 138

...
 0.1515% 100.0000%lcal81CXM22



For a large program, you may want to limit the amount of
 information produced by lstat by using the -t option. You can use
 the -t option to set a minimum number of hits that must be recorded
 for a subroutine before that subroutine will be included in the display.
 With this option, the final total percentage may not be 100%. Here is
 an example:

 1> lstat -f -t=2 testprog

 header size 0xlc, ProfileHeader 0xlc
 719 run + 158 ready + 77 wait = 954
75.367% run, 16.562% ready,8.071% wait
8.067% samples (58) out of profile range
 counted = 660, RUN - NonTable 661248 Chapter 10




lstat Analyzes and prints run-time statistics
(continued)


 Routine %Total % Offset HitsLabel
 59.5455% 59.545s% lc44c393 getrsc
 8.9394%68.4848% lc6fa59frersc
 3.6364%72.1212% 10d3824alcmem [lines 64-102 in mem.c]
 0.3030% (2) on line 64
 1.0606% (7) on line 68
 0.7576% (5) on line 69
 1.2121% (8) on line 80
 0.3030% (2) on line 90
 2.2727%74.3939% 1825215instal [lines 117-146 in sym.c]
 0.1515% (1) on line 117
 0.1515% (1) on line 129
 0.4545% (3) on line 131
 1.2121% (8) on line 132
 0.1515% (1) on line 133
 0.1515% (l) on line 138

 ...
 0.3030%98.3333% lca002xcovf249 Utility Reference




 omd Disassembles object modules


 Synopsis omd [r>destination] [-x] object [source]


Description 
 The omd (Object Module Disassembler) utility program disassembles an
 object file produced by the SAS/C Compiler and produces a listing
 consisting of assembly language statements (interspersed with the
 original C source code if you specified a source filename).
omd sends the output to the screen unless you redirect it by entering
 a greater than (>) sign followed by a destination. You rnay want to
 send the output to a file and then print the file.
The -x option sets the size of the buffer used to hold the external
 symbol section of the object module. For example, -x250 establishes a
 buffer that can hold 250 external symbols. The default size is 200. You
 should increase the buffer size only if omd reports that there are too
 many external symbols.
object is the object filename. You must specify the complete filename,
 including the .o extension.
source is the source filename. If you specify source, you must specify
 the complete source filename, and the source file should have been
 compiled with the debug compiler option. The debug option allows
 omd to associate source lines with the object code they generated. If
 you did not use the debug option, C source lines will not appear in
 the output produced by omd.


 Examples 
 The following example compiles myprog.c to produce myprog.o,
 which is then disassembled with omd. The disassembled listing is
 redirected to the file named myprog. 1st.


sc debUg=line myprog
omd >myprog.lst myprog.o myprog.c250 Chapter 10




 oml Manages libraries


 Synopsis oml [<cmdfile] [>listfile] [options] libfile [command [module...]]...


Description 
 You can use the oml (Object Module Librarian) to manage your
 libraries. oml allows you to:

 [] create library files
 [] list the modules in a library file
 [] delete modules from a library file
 [] replace old modules with new modules.

A link library is a group of object modules, each of which was
 originally in a separate file and consisted of one or more subroutines.
 Some advantages of using a link library are as follows:

 [] The subroutines in a library can be used by several programs.
 [] When you are linking your program, you specify only the library file
 instead of several individual object modules.
 [] The linker includes only those modules in the library that are
 required by your program.

Each module within the library is identified by a module name,
 which is placed in the object module by the program (the SAS/C
 Assembler or Compiler) that generates the module. The assembler and
 compiler use the name of the object file.
If a module does not contain a module name, oml assigns a module
 name of the form $nnn, where nnn is a decimal number.
A module may define one or more public symbols. A public symbol
 is something in the module that is available to other modules, such as
 global variables or functions. When the linker resolves external
 references for a program, it examines each module in each library you
 specify. It decides which of the modules are required by the program it
 is linking by looking at the module's list of public symbols. If any of
 the program's unresolved external references match any of the
 module's public symbols, that module will be included in the
 executable module.
When writing the modules for your library, be careful to avoid
 duplicate names for public symbols. If you create a library that defines
 a symbol more than once, oml issues a warning message. If you then
 link with that library without correcting the problem, the linker may
 include the wrong module or give a duplicate symbol error.
To invoke oml, enter the oml command followed by a library name,
 as follows:

 oml mylib.lib251 Utility Reference




 oml Manages libraries
(continued)




 oml waits for you to enter commands (and module names, if
 necessary) from the keyboard.oml executes the commands as you
 enter them and displays a list of any duplicate symbol names that it
 finds. After you have entered all your commands, enter a Control
 backslash (Control-\) to terminate the oml.
You also can include the commands and module names on the oml
 command line. If you enter commands on the command line, oml
 executes those commands and terminates. For example, the following
 command replaces the module ftoc.o in my lib.lib with the
 version of the same module in your current directory:

oml mylib.lib r ftoc.o


 oml replaces the module, lists any duplicate symbol names it finds,
 and terminates.
You also can enter some commands on the command line followed
 by some from the keyboard. If you include an at (@) sign at the end of
 the command line, oml executes the commands you enter on the
 command line and then waits for you to enter additional commands
 from the keyboard. You must enter a Control-\ to terminate oml. For
 example, the following command replaces the module ftoc.o in
 mylib.lib with the version of the same module in your current
 directory and then waits for you to enter additional commands from
 the keyboard:


oml mylib.lib r ftoc.o @


You also can enter the commands into a file and tell oml to use that
 file as input. You can tell oml to use that file by either of the following
 methods:

 [] entering a less than (<) sign followed by the filename (<cmdf ile)
as the second item on the oml command line
 [] entering an at (@) sign followed by the filename (@cmdf ile) as the
last item on the oml command line.

oml sends its output to the screen unless you redirect it by
 specifying a greater than (>) sign followed by a filename.252 Chapter 10




 oml Manages libraries
(continued)


 Specifying Com mands

 Commands specify the actions to be performed by oml with respect to
 the specified library file. Each command is specified as a single
 character, usually followed by a list of module names or object
 filenames. Separate commands and file and module names with one or
 more spaces. If you specify the r, d, or x command, oml assumes that
 the next item on the command line is a file or module name, so that
 item is not checked to determine if it is another command. If you need
 to enter a file or module name that may appear to oml to be a
 command, specify that file or module name as the first name following
 the command. oml supports the following commands:

 r file file . . .
 replaces the named object files in the library or adds them to the
 library, if they are not already present. Each module should be in a
 separate object file. To replace modules within a library, make sure
 that the module contains a module name and that the filename is
 the same as the module name.

 d module module . . .
 deletes the named modules from the library. oml assigns module
 names to those modules without names; therefore, you may need to
 get a listing of names in the library (using the 1 command) to
 determine the name of the module that you want to delete.

 x module module . . .
 extracts the named modules from the library and creates separate
 files using the same names. You may need to get a listing of names
 in the library (using the l command) to determine the correct name
 of the module that you want to extract. If the module name
 contains a pathname, oml attempts to create a file with that name.
 If the module name does not contain a pathname, oml creates the
 file in the current directory unless you specify a different pathname
 with the -o option. You can use an asterisk (*) to specify that you
 want all modules extracted. oml terminates if it cannot extract a
 module. You cannot extract and replace the same module with the
 same oml command line.

l
 generates a listing of the modules in the library after all other
 commands have been executed. If you also specify the -s option,
 the listing includes the public symbols defined in each module.253 Utility Reference




 oml Manages libraries
(continued)


 @[filename]
tells oml to execute the commands that you enter from stdin
(usually defined as the keyboard) or from the filename, if specified.
If you include this option it should be the last option on the
command line.

If you specify the r or d command, oml creates a temporary file in
 which it builds the new version of the library. After oml builds the
 new version, if it does not detect any errors, it deletes the original
 library file (if it existed) and renames the temporary file. Therefore, the
 original library file is not affected if an error occurs.


 Specifying Options
 oml supports the following options:

 -b tells oml not to issue prompts, including prompts for
 missing information.

 -n strips debugging information from modules before
 adding them to the library.

-oprefix specifies a prefix for the filenames to be created by the x
 command. If the prefix includes a directory name, you
 must include the forward slash (/) at the end of the
 name.

 -s includes, in the listing produced by the l command, a
 list of the public symbols defined in the module.

-tpathname specifies a path for the temporary library.

 -v tells oml to display messages as it adds or deletes
 modules to and from the library.

 -x generates a cross reference for variables and functions
 used in a library.

oml produces warning messages if either of the following are true:

 [] A module that you want to delete or extract is not in the library.
 [] Any module in the library includes a second definition for a public
 symbol.254 Chapter 10




 oml Manages libraries
 (continued)


 Examples 
 Since a single object file is essentially a library of one module, you can
use oml to find out what module name is included in the object file, as
follows:


oml name.o l


To build a new library, you can create a list of the filenames of the
 object modules that you want to include in the library and then create
 the library using the following command:


oml new.lib r @name.lst


The following command extracts all of the modules in the library
 cfuncs.lib and creates a file for each module in the directory
 :object/:


 oml -o:object/cfuncs.lib x *


Note: This command will succeed only if the module names in the
 library do not contain pathnames.
The following command deletes the module tribe.o from the
 library cfuncs.lib:


oml cfuncs.lib d tribe.o


The following command lists the modules and symbols in the library
 test.lib:


oml -s test.lib l


 You can save this listing in a file named test.lst by adding the
 greater than (>) sign followed by the filename:

oml >test.lst -s test.lib l255 Utility Reference




 scmsg Searches for and corrects errors and warnings


 Synopsis scmsg [options]


Description 
 The semsg utility helps you find and fix errors and warnings in your
 code. It acts as a filter between you and the compiler, allowing you to
 invoke the editor of your choice and go to the line causing the error or
 warning quickly and easily.
You can use semsg with the editor of your choice, using AREXX as
 a communication medium. AREXX is a standard part of AmigaDOS 2.0
 and can be purchased as a third-party product for use under
 AmigaDOS 1.3. If you do not have AREXX, you still can use semsg to
 control the se editor provided as part of the SAS/C Development
 System, but you will not be able to program the editor keys to control
 scmsg.
If you invoke the compiler from the Shell or by using the Build
 icon on the Workbench, semsg is automatically invoked for you.
You can specify the following options in the semsg command:

 autoedit
 specifies that you want semsg to invoke your editor automatically,
 open the source file, and display the line producing the message.
 The default value is noautoedit.

 config=filename
 specifies the name of a configuration file. Typically, the
 configuration file contains the command necessary to invoke your
 editor, open a source file, and display the appropriate line. For
 more information about configuration files, see "Using AREXX to
 Invoke Your Editor," later in this section.

 hidden
 specifies that you do not want semsg to display the message
 browser window until the compiler returns a message. The default
 value is noh i dden.
 To redisplay the message browser window, you can enter semsg
 nohidden at the Shell prompt or send the AREXX show
 command to the sC_ SCMSG AREXX port. For example, you can
 use the following AREXX script to send the show command:

/* AREXX script to send the SHOW command */
ADDRESS 'SC_SCMSG'
'SHOW'

 quit
 terminates scmsg.256 Chapter 10



 scmsg Searches for and corrects errors and warnings
(continued)


rexxonly
specifies that scmsg should not open a window. Use this option if
you intend to query scmsg for the messages from your editor or
some other AREXX-supporting program, and you do not want to
see the scmsg window.

 Unless you specify hidden or rexxonly, scmsg opens a window
on the Workbench screen. This window contains the first error or
warning message from the compilation. As additional messages are
produced, they are appended to the end of the list. These additional
messages may be produced in the same or a different source file.
 The current message is always highlighted. You can move from
message to message by clicking on the message or by using the arrow
keys. The scroll bar on the right side of the window allows you to
move around in the list. Double-clicking on a message invokes the
editor at the file and line number specified in the message.
 The scmsg window lists all messages in the following format:


primary: class msgno in secondary line lineno: text


where:

primary
is the C source file being compiled.

class
is either Error or Warning.

msgno
is the message number.

secondary
is the name of the file in which the error or warning occurred. This
file may be the same file as the primary file, or it may be a header
file included by the primary file using the #include statement.

lineno
is the line number in the secondary file.

text
is the message text. The message text may specify an alternate file
for a message. If a message describes a conflict between two
different places in your code, the alternate file gives the location of
one of them. The secondary file gives the location of the other. If an257 Utility Reference




 scmsg Searches for and corrects errors and warnings
(continued)


 alternate file is available for the message, the text contains the
 words

 See line num file filename.

Every time a C source file is compiled, all old messages listing that
 file as the primary file are deleted from the scmsg window.
The following sections describe the options available from the
 Project and Edit menus on the scmsg screen. Many of these menu
 items have menu acce1erator keys that allow you to perform the
 specified action without selecting the menu item. To use a menu
 accelerator key, hold down the right Amiga key (just to the right of the
 spacebar) and press the specified key.


 The Project Menu

 The Project menu allows you to control your message session. The
 following list describes each option on the Project menu and, where
 applicable, gives the menu accelerator key equivalent.

 Set Options
sets scmsg options that specify which editor you want to use and
any options for that editor. These options are typically saved in the
file ENV: sc/scmsg. The options available are as follows:

 editcommand
is the Shell command necessary to start your editor. Use the % f
sequence to indicate where the filename should be in the
command. If this option is left blank, scmsg does not attempt to
invoke your editor, and all the other options are ignored. If this
option is left blank but a portname is specified, scmsg sends
AREXX commands to the port, if it exists.

 gotofile
specifies the AREXX commaIld template needed to open a file.
Use the %f sequence to indicate where the filename should be in
the command. Once the filenaIlle has been substituted, this
command is sent to your editor's AREXX port when a new file
needs to be opened. If this option is left blank, scmsg always
uses the editcommand to invoke your editor each time there is
an error.258 Chapter 10



 scmsg Searches for and corrects errors and warnings
(continued)


 gotoline
specifies the AREXX command template needed to go to a
specific line. Use the %1 sequence to indicate where the line
number should be in the command. Once the line number has
been substituted, this command is sent to your editor's AREXX
port when scmsg needs to go to a new line. If this option is left
blank, scmsg does not attempt to move to the proper line
number in the file.

 hidden
specifies that scmsg should not open a window. Use this option
if you intend to query scmsg for the messages from your editor
or some other AREXX-supporting program and you do not want
to see the scmsg window. This option does not take any
arguments.

 portname
specifies the name of your editor's AREXX port. If this option is
left blank, but editcommand is specified, scmsg assumes that
your editor does not support AREXX. The scmsg utility issues
the editcommand option but does not attempt to send any
AREXX commands to your editor.

 wait
specifies that scmsg should not open a window until one or
more new compiler messages are available. This option does not
take any arguments.

 Use
 saves the current options to ENV:sc/scmsg.

 Save
 saves the current options in ENV:sc/scmsg and
 ENVARC:sc/scmsg. The left, top, width, and height
 options are set to the current window's values.

 Save As . . .
 allows you to save your current options to a specified filename. You
 will be prompted for the filename.

 Restore
 reads the option settings from ENV:sc/scmsg into memory.

 Restore from . . .
 reads the options settings from a specified filename. The scmsg
 utility prompts you to enter the filename.259 Utility Reference 




 scmsg Searches for and corrects errors and warnings
(continued)


 Reset to SAS/C defaults
 resets all options to the default values provided by the SAS/C
 Development System. Refer to Chapter 8, ''Compiling and Linking
 Your Program," in SAS/C Development System User's Guide,
 Volume I: Introduction, Compiler, Editor. These defaults are suitable
 for use with se.

 Hide Window
 closes the scmsg window until the compiler produces another
 message.
 To redisplay the message browser window, you can enter scmsg
 nohidden at the Shell prompt or send the AREXX show
 command to the SC_SCMSG AREXX port. For example, you can
 use the following AREXX script to send the show commalld:


/* AREXX script to send the SHOW command */
ADDRESS 'SC_SCMSG'
'SHOW'


 Quit
 terminates scmsg.


 The Build Menu
 You can use the Build menu to terminate any current builds or start
 new builds. The following list describes each option on the Build menu
 and, where applicable, gives the menu accelerator key equivalent.

 Abort Build
 terminates any current builds that are active. You may want to
 select this option if, for example, an error in a common header file
 is producing too many warnings or errors. The menu accelerator
 key for this command is Right-Amiga-A.

 Build Project
 starts a new build. The smake utility is invoked from the directory
 specified in the ENV: sc/pro jdir environrnent variable. This
 variable is automatically set for you each time you submit a smake
 command or click on the Build icon from Workbench. If unset,
 the current directory is used. The menu accelerator key for this
 command is Right-Amiga-B. Any build that is currently running is
 aborted before the new build is submitted.260 Chapter 10




 scmsg Searches for and corrects errors and warnings
(continued)

 The Edit Menu
 You can use the Edit menu to perform certain actions on the current
 (highlighted) message. The following list describes each option on the
 Edit menu and, where applicable, gives the menu accelerator key
 equivalent.

 Go to Error
 invokes the editor on the file and line number that produced the
 message. You can perform the same action by double-clicking on the
 message or by pressing the Return key.

 Go to Alternate
 invokes the editor on the alternate file and line. This option is valid
 for messages that have an alternate file and line number specified in
 the form

 See line num file filename.

 You also can edit the alternate file by holding down either Alt key
 and double-clicking on the message or by holding down either Alt
 key and pressing the Return key.

 Delete Message
 removes the highlighted message from the list. The menu
 accelerator key is Right-Amiga-D.

 Clear
 removes all messages from the list. The menu accelerator key is
 Right-Amiga-C.

 Delete by . . .
 displays a submenu that allows you to delete all messages that meet
 specific criteria. The options on the submenu are as follows:

 Message Number
deletes all messages with the same message number as the
current message. The menu accelerator key is Right-Amiga-N.

 File
deletes all messages produced by the same secondary file,
regardless of the primary file. The menu accelerator key is Right-
Amiga-F.

 Compilation
deletes all messages produced by the same primary file. The
menu accelerator key is Right-Amiga-P.261 Utility Reference




 scmsg Searches for and corrects errors and warnings
(continued)



 Using AREXX to Invoke Your Editor
 When scmsg wants to communicate with your editor, it issues an
 AREXX command based on the templates you provide with the Set
 Options submenu and the information from the highlighted message. It
 uses the template in the appropriate option as a base and performs
 substitutions on it. All templates start with a percent (%) sign. The
 following substitutions are performed:


 TemplateSubstitution

 %% percent (%) sign

 %n newline character

 %f filename

 %l line number

 %c column number

 %xhhhexadecimal character specified by hh

 %r carriage return


scmsg ignores any other sequence of a percent (%) sign followed by
 a character.
If scmsg finds the AREXX port described in your options file, it
 sends the openf ile AREXX sequence provided to the port to tell
 your editor to open the necessary file.
If scmsg cannot locate the AREXX port described in your options
 file, it attempts to invoke your editor on the appropriate file using the
 specified editcommand Shell command. If successful, it goes to the
 appropriate line using the AREXX command template.
The following values are typical of what might be found in a
 configuration file created for se by the Set Options submenu under the
 Project menu:


 editcommandSC:C/SE Shell command to invoke SE
 portnameSC_SEName of the editor's REXX port
262 Chapter 10


 scmsg Searches for and corrects errors and warnings
(continued)


 gotofileOW "%f"%rOpen specified file
 gotolineLL "%1"%rGo to line number %1.


 Configuration files and example AREXX scripts for several popular
editors have been included with the SAS/C Development System in the
sc:extras/scmsg drawer. Check that drawer to see if support for
your editor has been provided.


Using ehe SC_SCMSG AREXX Port
You can also use the built-in AREXX port iII scmsg to get information
on the messages remotely from your editor or from any other program
that supports AREXX. The port's name (for use with the AREXX
address command) is SC_SCMSG. The following commands are
supported:

abort
aborts any builds currently running.

altfile
returns the alternate filename (if any). An empty string indicates
that there are no messages on the list or that the current message
has no alternate file.

altline
returns the alternate line number (if any). An empty string indicates
that there are no messages on the list or that the current message
has no alternate file.

bottom
goes to the last message in the list.

build
submits a new build of the last project built. Any build that is
currently running is aborted before the new build is submitted.

class
returns either error or warning, depending on the current
message.

clear
deletes all messages.

delcomp [filename]
deletes all messages with the specified filename as their primary
filename. If no filename is specified, the primary filename of the263 Utility Reference


 scmsg Searches for and corrects errors and warnings
(continued)


 current message is used. If the current message is deleted, the next
 non-deleted message becomes current.

delete
 deletes the current message and goes to the next message in the list.

delfile [filename]
 deletes all messages with the specified filename as their secondary
 filename. If no filename is specified, the secondary filename of the
 current message is used. If the current message is deleted, the next
 non-deleted message becomes current.

delnum[msgno]
 deletes all messages with the specified message number. If no
 message number is specified, the number of the current message is
 used. If the current message is deleted, the next non-deleted
 message becomes current.

errnum
 returns the error number. An empty string indicates that there are
 no messages on the list.

file
 returns the filename for the current message. An empty string
 indicates there are no messages on the list.

hide
 closes the scmsg window, but keeps scmsg running. If you specify
 wait, the scmsg window reappears when a new message is issued
 from the compiler. Otherwise, you must send a show command
 with REXX or reinvoke scmsg from the command line to redisplay
 the window.

line
 returns the line number for the current message. An empty string
 indicates there are no messages on the list.

next
 goes to the next message in the list. If the current message is the
 last in the list, scmsg goes to the first message in the list.

prev
 goes to the previous message in the list. If the current message is
 the first in the list, scmsg goes to the last message in the list.

quit
 terminates scmsg.264 Chapter 10




 scmsg Searches for and corrects errors and warnings
(continued)


rexxonly
specifies that scmsg should close the message browser window and
not reopen it unless you specify scmsg nohidden at the Shell
prompt or send the ARGXX show command to the sc_ SCMSG
ARGXX port. Use this command if you intend to query scmsg for
the messages from your editor or some other AR~XX supporting
program, and you do not want to see the scmsg window.

select
selects the current message for editing. Your editor is invoked and
moved to the proper file and line number. This command is
equivalent to pressing the Return key on the current message.

show[activate]
pops the scmsg window to the front or redisplays the window if it
is hidden. If you specify activate, the scmsg window becomes
the active window, and you can enter keyboard commands to
scmsg.

text
returns the message text. An empty string indicates that there are
no messages on the list.

top
goes to the first message in the list.

Examples 
 The following AREXX script, when invoked from se, opens the file
containing the current message, moves to the appropriate line number,
and displays the message on the editor message line:


 /* AREXX script to move to next error */
 address 'SC_SCMSG' /* Set Up to talk to scmsg */
 Idelete'/* Delete the current error, move to next */

 options results /* Tell AREXX we want the return values */
 /* of issued AREXX commands*/

 'file' /* Get the new filename */
 file = result

 'line' /* Get the new line nUmber */
 line = result265 Utility Reference




 scmsg Searches for and corrects errors and warnings
(continued)


 'text'/* Get the new message text */
 text = result

 options/* Don't care about results any more */

 address 'SC_SE'/* Now talk to the editor */

 if file = "" then
'DMNo more errors'/* Display Message "No more errors" */
 else do
'OW UC' || file || "0d"x /* Open Window "file" */
'LL UC' || line || "0d"x /* Go to line "line"*/
'DM' || text /* Display Message "text" */
 end266 Chapter 10


 scopts Sets compiler options


 Synopsis scopts [options]


Description 
 The scopts utility allows you to set compiler options for a project by
 clicking on the gadget that corresponds to the option. The options you
 specify are used by the sc command whenever you compile and link
 your files.
To run scopts, you can double-click on the SCoptions icon, or
 you can enter scopts on the Shell command line. scopts displays
 the SAS/C Compiler Options Index window. This window contains
 buttons that open additional windows. Each of these windows allows
 you to set different compiler options. In all, scopts can display nine
 windows:

 Compiler Options Index
allows you to do the following:

[] set certain options such as list, xref, link, and map
[] specify the name of the final executable module
[] display additional windows such as the Optimizer Options
window and the Link Options windows
[] save your option settings to a file named scoptions in the
current directory
[] save your option settings in ENV:sc/scoptions.

 Compiler Options
contains gadgets for miscellaneous options such as debug,
shortintegers, and stringmerge.

 Diagnostic Message Options
contains gadgets for options, such as ansi, strict, and
errorrexx, that affect which messages are generated by the
compiler and linker and how those messages are handled.

 Code Generation Options
contains gadgets for options, such as data, code, and cpu, that
affect the code generated by the compiler.

 Listing/Cross-Reference Options
contains gadgets for options, such as listnarrow,
errorlisting, and xrefsystem, that affect the content and
formatting of any listing or cross-reference files generated.

 Optimizer Options
contains gadgets for options, such as optpeep, optsize, and
optalias, that affect the performance of the optimizer.267 Utility Reference


 scopts Sets compiler options
(continued)


 Prototype Generation Options
 contains gadgets for options, such as genprotoexterns,
 genprotoparms, and genprototypedef s, that affect how
 prototypes are generated.

 Linker Options
 contains gadgets for options, such as smallcode, stripdebug,
 and batch, that are passed to the linker when the linker is invoked
 by sc. These options are not used by the compiler.

 Map Options
 contains gadgets for options, such as maphunk, mapxref, and
 mapoverlay, that affect the content of the map file.

 For a brief description of an option, move the cursor to the option
 gadget and press the Help key. For a complete description of any
 compiler option, refer to Chapter 8, "Compiling and Linking Your
 Program," in User's Guide, Volume I.
These windows may contain one or more of the following basic types
 of gadgets:

 cycles appear as raised buttons with a cycle symbol on
 the left side. By clicking on the gadget with the left
 mouse button, you can cycle through the setting
 available for that option. To reverse the direction
 of the cycle, press the Shift key as you click the
 mouse button.

 actions appear as raised buttons. Selecting the button
 causes an immediate action to occur. For example,
 selecting the Compiler Options. . . gadget
 displays the Compiler Options window.

 strings appear as a raised ridge around a text area. You
 can enter data in the area by clicking within the
 text area and typing. When you have finished
 typing, press the Return key.

lists appear as a set of control gadgets (a scroll bar,
 arrow gadgets, a string area, and ADD and DEL
 buttons) combined with a raised scrolling area. Use
 the scroll bar and arrow gadgets to position the
 scrolling area on specific items. To add new items
 to the list, select the ADD button, type the new
 item name, and press the Return key. To remove268 Chapter 10


 scopts Sets compiler options
(continued)


 an item from the list, click on the item (to copy it
 to the string area), and select the DEL button. To
 modify an item, click on the item (to copy it), and
 enter any corrections.

To specify an option for which the scopts utility does not have a
 gadget, enter the option and any parameters required by the option
 into the SPECIAL gadget. You can enter as many additional options as
 you like. If you use the SPECIAL gadget to specify an option for which
 scopts already has a gadget, the next time you invoke scopts, the
 gadget for that option is selected, and the option is no longer included
 in the SPECIAL gadget. The only options remaining in the SPECIAL
 gadget are those for which scopts does not have a gadget. For
 example, if you enter link into the SPECIAL gadget, the next time
 you invoke scopts, the link gadget is selected, and the SPECIAL
 gadget does not contain the link option.
Any values you enter into the SPECIAL gadget are processed after
 all other gadgets are processed. Therefore, options you enter into the
 SPECIAL gadget may override other options.
To specify the name of your final executable module, specify a
 filename in the ProgramName gadget.
To save your option settings, select one of the following options from
 the Project menu:

 Save to SCOPTIONS
 saves the settings to the file scoptions in the current directory.
 You also can click on the Save button in the SAS/C Compiler
 Options Index window to save the settings in scoptions.

 Save as global defaults (ENV:)
 saves the settings to the file ENV:/sc/scoptions. You also can
 click on the Save Default button in the SAS/C Compiler Options
 Index window to save the settings in ENV:. The option settings are
 also saved to ENVARC:, if it exists.

 Save as . . .
 asks you for the name of the file in which you want to save the
 settings. To use the options saved in a file other than scoptions
 or ENV: sc/scoptions, you can specify the filename using the
 with compiler option in the sc command. The options in the
 with file are read as if they were specified in the sc command at
 the position occupied by the with option.269 Utility Reference



 scopts Sets compiler options
(continued)


To exit scopts without saving any of your changes, click on the
 Cancel button.
When you run the sc command, it first looks for an scoptions
 file in your current directory. If this file does not exist, the sc
 command looks for the ENV:sc/scoptions file.
The scoptions file is an ASCII file that contains the list of sc
 options that you specify. You can edit this file with a text editor and
 add any options you want.
To load a previously saved options file or to reset all options to their
 default values, select one of the following options from the Project
 menu:

 Restore from SCOPTIONS
 reads the contents of the scoptions in the current directory into
 memory.

 Restore from global defaults (ENV:)
 reads the contents of ENV: sc/scoptions into memory.

 Restore from . . .
 asks you for the name of the file from which you want to read
 option settings into memory.

 Reset to SAS/C defaults
 resets all options to the default values provided by the SAS/C
 Development System. Refer to Chapter 8, "Compiling and Linking
 Your Program," in SAS/C Development System User's Guide,
 Volume I: Introduction, Compiler, Editor.

You also can change option settings by specifying the option Oll the
 scopts command line. For example, to set the math=standard and
 link options, you can enter the scopts command as follows:

 scopts math=standard link

 If you enter the scopts command followed by option settings,
 scopts does not display any windows, and you cannot choose the file
 into which the options are saved. Specifically, scopts performs the
 following tasks:

1. reads the scoptions file in your current directory, if it exists.
 If this file does not exist, scopts reads ENV: sc/scoptions.
2. adds or changes the options you specified.270 Chapter 10



 scopts Sets compiler options
(continued)


3. saves the new option settings in the file scoptions in the
 current directory.271 Utility Reference



scsetup Sets up a new project


 Synopsis sc:scsetup [directory]. .

Description 
 The scsetup utility sets up a directory that you can use for C
 development. You can run scsetup on existing directories or use it
 to create new directories. scsetup creates an icon for the directory
 and copies into the directory icons for the most commonly used SAS/C
 Development System tools, such as smake and CodeProbe. You can
 add icons for any file extensions or tools that you want scsetup to
 copy in addition to the standard icons.
Specifically, scsetup performs the following actions:

1. Creates the directory, if necessary.
2. Creates an icon file for the directory being set up, if it does not
 already have one. scsetup uses the file
 sc: starter_project . info as a template for directory icons.
3. Creates icons for the files in the directory, if necessary. Default
 icons are supplied for . c, . h, . a, and . smk files. These icons
 are in the sc: icons drawer under the name def_c.info,
 def_h.info, def_a.info, and def_smk.info. You can add
 any default icons needed for other extensions by copying an icon
 into sc:icons with the appropriate name (def_extension.
 info).
4. Creates an icon file for any subdirectories of the directory being
 set up, if they do not already have one.
5. Creates icons for the files in each subdirectory, if necessary.
6. Copies the contents of the directory sc: starter_project, if
 present, to the directory being set up. This starter directory
 contains a Build icon, a Debug icon, an Edit icon, and an
 SCoptions icon. You can place any other icons or programs in
 this starter directory that you want copied to directories set up
 with scsetup.

 scsetup will not overwrite any existing files or icons.
You can run scsetup from the CLI or from the Workbench. To
 run scsetup from the CLI, enter the following command:

 sc:scsetup [directory] . . .

 If you do not specify a directory name, scsetup sets up the current
 directory. If you specify a directory that does not exist, scsetup
 creates the directory.
To run scsetup from the Workbench and create a new project,
 double-click on the SCsetup icon, and type the name of the drawer
 when prompted.272 Chapter 10



scsetup Sets up a new project
(continued)


To run scsetup from the Workbench and set up an existing
 drawer, click on the drawer icon. (Click on the actual drawer icon, not
 the file icons in the drawer.) To select additional drawers, hold down
 the Shift key and click on their icons. After you have selected all the
 drawers, hold down the Shift key and double-click on the SCsetup
 icon.
After you have set up a directory, you can run the editor by double-
 clicking on the Edit icon, and you can run CodeProbe by double-
 clicking on the Debug icon. You can run smake by double-clicking on
 the Build icon. smake looks for a smakefile or a makefile. If none
 are present, it compiles and links all.c files in the directory using the
 options specified through the scopts utility, described earlier in this
 chapter.273 Utility Reference




 smake Maintains and updates records of file dependencies


 Synopsis smake [options] [macro-definitions] [targets]


Description 
 The smake utility is a tool that you can use to maintain projects that
 are composed of many files. A file can be C source code, a data file for
 a graphics or audio, or perhaps a spreadsheet file. For example, you
 may have a project that consists of 50 files, and several programmers
 may be responsible for different files. To manage this project, you need
 to keep track of which files have been changed and which files must be
 compiled before other files (that is, which files are dependent on other
 files). You can use smake to keep track of file dependencies, recompile
 and relink any files that have been updated, and produce new product
 files.
In other words, smake determines if any of the source files have
 changed since the last version of the product file was generated and, if
 so, generates a new product file.
To use smake, you create a smakefile that identifies dependent files
 and target fi1es and describes the actions required to produce a new
 product. A basic description of these terms follows:

 target file is any file that is created or updated by smake.
 Producing this file may require creating or updating
 several intermediate files.

 dependent file is a file that must be created or updated before a
 target file can be updated. A dependent file can be a
 source code file, header file, or object code file. In
 other words, if a dependent file is changed (for
 example, by editing), then the target file must be
 rebuilt.

 actions are the commands necessary to update each dependent
 and target file. Actions can be calls to the compiler or
 linker or basic housekeeping commands.

smakefile is a file that identifies every dependent file required to
 create the target file and describes every action
 required to update or create the dependent and target
 files.

 When you run smake, it re-creates only the first target file specified in
 the smakefile (unless you specify an alternate target as described in
 "Using Alternate Targets," later in this section) and, if necessary, any274 Chapter 10



 smake Maintains and updates records of file dependencies
(continued)


 dependent files needed to re-create the target file. Specifically, smake
 performs the following actions:

1. Locates and identifies the target file. By default, smake remakes
 the first target file specified in the smakefile. You can specify an
 alternate target as described under "Using Alternate Targets,"
 later in this section.
2. ensures that any file on which the target file depends already
 exists and is up to date. To determine when dependent files were
 last modified, smake looks at the time stamp of the file. A file is
 considered current if it has a time stamp later than that of any of
 its dependent files.
 Note: Before using smake, make sure that your system clock
is accurate, using the date command if appropriate.
 An example of the date command under AmigaDOS follows:

date 12-Aug-92 16:34:57

 You must enter the time using 24-hour clock notation. Enter the
 month as a three-character field.
3. Re-creates the target file if any of the dependent files have been
 modified more recently than the target file.

Creating the smakefile 
A smakefile has the following basic format:

 # This is a comment.
 target-file1: dependent-file1 dependent-file2...
actions
 target-file2: dependent-file1 dependent-file2...
actions
 .
 .
 .

You can include comments in a smakefile by entering a pound (#)
 sign in the first column. smake will ignore the remainder of that line.
All target file names must

 [] start in the first column
 [] be followed by a colon (:)
 [] be followed by the name of any dependencies of the target.275 Utility Reference




smake Maintains and updates records of file dependencies
 (continued)

If there are too many dependent filenames to fit on one line, repeat the
target name and colon on the next line, and enter the remaining
dependent filenames.
 Immediately after the target-dependency line are any actions
required to generate the target. Each of the action lines, if any, must
be indented a minimum of one tab or space. To continue an action line
onto additional lines, end each continued line with a backslash (\). You
can have as many action lines as necessary for each target-dependency
line. You can call smake from within a smakefile. You cannot issue
the cd (change directory) command from within a smakefile. 
 For example, suppose you have an executable file named myfile
that you created by linking two object files, file1.o and file2.o .
These object files are created by compiling the source files file1.c
and file2.c, and each of these source files includes the header
stdio.h. Figure 10.1 shows the relationships among these files.


 ----------
Figure 10.1Executable File| myfile |
 Example File (primaryTarget)----------
 Dependencies/ \
/ \
Object Files---------------------- 
(Dependents of Primary and | file1.o || file2.o |
Targets of Source Files)----------------------
 / \ / \
/ \ / \
 ----------- ----------- -----------
Source Files | file1.c | | stdio.h | | file2.c |
(Dependents) ----------- ----------- -----------


 If any information in stdio.h changes, you would have to
recompile both source files and relink both object files to produce a
new executable file. However, you can create a smakefile that contains
all of the information necessary to recompile and relink these files and
then run smake to recompile and relink as necessary.276 Chapter 10




 smake Maintains and updates records of file dependencies
(continued)


Your smakefile could look like this:


1# Primary target is myfile
2myfile: file1.o file2.o
3 slink FROM LIB:c.o+file1.o+file2.o TO myfile LIB \
4LIB:sc.lib+LIB:amiga.lib
5
6file1.o: df1:source/file1.c stdio.h
7 sc data=absolute code=far dfl:source/file1.c
8
9file2.o: df1:source/file2.c stdio.h
 10 sc data=absolute code=far df1:source/file2.c

Note: Do not enter line numbers in your smakefiles. Line numbers
 are included here for use in the discussion that follows.
The first line is a comment line. The second line identifies the two
 dependent object files of the target file myfile. That is, it identifies
 the files that must be current before myf ile can be generated:
 file1.o and file2.o.
Lines three and four give the commands (actions) necessary to
 produce myfil e. In this example, the only command necessary to
 produce myf ile is a call to the linker, slink.
The sixth line identifies the files required to produce the object file
 file1.o. The two files are df1:source/file1 .c and stdio.h.
 Line seven gives the command necessary to produce the object file: a
 call to the compiler, sc. Lines nine and ten identify the dependent files
 and actions required to produce file2.o.
Target-dependency and action lines are the primary components of a
 smakefile. However, smake provides many special features that you
 can use to make your smakefiles more powerful. These features include
 macros, transformation rules, local input files, fake targets, and more.
 The following sections describe all of the special features you can use
 in your smakefile.277 Utility Reference




 smake Maintains and updates records of file dependencies
(continued)


 Using Special Symbols
 You can use special symbols to override some of the default actions of
 smake. These special characters are as follows:

 - Normally, when an action generates an error, smake stops
processing. If you want smake to continue processing when it
encounters an error caused by a specific action, begin the action
line with a minus (--) sign. If you want smake to continue
processing after all errors, specify the command line option -k.

 @ Normally, smake displays all commands and messages generated
by those commands on the screen as each command is executed. If
you do not want a command to be echoed to the screen, begin the
action line with the at (@) symbol. smake will still display any
generated messages. If you do not want any commands echoed to
the screen, specify the command line option - s.

 $ The dollar ($) sign is an escape symbol for the dollar sign itself. In
other words, to enter a dollar sign in a filename, enter two dollar
signs ($$). If you enter only one dollar sign, smake thinks that
the dollar sign indicates the beginning of a macro.

 \ The backslash (\) symbol is an escape symbol for the pound (#)
sign. Pound signs normally indicate the beginning of a comment.
To use a pound sign in a command line, enter a backslash before
the pound sign (\#).

 & The ampersand (&) symbol is provided for compatibility with other
implementations of smake. The ampersand is ignored under
AmigaDOS.


 Using Macros
 You can use macros to represent any character string, including
 AmigaDOS commands, directory specifications, header files, compiler
 or assembler flags, and constant strings. Macros are especially useful
 where long character strings are required.
Within a smakefile, you can define a macro using the equals (=) sign
 as follows:

 macro-name = definition

Make sure you define a macro before you attempt to use it. If you
 reference a macro that has not yet been defined, that macro will be
 expanded to an empty.278 Chapter 10



 smake Maintains and updates records of file dependencies
(continued)


Note: You purposely can define a macro to be the empty string by
 entering only the macro name and the equals (=) sign:

 macro-name =

To refer to a macro within a smakefile, use the following format:

 $(macro-name)

For example, you can define the macros source and f lags to
 represent the pathname of your source file and the compiler options
 you want to use to compile that file. Using these two macros, our
 earlier example now looks like the following:


# Define macros for soUrce pathname and compiler options
SOURCE = df1:source/
FLAGS = data=absolute code=far

# Primary target is myfile
myfile: file1.o file2.o
 slink FROM LIB:c.o+file1.o+file2.o TO myfile LIB \
LIB:sc.lib+LIB:amiga.lib


file1.o: S(SOURCE)file1.c stdio.h
 sc $(FLAGS) S(SOURCE)file1.c


file2.o: $(SOURCE)file2.c stdio.h
 sc $(FLAGS) $(SOURCE)file2.c

 Overriding a Macro Definition
 You can override the definition of a macro from the command line of
 smake by specifying the new definition as follows:

 macro-name = new-definition

 If you specify a macro definition on the smake command line, do not
 include spaces around the equals (=) sign. For example, you can
 redefine the debug macro as follows:


smake -f editor debug=yes279 Utility Reference




 smake Maintains and updates records of file dependencies
(continued)


 Using Default Macros
 smake provides five default macros that are defined after a target-
 dependency line is processed and before the next action line is
 processed.



 MacroDefinition

 $@ target filename

 $? list of dependent files, including the full directory
 pathnames, that are not current (that is, they have time stamps
 later than the target time stamps)

 $* name of the first dependent file, including the full directory
 pathname but excluding the filename extension

 $< name of the dependent file that caused the action, excluding
 the directory pathname but including the filename extension

 $> name of the dependent file that caused the action, excluding
 directory pathnames and filename extension


 For example, your smakefile could contain the following target-
 dependency line:

 obj/new/test.o: src/new/test.c hdr/test.h

 This line defines the source file as test.c located in the directory
 src/new and the header file test.h located in the directory hdr. If
 the source file test.c has a time stamp later than the target file
 test.o, then the default macros will have the following values:



 MacroValue
 S@ obj/new/test.o
 $? src/new/test.c
 $* src/new/test
 $<test.c
 $>test280 Chapter 10




 smake M aintains and updates records of file dependencies

(continued)


 Note: The value of each ofthese default macros changes after each
target-dependency line is processed.


Defining Transformation Rules

You can use transformation rules with macros to tell smake how to
make a file with a given filename extension from another file with a
different filename extension. Transformation rules are most useful
when you have several files with which you want to perform the same
action. smake uses transformation rules if you do not specify explicitly
the action required to create a certain target.
 For example, you can have a transform ation rule that tells smake
how to create object files with extensions of .o from source files with
extensions of .c. Ifthe only action required to produce the object file
from the source file is a callto the co mpiler, your smakefile can
contain the following transformation rule:


.c.o:
 sc $*281 Utility Reference




 smake Maintains and updates records of file dependencies
(continued)

 Then, smake would compile source files (os.c and strbpl.c)
 without an action line for each source file that explicitly specified the
 call to the compiler:

.c.o:
 sc $*


obj/os.o: os.c

obj/strbpl.o: strbpl.c

 Using Fake Targets
 Fake targets are a set of predefined targets that allow you to control
 the behavior of smake. smake does not remake fake targets. Fake
 targets allow you to set logical names, specify actions to be taken for
 certain conditions, and suppress certain messages.
 smake provides five fake targets:

 .DEFAULT
 .IGNORE
 .ONERROR
 .SET
 .SILENT

 The following list describes these targets in detail

 .DEFAULT
 specifies an individual action or a set of actions to be executed if

 [] there are no actions specified for a given target-dependency line
 [] there is no default transformation rule for the given target-
 dependency pair.

 The command line syntax used for the .DEFAULT target is as
 follows:


 .DEFAULT:
action- 1
action-2
.
.
.
action-n282 Chapter 10




 smake Maintains and updates records of file dependencies
(continued)



 You can use .DEFAULT actions to display messages to the screen as
 smake is running. For example, your smakefile can consist of the
 following lines:


 .DEFAULT:
 ; this target needs remaking $@
 alpha.cpp: alpha.clp


 If alpha.clp has a later time stamp than alpha.cpp, smake
 will print the following message to your screen:

this target needs remaking alpha.cpp

 .IGNORE
tells smake to ignore any error caused by the action lines.
Specifying . IGNORE is equivalent to calling smake with the -i
option. To specify . IGNORE, include the following line in your
smakefile:

 .IGNORE:

 .ONERROR
specifies an action or set of actions to be performed when smake
detects an error. For example, you may want to delete certain
temporary files or transfer them to a different directory if an error
occurs. Specify the actions to be taken after the . ONERROR target:


 .ONERROR
action-l
action-2
.
.
.
action-n

 .SET
allows you to set the values of logical name assignments (as created
by the assign command) from within a smakefile. When the
logical name is set from within a smakefile, the logical name retains283 Utility Reference




 smake Maintains and updates records of file dependencies
(continued)

the specified value and will be in effect for any secondary processes
spawned from the main process. To specify . SET, use the following
format:


.SET: logical-name = value


The value may be any character, including a space. However, the
leading and trailing space characters are ignored.
 For example, you can redefine the logical name INCLUDE as
follows:


 .SET: INCLUDE: = df0:sc/examples


 .SILENT
tells smake not to echo the action lines to the standard output
device before they are executed. Specifying . SILENT is equivalent
to calling smake with the -s option. To specify . SILENT, include
the following line in your smakefile:


 .SILENT:


 Using Multiple Targets
 If you have several target files that are dependent on the same
 dependent files, you can specify the target files together on the same
 target-dependency line. For example, if prog.c, my file.c, and
 newcode.c all included the header file stdio.h, you can use the
 following lines in your smakefile:


prog.c myfile.c newcode.c: stdio.h
 sc $@

 Using Alternate Targets
 Unless you specify an alternate target, smake remakes only the first
 target file specified in the smakefile and, if necessary, any dependent
 files needed to re-create the target file. However, your smakefile can
 contain target-dependency and actions lines for several targets. To tell284 Chapter 10




 smake Maintains and updates records of file dependencies
(continued)

 smake to remake a target other than the first one specified in the
 smakefile, enter the name of the target on the smake command line:
 smake target-name

 For example, you can have the following smakefile that specifies two
 targets, clean and backup:


clean:
delete S(OBJ)files.o.Ds
delete $(OBJ)os.o
delete $(OBJ)strbpl.o


backup:
copy files.c to df1:
copy os.c to df1:
copy strbpl.c to df1:


 If you enter the smake command without specifying a target, smake
 runs the commands listed under clean. To run the commands listed
 under backup, you must use this command line:


smake backup


 Using Local Input Files
 From within a smakefile, you can create a temporary disk file
 containing instructions that is passed to AmigaDOS when you run
 smake. Local input files are useful when you need to enter command
 lines that are too long to fit on one line.
Any macros defined in the smakefile can be used within a local input
 file. Local input files are automatically deleted before smake
 terminates.
You can construct a local input file with action lines as follows:

 command <[preface] <[!] [(filename)]
statement1
statement2
.
.
.
statementn285 Utility Reference




 smake Maintains and updates records of file dependencies
(continued)


 where:

 command is the command to be handed to AmigaDOS.

 preface is any text or symbol to be passed to AmigaDOS before
 the temporary filename. The preface may contain
 spaces.

 tellssmake to create a local input file containing the
 statements you specify but not to pass the filename as
 part of the generated command line.

 filenameis the name of the local file. If you do not specify a
 name, smake uses the temporary filename
 temp _ smake . tmp. If you specify a filename, enclose
 the filename in parentheses, and do not enter spaces
 before or after the filename.

 statementl-n are the statements that you want included in the local
 input file.

The following example shows a smakefile that uses macros and a
 local input file to create the target grep. grep is a utility that is
 composed of C source files and one assembly language module, the
 startup module c.a.


1 # Generate an Updated version of GREP
2
3 # Define macros
4SCHDRS = grep.h pat.h
5OBJ = obj/
6FLAGS = IDIR=INCLUDE: IDIR=INCLUDE:sc/ OUT=$(08J)
7SC = SC:sc
8
9 # Specify file dependencies for GREP executable, generate link
 10 # command to be passed to AmigaDOS, then specify contents of
 11 # WITH file .
 12grep: $(oBJ)grep.o $OBJ)c.o $(OBJ)-main.o $(OBJ)re_gen.o
 13grep: $(OBJ)re_match,c S(OBJ)os.o
 14 slink <WITH <
 15FROM $(OBJ)c.o+$(OBJ)grep.o+$(OBJ)-main.o+$(OBJ)re_gen.o
 16FROM $(OBJ)re_match.o $(OBJ)os.o
 17TO grep
 18LIBRARY LIB:sc.lib+LIB:amiga.lib286 Chapter 10




 smake Maintains and updates records of file dependencies
(continued)


19<
20
21# Specify remaining file dependencies for file needed to generate
22# GREP executable.
23$(OBJ)grep.o: grep.c $(LCHDRS)
24 $(SC) 5(FLAGS) define GREP grep
25
26$(OBJ)c.o: c.a
27asm -iinclude: -o$(OBJ)c.o c.a
28
29$(OBJ) main.o: main.c
30$(SC) 5(FLAGS) define GREP main
31
32$(OBJ)re_gen.o: re_gen.c S(LCHDRS)
33$(SC) $(FLAGS) define GREP re_gen


Note: Do not enter line numbers in your smakefiles. Line numbers
 are included here for use in the discussion that follows.
Lines three through seven define macros. Lines 12 and 13 list the
 files that must be current before smake can remake the grep target.
 If a target has too many dependent files to fit on one line, retype the
 target filename and colon on the next line, and enter the remaining
 dependent filenames.
Line 14 tells smake to

1. create a local input file, using the default temporary filename,
 that contains all the lines up to the less than (<) sign in line 19
2. execute slink to generate the target grep
3. pass the local input file to slink as a local input file.
 smake generates the following command and passes it to AmigaDOS:


slink WITH temp_smake.tmp


 The temporary file temp_smake.tmp contains the following lines:


FROM $(OBJ)c.o $(OBJ)grep.o $(OBJ)-main.o $(OBJ)re-gen.o
FROM $(OBJ)re_match.o $(OBJ)os.o
TO grep
LIBRARY LIB:sc.lib+LIB:amiga.lib287 Utility Reference




smake Maintains and updates records of file dependencies
(continued)


Using Default (.def) Default files are smakefiles that smake searches whenever
your
Files smakefile does not specify what action is required to create a target.
smake provides a default file called smake.def.
 To determine what action to take to create a target, smake looks for
instructions in the following order:

 1. actions specified below the dependency relation.
 2. transformation rules in your smakefile.
 3. .DEFAULT rules specified in your smakefile or in the smake .
 def file.
 4. rules taken from an alternate .def file.
 5. rules taken from a file named smake .def in the current
 directory.
 6. rules internal to this implementation of smake. smake internal
 rules are the same rules that are in the default smake .def file.
 However, editing smake.def does not change the internal rules.

Using the smake.def File
smake provides a default file, smake.def, that contains the basic
command for compiling and linking a file, and it contains
transformation rules for converting assembly language, C source code,
and header files into object files. You can change these rules as
necessary by editing smake.def .
 smake.def contains the following:


sc = sc:sc
SCFLAGS = IDIR=INCLUDE:
ASM = SC:asm
LINK = SLINK:slink



.DEFAULT:
 $(SC) $(SCFLAGS) $*


.a.o:
 $(ASM) $* -iinclude: -o$*.o


.c.o:
 $(SC) $(SCFLAGS) $*288 Chapter 10




 smake Maintains and updates records of file dependencies
(continued)


.h.o:
delete $*.o
$(SC) $(5CFLAGS) $*


 Creating and Using Your Own Default File
 You can create your own default files. To use a.def file other than
 smake.def, specify the -b option on the smake command line as
 follows:

 smake -bfilename.def

 Your default file must have the file extension .def .


 Running smake You can run smake from the Workbench or from the CLI.
To run smake from the Workbench, double-click on the Build
 icon. smake looks for the smakefile in your current directory. The
 default file names that smake looks for, in the order in which it looks
 for them, are as follows:

1.smakefile
2.smakefile.smk
3.lmkfile
4.lmkfile.lmk
5.makefile

 To use a different smakefile name, specify the -f option as described
 later in this section. To specify options, define macros, or specify
 alternate targets for the Build icon, select the Build icon, choose
 Information from the Icons menu, and add the necessary
 parameters in the Tool Types box.
When rurming smake from the Workbench, the search order of files
 is based on the assignment of the device smake _ files: . You can
 assign a value to this device using the following command (from the
 CLI):


assign smake_files: your-device:


 When no assignment has been made, smake searches the current
 directory for the required files.289 Utility Reference




 smake Maintains and updates records of file dependencies
(continued)


To run smake from the CLI, enter the smake command as follows:

 smake [options] [macro definitions] [targets]

 As with the suild icon, smake looks for one of the three default
 smakefile names in your current directory. To use a different smakefile
 name, specify the -f option as described later in this section.
 smake supports the following options:

 -arebuilds all targets and subtargets without regard to time
stamps.

 -bfile uses the . def file you specify instead of the default file
smake.def.

 -ctells smake to record everything it would have done if it had
executed the command you entered. When you specify the -c
option, smake does not execute the command you enter.
Instead, it creates a batch file containing all the instructions
it would have executed if you had not specified the -c
option. This file is named smakefile.bat in the current
directory, and you can run it by entering the following on the
command line:

 execute smakefile.bat

 -dprints detailed debugging information about the processing of
the smakefile.

 -eerases any out-of-date targets before remaking them.

 -ffile uses the filename you specify as the input smakefile. smake
attempts to locate the file with the exact name you have
specified. If this search is unsuccessful, smake searches for a
file with the name you specified plus an extension of
.smake. For example, suppose you have an executable
named alpha and a smakefile named alpha.smake in the
same directory. If you specify smake -falpha, smake will
assume that alpha is your smakefile. If you receive an error
message such as Line too long or Unexpected
punctuation, try renaming your file with an explicit
.smake extension and running smake with the full
filename.290 Chapter 10




 smake Maintains and updates records of file dependencies
(continued)


 -hprints help information and then exits.

 -iignores errors caused by executing the actions. Both the -k
and -i actions should be used with caution because smake
will continue running. The -k option incorporates all of the
functionality of the - i option.

 -kignores error returns from actions passed to AmigaDOS and
from smake not knowing how to make certain targets. Both
the -k and -i actions should be used with caution because
smake will continue running. The -k option incorporates all
of the functionality of the - i option.

 -ndisplays the actions smake would have taken, but smake
does not execute these actions.

 -pprints target descriptions and expanded macros.

 -qdetermines if the target file is current. smake prints a 1 if
the target is current or a 0 if it is not. smake will not
execute any actions.

 -sdoes not echo actions to the screen before executing them.

 -ttouches the target files by updating them with the current
system time. smake does not execute any of the actions
associated with these targets.

 -urebuilds unconditionally all targets and subtargets without
regard to time stamps.

 -xis for UNIX compatibility. If you specify this option, smake
attempts to detect any features of the smakefile that would
prevent it from working correctly with the llNIX make
utility.
Examples of such features are:

[] using a local input file
[] defining an action line without an initial tab character
[] specifying multiple target files on a single target-
dependency line.



 In each case, smake displays a message describing the incompatibility.291 Utility Reference


splat Searches for and replaces patterns that match regular expressions


 Synopsis splat [>destination] [options] pattern string file . .

Description 
 splat replaces all occurrences of pattern with string in each file that
 you specify. splat does not overwrite the original version of the file
 unless you specify the -o option. If you do not redirect the output by
 specifying a greater than (>) sign followed by a destination, splat
 places the changed file in either a temporary file or, if you use the -d
 option, in the specified directory. splat uses the same root filename
 with an extension of .$$$.
 You must use the rules recognized by grep for specifying the
 pattern and string. For example, to specify a string that contains spaces,
 you must enclose the string in double quotes. For additional
 information, see the description of the grep utility earlier in this
 chapter.
 splat supports the following options:

 -ddirectory
 specifies the directory where you want splat to place the new
 files. Using this option leaves the original versions untouched. If the
 specified directory does not exist, splat attempts to create it. If
 the attempt fails, splat displays an error message. The -o and -d
 options are mutually exclusive.

 -o

 tells splat to overwrite the original version of the file with the
 new version. The -o and -d options are mutually exclusive.

 -s
 displays the name of the file on which splat is currently working.
 It also displays a message saying that no substitutions have been
 performed if it was unable to find the specified pattern in the file. If
 you do not specify -s, splat performs its task silently.

 -v
 displays all lines in which substitutions are made, but it does not
 create new versions of the files. You can use this option to
 determine the changes that splat will make to your files.

 Examples 
 For example, suppose you want to substitute INT for int in every
 declaration of an integer identifier in your C source files. The following
 command replaces int with INT in all files with the .headers and
 .source extensions in your current directory. It writes the new
 versions of these files in the directory named /backup.

splat -d/backup/ int INT N?.headers #?.source292 Chapter 10




splat Searches for and replaces patterns that match regular expressions
(continued)



 However, you do not want calls to printf to become prINTf.
 Because in these declarations, the string int is followed by a space
 character, you should use the following command instead:


 splat -d/backup/ "int 1" "INT " #?.headers #?.source


 Similarly, the following command performs the same substitutions, but
 it writes the new versions of the files in the subdirectory backup of
 the current directory:

 splat -dbackup/ "int " "INT " #?.headers #?.source

 To avoid errors such as replacing printf with prINTf, you can use
 the -v option to determine, without changing your source files or
 creating new files, if you have entered the correct command. The
 following command performs the same substitutions as the previous
 command and displays those changes on the screen, but it does not
 change the files:

 splat -v "int "INT " #?.headers #?.source


The following command replaces all occurrences of the string
 un signed char with ehar within all files with the .c extension in
 the current directory:


splat "unsigned char" char #?.c


The following command appends the string -cc to the end of each
 line that contains the string sc1 in the file comp.bat:


splat -dbak/ "sc1.*$" " -ccll comp.bat


 The pattern sc1.*$ matches any string beginning with sc1 followed
 by O or more of any character and ending with the end of the line.
 The string& -cc appends a space followed by -cc to the end of the
 line.293 Utility Reference




splat Searches for and replaces patterns that match regular expressions
(continued)


You can also use splat to insert lines in a file or to break single
 lines into multiple lines. For example, you can have a file named
 text.c that contains the following line:


 parms(s);usage();exit(l);


 Suppose you want the calls to usage and exit to be on separate
 lines and indented one tab stop; enter the following command (all on
 one line):


 splat parms(s);usage();exit(1); parms(s);\n\tusage();
 \n\texit(1);\n\ttext.c294 Chapter 10




 tb Displays traceback information


 Synopsis tb [>destination] [options] [tbfile [program]]

Description 
 The tb utility processes the traceback file that is created when you
 link your program with catch.o and your program terminates
 abnormally.
To get traceback information for your program, you must link your
 program with catch.o. If your program terminates abnormally,
 catch.o creates a standard IFF format file named Snapshot . TB in
 your current directory. This file contains up to six sections:

 [] symbol cross reference
 [] stack
 [] registers
 [] environment
 [] memory
 [] user data.

 Each section contains information about your program at the time it
 terminated. (Two sections, memory and user data, may not be available
 for your program.)
tb displays the traceback information on the screen unless you
 redirect it by specifying a greater than (>) sign followed by a
 destination.
If you do not specify any options, tb displays only the current stack
 frame, which indicates the location where the program terminated. By
 specifying options, you can print 211 of the sections in the traceback
 file.
By default, tb looks for the traceback file Snapshot . TB in your
 current directory. If you want tb to use a different traceback file,
 specify the traceback file as the tbfile parameter.
The program parameter specifies the program from which you want
 tb to read debugging information. If you do not specify program, this
 utility uses the program specified in the traceback file.
Note: Specifying a program is useful when you have two
 executables of your program: one created with debugging information
 and another without debugging information. The version without
 debugging information loads faster, but you still have access to the
 traceback information if your program crashes.295 Utility Reference




 tb Displays traceback information
(continued)

tb supports the following options:

 -l displays all sections present in the traceback file

 -x displays the location of all symbols encountered in the program

 -s displays the contents of the entire stack at the time your program
 terminated

 -r displays the current contents of registers at the time your
 program terminated

 -v displays the callback chain and the location where the program
 terminated

 -m displays the amount of memory available at the time your
 program terminated (if present in Snapshot.TB)

 -u displays any user data generated by your program (if present in
 Snapshot.TB).

Examples 
 Suppose you have a program named testit that you link with
 catch.o, and testit terminates abnormally when you run it. You
 can display information about where the program terminates by
 entering the tb command without any options, as follows:


1> tb
Program Name: testit; run from CLl
Program load map (addresses are APTRs, sizes are in bytes)
220f78 $1110 211268 $5b4
Terminated with GURU number 00000005, Divide by Zero Error
Error occurred at address 221cde = _foo line 5
 called from 22156a = main line 11
 called from 221c60 = _main + 704
 called from 2210ca = hunk 0 + $152


However, the file created by catch.o contains much more
 information. To display all of the information contained in
 Snapshot.TB, you can specify the -l option, as follows:

1> tb -1
TraceDump 0.88 Copyright (c) 1988 The Software Distillery296 Chapter 10




 tb Displays traceback information
(continued)


 TraceDump Utility: catch.o; Version 1, Revision O
 Processor type: 68000
 VBlankFreq 60, PowerSupFreq 60


 Symbols for hunk O
_foo = 22153c_main = 22155c


 Program Name: testit; run from CLI
 Program load map (addresses are APTRs, sizes are in bytes)
 220f 78 S 1110 21 1268 $5b4
 Terminated with GURU number 00000005, Divide by Zero Error
 Error occurred at address 221cde = _foo line 5
called from 22156a = main line 11
called from 221c60 = _main + 704
called from 2210ca = hunk 0 + S152


 Registers:
 DO=00221cde D1=00000000 D2=00000001 D3=00002718
 D4=00000001 D5=0000002b D6=0000003b D7=00000000
 A0=00221f54 A1=00243fcc A2=0024460a A3=00225c68
 A4=00211268 A5=002445be A6=002033c8 A7=002445ae
 PC 221cdeC=0 V=0 Z=1 N=0 X=0


 stack top: 244640, stack pointer: 2445ae, stack length: $94
 entire stack, size = $94 bytes
 2445AE: 000003ED 00221558 0000002B 00000000: ...m.".X...+....
 2445BE: 002445CA 0022156A 00225C68 002445F6: .$EJ.".j."h.$E.
 2445CE: 00221C60 00000001 00211620 00225CC4: .".'.....!. ."D
 2445DE: 00226030 00225C68 83D10000 00000021: ."'0."h.Q.....!
 2445EE: 13230021 00211620 00244640 002210CA: .#.!.!..$F@.".J
 2445FE: 00244602 74657374 6974000A 00000022: .$F.testit...."
 24460E: 60300000 27100000 27180000 00010000: '0'..'...'..... 
 24461E: 002B0000 003B0022 60300022 61300020: .+...;."'0."a0.
 24462E: 35300022 0F740024 464400FF 425800FF: 50.".t.$FD..BX..
 24463E: 424C0022: BL."297




Part3
Using the SAS/C
Macro Assembler






Chapter 11 Using Assembly Language with C Language288299





 11 Using Assembly Language
 with C Language


299 Introduction
300 Writing Assembly Language Functions
 300 Writing Assembler Statements
 304 Using Assembler Directives
 308 Defining and Using Macros
 309 Defining Control Sections
314 Communicating between Assembly Language and C Language
 314 Calling Assembler Functions from C Functions
 322 Calling C Functions from Assembler Functions
 322 Referencing Global Data
323 Running the Assembler



Introduction

The SAS/C Macro Assembler reads an assembly language source file
and produces an object file in the Amiga object file format. You can
use the assembler to generate assembly language modules for your C
programs, or you can generate programs written entirely in assembly
language. For example, some operations such as directly accessing CPU
and I/O registers cannot be handled easily in the C language. Also,
assembly language is sometimes necessary to get the best combination
of code size and speed.
 The assembler supports the full set of 68xxx mnemonics, an
extensive set of assembler directives, and a powerful macro facility. To
use the assembler, you should understand thoroughly the Motorola
68xxx instruction set. The "Additional Documentation" section in
"Using This Book" lists books that describe the Motorola 68xxx
instruction set. If you are writing assembly language modules to be
called from C functions, or if your assembly language modules call C
functions, you should also understand the SAS/C function protocol.
This chapter assumes that you have a knowledge of assembler, but not
necessarily the SAS/C Macro Assembler.
 This chapter describes the directives supported by the assembler,
discusses how to write and use macros, and describes how to call C
functions and assembler modules.300 Chapter 11



 Writing Assembly Language Functions

 The following sections provide an overview of the syntax expected by
 the SAS/C Assembler. The topics covered include

 [] the format of assembler statements
 [] the directives supported by the Assembler
 [] how to create and use macros
 [] how to define control sections
 [] how to specify addresses in assembler statements
 [] how to specify floating-point data
 [] the offsets supported by branch instructions.


Writing Assembler Statements
 Each assembly language source line has the following format:
 
[label:] operation[.size] operand . . . [;comment]

You can enter white space (spaces or tabs) before any field. You
 must enter white space between the operation and operand. The fields
 of the source line are described below:

 label
 can start in any column and end with a colon, or can start in
 column one and end with either a colon or white space. A label can
 be up to 31 characters long and can contain letters, digits,
 underscores (_), and dollar ($) signs. A label cannot start with a
 digit, and the case of letters is significant. For example, the
 assembler differentiates between xYz, xYZ, and xyz.

 operation
 is the name of an instruction, a directive, or a macro. Do not begin
 an operation in column one. If no label is present, precede the
 operation with white space. If a label is present, you must include a
 colon or white space between the label and operation. The case of
 this field is not significant. For example, MOVE is the same as
 move.

 size
 specifies either the size of the operands or the offset, depending on
 the type of instruction. See the following section, "Specifying Sizes,"
 for additional information.

 operand
 may contain 0 or more expressions, depending on the specific
 operation. Expressions are composed of constants, variables, and
 operators. The information in the following section, "Specifying
 Expressions," describes constants and operators in more detail.301 Using Assembly Language with C Language




comment
can be entered in your assembler source code by preceding the
comment text with a semicolon.


Specifying Sizes
Support for size suffixes depends on the instruction that you enter and
the processor that you use. Check the documentation for your
processor to determine which size suffixes are valid. For most non-
floating-point instructions, the following suffixes are valid:


 Suffix Meaning

 nonedefaults to word (two bytes)
 Bbyte
 Llong
 Sshort (same as byte)
 Wword


For floating-point instructions, the following suffixes are valid:



 Suffix Meaning

 nonedefaults to word
 Bbyte
 Ddouble
 Llong
 Ppacked
 Ssingle
 Wword
 xextended
302 Chapter 11




 For branch instructions BSR and BRA, the sizes supported by the
 assembler are as follows:



 Suffix Meaning

 nonecalculates the size offset needed. For externs, the assembler
 generates a 16-bit offset.

 sgenerates 8-bit offsets.

 Bgenerates 8-bit offsets.

 wgenerates 16-bit offsets.

 Lgenerates 32-bit offsets.BSR.L is supported only on the 68020
 and higher processors, and you cannot use BSR.L to branch to
 externs.


 For example, the following instruction creates a 32-bit branch:

BRA.L subpr

Data are converted into single, double, or extended precision
 according to the type of instruction. For example, the following
 instruction converts 2.1 into single precision and stores it in floating-
 point register 1:

fmove.s #2.1,fpl

As an additional example, the fmove instructions for the decimal
 number 2.1 specifying the bit pattern in hexadecimal are as follows:

fmove.s #$40066666,fpl
fmove.d #$4000CCCCCCCCCCCD,fPl
fmove.x #$400000008666666666666666,fpl

 Specifying Expressions
 As described earlier, an expression is composed of constants, variables,
 and operators.
A variable is a label name or a name defined using an assembler
 directive.303 Using Assembly Language with C Language



 A constant is a decimal, hexadecimal, octal, or binary mlmber, or an
ASCII literal. Unless you specify otherwise, the assembler expects a
decimal number. To specify an ASCII literal, enclose the literal in
single quotes. To specify a hexadecimal number, precede the number
with a dollar sign. To specify an octal number, begin the number with
an at (@) sign. To specify a binary number, begin the number with a
percent (%) sign. The following table shows how to enter different
types of constants:


 Type or Base Prefix Example

 decimalnone1234
 ASCII literal 'literal''AC9T'
 hexadecimal$$89AB
 octal @@743
 binary%%1011
 floating pointnone2.1
 scientific notationnone2.1E+10
 hexadecimal floating point$$4066666

 Note: If you use hexadecimal notation to specify floating-point
numbers, you must use either the IEEE or FFP bit pattern
representation. For information about this representation, refer to a
manual for the 6888x math coprocessor.
 The following table lists the operators recogni~ed by the assembler in
the order in which they are processed.


 OrderOperatorMeaning

 1-unary minus
 2>> right shift
 << left shift

(continued)304 Chapter 11




 OrderOperatorMeaning

 3*multiply
 /divide
 %modulus
 4+add
 -subtract
 5<less than
 <= less than or equal to
 >greater than
 >= greater than or equal to
 == equal to
 != not equal to
 6&bitwise AND
 !bitwise OR


 For example, in the following expression, PDQ is first negated and
then multiplied by DEF, and the result is added to ABC:

ABC+DEF*-PDQ

 Each expression represents a 32-bit value. An absolute expression is
one that contains only constants. A relocatable expression contains
symbols whose values are determined during the linking and loading
procedure.


Using Assembler Directives
 With the exception of the DC, DCB, and DS directives, an assembler
directive is an instruction to the assembler instead of an instruction to
be translated into object code. Directives cannot begin in the first
character of the input line.
 The assembler supports the following directives:

[label] CNOP offset,alignment
aligns any data structure or entry point to any boundary. alignment
is the alignment required for the base, such as 4 for long word, and
offset is the offset from that alignment.305 Using Assembly Language with C Language

End Of Part 3

