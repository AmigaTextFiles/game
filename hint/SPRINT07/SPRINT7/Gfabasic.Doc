                             GFA BASIC MANUAL

                       GFA BASIC by GFA Systemtechnik 
                   
 
  Which HIGH LEVEL language for the AMIGA is as easy to program as BASIC yet
offers full access to system features and an execution speed that rivals 
assembly language? The answer?   GFA BASIC.
 
 GFA BASIC offers everything found in  conventional  BASICs, plus much more.
The GFA BASIC resembles Modula-2 or Pascal code with ability to accept 
parameters from the main program as well as using local variables.

  Perhaps  the most impressive functions of GFA BASIC  are  the  EXEC and C:
commands.  EXEC lets you load and execute a non-BASIC AMIGA application from
within a BASIC program.   While the C: command calls a routine written and 
compiled in C. 
 
                             FOREWORD 

  It is a fact: BASIC is the most widespread computer language. 

  In spite of this, BASIC does not have a very good reputation.   

 This becomes clear when, for example, PASCAL is given preference over BASIC
as the programming language in computer studies classes in higher education
centers (in some cases BASIC is completely rejected).
 
 The main reason for this is that PASCAL enables the user to program in a 
structured manner.  BASIC has, of course, been constantly updated from the
time it first appeared. Consider the development of the command IF...THEN:
 
  In the very beginning,  only a line number could follow THEN, which 
resulted  in the need to jump from one point to another. Then it was made
possible to enter a string of commands after THEN and today nearly all BASIC
versions include the use of ELSE. 
 
 The concept behind the development of GFA-BASIC was not to make further 
minor improvements.  It was far more, to develop a totally new form of BASIC
which, however, had to meet the following conditions: 
   
   *Structured  programming  should be possible in its entirety. 
   *Everyone who has programmed in BASIC should be able  to  
      use the new Interpreter in the shortest time possible. 
   *The advantages of BASIC should definitely be present in  
      the newly developed BASIC. 
 

           DIFFERENCES FROM TRADITIONAL BASIC LANGUAGES 

     There are three essential differences: 

     *There are no line numbers in GFA-BASIC. 
     *Only one command is allowed per line. 
     *There are a few new structure commands and the structure  of  
     some traditional commands have been modified in GFA-BASIC. 
 
  The first difference you will notice when listing a program written in 
GFA-BASIC is that there are no line numbers.  The BASIC user is so used to
seeing those line numbers that the question of why they are there does not
arise: 
      *Through the use of line numbers in the commands GOTO,  GOSUB  
        or  IF..THEN, it is possible to move every section of the program. 
      *If the line numbering sequence is 10, as it generally is, it  
        is possible to insert further program lines between two commands.  
      *Searching,  listing,  altering  and deleting sections  of  a  
        program is made possible. 
    
 The last two points are far more easily achieved by the use of a suitable
Editor, like the one used in GFA-BASIC.   The first point can be achieved by
use of labels. These methods do away with the need for line  numbers  and,  
equally important, save storage space. 

 As already  mentioned in the  Forward, GFA-BASIC makes it possible to carry
out structured programming. In order to do this, several additional structure
commands were added to  those normally found in BASIC, for example: 

               DO...LOOP 
               WHILE...WEND 
               REPEAT...UNTIL 
               PROCEDURE (with local variables) 
      
  In order to keep the structure of the program simple,  it was considered
necessary to limit the number of commands per line to one. The following 
example shows the structure of the program, and also shows clearly how the
command IF...THEN has been modified: 

          INPUT A 
          IF A>O THEN 
           PRINT "positive" 
          : 
          ELSE 
           IF A=O THEN 
            PRINT "nil" 
          : 
          ELSE 
            PRINT "negative" 
            : 
           ENDIF 
          : 
         ENDIF 

 The colons indicate the sections in which any amount of additional
commands can be inserted without altering the structure of the program. 


                             REMARKS 

 Before you can begin to program in GFA-BASIC, you should make a back-up
copy of the program disk. As well as the GFA-BASIC Interpreter,  there is 
also a  file  called "GFABASPRO.PRG" on the program disk.  This is the RUN
ONLY  version of GFA-BASIC. 

 It is not possible to write programs with this version since it is only
used to load and start up programs already stored in GFA-BASIC.  You may 
pass on this program to other people, thus enabling other AMIGA users who 
do not yet use GFA-BASIC to use the programs you write in GFA-BASIC. 
      
              INTRODUCTION TO PROGRAMMING IN GFA BASIC      

  When  you  load GFA-BASIC from the diskette you go straight into the
Editor This means that you can start  entering  your program  right  away. 
However, you must be patient!  It is necessary to know a little about the
structure  of GFA-BASIC first: 

 You will be using 2 "screens" which are independent of one another.  One
is the Editor screen which has a command line at the top of the screen. 
The  other is a display screen which shows the output results of the
program  commands which have  been  entered, when you RUN the program. 

 When you are in the Editor, you can go to the display screen in three 
different ways: 

 *Run the program by pressing the <SHIFT> AND <F10> keys or by  
  clicking RUN in the command line.  (Return to the Editor after the  
  program has ended by <RETURN>,  or by clicking the "RETURN" in the  
  "Program End" Alert Box). 

 *Press the function key <F9> or click on "FLIP".   (Return by  
  pressing any key or by clicking the left mouse key.) 

 *Press the key <ESC> or <SHIFT> and <F9> or click on "DIRECT"  
  with the mouse. This takes you into direct mode where commands are  
  carried out immediately and the program is by-passed. 
      
 In  order  to  be able to show the results  on  the  monitor,  
direct mode is displayed on the display screen. (Leave direct mode  
by <ESC> and then <RETURN> or by the command EDIT (abbreviated ED)  
or by the STOP function (<SHIFT>+<ALTERNTE>+<CONTROL>). 

     This can be demonstrated by the following example: 

          BOX 140,0,500,175 
          PCIRCLE 320,50,100 

  Run  the program as described above.   In order to return  to  
the Editor you can press <RETURN>,  as mentioned above, or you can  
click on "RETURN" with the mouse. 

 Now you can switch from one screen to the other by  pressing  <F9> 
 Switch  from the Editor to direct mode by means of  <ESC>  or  
 <SHIFT> and <F9> and enter the following line: 
 
    PRINT AT(36,12); "GFA-BASIC" 

 You can see the result immediately by pressing RETURN at the end of the
line.  After  leaving direct mode by <ESC> and then <RETURN>  or  by the
command  EDIT,  you should be thoroughly familiar with the  two screens 
and be ready to go on to discover the full  potential  of the Editor. 
 

                            VARIABLES
 
  GFA-BASIC  allows  many options when it comes  to  variables. First of
all, you have the option of which number base you want to use.  Variables 
written with  no  prefix  are  normal  decimal  variables.   Variables with
the "&"  or "&H" prefix are written in Hexadecimal.  Variables written with
the prefix "&O" are in Octal (base eight).  Finally,  prefixs written with
the prefix  "&X" are  in binary.
 
                    "&" or "&H" = Hexadecimal 
                    "&O" = Octal (base eight) 
                    "&X" = binary

 GFA  has  a series of powerful statements which  can  convert between the 
various number bases.   For details,  see Appendix  A   Information  on how
GFA stores variables can be found in  Appendix  D.
 
 Besides  the  different  number  bases  (hexadecimal,  octal,  decimal, 
and binary),  GFA can handle several different TYPES  OF  VARIABLES.  
Variables written with no suffix are  "normal"  real  variables,  accurate
to 13  decimal places.  Variables written with  a suffix of "%" are integer
variables. They can be of any integer value between 2147483647 and
-2147483648.   The  advantage to using integer  variables  when you do not
need floating (real)  is  that  operations with integers execute much
faster.   Variables with the suffix  "!" are  BOOLEAN,  that is,  they only
take on  the  value  "true"  (-1) or "false" (0).   Finally,  the suffix
"$" indicates a  string variable or string constant. 

 GFA-BASIC  supports arrays and string arrays. Multidimensional arrays
provide for considerable flexibility.  For details on the restrictions for
the array fields,  see  the  DIM  command. 
 
                 HIERARCHICAL FILE STRUCTURE
      
  When you double-click on a disk drive to open a window  which  shows the
files and directorie located on a disk,  this  is  called  "getting a 
directory" of the disk.  If you then click on a folder,  whatever  files or
 other directories are contained in the disk will then be visible in the 
window.  In GFA-BASIC, the convenient icons  (pictures)  which represent
the disk,  directories and files  are  not  visible  as  they  are from 
the workbench.   There  are,  however,  commands  which  will do many of
the same things from  within  the  GFA-BASIC  that  you can do from the
workbench or cli.   You  will  need  a  different  method of specifying
drives, directories and files  than  pointing and clicking. 

 To  specify that you want to work with a file in the  current  directory,
(there are commands to change dirs as well),  you  would  simple use the 
name of the file with a command, such as: 

     PRINT  EXIST("PAPPY.dat") which checks to see if the  file 
"PAPPY.dat" exists in the current dir.  To specify a different dir you 
will   need  to use  the  "\"  character.    Thus,   to   specify 
"PAPPY.dat"  in  the dir  "DIR1",  you  would type:

               DIR1\PAPPY.dat
 
 Recall that there can be dirs  within dirs (called  nesting).  Use a "\"
between  each  dir name:  DIR2\DIR1\PAPPY.dat  looks  for file  "PAPPY.dat"
 in  dir "DIR1" which is in "DIR2".  To make sure a search for a file  or 
dir begins in the "root" directory (the list of  files  and dirs  you would
see when you first click on a disk drive  icon), preface the whole string
of dirs filename with a "\":  \DIR2\DIR1\PAPPY.dat 

 Finally,  if  you wish to change which disk you want to  look  at, use the
 disk drive letter with a colon:      DH0:\DIR2\DIR1\PAPPY.dat  looks for
"PAPPY.dat" in DIR 1 which is in DIR 2 which is  in the root  directory of
drive DH0.
 
 Because of the hierarchy of files,  dirs and  drive specifications, the 
method detailed above for choosing files  is  called  the "hierarchical
file system".   Reference  to  this  system is made many times in the
course of  this manual. 
 
                            THE EDITOR 
INTRODUCTION: 

     The editor,  which was created in order to produce  programs,  
outputs  to  the  monitor  screen.    The  Editor  supports  block  
operations and searching and replacement of program sections. 

     At  the top of the screen there are two command  lines  which   are
activated by the function keys and the mouse.  The rest of the   screen is
reserved exclusively for programming.  The layout of the   command lines
corresponds to the function keys.   The commands  on   the  top line are
activated by pressing the shift & function  keys   simultaneously.   The
commands on the bottom line are activated by   the function keys alone. 

     Two   different  text  sizes  can  be  chosen   by   pressing  
<SHIFT>+<F8>  or by clicking TEXT 8 or TEXT 16 with the  mouse  in   the
command line (only for monochrome monitors).   It is  possible   to display
23 program lines in normal type (TEXT 16) and 48  lines   in  reduced  type
(TEXT 8) on the screen.   In  the  latter  mode,   programs can be listed
and edited very clearly. 

     Only one BASIC command can be accepted per program line.  One  
program line can contain a maximum of 255 characters or use at the   most 
255  bytes.   For example,  ****** need 6 bytes  of  storage   capacity
(and up to 8 bytes in a program).   It is quite  possible   to  receive the
message "LINE TOO LONG" even if far less than  255   characters have been
entered. 

     Since  only 80 characters can be displayed on the  screen  at   one 
time,  the text at the left margin of the program line  being   entered
disappears when more then 80 characters are entered.   The   rest of the
program is not altered. 

     After  terminating input by pressing,  for example  <RETURN>,   the 
first  79 characters will be displayed followed  by  a  right   arrow, 
which  indicates that the line is more then 80  characters   long and that,
therefore, the complete line cannot be displayed at   once. 

     The program lines are entered via the keyboard,  and  special  
characters  can  be displayed which are not represented by  a  key   (see
Appendix C), by use of the <ALTERNATE> and <CONTROL> keys. 

     A  line can be terminated by <RETURN> or by using any  cursor  
movement  by which a line can be exited (see  below).   When  this  
happens, the syntax of the line is checked and, if applicable, the  
message "Syntax Error" is displayed to indicate a syntax error  is   the 
line.   The  program  structure  is  made  more  distinct  by   indentation
 and  any abbreviated commands (see  Appendix  A)  are   written out in
full. 

     The  various  Editor  commands can be divided  up  into  five  
categories: 
          Cursor Movement Commands 
          Programming Commands 
          Find and Replace Commands 
          Block Commands 
          Other Commands in the Command Line 
 
THE VARIOUS COMMANDS ARE AS FOLLOWS: 
                     CURSOR MOVEMENT COMMANDS 

<ARROW LEFT> 
          Moves the cursor within a line one character to the left  
          at a time. 

<ARROW RIGHT> 
          Moves  the  cursor within a line one  character  to  the  
          right at a time. 

<CONTROL>+<ARROW RIGHT> 
          Moves the cursor to the end of the line. 

<CONTROL>+<ARROW LEFT> 
          Moves the cursor to the beginning of the line. 

<TAB> 
          Moves  the cursor one Tab position to  the  right.   The  
          individual positions are every 8 spaces, and are denoted  
          by  a vertical stroke in the command line up to  a  line  
          length of 80 characters. 

<CONTROL>+<TAB> 
          Moves the cursor one Tab position to the left. 

<DOWN ARROW>or <RETURN> 
          Places the cursor at the beginning of the next line. 

<UP ARROW> 
          Places the cursor at the beginning of the previous line. 

<CONTROL>+<DOWN PAGE>or<F7> 
          Scrolls  down  one  page and places the  cursor  at  the  
          beginning  of  this page.   (This command  can  also  be  
          carried out by clicking "PGDOWN" in the dommand line). 

<CONTROL>+<UP ARROW>or<SHIFT>+<F7> 
          Scrolls  up  one  page  and places  the  cursor  at  the  
          beginning  of  this  page.  (This command  can  also  be  
          carried out by clicking "PG UP" in the command line). 

<HOME> 
          Moves the cursor to the beginning of the present program  
          page.  This  automatically brings the structure  of  the  
          listings (indentations) up to date. 

<CONTROL>+<HOME> 
          Places the cursor at the beginning of the program. 

<CONTROL>+<Z> 
          Moves the cursor to the end of the program. 
 
     It  is  also  possible to position the cursor  by  using  the  
     mouse.   Move  the mouse to the desired position  and  click.   
     The cursor is thus moved to the position chosen by the mouse.   
     If  the program line being worked on at the time is  left,  a  
     syntax check is carried out. 

<F8> 
          With this function key (or by clicking INSERT or OVERWRT  
          with  the  mouse) it is possible to choose  between  two  
          modification modes - the Insert or the Overwrite  modes.   
          In  Insert  mode you are able to make  insertions  in  a  
          finished text.  The text to the right of the cursor will  
          be  moved to the right as you type.   In  the  Overwrite  
          mode the character which the cursor is on at the time is  
          replaced by the new character. 

<BACKSPACE> 
          Deletes  the character to the left of the  cursor.   The  
          cursor,   the  character  under  the  cursor,   and  all  
          characters   to   the   right   of   the   cursor   move  
          simultaneously one place to the left. 

<DELETE>   
          Deletes the character under the cursor.  Aall characters  
          to the right of the cursor move one place to the left. 

<INSERT> 
          Moves  the  line  with  the cursor  and  all  the  lines  
          underneath  it one line down (the cursor must be at  the  
          beginning  of the line for the line to be  moved).   The  
          cursor itself remains where it is, i.e. at the beginning  
          of  the new line,  so that the new program line  can  be  
          entered   immediately.    After  terminating  input   by  
          <RETURN>,   this  procedure  is  repeated  until  it  is  
          interrupted by pressing <RETURN> on a new line or  until  
          the  line  is  exited by the use of  some  other  cursor  
          command. 

<HELP> 
          "undoes" all changes made in a line and returns the text  
          to its original state, i.e. before it was changed.  This  
          command  can only be carried out when the syntax of  the  
          line  has  not  already been  checked  (before  pressing  
          <RETURN> or exiting the line by use of some other cursor  
          command). 
          Apart from this,  and like when using <HOME>, the screen  
          is   rewritten  and  the  structure  of   the   Listings  
          (indentation) is updated. 

<CONTROL>+<DELETE> 
          The  line on which the cursor is positioned  is  deleted  
          irretrievably from the progrm and all the lines below it  
          move  one line up.   The cursor remains in the line  and  
          appears  at the beginning of the line following the  one  
          which  was deleted after the command has been  executed.   
          This line cannot be retrieved by <HELP>! 
 
                  FIND AND SEARCH COMMANDS      

<F6>(=FIND from the Command Line) 
          The  first line of the Command Line disappears  and  the  
          word "FIND" appears.   

     You  can  enter a search string with a maximum length  of  60  
     characters.   The input of the search string can be  corected  
     by  <DELETE> and <BACKSPACE>.   Any place within  the  search  
     string already entered can be reached by the use of the  left  
     and right arrow keys.   When entering text, the cursor can be  
     moved either to the beginning or the end of the entered  text  
     by  using  the up and down arrow  keys.   After  <RETURN>  is  
     pressed,  the  cursor moves to the beginning of a line  which  
     has  a  search string in it,  or it moves to the end  of  the  
     program if the search string is not found. 
 
     The search procedure within a program is always begun in  the  
     line  beneath the cursor position.   Therefore it is  a  good  
     idea  to move the cursor to the beginning of the  program  by  
     <CONTROL>  +  <HOME>  before  activating  the  FIND  command.   
     Further occurrences of the search string within the text  can  
     be found by using <CONTROL> + <F> (see below).  If "FIND"  is  
     accidently  chosen,  it  can be canceled  by  pressing  <ESC>  
     followed by <RETURN>. 
 

<SHIFT> + <F6> (=REPLACE from the Comand Line) 
     The  first line of the Command Line is deleted and  the  word  
     "FIND:"  appears.   The  search  string  can  be  entered  as  
     described  above  in "FIND".   Then the second  line  of  the  
     Command  Line  is deleted and "REPLACE:"  appears.   As  with  
     "FIND", the same editing features for entering a string of up  
     to  60  characters  are  available.   The  search  string  is  
     replaced after entering <CONTROL>+<R>(see below).   All other  
     features of this command are the same as for "FIND". 
 
     It  is important to remember that both "FIND"  and  "REPLACE"  
     are case sensitive,  i.e.  the itembeing searched for in  the  
     program will only be found if it exactly matches your  entry,  
     including capital and small letters. 

<CONTROL>+<F> 
     Looks  for the search string entered in "FIND" or  "REPLACE".   
     Once  a  string  has  been  entered,   it  can  be  caled  up  
     continuously until a new search string is entered.  Searching  
     begins in the line below the cursor,  i.e. the line which the  
     cursor is in will not be earched.   After searching has  been  
     completed,  the cursor moves to the beginning of the line  in  
     which the search string is located or,  if the string is  not  
     found, to the end of the program. 

<CONTROL>+<R> 
     Looks  for a search string entered in "REPLACE"  or  replaces  
     the search stringby the replace string.   If this command  is  
     given in a line where the search string is located,  it  will  
     be  replaced  (the  replacing of  text  can,  of  course,  be  
     reversed  by <HELP>.   If this command is entered in  a  line  
     where the search string is not located,  the command  assumes  
     the same function as <CONTROL>+<F>,  i.e. the next occurrence  
     of the search string is located.   Pressing <CONTROL> and <R>  
     again will then replace the search string. 
 
     If  the search string which has been located in a given  line  
     is  not to be changed,  the next occurrence can be sought  by  
     simply using <CONTROL>+<F>. 
 
<SHIFT>+<5>(=BLK STA from the Command Line) 
     Marks  the  beginning of a block.   A block is a  part  of  a  
     program  and  is made up  of  complete,  consecutive  program  
     lines.  When the command BLK STA (Block Start) is given,  the  
     beginning of the line in which the cursor is situated at  the  
     time is marked as the beginning of the block. 

<F5> (=BLK END from the Command Line) 
     Marks the end of a block.   The end of the block is marked at  
     the  beginning of the line in which the cursor  is  situated,  
     i.e.  the line in which the cursor is located does not belong  
     to  the block.  The Block Start must be higher on the  screen  
     then the Block End, i.e. you cannot see the Block Start, move  
     up the screen with the cursor,  and set the Block  End.   The  
     block is only defined when both beginning and end are marked.   
     It  is  then highlighted.   The block markers  and  also  the  
     highlighting can be deleted by placing the beginning and  end  
     of a block in one line, or by using "HIDE". 

<F4> (=BLOCK in the Command Line) 
     Selection  of  the block operations.   If one or  both  block  
     markings are missing,  the error message BLOCK  ???  appears.   
     You  may  remove  the error messge by using the  up  or  down  
     arrows, or by clicking the mouse.  Otherwise a Selection Menu  
     apears  instead of the Command Line.   The functions in  this  
     menu will be explained in more detail at a later  stage.   To  
     activate a Block Selection command, press the appropriate key  
     or click on the command with the mouse.  If the Block command  
     is  selected  by mistake,  it can be reversed by  the  mouse- 
     click. 

<C> (=COPY) 
     The defined block is copied to the area immediately above the  
     line  on which the cursor was located previous to  the  block  
     command. However, this is only possible if the cursor was not  
     located  inside  the block.   If it  is,  the  error  message  
     "CURSOR IN BLOCK" appears (continue by clicking the mouse). 

<M> (=MOVE) 
     Move  the  block to the area immediately above  the  line  in  
     which  the cursor was located before the Block  command.   As  
     with the command "COPY",  this is only possible if the cursor  
     is  not  located inside the block (continue by  clicking  the  
     mouse if you get an error).   This is equivalent to a  "COPY"  
     function followed by a "DELETE". 

<W> (=WRITE) 
     Writes the block as a text file (.LST) onto the diskette. 

<L> (=LLIST) 
     Prints the block on the printer 

<S> <=START) 
     Moves the cursor to the beginning of the block. 

<E> (=END) 
     Moves the cusor to the en dof the block. 

<CONTROL>+<D> or <^D> (=DEL> 
     Deletes the block irretrievably.   This cannot be reversed by  
     "HELP". 

<H> (=HIDE) 
     Deletes the block markers. 
 
               OTHER COMMANDS FROM THE COMMAND LINE 

All  commands  in the Command Line can be selected by  either  the  
corresponding function key or by clicking the mouse. 
 
<F1> (=LOAD) 
     Loads a program from the diskette. The search path * .BAS. is  
     preset.   Any  program which is in the Editor at  this  time,  
     will be overwritten. 

<SHIFT>+<F1> (=SAVE) 
     Saves  the most recent program on diskette.   If there is  no  
     extension, the suffix .BAS is automatically selected. 

<F2> (=MERGE) 
     Loads  a  text file from diskette (the search path  *.LST  is  
     preset)  and  adds the corresponding program lines  into  the  
     existing  program  immeditely  above the line  in  which  the  
     cursor is located.  Should a syntax error occur the following  
     symbol appears:==>, at the line with the error. 

<SHIFT>+<F2> (=SAVE.A> 
     Saves the most recent program as a text file.  If there is no  
     extension, the sutffix .LST is automatically selected. 

<F3> (=LLIST) 
     Prints  the  program  on the  printer.   A  printout  can  be  
     interrupted by switching off the printer.  After  approx.  30  
     seconds the Editor reappears. 

<SHIFT> + <F3> (=QUIT) 
     Enables  you to leave the Interpreter and return to  the  GEM  
     desktop.  GFA will ask for confirmation. 

<SHIFT>+<F4> (=NEW) 
     Deletes  the program currently in the memory.   GFA will  ask  
     for confirmation. 

<F9> (=FLIP) 
     Switches to the display screen. (see Forward). 

<SHIFT>=<F9> (=DIRECT) 
     Switches to direct mode. (see Forward). 

<F10> (=TEST) 
     Checks whether all the loops within the program are correctly  
     entered. 

<SHIFT>+<F10> (=RUN) 
     Runs the program. 
 
 
                    EDIT COMMANDS AT A GLANCE 

(^=CONTROL) 
 
LEFT ARROW          Cursor moves left one character 

RIGHT ARROW         Cursor moves right one character 

^LEFT ARROW         Cursor moves to beginning of line 

^RIGHT ARROW        Cursor moves to end of line 

TAB                 Cursor moves right one Tab position 

^TAB                Cursor moves left one Tab position 

DOWN ARROW          Cursor moves down one line 

RETURN              Cursor moves down one line 

UP ARROW            Cursor moves up one line 

^DOWN ARROW         Cursor moves to next progrm page 

PG DOWN             Cursor moves to next program page 

^UP ARROW           Cursor moves one program page back 

PG UP               Cursor moves one program page back 

HOME                Cursor moves to begining of pge 

^HOME               Cursor moves to begining of program 

^Z                  Moves cursor to end of program 

F8                  Insert/Overwrite 

BACKSPACE           Cursor deletes back one space 

DELETE              Character under cursor is deleted 

INSERT              Insert line 

HELP                Reverses Last Command 

^DELETE             Deletes line 

F6FIND,<SHIFT>F6    Enter Search String and locate 

REPLACE             Enter Search Replace String 

^F                  Locate Search String 

)^R                  Replace Search String 

<SEARCH>F5,BLK STA  Marks beginning of block 

F5 BLK END          Marks end of block 

F4 BLOCK            Select block function by using: 

   C (COPY)         Copy block 

   M (MOVE)         Move block 

   W (WRITE)        Save block 

   L (LLIST)        Print block 

   S (START)        Move cursor to block begining 

   E (END)          Move curso to block end 

   H (HIDE)         Delete Block Markes 

   ^D(DEL)          Delete block 

F1 LOAD             Load program 

<SHIFT>F1 SAVE      Sve program 

F2 MERGE            Merge program 

<SHIFT>F2 

   SAVE,A           Save program as a text file 

F3 LLIST            Print program 

<SHIFT>F3 QIT       Leave the Editor 

<SHIFT>F4 NEW       Delete program 

F9 FLIP             Change to display screen 

<SHIFT>F9 

  DIRECT            Switch to Direct Mode 

F10TEST             Check loop contruction 

<SHIFT>F10RUN       Run program 

                            FUNCTIONS 

It  is possible to differentiate between two types  of  functions:  
numerican and character string functions,  depending upon  whether   the 
result  of the operation is a number or a  string  (character   string). 
     
    There are two types of CHARACTER STRING OPERATORS: 

          *The  linking of charcter strings by the  function  "+":  

    Seperate strings are joined together by "+".  If, for example,  
    A$="GFA",  B$="-"  and C$="BASIC" then A$+B$+C$ gives you  the  
    character string "GFA-BASIC". 

                *The       character       string       functions:  

    LEFT$,RIGHT$,MID$,SPACE$,STRING$  and STR$.   These  functions  
    are described in more detail in Appendix A. 

The NUMERICAL OPERATORS can be divided u into 4 categories: 

          *Arithmetic functions 
          *Comparison functions 
          *Logical functions 
          *Numerical functions 

These NUMERICAL OPERATORS are described in more detail in Appendix A. 
 
                      ARITHMETIC FUNCTIONS                  

GFA BASIC recognizes the following arithmetic operations  (methods   of
calculation). 

    ^ Exponentation 
      For example: 2^3=2*2*2=8 
     
    - The minus sign 
    * Multiplication 
    / Division 
 
DIV  or  / Integer division of numbers divides  and  converts  the  
results to a whole number.  This is donw as follows: A DIV B=TRUNC  
(A/B).   Therefore,  for example,  3.7 DIV 0.7 equals 5, -17 DIV-4  
equals 4. 
 
MOD  Using modulation,  the remainder left after a division  which  
results in a whole number.   For example:  3.7 MOD 0.7 =0.2 or -17  
MOD-4=-1. 
 
+ Addition 
- Subtraction 


                       COMPARISON FUNCTIONS 

Comparison   functions  can  be  placed  between   two   numerical  
expressions or between two character strings. 
Depending  on the result of the comparison (true  or  false),  the  
statement is given the value -1 for true or 0 for false. 
 
The following comparison functions are possible: 

    =         Equal to 

    >         Larger than 

    <         Smaller than 

    <>        Not equal to 

    >=or=>    Greater than or equal to 

    <=or=<    Less than or equal to 
 
A few numerical expressions are given below as examples: 

    PRINT 3 =1.5*2 results in the value -1 (true) 

    PRINT 5>5  results in the value 0 (false) 

    PRINT 7<>17 results in the value -1 (true) 

    PRINT 8< =8  results in the value -1 (true) 

Character strings are compared using the following rules: 

    *Two  character  strings  are said to be the  same  when  each  
    character  of one matches the other exactly  (all  characters,  
    spaces  and punctuation are taken into account,  for  example,  
    "1,7"?::"="1,7 ?::"). 

    *The  comparison  of the "size" of strings is carried  out  as  
    follows: 
 
    The  two  first characters of the strings are checked  by  the  
Interpreter to see whether or not the characters ASCII Codes  (see  
Appendix  C) are identical.   If they are  different,  the  string  
having  the  first character with the greater ASCII value  is  the  
"larger".  If they are identical, the second pair of characters is  
checked,  and so on,  until either one character differs or  until  
the end of the string is reached.  In the latter case, the longest  
of two strings is also the "larger" one.  Here are some examples: 

    PRINT ("GFA">"GFA") equals 0 (false, they are equal) 

    PRINT ("123"<"ABC") equals -1 (true) 

    PRINT ("May">"Mai") equals -1 

    PRINT ("Z:>"A") 
 
                      LOGICAL FUNCTIONS      

    With the help of logical functions,  it is possible to combine  
expressions or determine the relationships between expressions. 

    The  following  explains the individual logical  functions  in  
more detail.  In this case, "t" stands for true and "f" stands for  
false: 

    AND Conjunction 
      The result of AND is only t when both arguments are t: 
 
      A      B     A AND B  
      t      t        t 
      t      f        f 
      f      t        f 
      f      f        f 

EXAMPLES: 

    PRINT 3=3 AND 4>2    equals -1 (t) 
    PRINT 3>3 AND 5>3    equals  0 (f) 
 

OR  Disjunction (a non-excluding "or").   The result of OR is only  
f when both arguments are f: 

     A    B    A OR B  
     t    t       t 
     t    f       t 
     f    t       t 
     f    f       f 
 
EXAMPLES: 

    PRINT "A"<"a" OR 3=5   equals -1 (t) 
    PRINT 2>7 OR 10=20     equals  0 (f) 
 
XOR  An excluding "or" 
     The result of XOR is f if the arguments have the same values: 

      A    B   A XOR  B  
      t    t      f 
      t    f      t 
      f    t      t 
      f    f      f 

    Examples: 

    PRINT 3=3 XOR 6=6    equals 0 (f) 
    PRINT 3>5 XOR 3<5    equals -1 (t) 

NOT  THE NEGATION GIVES THE VALUE ITS OPPOSITE MEANING 
    
    A   NOT     A 
    t           f 
    f           t 

    EXAMPLE:  PRINT NOT 5>7  equals -1 (t) 
 
IMP   Implication or conclusion is only f when it is  stated  that  
something untrue can result from something true. 
       ˆA   B   AIMPB € 
      t   t      f 
      t   f      f 
      f   t      t 
      f   f      t 

  Examples: 

    PRINT 3=5 IMP 2>3     equals  -1 (t) 
    PRINT 4>2 IMP 1=1*2   equals   0 (f) 
    PRINT 3<4 IMP 5=5     equals  -1 (t) 
 
EQV  Equivalent to.  This is identical to (A IMP B) AND (B IMP A). 
     ˆ A    B  AEQVB  € 
     t    t    t 
     t    f    f 
     f    t    f 
     f    f    t 

    EXAMPLES: 

      PRINT "A"<"AB"EQV 3=3 equals -1 (t) 
      PRINT 3+3>8EQV 2+2=4  equals  0 (f) 

    Logical  functions are mainly used to enable  various  program  
sequences  to be carried out,  independent of the actual value  of  
the expressions concerned. 

    Due to the structure of the logical functions described below,  
they can also be ued to test certin Bit Sequences: 

    The  operands  of the logical functions must  lie  within  the  
range  of  -2147483648  to  +2147483647,   because  these  logical  
functions work with 32 Bit figures.   The operands are broken down  
into  whole (binary) numbers and processed Bit by  Bit.   In  this  
way,  every one of the resulting 32 Bits are ascertained from  two  
corresponding  operand  Bits,   by  means  of  the  above  tables.   

Therefore, 1 means t (true) and 0 means f (false). 

    This  can  be  more  easily explained with  the  help  of  the  
following examples: 

    PRINT 29 AND 267 gives the value of 9 
   00000000 00000000 00000000 00011101 =  29 
   00000000 00000000 00000001 00001011 = 167     
   00000000 00000000 00000000 00001001 =   9 
 
   PRINT -8 EQV 30 gives the value of 25 
   11111111 11111111 11111111 11111000 = -8 
   00000000 00000000 00000000 00011001  = 30 
   00000000 00000000 00000000 00011001 = 25 

                        FUNCTION PRIORITY 

The functions are dealt with in the following order: 

()     Parenthesis' have the highest priority.  They are used to 
       change an undesired order of precedence. 

^      Exponentiation 

-,+    The prefix sign 

*,/    Multiplication and division 

DIV,\,MOD  Integer division and modulation 

+,-    Addition and subtractions 

=,<>,<,>,<=,>=  Comparisons 

NOT,AND,OR,XOR,IMP,EQV  Logical functions 
 
                APPENDIX A: COMMANDS AND FUNCTIONS 

    All  available  commands  and  functions  in  GFA  BASIC   are  
described in alphabetical order in this appendix. 

    The  description of the commands is divided into  5  sections,  
the description of the functions into 4: 
 
How:   This  is  where the format of the command  or  function  is  
given.  Words  written  in capital letters  are  key  words.   All  
instructions enclosed in square brackets are optional.   A  series  
of dots "..." means that the instruction can be repeated at  will.   
The  command or function is explained in more detail in a  further  
section, where necessary. 
 
Abbr.:  There is an abbreviation for almost all commands.  In each  
case  the shortest abbreviation is given.   In the case of  PRINT,  
for  example,  only  a P has to be  typed.   However,  the  Editor  
understands PR,  PRI, PRIN and, of course, PRINT as well.  After a  
syntax check has been carried out,  the Editor writes the word out  
in full.  This is only true of commands;  functions always have to  
be written out in full. 
 
Example:  A  brief  example is given in order  to  illustrate  the  
different possibilities of the command or function and to show how  
and   when  it  is  used.    If  this  explanation  still   proves  
insufficient, the example should be entered and tested. 
 
    As  some  of the examples produce a  continious  loop,  it  is  
important  to know that this can be either stopped or  interrupted  
by pressing <CONTROL>, <SHIFT> AND <ALTERNATE> simultaneously. 
 
Purpose:   This  section  describes what the command  or  function  
does. 
 
Explanation:   This  section  explains  the  important  points  to  
remember in order to use the command or function effectively. 
 
    If  a  command  is clearly one of the following  types  it  is  
identified at the very top of the page: 

    I/O Command (Input//Output Command) 
               Graphics Command 
             Arithmetic Command 
              Structure Command 

     [[[[[[[[[[[[[[[[[[[[[[[[[[ The Commands ]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
     
------------ 
Function ABS 
    
    HOW: ABS(x) 
    
    EXAMPLE: A=2329 
             PRINT ABS(A) 
             PRINT ABS(&X1010) 
             PRINT ABS(3*(-7)) 
     
    PURPOSE: Returns the absolute value of "x". 
 
    EXPLINATION: "x" can represent any numerical expression. 
 
    ABS(x) is the mathematical value function. 
 
    The absolute value of a numerical expression is always  
    greater than or equal to 0. Therefore: 

       - for x>0 = ABS(x)=x 
       - for x=0 = ABS(x)=0 
       - for x<0 = ABS(x)=-x 
 

-----------------
Function ABSOLUTE

      HOW: ABSOLUTE x,y

 With the command ABSOLUTE the address (ARRPTR/*) of a varible will be
changed. The varible then will be sent to the given address. It will also
acquir the value of the new address, the value in y must be an even value,
as long as x does not contain a boolean, byte or string varible.

 x=13
 y=7
 ABSOLUTE y,*x
 PRINT x,y,*x,*y

Function ADD: 
    
    HOW: ADD var,n 
    
    EXAMPLE: T = TIMER 
                FOR I%=1 TO 10000 
                ADD A%,5 
                NEXT I% 
                PRINT (TIMER-T)/200 
                A%=0 
                T=TIMER 
                FOR I%=1 TO 10000 
                A%=A%+5 
                NEXT I% 
                PRINT(TIMER-T)/200 
    
    PURPOSE: Increases the value of "var" by n. 
    
    EXPLINATION:  "var"  must be a numeric variable or  a  numeric  
                   array variable. "n" is a numerical expression. 
    
    ADD  var,n is the same as var=var+(n).   The advantage of  the  
       command ADD  is  that the speed of execution  is  increased  
       (try out the above example!).  The increase in the speed of  
       execution in the above example is, in fact, almost double. 

 
----------------------
Graphics Command ALERT          
    
    HOW: ALERT sym,text$,default,button$,choice
     
    EXAMPLE: ALERT 1,"Please choose|a gadget !",1,"Left|Right",a%
             ALERT 0,"You have chosen "+STR$(a%)+" gadget.",0," OK ",a%
         
    PURPOSE: Creates an ALERT box 
    
    EXPLINATION: An ALERT box makes it possible to either warn the  
                program  user,   ask  something,  or  give  hints.   
         
 
-----------------
Command ARRAYFILL 
     
    HOW: ARRAYFILL X(),n 
    
    EXAMPLE: DIM X%(10) 
             PRINT X%(4) 
             ARRAYFILL X%(),5+1
             PRINT X%(4) 
 
   PURPOSE:  Assigns the value "n" to all elements of an array. 
 
   EXPLANATION:  "field" can be any numeric or boolean array. all  
                elements  of "field ()" are assigned the value  of  
                the  constant  "n".   "n"  can be a  number  or  a  
                numeric variable. 
 

------------------------
Function ARRPTR / VARPTR
     
    HOW: VARPTR(x) 
         V:x
         ARRPTR(y)
         *Y

 EXAMPLE: A$="BASIC" 
             PRINT ARRPT(A$) 
             PRINT LPEEK(ARRPTR(A$))!Start Address 
             PRINT DPEEK(ARRPTR(A$)=4)! Length 

    PURPOSE:  Determines the address of the Descriptor of a string  
             or array. 

DIM x%(10)
A$="TEST"
PRINT ARRPTR(X%()),VARPTR(X%(0)),V:X%(1)
PRINT ARRPTR(A$),*A$,VARPTR(A$)

 Returns on the first line the address of the array descriptor as well as
the address of both the first array elements of x%(). On the second line
the address of the string desriptor of A$ is displayed twice and the
address of the first bytes of the character string is displayed once.

------------ 
Function ASC 
    
    HOW: ASC(x$) 
    
    EXAMPLE: A$="GFA" 
             PRINT ASC(A$) 
             PRINT ASC("!") 
             PRINT ASC("!WARNING!") 
    
    PURPOSE: Determines the ASCII Code of the first character of a  
             character string "x$". 
    
    EXPLANATION:   The  characters available on the AMIGA are  
    represented  by  ASCII  Codes.
 
    "x$" can be any character string.  The ASC function determines  
    the ASCII code of the first character of a string.  Therefore,  
    in the above example ASC("!WARNING!") as ASC("!") both  return  
    the value 33.  If the $ is an empty string, the value returned  
    is 0. 
 

------------
Function ATN 
    
    HOW: ATN(x) 
    
    EXAMPLE: INPUT slope 
             RAD=ATN(slope/100) 
             GRAD=RAD*180/PI 
             PRINT GRAD 
    
    PURPOSE: Returns the arc tangent of "x" in radians. 
    
    EXPLINATION: "x" is a numeric expression which is the  tangent  
                 value  of a given angle to be determined  by  the  
                 function. 

    The function ATN returns a value betweeen -PI/2 and PI/2.   If  
    this  value is required in degrees,  it must be multiplied  by  
    180/PI. PI is a predefined constant in GFA BASIC.  The example  
    calculates  the angle of a road from the percentage  slope  as  
    seen on road signs. 
 

-------------------------------------------------------
FUNCTIONS:   BCLR(x,y)  BSET(x,y)  BCHG(x,y)  BTST(x,y)

  These commands allow the erasing, setting, negating, and testing of
bits. The bit count begins with zero. The bit lies in the range from 0 to
31 and is internally masked by the processor with AND 31.

 0 is the lowest valued bit; with 4 byte integer values, 31 is the highest
valued bit and at the same time the prefix bit (if prefix bit is set in
2's complement the number is considered neagtive, otherwise it will be
a positive number)

 The function BCLR sets the yth bit of the numerical expression x equal to
zero. BSET sets bit number y of expression x equal to 1. BCHG sets bit y
of x equal to 1, when it was previously 0 and equal to 0 when it was
previusly equal to 1. The functions BTST returns 1 (TRUE) when bit y of x
equals 1 and 0 (FALSE) when bit equals 0.

x=BSET(0,3)
PRINT x,BSET(0,5)

 The numbers 8(2^3) and 32(2^5) are displayed

t|=ASC("x")
PRINT CHR$(t|),CHR$(BCLR(t|,5))
 

------------- 
Function BIN$ 
    
    HOW: BIN$(x) 
    
    EXAMPLE: A=1 
             B=&-22 
             PRINT BIN$(A) 
             PRINT BIN$(234) 
             PRINT BIN$(B) 
    
    PURPOSE:Changes the value "x" to a character string containing  
    the binary value of "x". 
    
    EXPLINATION:  "x" can be an integer between -2111474833648 and  
    +21474483647 in any form (i.e. the normal decimal form without  
    prefix,  in  hexidecimal form (prefix & or &  H),  octal  form  
    (prefix &0), binary form (prefix &X). 

       BIN$ changes the value "x" to a character string containing  
    the binary value of "x" (i.e.  B in the above example produces  
    the string "100010"). 

        BIN$  (and also HEX$ and OCT$)  always  produce  character  
    strings containing the values as 32-bit digits without a sign,  
    but these are always treated as signed integer values. 
    (see also HEX$(x), OCT$(x) and STR$(x)). 
 

---------------------------------
I/O Command BLOAD/BSAVE/BGET/BPUT 

    HOW: BLOAD "filename"[,address] 
         BSAVE "filename",address,len 
         BGET #n,adr,num
         BPUT #n,adr,num
 
    EXAMPLE: BSAVE n$,adr,num
             CLS 
             BLOAD n$,adr
    
    PURPOSE:  Stores  and  loads  parts  of  main  memory  to/from  
              diskette.            
 
    EXPLINATION:   "filename"  is  the  name  of  a   file.    The  
    specifications  of  the  DIR function  and  hierarchical  file  
    systems are allowed.   "address" is a numeric expression which  
    denotes  the  start  address  of  the  memory  area.   If  the  
    "address" for BLOAD is not given then the address given in the  
    BSAVE  is  used.   If  no  BSAVE  had  been  done  previously,  
    "address" must be specified or the computer will crash.  "len"  
    is a numeric expression which specifies the size of the memory  
    area to be saved. 

 BSAVE and BLOAD can access only the entire file.  In contrast to BPUT
and BGET which go through their channel numbers n.  Thus it is possible
to access only parts of a file with BGET and BPUT.
 

-----------------------------
Graphics Comand    BOUNDARY n

  The instruction BOUNDARY turns on the automatic framing of the fill area
on or off. If n equals zero the framing is turned off and for non zero n
it is turned on.

DEFFILL 1,2,2
BOUNDARY 1          ! ON
PBOX 50,50,100,100
BOUNDARY 0          ! off
PBOX 150,150,200,100

Commands     BYTE{x}
             CARD{x}
             INT{x}, WORD{x}
             LONG{x},{x}
             FLOAT{x}
             SINGLE{x}
             DOUBLE{x}
             CHAR{x}


  With the help of these commands certain varible types can be read or
written starting at an address. As a function (for ex: y=BYTE{x})it reads
from an address x.  As a command (for ex: BYTE{x}=y) it writes the value y
to the address.

Care must be taken that only even addresses are used with INT{},
CARD{},WORD{},LONG{},{},FLOAT{},SINGLE{}, DOUBLE{}
 
TYPE                   MEANING
-----------------------------------------
BYTE{x}          one byte
CARD{x}          one 2-byte interger without leading character
INT{x},WORD{x}   one "               with
LONG{x},{x}      one 4-byte interger value
FLOAT{x}         one 8-byte floating point varible in GFA format
SINGLE{x}        one 4-byte floating point varible in IEEE single format
DOUBLE{x}        one 8 "                                   double      "
CHAR{x}          one string ending with a null byte. extremely important
                     for communcation with C routines.

a$=SPACE$(8)
SINGLE{V:a$}=1.2345
PRINT HEX$(CVL(a$),8)

or

a$=SPACE$(8)
DOUBLE{V:a$}=1.2345
PRINT HEX$({V:a$},8)
PRINT HEX$({V:a$+4},8)


----------------------
Commands       BYTE(x)
               CARD(x)
               WORD(x)

 BYTE returns the lower eight bits of the numeric expression x.
 CARD reads the lower 16 bits of x.
 WORD enlarges a word into a long word (that is, bit 15 is copied into
      bits 16 through 31)

PRINT BYTE(1+254),BYTE(1+255)
PRINT HEX$(CARD(&H1234ABCD))

Displays 255,0 and ABCD 


-----------------------------
Graphics Command   BOX / PBOX

    HOW: BOX x0,y0,s1,y1 
    
    EXAMPLE: BOX 20,20,120,120
             PBOX 20,20+x,120,120+x
 
   PURPOSE: Draws a rectangle and a non-filled rectangle
             

----------- 
Function C: 
 
    HOW: C:var(parameters) 
 
    EXAMPLE: Q%=VARPTR(Q$) 
             A=C:Q%(17,L:0,W:-1) 
 
    PURPOSE:   Calls a machine code sub-program (compiled C)  with  
             transfer of parameters as in C. 
 
    EXPLINATION:  "var"  is a numeric variable (but not a  boolean  
    variable) which contains the start address of the C: routing. 
    "parameters"  is (as in C) a list of the parameters either  as  
    (16-bit)  words or (32-bit) long-words which are to be  passed  
    to the called routine.  This list may be empty. 
    Long-words  must be prefixed by "L:" and words have either  no  
    prefix or "W:",' 

    After executing the C:  routine GFA-BASIC (just as C)  returns  
    the long-word in register D0. 
    The  example  is only to clarify the format and would  call  a  
    routine contained in the string Q$.       
 
  Void C:adr%(L:x,W:y,z)

 creates the following stack

 (sp)   return address
4(sp)   x (4 bytes)
8(sp)   y (2 bytes)
10(sp)  z (2 bytes) 


------------
Command CALL 
 
    HOW: CALL var 
         CALL var(parameters) 
  
    EXAMPLE: CALL Text(3,i%,a$) 
 
    PURPOSE: Calls a machine code program. 
 
    EXPLINATION:  "var"  is a numeric variable (but not a  boolean  
    variable) which contains the start address of the routine. 
    "parameters"  is  a  lsit of the parameters which  are  to  be  
    passed to the routine. In the "stack" the machine code program  
    receives  the number of parameters as a (16-bit) word and  the  
    address  of the 4-byte fields which contain each parameter  as  
    (32-bit)  long-words.   Numbers are transferred  in  long-word  
    format and in the case of strings and start address is passed. 
    The example is only to clarify the format. 
 

-----------------
I/0 Command CHAIN 
 
    HOW: CHAIN "filespec" 
 
    EXAMPLE: SAVE "PROGRAM" 
             CHAIN "PRO*" 
 
    PURPOSE: Loads a program file into the work area and starts 
             the program. 
 
    EXPLINATION:  "filespec" is a file name which allows the  same  
    specifications  as those described in the DIR  commands.  (See  
    DIR) 

    If no extension is given in the file name then GFA-BASIC  adds  
    the extension .BAS. 

    If "filespec" is not in quotes they are assumed present. 
    The value of variables in the original program are NOT  passed  
    to the changed program. 
 

----------------- 
I/O Command CHDIR 

    HOW: CHDIR "directory name" 

    EXAMPLE: MKDIR"\DIR1" 
             MKDIR"\DIR1\DIR2" 
             VHFIT "\" 
             FILES 
             CHDIR"\DIR1" 
             FILES 

    PURPOSE: Changes the current directory. 

    EXPLINATION:  In  naming the directory the  hierarchical  file  
    system (\) can be used. 
    CHDIR  "\" switches to the root directory.   To switch to  any  
    other  directory the path must be given.   This always  begins  
    with  "\"  when starting out from  the  root  directory.   For  
    example,  CHDIR "\VEHICLE\DRIVER" declares the directory  with  
    the name DRIVER,  in directory VEHICLE of the root  directory,  
    as the durrent directory. 
 
 
-------------
Function CHR$ 

    HOW: CHR$(x) 

    EXAMPLE: PRINT CHR$(65) 
             PRINT CHR$(577) 
             PRINT CHR$(-191) 

    PURPOSE: Returns the character which corresponds to the ASCII 
             value of "x". 

    EXPLINATION:  The  characters  available on the ATARI  ST  are  
    represented  by  ASCII  codes.    There  are  256   characters  
    available  which correspond to the codes 0 to 255 (codes 0  to  
    31 are control characters).  A table showing all the codes and  
    their corresponding characters is in Appendix C. 
    "x"  is  an  integer  numeric  expression.    The  interpreter  
    transforms  "x" into a number between 0 and 255  according  to  
    the formula x AND 255. 

    A one-character string containing the character  corresponding  
    to  the ASCII code is returned.   In the  above  example,  all  
    three cases return the string "A". 
 

-------------------
FUNCTION  CINT(x)
          CFLOAT(y)

   The function CINT changes a floating point number "x" into a rounded
interger value.  CFLOAT on the other hand changes an interger value "y"
into a floating point number.


a=1.2345
a&=10000
b%=CINT(a)
b=CFLOAT(a%)
Print b%,b
 

-------------------------
Graphics Command CIRCLE 
                 PCIRCLE
                 ELLIPSE
                 PELLIPSE
  
    HOW: CIRCLE x,y,r
         PCIRCLE x,y,r
         ELLIPSE x,y,rx,ry
         PELLIPSE x,y,rx,ry


 CIRCLE draws a circle around the middle point with the coordinates x,y
and the radius r.  PCIRCLE draws a filled circle.

 ELLIPSE draws a ellipse with the middle point coordinates x,y and the
horizontal radius r.  PELLIPSE draws a filled ellipse or ellipse segment.

OPENW 0
CIRCLE 160,100,100
ELLIPSE 160,100,50,100
PCIRCLE 160,100,50
PELLIPSE 160,100,100,50


----------------- 
I/O Command CLEAR 

    HOW: CLEAR 

    EXAMPLE: A=17 
             B$-"BASIC" 
             CLEAR 
             PRINT A,B$ 

    PURPOSE: Clears all variables and arrays. 

    EXPLANATION:  All numeric variables are changed to the value 0  
    and all character string variables become empty strings.   The  
    program  itself is not changed in any way.   The  command  may  
    not  be used within procedures or FOR-NEXT loops.   Running  a  
    program automatically CLEARs all variables. 
 

--------------
Command CLEARW 
        TITLEW 
        FRONTW
        BACKW
        FULLW

    HOW: CLEAR W no 
         TITLEW no,a$[,b$]
         FRONTW no
         BACKW no
         FULLW no

 The command CLEARW erases the contents of the window with the index "no"
 TITLEW writes the texts a$ in the upper line of the window with the index
"no". If b$ is given it will be displayed in the title line when the
window is active.  FRONTW gets window index "no" and places it in the
foreground. BACKW pushes the window to the background.  FULLW enlarges the
window index "no" to full screen.

DEFILL 1,2,4
PBOX 0,0,639,399
OPENW 1
PAUSE 50
FULLW 1
PRINT " Window 1"
OPENW 4,0,0,100,100,0,&HF
PAUSE 50
CLEARW 1
OPENW 3
PAUSE 50
FRONTW 1
PAUSE 50
CLOSEW 1
TITLE 4,"Window 4"
PUASE 100
CLOSEW 3
CLOSEW 4
CLOSEW 0


-------------------------------------------------------
Graphic Commands     CLIP x,y,w,h [OFFSET x0,yo]
                     CLIP x1,y1 TO x2,y2 [OFFSET x0,y0)
                     CLIP #n [OFFSET x0,y0]
                     CLIP OFFSET x,y
                     CLIP OFF

  This group of instructions is used for clipping. This is a limiting of
graphic output to any rectangular screen section. To set these screen
sections (clipping rectangles) the coordiantes of the diagonally opposite
corners, as well as the width and height must be given.

CLIP x,y,w,h    x=left y=upper w=width h=height

CLIP x1,y1 TO x2,y2  coordiantes of diagonally opposite corners


----------------- 
I/O Command CLOSE 

    HOW: CLOSE [[#]n] 

    EXAMPLE: OPEN "0",#1,"PRO" 
             PRINT #1,"GFA BASIC" 
             CLOSE #1 
             OPEN ""I",#1,"PRO" 
             INPUT #1,A$ 
             CLOSE 
             PRINT A$ 

    PURPOSE: Closes a data channel or closes a channel to a 
             diskette file. 

    EXPLINATION: "n" is a whole number expression between 0 and 99  
    and states the number of the file (which was originally opened  
    with  OPEN)  which  now has to be  closed.   If  the  optional  
    parameter "n" is missing in this statement, ALL channels which  
    are still open will be closed. 

    The  command OPEN created an open channel for the  file  which  
    enabled access to read and/or write activities.   This  access  
    is withdrawn with the CLOSE command. 


------------------------ 
Command CLOSEW    CLOSES

    HOW: CLOSEW n 
         CLOSES n

    EXAMPLE: CLOSEW 2 

    PURPOSE: Closes the window numbered "n" 

    EXPLINATION:  "n" is a numeric expression which has the window  
    number  as  its value.
 

-----------
Command CLS 

    HOW: CLS[#i] 

    EXAMPLE:  FOR I=1 TO 1999 
              PRINT "A"; 
              NEXT I 
              PRINT AT(32,13);"Press key!" 
              A=INP(2) 
              CLS 

    PURPOSE: Clears the screen 

    EXPLINATION:   The   command  CLS  is  identical  with   PRINT  
    CHR$(27);"E"; and causes the screen to be cleared.  The cursor  
    moves  to the "HOME" position (upper left  corner).   CLS  can  
    also   be  used  in  data  channels  (eg:   opened   by   OPEN  
    "",#1,"VID:").   The command CLS #1 is used ("i" refers to the  
    channel  number) and is,  in this case,  identical with  PRINT  
    #1,CHR$(27);"E";. 
 

---------------------------------
 Command    COLLISION ON/OFF/STOP

 =COLLISION(-1) does not return the window number

Note: See AMIGA BASIC manual for more details.
 

------------------------------------------------------------ 
Function COS(x)  ACOS(x) TAN(x) ASIN(x) ATN(x) SIN(x) DEG(x) 
         SINQ(degree)    COSQ(degree)    RAD(degree)

     SIN  Sine              SINQ(degree)  corresponds to SIN(RAD(degree))
     COS  Cosine            COSQ(degree)                 COS(RAD(degree))
     TAN  Tangent           DEG(x)                       (x*180/PI)
     ASIN Arc sine          RAD(degree)
     ACOS Arc cosine
     ATN  Arc tangent

x=90
y=COS(x*PI/180)
z=270*PI/180
PRINT y,SIN(z),TAN(45),ATN(1/2)

radius=PI/2
slow=SIN(radius)
fast=SINQ(DEG(raduius))
PRINT slow fast

    EXPLINATION:  "x"  is  a numeric expression  which  shows  the  
    angle, for which the cosine is calculated, in the radians. 
    If the angle is in degrees,  "x" must be multiplied by PI/180,  
    where PI is a constant in GFA BASIC. 

    In  the first example,  the cosine of an angle in  radians  is  
    calculated, followed by the cosine of an angle in degrees.  In  
    the second example, a spiral form is created. 
 

----------------------------
Function CVI CVL CVS CVF CVD 
    HOW: CVI(x$) 
    
         CVL(x$) 
         CVS(x$) 
         CVF(x$) 
         CVD(x$) 
    EXAMPLE: A=0.1111 
    
             A$=MKF$(A) 
             PRINT CVF(A$) 
    PURPOSE: Changes character stings into numeric values. 
    
    EXPLINATION: "x$" can be any character string expression.  The  
    functions change the character string expressions into numeric  
    values in the following way:
 
CVI changes  a  2-byte character  string  into  a  16-bit integer.

CVL changes a 4-byte character string into a 32-bit integer.

CVS changes a 4-byte character string in AMIGA BASIC compatible format 
    into a floating point in GFA BASIC.

CVF changes a 6-byte character string in GFA BASIC's own format into
    a number.  CVD  

CVD changes an 8-byte character string in MBASIC compatible format  
    into a number. 

    If  the  strings  are longer than are  allowed  in  the  above  
    mentioned  formats,  only  the part of the string  up  to  the  
    corresponding length allowed will be accepted.   If it is  too  
    short the value 0 will be returned. 

    (Reverse function: MKI$,MKL$.MKS$,MKF$,MKD$) 


------------ 
Command DATA 
    
    HOW: DATA[const[,const]...] 

    EXAMPLE:  READ A,B$,C$,D,E! 
              PRINT A;B$;C$;D;E! 
              DATA 234,"G,F,A", BASIC,&HFF,56 

    PURPOSE: Holds the data which can be read by the READ command. 

    EXPLANATION: "const" are numeric, boolean or string constants.   
    These  constants are separated by commas.   Numeric  constants  
    can  be written in any form (decimal,  hexadecimal,  octal  or  
    binary). 

         It is not necessary to write string constants in  quotes,  
    however,  only when quotes are present can commas be used in a  
    string constant.   If no quotes are used the string goes  from  
    comma to comma,  i.e.  any spaces before or after a comma in a  
    DATA line are taken as being part of the character string (see  
    example).   If the command DATA is not followed by a value, it  
    is considered to be an empty string. 

          If  a  constant with the value 0  refers  to  a  boolean  
    variable  in the READ command,  the result is  0.   All  other  
    numeric  values  which refer to a boolean  variable  return  a  
    value of -1. 

    (see also READ and RESTORE) 
 

--------------
Function DATE$ 
         TIME$

    HOW: DATE$ 
         TIME$

    EXAMPLE: 
             PRINT DATE$,TIME$ 
             DATE$="27.2.1990"
             PRINT DATE$,TIME$

    PURPOSE: Creates a date function 
  
  EXPLINATION:   The  function creates a character string  which  
    displays  the system's date facility.   It has  the  following  
    format: 
               mm/dd/yyyy 
               DD.MM.YYYY
               HH:MM:SS
 

----------------------
Arithmetic Command DEC 
                   INC

    HOW: DEC var 
         INC var

    EXAMPLE:
             x%=4
             y%=7
             DEC x%
             INC y%
             PRINT x%,y%

              The numbers 3 and 8 are printed

             a|=255
             INC a|
             INC a|
             PRINT a|

              Returns 1 !, because there is no error checking

    EXPLINATION:   "var"  must  be  a  numeric  or  numeric  array  
    variable.  DEC var is identical to var=var-1.   The advantages  
    of the command DEC lie its shortness (saves storage space) and  
    its  speed  of execution (try the  example!).   By  using  the  
    command DEC the already high execution speed is improved still  
    further (in the above example 35 times faster). 
 

---------------------
Commands    DEFBIT f$
            DEFBYT f$
            DEFINT f$
            DEFWRD f$
            DEFFLT f$
            DEFSTR f$

 The instructions DEFxxx serves to simplify the declaration of variables. 
xxx is a place holder for the abbreviation of the varible type.

DEFxxx  f$ Postfix   all varibles declared
------------------------------------------------------------------------
DEFBIT  b        !         varibles b will be declared boolean varibles
DEFBYT  by       |                  by                 1 byte-intergers
DEFWRD  w        $                  w                  2 byte-intergers
DEFSTR  s,t      $                  s and t            string varibles
DEFFLT  x-z      #                  x to z             8 byte floating
DEFINT  i-k,m-p  %                  i to k m to p      4 byte-intergers    


-----------------------
Graphic Command DEFFILL 
    
    HOW: DEFFILL [c],[s],[p]
         DEFFILL [c],bitpattern$ 
    
 OPENW 0
 GRAPHMODE 1
 DO
 COLOR RAND(64),RAND(64),RAND(64)
 DEFFILL 1,RAND(2)+2,RAND(24)+1
 PBOX RAND(320),RAND(256),RAND(320),RAND(256)
 LOOP

 Draws various sized rectangles with randomly selected fill patterns in
the window.

      EXPLINATION:  Shapes  can  be filled in or  your  own  fill-in  
    patterns can be drawn with the commands FILL,  PBOX,  PCIRCLE<  
    PELLIPSE and POLYFILL. 

          The  command DEFFILL sets the color and  pattern  to  be  
    used.  The  color can be set by "c" and the pattern by  "s,p".   
    The  commas  at the end of the command which appear  when  "s"  
    and/(or) "p" are not set, can be left out. 

         The type of fill is determined by "a"  (0=empty,  1=filled
    2=dotted,  3=hatched.
 

------------- 
Command DEFFN 
        FN 

    HOW: DEFFN name [(varlist)]=expression called up by: 
         FN name [(list of expressions)] 
    
    EXAMPLE:  DO 
                 INPUT X 
                 PRINT X,FN Three,FN MULT(10) 
                LOOP 
                DEFFN MULT(Y)=Y*FN Three 
                DEFFN Three=3*X 
    
    PURPOSE: Defines specific user functions. 
    
    EXPLINATION:  "name" is formed like a variable name and  names  
    the function.  "varlist" are numeric or string variable names.   
    Elements  of  "varlist"  must be  separated  by  commas.   The  
    inclusion  of "varlist" is optional.   The  word  "expression"  
    represents any numeric or character string expression  ("name"  
    must  match the type of expression).   Thus,  if the  function  
    returns a number, the function name must be a numeric variable  
    (like  "Mult").   If the function returns a string,  the  name  
    must be a string variable name (like "Mult$"). 

         A function written by a user can be defined by using  the  
    command DEFFN.   This function can be called up by FN followed  
    by  the  corresponding function name and list  of  expressions  
    matching "varlist".   When calling up the function by FN it is  
    necessary to specify the list of expressions when the optional  
    "varlist" is specified in DEFFN. 

         When calling up the function by FN or @, all variables in  
    the  list  of "expressions" are given the  current  values  of  
    those  variables  after  which the value of  the  function  is  
    calculated and returned. 

       It  is  possible to call up another function  by  using  FN  
    within  a  function definition (see example).   In  this  way,  
    functions which take up more than one line can be defined. 

       It  is  not  necessary to place the DEFFN  command  at  the  
    beginning  of the program because the Interpreter carries  out  
    all DEFFN's first.  The order in which the DEFFN's are defined  
    is  also unimportant,  even when a function which  is  defined  
    later on is first used in a definition (see example). 
 

------------------------
Graphics Command DEFLINE 
    
   HOW: DEFLINE [def]
 
   OPENW 0
   DEFLINE &X111100000111100000
   COLOR 1,2
   GRAPHMODE 1
   LINE 20,20,200,100

 Draws a two-coloured line in the window

 DEF   0 = line in background
       1 = cross hatched lines
       2 = line close togther
       3 = dotted lines
       4 = dashed lines
       5 = lines wide apart
       6 = pattern  dash dot dot


    EXPLINATION:   This command determines the type of line to  be  
    used with the commands BOX,  CIRCLE,  DRAW,  ELLIPSE, LINE and  
    RBOX.  The line width in graphic dots is set by "b".  The type  
    of  beginning  and end of the line is set by "a"  and  "e":  0  
    stands for normal,  1 for arrow and 2 for  rounded.   Finally,  
    the line style (dashed,  dotted,  or solid) is set by "s".  If  
    you do not specify any settings your lines will be solid, with  
    normal ends and a width of 1 (s=1,  b=1,a=0,c=0).  The example  
    above creates the following figure: 
           (ILLUSTRATION SHOWN IN MANUAL) 


-------------- 
Function DFREE 
    
    HOW: DFREE(n) 
    
    EXAMPLE:    PRINTDFREE(0) 
                PRINT DFREE(1) 
    
    PURPOSE: Returns the amount of free storage space on a diskette.
 
    EXPLINATION:  "n"  is a numeric expression,  which  gives  the  
    value  of the drive number.   The command  returns  the  
    free storage space on the diskette in drive (n)  The command  n=0  
    refers to the currently selected drive.
 
Commands   DELETE x(|)
           INSERT x(|)=y

  With INSERT and DELETE one element can be inserted into or deleted from
an array.

DIM x%(5)                              Dim x%(5)
FOR i%=1 TO 5                          FOR i%=1 TO 5
 x%(i%)=i%                              x%(i%)-i%
NEXT i%                                NEXT i%
INSERT x%(3)=33                        DELETE x%(3)
FOR i%=0 To 5                          FOR i%=0 To 5
 PRINT x%(i%)                           PRINT x%(i%)
NEXT i%                                NEXT i%

 The left displays the numbers 0,1,2,33,3 and 4
     right                     0,1,2,4,5, and 0


-----------


-----------
Command DIM  

    HOW: DIM var(indices)[,var(indices),...] 

    EXAMPLE:  DIM A(1000),B(4,5,3) 
              DIM N$(20,5) 

    PURPOSE: Sets the dimension of an array or several arrays. 
  
  EXPLINATION:  "var" can represent any numeric, alphanumeric or  
    boolean  array  variable  "indices"  is  a  list  of   numeric  
    expressions separated by commas which define the dimensions of  
    the arrays.   If more than one indices is specified,  then the  
    array is multidimensional. 

       For  example,  one  can imagine a three  dimensional  array  
    (such  as in B,  above) as an office block in which the  first  
    index  is  the  floor,  the second is the  room  number  on  a  
    particular  floor  and  the third is the  table  number  in  a  
    particular  room.   In  BASIC  this means  that,  by  using  a  
    variable array name, it is possible to address various storage  
    areas(in the example it is tables) by entering indices. 

       The  command  DIM  sets the upper limit  of  the  Index(the  
    smallest  Index value is 0) and reserves a storage area  of  a  
    corresponding size.   The number of array elements is  limited  
    to  65535  with multi-dimensional arrays  but  one-dimensional  
    arrays are only limited by memory. 
    (see also ERASE) 


------------- 
Function DIM? 

    HOW: DIM?(field()) 

    EXAMPLE:   DIM A $(3,4,5) 
                 DIM N%(12,12) 
                 print dim?(N%()) 

    PURPOSE: Determines the number of elements in an array. 

    EXPLANATION:  "field" can be any array variable.  The function  
    states the number of elements of an array,  the dimensions  of  
    which  have been previously set by the  command  DIM.   Please  
    note that the indices for creating the dimension begin with 0:   
    therefore the values returned in the above example are 120 and  
    169.   If the array had not been given dimensions,  the  value  
    returned would have been 0. 
 

---------------
I/O Command DIR 

    HOW: DIR["filespec"[TO "file"]] 

    EXAMPLE:  DIR "DH0:*.*"TO "A:CONTENTS" 
              DIR "DH0:*.*" TO "PRT:" 

    PURPOSE:   Lists the files on a diskete.  It does not list the  
               directories.
 
    EXPLINATION:  "filespec"  is  a  file  name  which  needs  the  
    following specification: 

       The disk drive is specified by a letter placed in front  of  
    the file name and followed by a colon. 
    
      If  one or more question marks are in a file  name,  all  
    files  which  correspond with the file name,  apart  from  the  
    characters  in the position of the question mark(s),  will  be  
    found. The letters in the file where the question marks appear  
    in  "filespec"  are not important when searching for  a  file.   
    Therefore,  for example, in DIR "ART??.DOC" all files with the  
    extension  DOC and the characters hving ART.  as  the  
    first  three  letters are searched for.   In  this  case  both  
    ARTNR.DOC and ARTEN.DOC would be found. 
  
     The character "*" means that a whole part in the file  name  
    is to be disregarded in the search.   Therefore,  for example,  
    in  DIR "*.DOC" all files with the extension DOC are  searched  
    for and in DIR "B*.*" all files with the first letter "B"  are  
    searched for. 

       If  DIR  is used with no arguments then it will  produce  a  
    lsit of the files in the currently selected drive and folder. 

       Using  "filespec" it is also possible to use the  UNIX  (or  
    MSDOS) compatible hiearchical file system (\).  Therefore, the  
    file  name "\VEHICLE\DRIVER\*.*" means that all the  files  in  
    the  directory  "DRIVER",  which is in  the  directory  
    "VEHICLE", will be listed. 

       By using the option addition "TO "file" " it is possible to  
    print  out a file list (PRT:") or to transfer the list to  any  
    other file. In the above example a file with the name CONTENTS  
    is created on the diskette in drive A containing all the files  
    on  the diskette.   This new file listing (which now  includes  
    the file name CONTENTS) is then printed. 
 

-------------
Function DIR$ 

    HOW: DIR$(n) 

    EXAMPLE:  MKDIR "\TEST" 
                CHDIR "\TEST" 
                PRINT DIR$(0) 

    PURPOSE:  Returns  the  name of the active directory  for  the  
        diskdrive with the number "n". 

    EXPLANATION:   "n" is a numeric expression,  which  represents  
    the value of the diskdrive number  (0=currently  
    selected diskdrive). 

       This  function gives the name of the active  directory  for  
    the  selected diskdrive.   If the root directory is  selected,  
    this results in an empty string. 
 

----------------------
Arithmetic Command DIV 

    HOW: DIV var,n 
    
    EXAMPLE: DIM A%(10000) 
               FOR I=1 TO 10000 
                A%(I)=5 
                NEXT I 
                T=TIMER 
                FOR I=1 TO 10000 
                 DIV A%(I),5 
                NEXT I 
                PRINT (TIMER-T)/200 
                T=TIMER 
                FOR I=1 TO 10000 
                 A%(I)=A%(I)/5 
                NEXT I 
                PRINT (TIMER-T)/200 
    
   PURPOSE: Divides the value of "var" by "n". 

    EXPLINATION: "var" must be either a numeric or a numeric array  
    variable.  "n" is a numeric expression. 

       DIV var,n is the same as var=var/(n).  The advantage of the  
    command  DIV  lies  in the speed of  its  execution  (try  the  
    example!).   By using DIV the already high execution speed  is  
    improved still further (in the above example by approx. 30%). 
 

---------------------------
Structure Command DO...LOOP 

    HOW: DO 
             LOOP 
   
   
    EXAMPLE:   DO 
                  INCI 
                  PRINTI 
                 LOOP 
   
    PURPOSE:  Creates an endless loop. 
   
    EXPLANATION:   The part of the program between DO and LOOP  is  
    repeated endlessly.   This loop can only be left by EXIT IF, GOTO or
    a program end command.
    if these  commands are not used the program can also be  stopped  by  
    pressing <CONTROL>,<SHIFT> and <ALTERNATE> simultaneously. 
 

-------------------------
Command    DO WHILE con
           DO UNTIL con
           LOOP WHILE con
           LOOP UNTIL con

 The command DO and LOOP can be modified with the addition of UNTIL and
WHILE. The loop header DO WHILE ensures that the command within the loop
are only executed as long as con is true. If loop begins with DO UNTIL the
commands will only be executed aslong as con is not satisfied.

 LOOP WHILE insures the program branches back to DO only as long as con is
true. or LOOP UNTIL the con must not be satifised (false) if the program
exection is to branch back to the beginning of the loop.

DO WHILE con                 WHILE con
.                            .
.      correspsonds to       .
.                            .
LOOP                         WEND

DO                           REPEAT
.                            .
LOOP UNTIL con               UNTIL con

ex:

OPENW 0
DO
LOOP UNTIL MOUSEK
DO UNTIL MOUSEK=2
DO WHILE MOUSEK=1
LINE 0,0MOUSEX,MOUSEY
LOOP
LOOP UNTIL INKEY$="a"

DO UNTIL EOF(#1)
INPUT #1,a$
LOOP

WHILE NOT EOF(#1)
INPUT #1,a$
WEND


----------------------
Command    DISPLAY ON
           DISPLAY OFF

 With the commands DISPLAY ON and DISPLAY OFF, the DMA bit of a play feild
is set or erased. In this manner it is possible to draw on a play feild
and then display the drawing upon its completion. Before the drawing is
begun the DMA bit must be erases with DISPLAY OFF and after the drawing
is complete set with DISPLAY ON.


---------------------
Graphics Command DRAW 

    HOW: DRAW [TO] [x,y] 
         DRAW [x1,y1] [TO x2,y2] [TO x3,y3] [TO...] 

    EXAMPLE:  DRAW 10,10 
                DRAW TO 200,10 
                DRAW 200,10 TO 200,190 
                DRAW TO 10,190 TO 10,10 

    PURPOSE: Draws  points  and connects two or more  points  with  
             straight lines. 

    EXPLANATION:  x1,y1  and  x2,y2 are the  co-ordinates  of  the  
    points. The top left corner of the screen is the origin. 

       The command DRAW x,y draws a point and is identical to  the  
    command PLOT x,y.   DRAW TO w,y connects the point (x,y)  with  
    the previous point( drawn by PLOT,  LINE or DRAW).  DRAW x0,y0  
    to  x1,y1  connects  the  points (x0,y0)  and  x1,y1)  and  is  
    identical  to  the command LINE x0,y0,x1,y1.   DRAW  x0,y0  TO  
    x2,y2  TO x3,y3 TO...connects each of the opints in the  given  
    order. 
 

-----------------------------
Graphics      DRAW expression
              DRAW (i)
              SETDRAW



 With DRAW an imaginary marker will be moved over the screen and is able
to draw. The paprameters of the individual commands are floating decimal
point, they can also be given in strings,  the commands are:

FD N Forward    moves the PEN n Pixels forward

BK N Backward                          backward

SX x Scale x    with the given factor SX and SY work on n only with the

SY y Scale y    commands FD and BK The scaling is turned off with SX0 or
                SY0

LT w Left Turn  gives the angle w around which the drawing direction is
                to turn to the left

RT w Right Turn opposite to the right

TT w Turn to    returns the current angle "w" for the following
                assignments:

                                  0
                                  |
                    270 ----- zero point ------ 90
                                  |
                                 180

                 the input for w=angle is in degrees.

MA x,y Move absolute moves pen to the absolute coordinates x and y

DA x,y Draw absolute "                                           "
                     and draws a line in the current color from the last
                     position to the point(x,y)

MR xr,yr Move relative like MA, however moves to the last position

DR xr,yr Draw relative like MA, "                                 " an
                     abbreviation for the expression DRAW"MA",x,y,"TT",w
                     is in the command SETDRAW x,y,w

CO c COLOR     sets the color c as the drawing color

PU PEN UP      raises the marker

PD PEN DOWN    lowers the marker

DRAW(0) returns x-position (as fdp, value)

DRAW(1)         y                        "

DRAW(2)         angle in degrees(as fdp, value)

DRAW(3)         scaling of the x-axes (as fdp, value)

DRAW(4)                        y

DRAW(5)         Penflag(i=PD,0=PU)

OPENW 0
DRAW "ma 160,200,tt()"
For i&=3 to 10
corner(i%,90)
Next I&
Procedure corner(n&, r&)
For i&=1 to n&
DRAW "fd",r&,"rt",360/n&
Next I&
Return

Draws a polygon.


---------------------------
Command   DUMP [a$ [TO b$]]

 Using the  DUMP command varible contents as well aas labels, procedures
and functions can be listed during a program execution. The string a$ can
be given one of the folowing values.

 DUMP      shows all varible values and the dimemsions of all arrays
 DUMP "a"  like above, only beginning with "a"
 DUMP ":b" Labels , gives line numbers
 DUMP "@"  procedures and functions and line number
 
 DUMP "a" TO TEXT.DMP (DMP = default) will dump all "A" items to a file
 called TEXT.DMP


------------ 
Command EDIT 

    HOW: EDIT 
 
    EXAMPLE: PRINT "Back to the editor without" 
               PRINT "a program-end box" 
             EDIT 

    PURPOSE: Returns to the editor. 
 
   EXPLANATION:   When  used in direct mode the command allows  a  
    return  to  the editor.   In a program the  EDIT  command  has  
    almost  the  same effect as the END  command,  the  difference  
    being  that  a return to the editor takes  place  without  the  
    program-end alert box. 


------------------------ 
Graphics Command ELLIPSE 

    HOW: ELLIPSE x,y,rx,ry[,phi0,phi1] 

    PURPOSE: Draws  an  ellipse (or ellipse segment)  with  center  
             (x,y) and the two axes rx and ry. 

    EXPLANATION:   The  upper  left corner of the  screen  is  the  
    origin for the center point (x,y).   Some combinations of  the  
    center  point (x,y) and the axes can lead to only part of  the  
    ellipse being visible on the screen. 

       "rx"  is the length of the horizontal axis and "ry" is  the  
    length  of  the vertical axis.   Should only a segment  of  an  
    ellipse be required the start and end angles are specified  by  
    phi0  and phi1.   These angles are in tenths of  a  degree;  0  
    degrees  (0) is right,  90 degrees (900) is  up,  180  degrees  
    (1800)  is left,  270 degrees (2700) is down and  360  degrees  
    (3600) is again right. 
    (see also DEFLINE) 
 

-----------
Command END 

    HOW: END 

    EXAMPLE:  DO 
                 INC I 
                IF I=10000 THEN 
                   END 
                  ENDIF 
                 LOOP 

    PURPOSE:  Closes all files and terminates program execution. 

    EXPLANATION:   The END command can be used in any part of  the  
    program. Its use at the end of the program is optional. 
 

------------
Function EOF 

    HOW: EOF([#]n) 

    EXAMPLE:  OPEN "0",#1,"DAT" 
                PRINT #1,"123456" 
                CLOSE #1 
                OPEN "I",#1,"DAT" 
                DO 
                 PRINT INP(#1),EOF(#1) 
                 EXIT IF EOF(#1) 
                LOOP 

    PURPOSE: Determines whether the file pointer for the file with  
             channel number "n" is at the end of the file. 

    EXPLANATION:  "n"  is an integer expression between 0  and  99  
    which  refers to the channel number of a file opened with  the  
    OPEN command. 

    Each  data  channel  has  a file pointer  which  points  to  a  
    particular byte in the file.  If this pointer is at the end of  
    the  file the function EOF returns the value -1(this value  is  
    the  logical state "true").   In all other cases the  value  0  
    will be returned. 

       The program line:  EXIT IF EOF(#1)in the example avoids the  
    error message:. "End of file reached". 

       The  function can only be used for diskette files (not  for  
    CON:,LST:etc.). 
 

-------------
Command ERASE 

    HOW: ERASE field() 

    EXAMPLE:  DIM A(100,50,5) 
                PRINT FRE(0) 
                ERASE A() 
                PRINT FRE (0) 
                DIM A(3000) 

    PURPOSE: Deletes an array and releases the dimensioned area. 

    EXPLANATION:   If an array is created and dimensioned with DIM  
    then  the same array cannot be dimensioned again.   The  ERASE  
    command deletes the array and therefore allows the array to be  
    dimensioned again. 

       If an array is no longer needed for the rest of the program  
    and the available memory is small it is a good idea to  delete  
    the array with ERASE.  This allows the reserved memory area to  
    be used for other purposes. 


------------
Function ERR 

    HOW: ERR 

    EXAMPLE:  ON ERROR GOSUB Error_routine 
                 PRINT SQR(-1) 
                 PROCEDURE Error_routine 
                  PRINT "ERROR NR.:";ERR 
                 RESUME NEXT 
                 RETURN 
    PURPOSE:   Returns the error code of any error that has occurred.
 
    EXPLANATION:   ERR  is in fact a variable containing the  code  
    number  of the error that has occurred .    
    
    It can  therefore  not  be  used  as  a  varable!
    

------------- 
Command ERROR 

    HOW: ERROR n 
         ERR
         ERR$(x)


    EXAMPLE   PRINT "Enter error number:"; 
                INPUT e 
                ERROR  e 

    PURPOSE: Simulates the occurrence of the error with the  error  
             code "n". 

    EXPLANATION:  "n"  is an integer expression.
   
     If  an error routine is specified by an ON  ERROR  GOSUB  
    then this routine is executed otherwise the appropriate  error  
    message is displayed (see Appendix ) and the program stops. 
 

-----------------------
Function  EVERY / AFTER

 HOW:  EVERY ticks GOSUB proc
       EVERY STOP
       EVERY CONT
       AFTER ticks GOSUB proc
       AFTER STOP
       AFTER CONT

 Every and After procedures can be executed after a specific time. The
command every ensures that the procedure proc is executed every ticks time
unit; after ensures that the procedure is executed once after every tick

OPENW 0
EVERY 4 GOSUB lines
line!=TRUE
GRAPHMODE 3
DEFFILL 1,0
PLOT MOUSEX,MOUSEY
REPEAT
IF MOUSEK=1
EVERY STOP
ELSE
EVERY CONT
ENDIF
DRAW TO MOUSEX,MOUSEY
UNTIL MOUSEK=2
PROCEDURE LINES
INC y%
LINE 160,y%,320,y%
IF y%=0
ENDIF
RETURN


--------------
Function EXIST 
    
    HOW: EXIST ("filespec") 
    
    EXAMPLE:  OPEN "0",#1,"FILE.DOC" 
                CLOSE #1 
                PRINT EXIST ("FILE") 
                PRINT EXIST ("FIL*.DOC") 
                PRINT EXIST ("*.*") 
    
    PURPOSE: Determines  whether a particular file is  present  on  
             diskette. 
    
    EXPLANATION:  "filespec" is a file name which allows the  same  
    specifications as the DIR command (see DIR). 

       If  the file is present the value -1 is  returned,  if  not  
    then  the value 0 is returned.   A file will only be found  if  
    the  given file name matches a name in the  directory  exactly  
    (including the extension).  The example above returns 0,-1,-1. 
 

------------------------- 
Structure Command EXIT IF
 
    HOW: EXIT IF Condition 
    
    EXAMPLE:   DO 
                 A=A+1 
                 PRINT A 
                 EXIT IF A=20 
                LOOP 

    PURPOSE: Enables  the exit from a loop when the  condition  is  
             satisfied. 
    
    EXPLANATION:   If  the EXIT IF command is met in a loop and  the  
    condition  is satisfied,  then the program continues from  the  
    first command after the loop.
            

------------
Function EXP 
    
    HOW: EXP(x) 
    
    EXAMPLE: PRINT EXP(1) 
               PRINT EXP(0.5) 
               PRINT EXP(-2) 
    
    PURPOSE: Calculates the value of an exponent. 
    
    EXPLANATION:  "x" can be any numeric expression.  The function  
    EXP(x) calculates the value of e^"x" (e=2.718281828...). 


------------------
Comnmands    FALSE
             TRUE
             PI

 Both FALSE and TRUE contain the constant logical false and logical true.
FALSE equals 0 and TRUE equals -1.  PI contains the value of PI.

Print FALSE
IF TRUE
  Print PI
ENDIF

 Displays the number 0 and 3.14159265359
 

-----------------
I/O Command FIELD 
    
    HOW: FIELD #n,num AS set$ [,num AS set$, num AS set$]
         FIELD #n,num AT(x) [,num AT(x) [,num AT(x)[....]
 
    EXAMPLE:
               FIELD #1,4 AT(*a%),2 AT(*b%),8 AT(*c#)
               FIELD #2,4 AS a$,2 AT(*b&),8 AT(*c#),6 AS d$


    PURPOSE: Divides the records into arrays. 

    EXPLANATION:  "n"  is an integer expression between 0  and  99  
    which  refers  to  the  number of a  data  channel  opened  by  
    OPEN.  The section "expression AS svar" can be repeated (separated  
    by commas) if the record is to be divided into several fields.   
    The sum of the field lengths should equal the record length. 
    Each opened data channgel may only have one FIELD command. 

    The  length  of "svar" may not be changed if  it  is  still  
    required for a GET or PUT command.  Any changes should be made  
    by using LSET or RSET.  With the help of the AT. numeric varibles
    can be written into an R DATA (random access); in this format they
    need not be converted into a character string form.


----------------- 
I/O COMMAND FILES 
 
    HOW: FILES ["filespec"[TO"file]] 
 
    EXAMPLE:  FILES "DH0:*.*"TO"DH0:CONTENTS" 
                 FILES"DH0.*.*"TO"PRT:" 
 
    PURPOSE: Lists the files on a diskette. 
 
    EXPLANATION:   "filespec" is a file name which allows the same  
    specifications  as the DIR command.   The command FILES  works  
    almost the same as the command DIR,  the difference being that  
    FILES  compiles  a detailed data listing  which  contains  its  
    length, the time and the date as well as the file name.  FILES  
    also  shows this information for folders.   If you  use  FILES  
    with  no  arguments,  you  will get a list of  the  files  and  
    folders on the currently selected drive and directory. 

       The optional "TO FILE" allows the list produced by FILES to  
    be printed (LST:) or to be transfered to any other  file.   In  
    the  example,  the  results of FILES are routed  to  the  file  
    "CONTENTS".   The  list  (now including  "CONTENTS")  is  then  
    printed. 
    (see DIR for further information). 
 

------------------
Command FILESELECT 

    HOW: FILESELECT title$,oktext$,path$,name$
    
         FILESELECT "DH0:","Load File","Load",name$
         IF name$=""
         PRINT " You have chosen the cancel button."
         ELSE
         If RIGHT$(name$)=":"
         PRINT " You have chosen the OK-button with no data selction."
         ELSE
         PRINT " You have chosen the filename: ";name$
         ENDIF
         ENDIF


    PURPOSE: Creates a fileselect box on the screen. 
    
    EXPLANATION:   Title$ = action name
                   OKTEXT$ = passes the name of the OK-gadget
                   Path$ = drive and directory that is to be shown
                   Name$ = selected file

       For  a better understanding of this command,  it is a  good  
    idea to try out the above example. 
 

--------------------- 
Graphics Command FILL 
    
    HOW: FILL x,y[.c] 
    
    EXAMPLE:   LINE 0,180,639,180
               FOR i=1 to 19
               BOX i*20,200,i*20+20-i,180
               TEXT i*20-4,195,i
               DEFFILL ,2,i
               FILL i*20+1,101,1
               NEXT i


 
    PURPOSE:  Fills in a bordered area with a pattern. 
  
   EXPLANATION:  "x"  and "y" are the coordinates of  the  points  
    from  where  the filling will commence.   The  origin  of  the  
    coordinates is the top left corner of the screen. When C is 
    included the fill is limited to points of color C and the edge
    of the screen. Without C or with C=-1 every point is given another
    color then the start point (x,y)
 

------------
Function FIX 
 
    HOW: FIX(x) 

    EXAMPLE:  A+3,1415 
                PRINT FIX(A) 
                PRINT FIX(-12) 
                PRINT FIX(-1.99) 

    PURPOSE:  Returns the integer portion of "x" after the figures  
       following the decimal point have been removed. 

    EXPLANATION:   "x" can be any numeric expression.  If "x" is a  
    positive  number then the effect is the same as that  of  INT.   
    The  difference  only  becomes  obvious  when  using  negative  
    numbers:  FIX(-1.99) in the above example returns the value -1  
    but INT(-1.99) would return the value -2.   FIX (and not  INT)  
    complements FRAC(see function FRAC). 

    The following is true: 

    x=FIX(x)+FRAC(x) 
    The function FIX is identical to the function TRUNC. 
 

----------------------------
Structure Command FOR...NEXT
                  FOR...TO
                  NEXT i
                  DOWNTO
 
    HOW: FOR Var= a [DOWN]TOe[STEPs] 
          NEXT Var 

    EXAMPLE:  FOR I=3 TO 5 
                 FOR J=5 DOWNTO 3 
                  FOR K=1 TO 5 STEP 2 
                   PRINT I,J,K 
                  NEXT K 
                 NEXT J 
                NEXT I 

    PURPOSE: Creates a loop which is executed as many times as has  
             been specified at the beginning of the loop. 

    EXPLANATION:   The  variable "Var" is given the value "a"  and  
    the  commands between FOR and NEXT are executed.   Then  "Var"  
    (by NEXT) is increased by the value "s" and the program checks  
    whether  the value of "Var" is greater than "e".   If this  is  
    not the case,  the program goes back to FOR.  This is repeated  
    until the value of "Var" exceeds that of "e". 

       If the "s" has a negative value,  the reverse occurs:   The  
    value of "Var" is decreased and the program checks whether the  
    value of "Var" is smaller than "e". 

       If the optional command STEP "s" is not used,  the value of  
    "s"  is  set at 1.   The optional command may not be  used  if  
    DOWNTO is used instead of TO.   In this case "s" receives  the  
    value of -1. 

    FOR...NEXT loops can be nested. 

       The  execution speed of a FOR...NEXT loop can be  increased  
    considerably if an integer variable is used in "var" to  count  
    the  loops.   In the following example,  by using the  integer  
    variable I% instead of I,  the time needed to execute the loop  
    drops from 1.19 sec. to 0.40 sec.: 

             T=TIMER 
             FOR I=1 TO 10000 
             NEXT I 
             PRINT (TIMER-T)/200 
             T=TIMER 
             FOR I%=1 TO 10000 
             NEXT I% 
             PRINT (TIMER-T)/200 


----------------------            
I/O Command FORM INPUT   

    HOW: FORM INPUT n,var 
    
    EXAMPLE:  PRINT "Enter your name" 
                PRINT "(max. 15 letters)" 
                FORM INPUT 15, Name$ 
                PRINT "Your name is"; Name$ 

    PURPOSE: Enables  the  input  of  a  character  string  during  
             program execution. 

    EXPLANATION:   "n"  represents  the  maximum  length  of   the  
    character string.  "var" is the name of a string variable. 

        When the Interpreter encounters the command FORM INPUT  it  
    stops  the  execution of the program and gives  the  user  the  
    opportunity to enter a character string, the maximum length of  
    which is limited by "n".   When the maximum length is reached,  
    the bell sounds.  A character string can have a maximum of 255  
    characters. 
  

------------
Function FRE 

    HOW: FRE(x) 

    EXAMPLE:  PRINT FRE(A%) 
                DIM N$(1000) 
                PRINT FRE(0) 

    PURPOSE:   Calculates the amount of free storage space in  the  
        main memory in bytes.  

    EXPLANATION:   The  parameter  "x",  which may  be  a  numeric  
    expression, is disregarded. 

          If the function FRE is used,  GFA-BASIC  calculates  the  
    free storage space in the main memory in bytes after  carrying  
    out a Garbage Collection (collection and direction of all  the  
    unused areas in the main memory. 
 

----------------------
Command FRONTS / BACKS

   Every open screen contains two gadgets on the upper right edge. It is
possible to change the screen through these gadgets.

    For i%=1 to 5
      OPENS i%,0,i%*30,320,200,1,128
    NEXT i%
    DO
    FRONTS RAND(5)
    BACKS RAND(5)
    LOOP

 Five screens are opened at various positions and an endless loop moves
the screens from the foreground to the background.


-------------
Command FULLW 

    HOW: FULLW no
    
    EXAMPLE: FULLW 2 

    PURPOSE: Enlarges window "n" to full screen size. 

    EXPLANATION:  "n"  is a numeric expression which represents the 
    window number.

Command   @Func(part1,par2,....)
           FUNCTION funk [(var1,var2...)]
           RETURN exp
           ENDFUNC

  The commands of the subroutine (simalar to PROCEDURE) are placed between
the command words FUNCTION and ENDFUNC. To call to the subroutine the @ is
used. This will be followed by a parameter list.  When the program
execution reacheas RETURN the program will jumpp to the command that
following the function call.  RETURN can be used many times within a
function, but not allowed to end a function inside an IF or other
structures within a RETURN(for ex: using ENDFUNC instead)
 
 Varibles, constants and expressions can be passed and a $ character at eh
end of a function name identifies functions with string values.

ex:

OPENW 0
toronto=@tor_loop(15)
friday=@fak_recurs(10)
Print " Loop: fak(15) = ";toronto
Print " Recursion: fak(10) =";friday
FUNCTION fak_loop(f%)
w=1
For j%=1 TO f%
MUL w,j%
NEXT j%
RETURN w
ENDFUNC
FUNCTION fak_recurs(f%)
If f%=2
RETURN 1
ELSE
RETURN f%"@fak_recurs(PRED(f%)
ENDIF
ENDFUNC


----------- 
Command GET  
        PUT
   
  HOW: GET x1,y1,x2,y2,section$ 
       PUT x1,y1,section$ [mode,mask]

  The command GET puts a rasport section (32768 bytes) into a string
varable. The varible x1 and y1 set the start coordinates, and x2 or y2
set the end coordinates of the graphic section. PUT draws a rasport
section saved with GET at the points x,y in the current window. "mode"
determines how the section is to be combined in a bit pattern with the
window contents.

  Normally the window contents are copied with no changes with a value
of 192 (&HC0) for "mode".
 

---------------
I/O Command GET 
            PUT
            RECORD

    HOW:  GET #n [,set]
          PUT #n [,set]
          RECORD #n,set

    EXAMPLE: See FIELD 

             PUT #2,i&

             GET #2,i%

             RECORD #2,i%

    PURPOSE:  Reads a record from a random access file. 

    EXPLANATION:  "n"  is an integer expression between 0  and  99  
    which  refers  to the number of the data channel  opened  with  
    OPEN. "i" is an integer expression between 1 and the number of  
    records in the file (max.  655) and denotes the record  number  
    of the record to be read.   If "i" is not given then the  next  
    record in the file will be read. 

    NOTE  that if you try to GET information from a file you  have  
    just  created and PUT into,  you MUST specify "i" because  the  
    file pointer is located at the end of the file,  and using GET  
    without "i" will cause an "End of file reached" error. 
 

-----------------------
Structure Command GOSUB 

    HOW: GOSUB name [(list of expressions)] 

    EXAMPLE:  PRINT "Main Program" 
                 GOSUB Routine.1 
                 PRINT "Back from 1" 
                 PROCEDURE Routine.1 
                   PRINT "Procedure 1" 
                   GOSUB Routine.2(3,2) 
                   PRINT "back from 2" 
                   PRINT A,B 
                  RETURN 
                  PROCEDURE Routine.2(A,B) 
                   PRINT A,B 
                   PRINT "Procedure 2" 
                  RETURN 

    PURPOSE:  Branches to the procedure called "name". 

    EXPLANATION:   A  procedure name may (unlike a variable  name)  
    begin with a digit and can contain letters,  numbers, dots and  
    the   underline.   The  list  of  expressions   contains   the  
    values(separated  by  commas)  of any local  variables  to  be  
    passed to the procedure (see PROCEDURE). 

        When  the  interpreter  comes across a  GOSUB  command  it  
    branches to the procedure named in the GOSUB.   Procedures can  
    be  "nexted" i.e.  it is possible to call one  procedure  with  
    GOSUB from within another procedure.   It is even possible  to  
    call  the  procedure  that  one is  already  in  at  the  time  
    (recursive call). 

        The  above  example  calls the  procedure  with  the  name  
    "Routine.1"  from  the  main  program.    From  the  procedure  
    "Routine.1" the procedure "Routine.2" is called and the values  
    2 and 3 are given to the local variables A and B respectively.   
    To  show  that these really are local variables A  and  B  are  
    again  printed after returning from procedure "Routine.2"  but  
    then they both have the value of zero. 

    (see PROCEDURE, RETURN, LOCAL) 
 

----------------------
Structure Command GOTO 

    HOW: GOTO label 

    EXAMPLE:  Beginning: 
                PRINT "Endless loop"; 
                GOTO Beginning 
    
    PURPOSE: Allows  an unconditional jump to another part of  the  
             program. 

    EXPLANATION:  "label" is character string which can consist of  
    letters,  numbers,  dots and dashes.   Unlike variable  names,  
    labels can begin with a digit as well. 

        As  GRA-BASIC does not use line numbering it is  necessary  
    to  put  labels at those points in the program which  are  the  
    targets for GOTO jumps.  Note that the lbel name must end with  
    a colon. 

        The above example simulates the command DO...LOOP. 
 

--------------------------
Graphics Command GRAPHMODE 

    HOW: GRAPHMODE n 

    PURPOSE:  Sets graphic mode: 
                  n=0: JAM1       replace
                  n=1: JAM2       transparent
                  n=2: COMPLEMENT xor
                  n=3: INVERSED   reverse transparnet

 Openw 0
 Color 1,0,1
 For i%=1 to 8
 Graphmode I%-1
 Deffill 1,2,18+i%
 Pbox 75*i%-50,20,75*i%,70
 Deffill 1,3,i%
 Pbox (75*i%)-70,50,75*i%-20,100
 Next i%

 shows 8 pairs of squares with various patterns in 4 modes


    EXPLANATION:   The graphic mode "n" is improtant when pictures  
    are to be drawn on top of each other. 

        When "n" has the value 1 (normal mode), the old picture is  
    replaced  by  the new one.   If n=2 then the  new  picture  is  
    "transparent"  i.e.  the old picture can still be seen  behind  
    the new one anywhere the new picture has an area drawn in  the  
    background color.   A similar thing happens with 4=4,  but  in  
    this case the new picture is shown in inverse. 

        If n=3,  every element of the new picture is drawn  except  
    where a graphic dot is already present,  here the new  graphic  
    dot is XORed against the old one.   XORing the new dot against  
    the old one twice leaves the old dot on the screen  unchanged.   
    In  this  mode blinking figures and animatio  is  possible  by  
    repeated drawing of the same figure. 
 

--------------------
I/O Command HARDCOPY 

    HOW: HARDCOPY 
         HARDCOPY [adr,comap,modes,srcx,srcy,srcw,srch,destc,destl,spec]
 
    PURPOSE: Makes a hardcopy. 

    EXPLANATION:  HARDCOPY without parameters initiates a graphic output
 of the current window or RASPORT to the printer. Printing is from
 system prefs. If another window is opened after a RASTPORT an error
 message will be displayed. The optional paprameters can be given in order
 to change the output.

 adr:   address of rastport from which the hard copy is to be made

 comap: address of color map containing the colors of the picture

 modes: resolution mode as they are given in the viewpoint structure

 srcx:  offset to the left edge of rasterport

 srcy:  "             right

 srcw:  The width of the printed area

 srch:  "   Height

 destc: Number of columns to be printed

 destl: "         lines

 spec:  Tells how the parameter "destc" and "destl" are to be evaluated
        if bit 0 is set then the input in "destc" is set to thousands of 
        an inch, with bit 1 having the same meaning for "destl". Bit 2
        means the max line width when it is set. Bit 3 means the max
        height. Bit 4 means that "destb" is a part of the max width, bit
        5 corresponds to the height. Bit 6 (64) means that the printed
        picture output will be centered. Bit 7 means that the page
        directory corresponds to the paper on the screen.


-------------
Function HEX$ 

    HOW: HEX$(x) 

    EXAMPLE:  A=1 
                B=&022 
                PRINT HEX$(A) 
                PRINT HEX$(234) 
                PRINT HEX$(B) 

    PURPOSE: Changest  he  value  "x"  into  a  character   string  
             expressing  which  contains  the  value  of  "x"   in  
             hexadecimal form. 

    EXPLANATION:  "x"  can be an integer between  -2147483648  and  
    +2147483647 in any form (i.e.  the normal decimal form without  
    prefix,  in  hexadecimal form (prefix & or &  H),  octal  form  
    (prefix &0), binary form (prefix &X). 

        HEX$   changes  the  value  "x"  to  a  character   string  
    containing the hexadecimal value of "x" (i.e.  B in the  above  
    example produces the string "22"). 

        HEX$ (and also BIN$ and OCT$) always produce values as 32- 
    bit  digits without a sign,  but these are always  treated  as  
    signed integer values. 

    (see also BIN$(x),OCT$(x) and STR$(x)). 
 

-------------------------
Structure Command IF 
                  ELSE
                  ELSE IF
                  ENDIF


IF a=1 THEN               IF a=1
PRINT " a equals 1"       PRINT " a equals 1"
ENDIF                     ENDIF

IF a=1                    IF a=1              IF a=1
Print " 1 "               PRINT " 1 "         PRINT " 1 "
ELSE                      ELSE                ELSEIF a=2
PRINT " NOT 1"            IF a=2              PRINT " NOT 1"
ENDIF                     PRINT " 2 "         ENDIF
                          ENDIF
                          ENDIF


 
   PURPOSE: Determines which block of code will be executed based  
             on condition. 

    EXPLANATION:  This  command allows you to make the rest  of  a  
    program dependent upon certain conditions. 

        If the "condition" is fulfilled, the program block between  
    the IF question and ELSE is executed (or when optional ELSE is  
    not used between, IF and ENDIF). 

    If  the "condition" is not fulfilled,  the block between  ELSE  
    and ENDIF is executed.   If ELSE is not used, the entire block  
    of code bwetween IF and ENDIF is ignored. 

    Whatever the case may be,  execution of the program  continues  
    with  the  first command after ENDIF when the IF  command  has  
    been  completed.   As  this  often  used  command  differs  in  
    structure from other types of BASIC,  it is a good idea to try  
    the  above  example to gain a better understanding of  how  it  
    works. 
 

----------------------
Arithmetic Command INC 

    HOW: INC var 

    EXAMPLE:  T=TIMER 
                FOR I%=1 T0 10000 
                 INC A% 
                NEXT I% 
                PRINT (TIMER-T)/200 
                A%=0 
                T=TIMER 
                FOR I%=1 TO 10000 
                 A%=A%+1 
                NEXT I% 
                PRINT (TIMER-T)/200 

    PURPOSE:  Increases the value of "var" by 1. 

    EXPLANATION: "var" must be either a numeric or a numeric array  
    variable. 

    INC  "var" is identical to var=var+1.   The advantage  of  the  
    command INC lies in shortness (saves storage space) and  above  
    all  in the speed of execution (try the above  example!).   By  
    using  INC the already high execution speed is improved  still  
    further (in the above example by approx. 35 times). 
 

--------------- 
Function INKEY$ 

    HOW: INKEY$ 

    EXAMPLE:  DO 
                REPEAT 
                Z$=INKEY$ 
                UNTIL Z$<>"" 
                PRINT LEN(Z$ 
                PRINT LEFT$(Z$)""ASC(Z$), 
                PRINT RIGHT$(Z$)""..... 
                    ...ASC(RIGHT$(Z$)) 
              LOOP 

    PURPOSE: Reads a character from the keyboard. 

    EXPLANATION:   The  function returns a character string  which  
    consists of two,  one or no characters.  If no key was pressed  
    since INKEY$ was last used, an empty string results. 

        If a key,  with an ASCII code assigned to it,  is  pressed  
    (seeCHR$), the corresponding CHR$ is returned.

       The following program delays execution until any one key is 
    pressed: 

        PRINT"Press any key!" 
        REPEAT 
        UNTIL INKEY$<>"" 
        PRINT"OK" 
 

-----------------------
Command  INLINE adr,num

  adr:  4 byte interger varible, no array varibles
  num:  interger constant smaller than 32700

 When INLINE is executed the address of this interger varible is written
to adr, when the prpogram is saved or loaded this memory area is saved or
loaded with the program.


------------
Function INP 

    HOW: INP(x) 
         INP(#n) 

    EXAMPLE:  OPEN "O",#1,"DAT" 
                PRINT #1,"ABC" 
                CLOSE#1 
                OPEN"I",#1,"DAT" 
                PRINT INP(#1) 
                PRINT "Press any key" 
                PRINT INP(2) 

    PURPOSE: Reads one byte from the peripheral or from a file. 
    The function INP(x) reads exactly one byte from the peripheral  
    named  in "x".   The execution of the program is halted  until  
    the byte is received (i.e. with x=2 until a key is pressed). 
          INP(#n) reads one byte from a file on the  data  channel  
    "n". 
 
-------------------------


-------------------------
I/O Command INPUT, INPUT# 

    HOW:  INPUT["text";(or,)]var[,var...] 
          INPUT#n,var[,var...] 

    EXAMPLE:  INPUT K 
                 PRINT AT (15,15); 
                 INPUT"Your name";N$ 
                 INPUT"Age and address:",A,W$ 

    PURPOSE: Makes it possible to enter information during program  
             execution. 

    EXPLANATION:  "text" can be any string which is to be shown on  
    the  screen prior to information being entered on the  screen.   
    This text must always be written in quotes.   "var" can be any  
    variable name, including a string variable. 

        When the Interpreter comes across the INPUT  command,  the  
    execution  of  the program isstopped and the user is  able  to  
    enter   information  from  the  keyboard.    With  INPUT   #n,  
    information is entered via the file on channel "n". 

        The "text" will be shown on the screen and the cursor will  
    be to the right of the text;  if there is a semicolon  between  
    "text"  and "var" a question mark and a space will  appear  to  
    the right of the text.  If "text" and "var" are separated by a  
    comma,  information  willb e typed from the keyboard  directly  
    after the last character in "text". 

        If  the  wrong  information is entered  for  the  type  of  
    variable present, a bell will sound and another attempt can be  
    made.  If the information has been input from a file an  error  
    message will appear. 

        A  character  string entered with input can be up  to  255  
    characters long. 

        Both  <DELETE> and <BACKSPACE> can be used as  normal  for  
    corrections.   The  right and left arrow keys can be  used  to  
    reach any part of the text.   The beginning and end of the key  
    can   be  reached  by  using  the  up  and  down  arrow   keys  
    respectively. 

        If  an input command is followed by a single variable  and  
    the  information  entered  contains  a  comma  then  only  the  
    information before the comma will be accepted (different  from  
    LINE  INPUT).   A comma and the information after it  will  be  
    accepted,  however,  if the string is enclosed in quotes.  The  
    quotes are not stored. 

        If  an INPUT command is followed by two or more  variables  
    which are separated by commas, the information entered must be  
    separated by commas or by RETURN. 

        If you press RETURN before entering all the required data,  
    the  system  will  present you with a  question  mark  on  the  
    screen, informing you that more enteries are required. 

    ADDITIONAL EXAMPLE (INPUT#): 

        OPEN"0",#1,"test" 
          WRITE #1,"Gordon",35,"Michtron" 
          CLOSE #1 
          OPEN"I",#1,"text" 
          INPUT#1,Name$,Age,Company$ 
          PRINT"Your name:";Name$; 
          "Your age:"'age;"Your Company:";Company$ 
 

---------------
Function INPUT$ 

    HOW: INPUT$(X[,#N]) 

    EXAMPLE:  OPEN "0",#1,"DAT" 
                PRINT #1,"GFA-BASIC" 
                CLOSE #1 
                OPEN"I",#1,"DAT" 
                PRINT INPUT$(3,#1) 
                PRINT "Type in 5 characters" 
                PRINT INPUT$(5) 

    PURPOSE: Reads"x" characters from the keyboard or from a  file  
             as a string. 

    EXPLANATION:"x"  is  an integer with a value  which  must  lie  
    between 0 and 32767(string length). 

        "n"  is an integer between 0 and 99 which  represents  the  
    data channel number opened with OPEN. 

        If the optional part "#n" is not used, the command forms a  
    string  of "x" characters from the keyboard.  If the  optional  
    part "#n" is used then a string of "x" characters will be read  
    from the file with the data channel "n". 

        INPUT$ will read ALL the characters from a file, including  
    those  that might normally terminate an input,  such as CR  or  
    LF.  Thus, INPUT$ is ideal for reading such things as PICS.


-------------- 
Function INSTR 

    HOW: INSTR([N,]A$,B$) OR       
         INSTR(A$,B$[,N]) 

    EXAMPLE:  N$="GFA-BASIC" 
                S$="BASIC" 
                PRINT INSTR(N$,"A") 
                PRINT INSTR(4,N$,"A") 
                PRINT INSTR("GFA-BASIC",fB") 
                PRINT INSTR(N$,S$) 

    PURPOSE: Searches  to  see whether a character  string  B$  is  
             present in the string A$ and returns its position. 

    EXPLANATION:  "n"  is  a  numeric  expression  indicating  the  
    position in "A$" at which the search is to begin.   If "n"  is  
    not  given,  then the search begins at the first character  of  
    "A$". "A$" and "B$" can be any character string expressions. 

        If "B$" is found in "A$",  the position at which it starts  
    within "A$" is returned.  If "B$" is not found, then the value  
    0 is returned.   The value 0 will also be returned if "A$"  is  
    any  string with at least one character and "B$" is  an  empty  
    string. If both strings are empty the value of 1 is returned. 
 

------------
Function INT 

    HOW: INT(x) 

    EXAMPLE: A=3.1415 
               PRINT INT(A) 
               PRINT INT(678) 
               PRINT INT(-1.001) 

    PURPOSE: Determines  the largest integer that is less than  or  
             equal to x. 

    EXPLANATION:  "x"  is any numeric  expression.   The  function  
    INT(x)  returns the largest whole number that is less than  or  
    equal to "x".   For a positive value of "x" this simply  means  
    that  everything after the decimal point is  lost.   (In  this  
    case the function INT is identical to the function TRUNC).  If  
    "x"  is  negative,  then  INT has a  rounding  effect  in  the  
    negative  direction.   Therefore,  INT(-1.001) in the  example  
    would return a value of -2. 
 

---------------------------------
I/O Command   KILL name$
              RENAME old$ as new$
              NAME old$ as new$ 
            

    EXAMPLE:  OPEN "0",#1,"JUNK" 
                CLOSE 
                FILES 
                KILL"JUNK" 
                PRINT 
                FILES 

                -------

                RENAME "DH0:EATME.TXT" as "EATMEMORE.TXT"

                -------

                NAME "EATMEMORE.TXT" as "EATME.TXT"


     The command KILL deletes only one file at a  time,  namely  
    the  first occurrence of a file whose name matches that  given  
    in "filespec". 

    If  the  "filespec"  is not in  quotes  they  are  assumed  
    present by GFA-BASIC. 

    NOTE: This command accepts the usage of "?" and "*" to specify  
    filenames.   Be very careful if you use these to make sure the  
    wrong file is not erased. 
 

--------------
Function LEFT$ 

    HOW: LEFT$(string[,n]) 

    EXAMPLE:  N$="GFA-BASIC" 
               PRINT LEFT$(N$) 
               PRINT LEFT$(N$,3) 
               PRINT LEFT$(N$,12) 

    PURPOSE: Returns   the  first  character  or  the  first   "n"  
             characters(from the left) or a string. 

    EXPLANATION:  "string"  is  a  character string  or  a  string  
    variable.  "n" is a number or a numeric variable.   If "n"  is  
    not  an integer the editor only uses the integer part  of  the  
    number.  If "n" is not given then only the first character  of  
    the string is returned.   If "n" is larger than the length  of  
    "string"  then "string" itself will be returned.   If  "n"  is  
    zero then an empty string is returned. 
 

------------------
Function  LEN(a$) 
          TRIM(a$)


    EXAMPLE:   A$="Test" 
               x=Len(a$)+1             
               PRINT x,LEN("WORD")

Prints numbers 4 and 5

               b$="   test   "
               Print Len(b$)
               Print Trim$(b$)
               Print Len(trim$(b$))

Displays the number 10, the string "Test" without the empty spaces and
the number 4 on the screen.
 
 LEN returns the number of the charcters in the string a$

 TRIM$ removes empty spaces from the left and right of a string.


----------- 
Command LET 

    HOW: [LET] var=expression 

    EXAMPLE: DIM A(18) 
              LET A(15)=2*993 
              B=A(15) 
              N$=M$ 
              PRINT N$;B 

    PURPOSE: Assigns the value of an expression to a variable. 

    EXPLANATION:  "var"  can be a numeric or a string or an  array  
    variable. 

        "expression" can be another variable,  a number, a string,  
    combinations of variables, or a function. 

        The word LET is itself optional i.e.  LET A=B is identical  
    to A=B. 

        Care  must  be  taken  to match  the  type  of  "var"  and  
    "expression" otherwise the syntax error messages of  GFA-BASIC  
    will be appear. 
 

---------------------
Graphics Command LINE  

    HOW: LINE x0,y0,x1,y1 

    EXAMPLE:  Monochrome:  LINE 0,0,639,399 
                                  LINE 639,0,0,399 
              Color:  LINE 0,0,639,199 
                             LINE 639,0,0,199 

    PURPOSE:  Connects  two  points  (x0,y0) and  (x1,y1)  with  a  
        straight line. 

    EXPLANATION:   The origin for the coordinates is the left  top  
    corner of the screen.              

    x0 and y0 are the coorinates of the point where the line is to  
    start and x1 and y1 are the coordinates of the point where the  
    line is to finish.   The above example draws the two diagonals  
    of the screen. 

        This  command  is identical to the command DRAW  x0,y0  TO  
    x1,y1. 

    (see also DEFLINE) 
 

-----------------------------------
I/O Command LINE INPUT, LINE INPUT# 

    HOW: LINE INPUT["text";(,)]var[,var..] 
         LINE INPUT #n,var[,var...] 
    
    EXAMPLE:  LINE INPUT K$ 
              LINE INPUT A$,B$,C$ 
              PRINT AT(15,15); 
              LINE INPUT "Your name",N$ 
              LINE INPUT"Street & town:",S$,T$ 
   
    PURPOSE:  Makes it possible to enter a string  during  program  
             execution. 

    EXPLANATION:  "text" can be any string which is to be shown on  
    the screen prior to information being entered.  This text must  
    always be written in qultes.  "var" can be any string variable  
    name.  When  the  interpreter  comes  across  the  LINE  INPUT  
    command,  the execution of the program is stopped and the user  
    is able to enter a string from the keyboard.   With LINE INPUT  
    #n,  information  is  entered via  channel  "n".   Unlike  the  
    command INPUT,  a comma is not regarded as a separater but  as  
    part  of the character string.   Only RETURN is regarded as  a  
    separator.  LINE INPUT# will pick up the quotes around strings  
    written  out  to  disk  by  WRITE#,  where  INPUT#  does  not.   
    Therefore,  PRINT#  works better for sending data  which  will  
    later  be ready by LINE INPUT#(PRINT# does not write  out  the  
    quotes). 

    EXAMPLE: OPEN "0",#1,"test" 
             PRINT #2;"Michtron'e GFA BASIC" 
             PRINT #1;"here's a comma" 
             CLOSE #1 
             OPEN"I",#1,"test" 
             LINE INPUT #1 Company$,Dummy$ 
             PRINT Company$,Dummy$ 
             CLOSE 

    In all other respects the command is identical to INPUT. 


---------------- 
I/O Command LIST 

    HOW: LIST"filename" 

    EXAMPLE:  PRINT"Store in ASCII-Format" 
                 LIST"PROGR" 
                 PRINT "Listing on screen" 
                 LIST"" 


    PURPOSE: Stores the program currently in memory in diskette in  
             ASCII-Format. 

    EXPLANATION:   "filename" is the name under which the  program  
    is to be stored.  The use of the hierachical file system(\) is  
    allowed (see DIR). 

        If "filename" is the empty string then the program listing  
    is  shown ont he screen.   In all other cases the  command  is  
    identical to SAVE, A from the editor menu. 

        Programs  which  are to form part of  another  program  by  
    means of the MERGE command must be stored in ASCII-format with  
    LIST or SAVE,A. 

        If  no  extension is given in the filename  then  .LST  is  
    assumed. 

    If the filenames are not in quotes they are assumed present. 
 

-----------------
I/O Command LLIST 

    HOW: LLIST 

    EXAMPLE: PRINT "Printer listing" 
                      LLIST 

    PURPOSE: Prints the program currently in memory on the printer. 

    EXPLANATION:  The  printer listing can only be interrupted  by  
    switching off the printer.   After this the program can be run  
    or edited after about 30 seconds. 
 

----------------
I/O Command LOAD 

    HOW: LOAD "filespec" 

    EXAMPLE: SAVE "PROGRAM" 
               LOAD "PRO*" 

    PURPOSE: Loads a program into memory. 

    EXPLANATION: "filespec" is a file name which allows the use of  
    the specifications as in the DIR command (see DIR). 
    If  no  extension is given in the program name  then  .BAS  is  
    assumed. 

    If the filename is not in quotes they are assumed present. 
 

------------
Function LOC 

    HOW: LOC([#]n) 

    EXAMPLE:  OPEN "0",#1,"DAT" 
                PRINT #1,"1234567" 
                SEEK #1,3 
                PRINT LOC(#1) 

    PURPOSE: Returns the location of the file pointer for the file  
             with channel number "n". 

    EXPLANATION:  "n"  is an integer expression between 0  and  99  
    which refers to the number of the channel that has been opened  
    with OPEN. 

    Each  data  channel  has  a file pointer  which  points  to  a  
    particular  byte in the file.   The function LOC  returns  the  
    value  in the file pointer i.e.,  the displacement (in  bytes)  
    from the beginning of the file.   This is only valid until the  
    channel  is closed (after the channel is closed,  LOC  returns  
    0). 

    The  function  can  only be used on diskette  files  (not  for  
    CON:,LPT:etc.) 
 

-----------------------
Structure Command LOCAL 

    HOW: LOCAL var[,var...] 

    EXAMPLE: A=1000 
               PRINT A 
               GOSUB Subroutine 
               PRINT A 
               PROCEDURE Subroutine 
                 LOCAL A 
                 I=I+1 
                 A=I 
                 PRRINT A 
                 IF I=10 THEN 
                   GOSUB Subroutine 
                 ENDIF 
                 PRINT A 
               RETURN 

    PURPOSE: Declares "var" to be a local variable. 

    EXPLANATION:  "var" can be any variable name (except an  array  
    variable).  Local variables can only be used within PROCEDURES  
    (subroutines) in GFA-BASIC. 

    If these varriables are assigned values within a procedure the  
    value  of  any variables with the same name used  outside  the  
    procedure remains unchanged. 

    The above example demonstrates this by means of a  recursively  
    called procedure (procedure which calls itself). 

    (see also GOSUB, PROCEDURE, RETURN) 
 

------------
Function LOF 

    HOW: LOF([#]n) 

    EXAMPLE:   OPEN "0",#1,"DAT" 
                 PRINT LOF(#1) 
                 PRINT #1,"1234567" 
                 PRINT LOF(#1) 

    PURPOSE: Determines the length of the file with channel number "n". 

    EXPLANATION:  "n"  is an integer expression between 0  and  99  
    which refers to the number of the channel that has been opened  
    with OPEN. 

    The  function LOF (#n) returns the number of bytes  that  have  
    been allocated to the file with channel number "n"  (i.e.  the  
    length of the file). 

    If  a file has just been opened for output the file length  is  
    0. 

    The  function  can only be used for diskette  files  (not  for  
    CON:,LST: etc.). 
 

------------------
Function LOG LOG10 

    HOW: LOG(x) 
         LOG10(x) 

    EXAMPLE: A=2.718281818285 
               PRINT LOG(A) 
               PRINT LOG(A^2) 
               PRINT LOG10(10*10*10) 
               PRINT LOG10(2.456 

    PURPOSE: Determines the natual logarithm(LOG) or the logarithm  
             base 10(LOG10) of "x". 

    EXPLANATION: "x" is a numeric expression greater than 0. 

    LOG(x) calculates the natural logarithm (to the base e  where  
    e=2.71828182...). 

    LOG10(x) calculates the logarithm to the base 10. 
 

-------------
Function LPOS 

    HOW: LPOS(n) 

    EXAMPLE: FOR I=1 TO 600 
                 LPRINT "A"; 
                 IF LPOS(1)=30 THEN 
                  LPRINT 
                 ENDIF 
              NEXT I 

    PURPOSE: Returns the column in which the printer head (in  the  
             printer buffer) is located. 

    EXPLANATION:"n" can be any number.   The function returns  the  
    horizontal position of the printer head.   The counting of the  
    columns begins with 0. 

        The value returned by this function will not correspond to  
    the actual physical position of the printer head in every case  
    because for this function only the characters actually printed  
    by  the printer are counted.   CR,LF,  and BS  [CHR$(13,10,9)]  
    affect the value of LPOS. 
 

------------------
I/O Command LPRINT 

    HOW: LPRINT[expressions[,][;][']] 

    EXAMPLE:  A$="GFA"        
                B=1986 
                LPRINT A$' 
                LPRINT B, 
                LPRINT A$,B;"GFA" 
                LPRINT A$'''''B 
                LPRINT USING "###.###",PI*100 

    PURPOSE: Prints data on the printer. 

    EXPLANATION:  "expressions" is any number of expressions  that  
    are separated by commas or semicolons or apostrophes.  If none  
    of these are used a semicolon is assumed. 

    This  command is similar to the PRINT command in all  respects  
    aprt from the fact that the option AT(x,y) cannot be used. 
    (see also PRINT and PRINT USING) 
 

---------------------
Command    LSET a$=b$
           RSET a$=b$        


    EXAMPLE: A$="AAAAAAAAA"    
               B$=SPACE$(7) 
               C$="GFA" 
               LSET A$=C$ 
               LSET B$="GFA-BASIC" 
               PRINT A$;B$ 

    PURPOSE: Purs "string" in the string variable "var"  justified  
             to the left for LSET and right for RSET. 
  
  EXPLANATION: "var" is the name of a string variable.  "string"  
    is  any  character string expression.   The  character  string  
    "string" is put in the string variable "var".   If "string" is  
    shorter than "var" then the unused part of "var" will  contain  
    spaces.   If "string" is longer than "var" then "string" willb  
    e truncated from the right. 

    LSET is normally used in conjunction with FIELD when  creating  
    a random access file.  In this case the numeric values must be  
    transformed  into strings with MKI$,MKS$,MKF$ or  MKD$  before  
    the command LSET can be used. 

    The opposite of LSET is the command RSET. 
 

------------
Function MAX 

    HOW: MAX(expression[,expression...]) 

    EXAMPLE:   a=17 
                  b-3 
                  a$-"aaa" 
                  PRINT MAX(A,B,2*2) 
                  PRINT MAX(a$,"AAAA") 

    PURPOSE: Returns the greatest value (or largest string) from a  
             list of expressions. 

    EXPLANATION: "expression" is any numeric or string expression.   
    All expressions in the list of expressions must be of the same  
    type (i.e. all numeric or all string). 

    If the expressions are numeric then the one with the  greatest  
    value is returned. 

    If  the  expression are strings then the "largest"  string  is  
    returned (by means of the ">" operator).   See the chapter  on  
    Comparison operators. 

    The opposite of MAX is the function MIN. 
 

-------------
Function MID$ 

    HOW: MID$(string,a[,n]) 

    EXAMPLE: N$="GFA BASIC" 
              PRINT MID$(N$,5) 
              PRINT MID$(N$,1,3) 
              PRINT MID$(N$,3,12) 

    PURPOSE: "string"  is a character string or a string  variable  
             and  "a" and "n" are integer constants  or  variables  
             (decimal numbers can also be used, however the editor  
             will only recognize the integer part). 

        If  the optional parameter "n" is not used,  the  function  
    returns  all characters of the character string "string"  from  
    the position "a" onwards.  Otherwise a part-string is returned  
    which  starts at the character "a" and contains "n" amount  of  
    characters (spaces are also counted). 

        a=0  produces the same result as a=1.   If "n"  is  larger  
    than the number of characters from "a" to the end of "string",  
    MID$(string,a)  is  returned,  if n=0,  an empty  string  will  
    result. 
 

------------
Function MIN 

    HOW: MIN(expression[,experssion...]) 

    EXAMPLE:  a=17 
                b=3 
                a$="aaa" 
                PRINT MIN(A,B,2*2) 
                PRINT MIN(a$,"AAAA") 

    PURPOSE: Returns the smallest value (or smallest string)  from  
             a list of expression. 

    EXPLANATION:    "expression"   is   any  numeric   or   string  
    expression. All expressions in the list of expressions must be  
    of the same type (i.e. all numeric or all string). 

        If  the  expressions  are numeric then the  one  with  the  
    smallest value is returned. 

        If the expressions are strings then the "smallest"  string  
    is returned (by means of the "<" operator).   See the  chapter  
    on Comparison operators. 

    The opposite of MIN is the function MAX. 
 

-----------------
I/O Command MKDIR 

    HOW: MKDIR"directory name" 

    EXAMPLE: MKDIR"DH0:\DIRECTORY1" 
               MKDIR"DH0:\DIRECTORY1\DIRECTORY2"  
               FILES"DH0:\*.*" 
               FILES"DH0:\DIRECTORY1\*.*" 

    PURPOSE: Creates a new diretory. 

    EXPLANATION:   "directory  name"  is  the  name  of  the   new  
    directory.  It is possible to use the hierarchical file system  
    (\) when choosing the name: 

        If a directory name not using the hierarchical file system  
    (\) is placed in the quotes,  the directory will be creatd  in  
    the  directory  that  is  being  used  at  the  time   (change  
    directories with CHDIR). 

        If the directory is to be created in a specific directory,  
    it   is  necessary  to  indicate  the  search  path  for   the  
    destination directory.   When starting from a root  directory,  
    this      must      be      "\".        Therefore,       MKDIR  
    "\VEHICLE\LICENCENO\DRIVER" wwould create a directory with the  
    name  DRIVER  in  the directory  LICENCENO  of  the  directory  
    VEHICLE in the root directory. 

        If a specific disk drive is to be used, it is necessary to  
    place the letter of the disk drive,  followed by a  colon,  in  
    front of the directory name (e.g. "DH0:\DIRECTORY"). 
 

---------------------------------
Function MKI$,MKL$,MKS$,MKF$,MKD$ 

    HOW: MKI$(n) 
         MKL$(n) 
         MKS$(n) 
         MKF$(n) 
         MKD$(n) 

    EXAMPLE:  A=0.1111 
                PRINT MKF$(A) 
                FOR I=O TO 5 
                 Z=PEEK(VARPTR(A)+I) 
                 PRINT Z,CHR$(Z) 
               NEXT I 

    PURPOSE: Transforms a numeric value into a character string. 

    EXPLANATION:  "n"  is  a numeric  expression.   The  functions  
    transforms   the  values  of  the  numeric  expressions   into  
    character strings as follows: 
 
    MKI$ transforms a 16-bit integer into a 2-byte string. 

    MKL$ transforms a 32-bit integer into a 4-byte string. 

    MKS$ transforms a number into an Atari BASIC compatible 4-byte  
        format.                       

    MKF$ transforms a number into GFA-BASIC'S own 6-byte format. 

    MKD$  transforms a number into an  MBASIC  compatible  8-byte  
         format. 

        Every  numeric  vlaue  that is to be stored  in  a  random  
    access file must first be transformed into a character  string  
    with one of the above functions. 

        The example shows that GFA-BASIC stores numbers internally  
    in  the 6-byte format which can also be created by  using  the  
    MKF$ functions. 

        The corresponding reverse functions: 

        CVI,CVL,CVS,CVF, and CVD. 
 

----------------------
Graphics Command Mouse 

    HOW: MOUSE mx,my,mk 

    EXAMPLE: DO 
                MOUSE A,B,C 
                PRINT AT (1,1);A,B,C 
              LOOP 


    PURPOSE: Determines the mouse position (mx,my) and the status of  
    the mouse buttons (mk). 

    EXPLANATION:   The  mouse can be moved over the entire  screen  
    area,   The origin for the coordinates is the top  
    left-hand corner of the screen.  The command MOUSE returns the  
    current position of the mouse and stores this as the  vertical  
    and  horizontal  values mx and my.   "mk"  contains  the  current  
    status of the mouse buttons as follows: 

        0 if no button is pressed down 

        1 if the left button is pressed down 

        2 if the right button is presed down 

        3 if both buttons are pressed down 

        4 if middle mouse button 


-------------------------------
Function MOUSEX, MOUSEY, MOUSEK 

    HOW: MOUSEX 
         MOUSEY 
         MOUSEK 

    EXAMPLE: DO 
              X=MOUSEX 
              Y=MOUSEY 
              K=MOUSEK 
              PRINT AT (1,1);X,Y,K 
             LOOP 

    PURPOSE: Returns mouse position or button status. 

    EXPLANATION: MOUSEX returns the x(horizontal) coordinate of he  
    mouse pointer,  MOUSEY returns the y(vertical) coordinate

    The origin  for  these  
    values is the top left-hand corner of the screen. 

    MOUSEK returns the status of mouse buttons as follows: 

        0 if no buttons are being pushed 

        1 if the left button is being pressed 

        2 if the right button is being pressed 

        3 if both buttons are being pressed 

        4 if middle button


----------------------
Arithmetic Command MUL 

    HOW: MUL var,n                        

    EXAMPLE:  Dim A%(10000) 
              ARRAAYFILL A%(),5 
              T=TIMER 
              FOR I=1 TO 10000 
               MUL A%(I),5 
              NEXT I 
              PRINT (TIMER-T)/200 
              T=TIMER 
              FOR I=1 TO 1000 
               A%(I)=A%(I)*5 
              NEXT I 
              PRINT (TIMER-T)/200 

    PURPOSE:  Multiplies the value in the 'var" by 'n'. 

    EXPLANATION:  'var"  must be a numeric variable or  a  numeric  
    array variable.  'n" is a number or other variable.  MUL var,n  
    is  identical  to var=var*(n).   The advantage  in  using  MUL  
    however  lies in its speed of execution.   (Try the  example).   
    By  using  MUL  the already high execution  speed  is  further  
    improved (By about 30% In the example). 
 

---------------------------
FUNCTION      MALLOC(x,art)
              MFREE(y,a)

Malloc serves to reserve (allocate) blocks of memnory. If x is a postive
number then x bytes will be allocated and the address will be returned. if
an error is encountered, a zero or some negative value is returned.

2(&H2) MEMF_CHIP chip memory, can also be used for graphic chips

1(&H1) MEMF_PUBLIC when comaptiblity of future os's is to ensured

4(&H4) MEMF_FAST memory outside of graphic chip range will be used

65535(&H10000) MEMF_CLEAR can be combined with all other types

adr%=MALLOC(60000,&H10000)
Print adr%
If adr%0
return%=MFREE(adr%,60000)
Endif

Reserves 60000 bytes in size and then returns it.


-----------------
Command    MODE n

 Through MODE, decimal points amd commas denoting thousands as well as
decimal commas and points denoting thousanths can be exchanged.  Besides
this, the format of the date presentaion can be selected. Points and
commas are used for PRINT USING and STR$(x,v,n) The date setting applies
to DATE$, SETTIME, DATE$=and FILE$.

parameter n      Using    DATE$
-----------------------------------
MODE 0          ,###.##   16.05.1990
MODE 1         #,###.##   05/16/1990
MODE 2         #.###,##   15.05.1990
MODE 3         #.###,##   05/16/1990


---------------------------
Graphics       MOVES no,x,y

  The position that the screen is to drawn is given in x and y in the
command OPENS.  With MOVES the position can be changed.

OPENS 1
OPENS 2
OPENW 0
FRONTS 1
FOR x&=0 to 2
for i&=0 to 100
MOVES x&,0,i&
NEXT i&
NEXT x&

 two windows are opened and moved.


-----------------------
Graphics   MOVEW no,x,y
           SIZEW no,w,h
           LIMITW no,min_x,min_y,max_x,max_y

MOVEW moves the window wit the index "no" to the absolute x and y position
relative to the upper corner of the screen.  The window index "no" can be
enlarged or shrunk with the SIZEW command. w and h contain the new width
and height of the window. LIMITW set the minimum and the maximum size of a
window.  min_x and min_y contain the minimum size of the window and max_x
and max_y contain the maximum size of the window. This applies to changing
the window size with the mouse as well as with the commad SIZEW

OPENS 1
OPENS 2
OPENW 0,0,0,160,100,0,15,1
OPENW 1,0,0,160,100,0,15,2
LIMITW 0,100,100,200,200
FULLW 0
FULLW 1


----------------
I/O Command NAME 

    HOW: NAME "oldfile" AS "newfile" 

    EXAMPLE:  OPEN "O",#1,"OLDFIL" 
              CLOSEE #1 
              FILES 
              NAMES "OLDFIL" AS "NEWFIL" 
              FILES 

    PURPOSE: Canges the name of a file. 

    EXPLANATION:   :"oldfile" and "newfile" are file names.   When  
    choosing  the names the hierarchical file system (as in  MKdIR  
    for example) is allowed. 

        The  command  searches (in the  appropriate  directory  if  
    given)  for the file alled "oldfile" and changes its  name  to  
    "newfile".  The contents of the file are not affected by this. 

        The comandcan only refer to one drive.  If "oldfile" is on  
    drive DH0: (i.e.  with the prefix DH0:) then "newfile" must also be  
    on this drive.  It is possible to put "newfile" into any other  
    directory.  i.e. the folowing is allowed: 

        NAME  "DH0:PART" AS "\CAR\PARTNR\.   This renames  the  file  
    "PART"  in the root directory as "PARTNR" and puts it  in  the  
    "car" directory (The file "PART" then no longer exists). 
 

-----------
Command NEW 

    HOW:NEW 

    EXAMPLE: PRINT "Program is deleted!" 
             NEW 
    PURPOSE:   Deletes  the  program currently in memory  and  all  
    variables. 
 

--------------------------------- 
 OBJECT statements and functions 
 

  o Syntax

 OBJECT.AX        object_id,value
       .AY        '             '
       .CLIP      (x1,y1)-(x2,y2)
       .CLOSE     [object_id,[object_id...]]
       .HIT       object_id,[memask][,hitmask]
       .ON        object_id[,object_id...]]
       .OFF       '                       '
       .PLANES    object_id[,plane_pick][,plane_on_off]         
       .PRIORITY  object_id,value
       .SHAPE     object_id1,{string_expression|object_id2}
       .START     object_id[,object_id...]]
       .STOP      '                       '
       .VX        object_id,value
       .VY        '             '
       .VX        (object_id)
       .VY        '         '
       .X         object_id,value
       .Y         '             '
       .X         (object_id)
 OBJECT.Y         '         '

  o Effect

 These are the AMIGABASIC compatible object (or sprite) statements and
functions. These described in detail in the AMIGAbasic manual.


-------------
Function OCT$ 

    HOW: OCT$(x) 

    EXAMPLE:  A=1 
              B=&H22 
              PRINT OCT$(A) 
              PRINT OCT$(234) 
              PRINT OCT$(B) 

    PURPOSE: Changes  the value "x" into a character string  which  
             shows the value of "x" in octal form. 

    EXPLANATION:   "x"  can be an integer between -21474483648  and  
    +214744833647  in  any  form (i.e.  the  normal  decimal  form  
    without prefix,  in hexadecimal form (prefix & or  &H),  octal  
    form, (prefix &O), binary form (prefix &X). 

        OCT$   changes  the  value  "x"  to  a  character   string  
    containing the octal value of "x" (i.e. B in the above example  
    produces the string "42"). 

        OCT$(and also BIN$ and HEX$) always produces values as 32- 
    bit  digits without a sign,  but these are always  treated  as  
    signed integer values. 

    (see also HEX$(x), BIN$(x) and STR$(x)). 
 

----------------------------
Structure Command ON...GOSUB 

    HOW: ON expression GOSUB procedure list 

    EXAMPLE: DO 
              INPUT A 
              ON A GOSUB PRO1,PRO2 
             LOOP 
             PROCEDURE PRO1 
              PRINT "1<=A<2" 
             RETURN 
             PROCEDURE PRO2 
              PRINT "2<=A<3" 
             RETURN 

    PURPOSE: Depending  on the value of the "expression",  one  of  
             several given procedures is processed. 

    EXPLANATION:  "expression"  can  be  any  numeric  expression.   
    "procedure  list"  is  a  set of  procedure  names  which  are  
    separated by commas.   If the value of the integer portion  of  
    the  expression  is  greater than or equal  to  1,  the  first  
    procedure in the list is processed.   If the value is equal to  
    2,  the second procedure in the list is  processed,  etc.   No  
    procedure  is called up when the given value falls outside  of  
    the  number of procedures listed after GOSUB (e.g.  0 or 3  in  
    the above example). 
 

---------------------------
Command ON BREAK
        ON BREAK CONT 
        ON BREAK GOSUB name 
    
   HOW: ON BREAK 
        ON BREAK CONT 
        ON BREAK GOSUB name 

    EXAMPLE: ON BREAK GOSUB comment 
              PRINT"interrupt program" 
              REPEAT 
              UNTIL MOUSEK 
              ON BREAK 
              PROCEDURE comment 
               PRINT "No interruption possible" 
              RETURN 

    PURPOSE: These  three  routines determine how a  program  will  
             react  when  a user attempts to  interrupt  it,  i.e.  
             whether  a  break will occur,  whether  nothing  will  
             happen,  or  whether a procedure called name will  be  
             executed. 

    EXPLANATION:  "name" is a procedure name.   A standard program  
    can  be  interrupted  by  pressing  <CONTROL>,   <SHIFT>   and  
    <ALTERNTE>   simultaneously.    The  command  ON  BREAK   CONT  
    deactivates  this command sequence (so it is not  possible  to  
    break the program), ON BREAK reactivates it. 

        The  command  ON BREAK GOSUB "name" makes it  possible  to  
    jump   to   the  procedure  "name"  by  pressing   the   above  
    combination.  The  command  ON BREAK also deactivates  the  ON  
    BREAK  GOSUB,  so that a break will occur if the  three  above  
    mentioned keys are pressed simultaneously. 
 

----------------------
Command ON ERROR
        ON ERROR GOSUB 

    HOW: ON ERROR 
         ON ERROR GOSUB name 

    EXAMPLE: ON ERROR GOSUB error routine 
             PRINT SQR (-1) 
             PRINT 3/0 
             ON ERROR 
             PRINT SQR (-1) 
             PROCEDURE errorroutine 
              PRINT "Error No>:";ERR 
              ON ERROR GOSUB errorroutine 
              RESUME NEXT 
             RETURN 

    PURPOSE: Performs the procedure "name" when an error occurs. 

    EXPLANATION:  "name"  is  a procedure  name.   When  an  error  
    occurs,  the  program branches to the procedure  "name".   The  
    program  is  not interrupted and no system  error  message  is  
    given.  The command must be present in the program before  the  
    error occurs,  and branches only once to the procedure.   If a  
    further error appears,  the corresponding system error message  
    is issued.  If it is necessary to branch with every error then  
    this  mode  must  be switched on each time  within  the  error  
    routine by ON ERROR GOSUB before returning to the main program  
    (see example). 

        The  command  ON ERROR switches the program  back  to  the  
    normal error handling procedure. 
 

---------------- 
I/O Command OPEN 

    HOW: OPEN"mode",[#]n, "file name"[,len] 

    EXAMPLE: OPEN "O",#1,"NAME" 
             PRINT #1,"Gfa BASIC" 
             OPEN "I",#2,"NAME" 
             DO 
              EXIT IF EOF(#2) 
             LOOP 
             CLOSE 

    PURPOSE: Opens a data channel to a diskette file. 

    EXPLANATION:  "mode"  must always be written in quotes and  is  
    one  of  the characters O,I,A,U or R.   "O" opens a  file  for  
    output creating a new file if necessary.  "I" opens a file for  
    input.  "A"  enables data to be appended to an existing  file.  
    "U" enables both reading and writing on a file,  however,  the  
    file  must have been created by opening with  "O"  beforehand.   
    Opening  with a "U" will not create a new file.   "R" opens  a  
    Random Access File. 

        "n" is an integer expressionb etween 0 and 99 and  defines  
    the  channel number which will be used throughout the  program  
    for  input and output operations until the channel  is  closed  
    using CLOSE. 

        "filename" is the name of the file.  The hierarchical file  
    system (as in DIR) may be used.   If one wishes to assign  the  
    file to a specific disk drive,  for example disk drive DF0, this  
    is done by using the prefix "DF0:". 

        Note  that  you  can  open  a  file  twice,  on  different  
    channels, even in different modes  (see example). 

        System devices can also be used as filenames: 

    "CON:"  for the console 

    "LST:" or "PRT:" for the printer 

    "AUX:"  for the serial interface cards 

    "MID:" for the MIDI ports 

    "VID:" for the console in transparent mode (commands are 
           shown on the screen as special characters, not  
           executed). 

    "IKB:" for direct access to the 6301 keyboard processor 
           (CAUTION!). 

    The  access  codes (O I A U R) are not required in  the  above  
    mentioned  device names.   Therefore it is only  necessary  to  
    enter an empty string"". 

        "len"  is  only used in random access files.   It  is  the  
    length of a file entry.   If this parameter is not present,  a  
    length of 128 bytes is designated. 
 

-------------
Command OPENW 

    HOW: OPENWn[,x,y] 

    EXAMPLE:  OPENW 1,320,200 

    PURPOSE:   "n"  is a numeric expression which has  the  window  
    number  as  its value.   The optional parameters "x"  and  "y"  
    define the point of contact for the four possible windows. 

        The  four possible windows are arranged on the  screen  in  
    the four quadrants shown.   The point of contact is the  point  
    where the four windows meet (they may not overlap).   Each  of  
    the  four  windows  has a corner which remains  fixed  to  one  
    corner of the screen.  The "point of contact" then defines the  
    size and shape of the windows.   The numbering of the  windows  
    is set as follows: 

                            |         * x,y,defines this point 
                 1          |      2 
        ____________________*_____________________ 
                            | 
                 3          |      4 
                            | 

        After using the command OPENW 0 the whole screen,  without  
    the  menu bar,  is used as a window.   The starting point  for  
    graphics commands is set with OPENW 0,x,y. 

        You  should  only specify x and y for  one  window  (which  
    defines  the  point  of contact for all  four)  otherwise  the  
    screen gets confused.   If you need to change the  coordinates  
    of the point of contact,  it is best to close all windows  and  
    reopen  them,  specifying the point of contact with the  first  
    window you open. 
 

---------------
I/O Command OUT  

    HOW: OUT x,a 
         OUT #n,a 

    EXAMPLE:  OPEN "O",#1,"DAT" 
              OUT #1,65 
              CLOSE #1 
              OPEN "I",#1,"DAT" 
              PRINT INPUT$(1,#1) 
              OUT,2,66  

    PURPOSE: Transfer  a byte with the value "a" to  a  peripheral  
             device/file. 

    EXPLANATION:   "x" is an integer expression
    "a" is an integer expression which should have a value between  
    0 and 255.   If the value is greater then only (a mod 256)  is  
    used. 

        OUT  x,a  transfers  a  byte with the  value  "a"  to  the  
    peripheral device defined by "x". 

        OUT  #n,a  transfers a byte with the value "a" to  a  file  
    which is assigned to the data channel "n". 
 

-------------
Command PAUSE 
        DELAY

    HOW: PAUSE x 
         DELAY x

    EXAMPLE:  Print "Please wait 5 seconds!" 
                  PAUSE 100         100 or 2 = 2 seconds 
           or     DELAY 2
                  PRINT "Ready!" 
    PURPOSE: Interrupts  program execution for an exactly  defined  
             period of time. 

    EXPLANATION:   "x"  is a numeric expression which has a  value  
    which lies between -2147483648 and +2147483647 (integers). 

        The command creates a pause in the program,  the length of  
    which is (x)/50 seconds. 

--------------------


--------------------
Graphic Command PBOX 

    HOW: PBOX x0,y0,x1,y1 

     See BOX                                                    

------------------------
Graphics Command PCIRCLE 

    HOW: PCIRCLE x,y,r[phi0,phi1] 

     See CIRCLE                                                 

-------------------------
Graphics Command PELLIPSE 

    HOW: PELLIPSE x,y,rx,ry{phi0,phi1] 

     See ELLIPSE                                               

----------------------
Graphics Command PRBOX 

    HOW: PRBOX x0,y0,x1,y1 

    See: RBOX 

    EXPLANATION OF ALL COMMANDS ON THIS PAGE: 

        These  commands  are  very similar to  the  commands  BOX,  
    CIRCLE, ELLIPSE, and RBOX, the difference being that they draw  
    filled-in shapes.   The type of filling must be defined  first  
    by the command DEFFILL.   Further information is given in  the  
    explanations of the aforementioned commands. 
 

---------------
Functions PEEK
          DPEEK
          LPEEK 

    HOW: PEEK(x) 
         DPEEK(x) 
         LPEEK(x) 

    EXAMPLE: A$="A" 
             D=ARRPTR(A$) 
             A=LPEEK(D) 
             L=DPEEK(D+4) 
             C=PEEK(A) 
             PRINT "DES.ADDRESS"""D 
             PRINT "ADDRESS"""A 
             PRINT "LENGTH"""L 
             PRINT "ASCICODE"""C 

    PURPOSE: Returns  the  contents of 1,2,  or 4  bytes  of  main  
             memory. 

    EXPLANATION:  "x"  is a numeric expression which specifies  an  
    address in the main memory.   The value of "x" must be an even  
    number in the functions DPEEK and LPEEK. 

    PEEK(x) returns the contents of the byte in address "x". 

     DPEEK(x)  returns the contents of two  consecutive  bytes  in  
   address "x" and "x+1" as 16 bit binary numbers in decimal  form  
   (e.g.  if  the first byte has the value 11 and the second  189,  
   then  by  calculating 11*256+189 DPEEK(x)  returns  the  number  
   3005). 

    LPEEK(x)  works in a similar way to DPEEK(x),  except that  in  
    LPEEK(x) the value of 4 bytes is returned.   If,  for example,  
    the  content of address "x" is 8,"x+1" has the value  45,  the  
    next  address  contains 156,  and the last byte  contains  the  
    value  126,  then by  calculating  8*1^24+45*2^16+156*2^8+126,  
    LPEEK(x) returns the value 137206910. 

        In  the  example  at the beginning,  the  address  in  the  
    Descriptor  which contains A$ is located by using  LPEEK,  the  
    length  of  the string is ascertained by DPEEK and  the  ASCII  
    code  of  "A"  by PEEK(see  also  Appendix  D:  Variables  and  
    Variable Organization). 


-----------
Function PI 

    HOW: PI 

    EXAMPLE: INPUT R 
               U=2*PI*R 
               F=PI*R*R 
               PRINT U,F 

    PURPOSE: Returns the value of PI. 

    EXPLANATION:   PI describes the relationship of  circumference  
    to diameter in a circle.  The value is: PI=3.141592653... 

        The  above  example  uses  the radius  of  the  circle  to  
    calculate its circumference and area. 
 

---------------------
Graphics Command PLOT 

    HOW: PLOT x,y 

    EXAMPLE: PLOT 320,199 
                              
    PURPOSE: Draws a point on the screen. 

    EXPLANATION:   "x" and "y" are the coordinates for the  screen  
    dot.   The  coordinates  start at the top left corner  of  the  
    screen.   "x" represents the horizontal row starting from  the  
    left  hand  side  of the screen and "y"  the  vertical  column  
    starting from the top of the screen. 

        This command is identical to the command DRAW x,y. 

        If  a  line  width has been defined  by  DEFFLINE,  it  is  
    necessary to set its value back to 1, otherwise no dot will be  
    drawn.  There is,  however,  an exception to this rule: if the  
    beginning and end type of DEFLINE (the two last parameters) is  
    "rounded'2",  a  large dot,  varying in size according to  the  
    line width set, will be drawn. 
 

--------------
Function POINT 

    HOW: POINT(x,y) 

    EXAMPLE: PLOT 100,100 
               PRINT POINT (99,100) 
               PRINT POIINT (100,100) 

    PURPOSE: Checks  whether a graphic dot has been set  and  then  
             returns its color value. 

    EXPLANATION:  "(x,y)" are the coordinates of a screen dot. The  
    coordinates  start at the top left hand corner of the  screen.   
    

-------------
Command POKE
        DPOKE
        LPOKE 

       HOW: POKE x,n 
            DPOKE x,n 
            LPOKE x,n 


    EXAMPLE: A$="A" 
               L=ARRPTR(A$) 
               DPOKE L+4,4 
               Z=VAPRTR(A$) 
               LPOKE Z, 1111638594                       
               PRINT A$ 
               POKE Z,67 
               PRINT A$ 

    PURPOSE: Writes  1,2,  or 4 bytes into an area of main  memory  
             which begins with the address "x". 

    EXPLANATION:  "x"  is a numeric expression which specifies  an  
    address in the main memory.   The value of "x" must be an even  
    number  in  the commands DPOKE and LPOKE.   "n" is  a  numeric  
    expression,  the value of which must lie between 0 and 255 for  
    POKE,  between  0 and 65535 for DPOKE and between  -2147483648  
    and +2114744833648 for LPOKE. 

        POKE x,n writes a byte (with the value "n") into the  area  
    of main memory with the address "x" . 

        DPOKE x,n writes the value "n" in two consecutive areas of  
    main memory with the addresses "x" and "x+1". 

        If,  for example, "n" had the value 257, the value 1 would  
    be placed by POKE in both "x" and "x+1", i.e. 157=1*2^8+1. 

        LPOKE  x,n writes the value "n" into the four  consecutive  
    bytes  which  begin with the address "x" (if the  value  1  is  
    written in all four bytes,  then "n" had the value 16843009 by  
    the following calculations: (1*2^24+1*2^16+1*2^8+1). 

        As  the  highest  value  for  "n"  is  2147483647,  it  is  
    necessary  to  use  the complement in order  to  place  values  
    greater than 127 in the first byte. (e.g. by using LPOKE x,-1,  
    all 4 bytes are given the value 255). 

        The  commands mentioned here all work in the user mode  of  
    the 68000 CPU,  i.e.  reserved memory (usually the areas 0  to  
    2047 and the area over 9 MBytes) cannot be accessed.  An error  
    will occur if you attempt it. 

        In  order to reach these storage areas it is necessary  to  
    use the POKE commands in Supervisor mode:   SPOKE, SDPOKE, and  
    SLPOKE  (see  the  revelant  section  for  details  of   these  
    commands). 

        The  opposite  of  POKE commands are  the  PEEK  commands.   
    These always work in supervisor mode. 

        In the above example the variable A$ is given a  different  
    value  by  using  POKE commands (see Appendix  D  for  further  
    explanation). 
 

----------------------------------
Graphics Command POLYLINE POLYFILL

    HOW: POLYLINE n,X(),Y()[OFFSET X0,Y0] 
         POLYFIL n,X(),Y()[OFFSET X0,Y0] 
          
    EXAMPLE:    OPENW 0
                GRAPHMODE 1
                DIM X%(30),Y%(30) 
                DO               
                COLOR RAND(64),RAND(64),RAND(64)
                DEFFILL 1,RAND(4),RAND(25)
                FOR I%=0 TO 30
                X%(I%)=RAND(320)
                Y%(I%)=RAND(200)
                NEXT I%
                POLYFILL 30,X%(),Y%()
                LOOP


  PURPOSE: Draws  random filled polygrams with 30 corners.


    EXPLANATION: "n" is a numeric expression (with a maximum value  
    of 128) which states the number of dots which are to be joined  
    by  straight lines.   If a closed "n-corner" is to  be  drawn,  
    then n+1 corner dots must be specified (the first and last dot  
    must be identical).   POLYLINE works similarly to DRAW but  is  
    considerably  quicker  than DRAW,  especially when  using  the  
    integer fields X%() and Y%().   X() and Y() are numeric fields  
    which  contain the coordinates of the "n" dots from which  the  
    shapes  will be drawn.   Note:   it is necessary to store  the  
    first dot in X(0) and Y(0). 

        If  OFFSET  is used,  the whole shape  will  be  displayed  
    offset X0 horizontally and Y0 vertically (see example). 

        POLYFILL draws a filled-in shape.   The first and last dot  
    are  joined by a straight line and the space inside the  shape  
    is filled with the pattern selected by DEFFILL.   Areas  where  
    lines cross each other, however, are not filled-in. 
 

------------
Function POS 

    HOW: POS(n) 

    EXAMPLE:  FOR I=1 TO 600 
                  PRINT "A"; 
                  IF POS(1)=30 THEN 
                   PRINT 
                  ENDIF 
                  NEXT I 

    PURPOSE: Returns the column in which the cursor is positioned. 

    EXPLANATION:  "n" is a dummy argument.   The function  returns  
    the horizontal position of the cursor.   The columns start  in  
    this case at the value 0. 

        The  value returned does not always have to correspond  to  
    the  actual  position  of the cursor  as  only  the  resulting  
    characters are counted and PRINT AT,  cursor  commands,  etc.,  
    are  ignored.   Only CR,  LF and BS[CHR$(13,10,8)]  reset  the  
    value of POS. 

        If  a  string  of over 80 characters  without  a  carriage  
    return  (e.g.  PRINT SPACE$(100);) is printed on  the  screen,  
    then POS also returns a value greater than 80 (in the example,  
    100). 
 

---------------------
Commands     PRED(|)
             SUCC(|)
             PRED(a$)
             SUCC(a$)

PRED(|)    returns the next smaller number

SUCC(|)    returns the next higher number

PRED(a$)   returns the character that is one ASCII value lower

SUCC(a$)   returns the character that is one ASCII value higher

charcter$="B"
previous$=PRED(character$)
next$=SUCC(character$)
PRINT previous$,character$,next$

e%=6
j%=PRED(e%)
PRINT j%,SUCC(2),PRED(3*e%)


------------------------------------------
I/O Commands PRINT
             PRINT #
             PRINT AT(col,line);expression
             WRITE expression
             LOCATE line,col
  
    EXAMPLE:  A$="GFA" 
                B=1986 
                PRINT A$" 
                PRINT B, 
                PRINT A$,B;"GFA" 
                PRINT 
                PRINT A$"""""B 
                PRINT At(77,25);a$; 

    NOTE:    PRINT  At(77,25) refers to printing at 77 across  and  
             25 down. 

    PURPOSE: Displays  information on the screen or  data  channel  
             "n". 

    Explanation:  "expr"  can be any number of  expressions  which  
    must be separated by commas,  semicolons or  apostrophes.   If  
    these   characters   are  missing  a   semicolon   is   placed  
    automatically. 

        If a semicolon is placed between two expressions they  are  
    displayed  one after the other in one line (this is also  true  
    of  digits  as GFA BASIC does not reserve a space  before  and  
    after these). 

        If  a  comma  is  placed  between  expressions  these  are  
    displayed  at  intervals of 16 columns  (i.e.  the  expression  
    after the coma begins at column 17..33..49..etc. 

        If  apostrophes  are placed between expressions  then  one  
    space is left for each apostrophe. 

    If  neither  a semicolon,  colon nor an apostrophe  is  placed  
    after "expr",  a CRLF (carriage return with line feed) is made  
    i.e.  the cursor moves to the beginning of the next line.   If  
    the  command ends with a semicolon,  comma or  apostrophe,  no  
    CRLF takes place. 

        The  optional  addition,  AT(c,l),  makes it  possible  to  
    display  information  at  a  certain  place  on  the   screen.   
    Usually,  the  screen  has  25 lines (1) and  80  columns  (c)  
    beginning at the top left hand corner.  The coordinates of the  
    top  left  of the screen are 1,1.   When the  screen  position  
    (c,l)   is   specified  the  cursor  is  positioned   in   the  
    corresponding  column/line  indicated (It is necessary  to  be  
    careful  when something is to be put in the last line  of  the  
    screen.  It is important to close the command with a semicolon  
    to avoid scrolling - see above example) 

        Only the command PRINT can create a line space. 

        The PRINT #n command prints "expr" to the data channel "n"  
    which  must have previously been opened.   The format  of  the  
    data  PRINTED  to the file is identical to that of  the  PRINT  
    command. You may not use AT with the PRINT #n. 
 

-----------------------
I/O Command PRINT USING 

    HOW: PRINT USING "format",list[;] 
         PRINT #n, USING "format", list[;] 

    EXAMPLE:    PRINT AT (7,5); USING 
          ......."###,##",PI*100 
          PRINT USING "A!b","lambda" 

    PURPOSE:  Issues formatted digits and character strings. 

    EXPLANATION:   "format" is a string expression which sets  the  
    printing format (see below).   "list" is a list of expressions  
    separated by commas. 

    Format Description: 

        #    Reserves  space for digits.   If you do  not  reserve  
             enough digits to fully display the number it will  be  
             printed ignoring the format string with a "5" at  the  
             front. 

        .    Position of the decimal point. 

        +    Prints a plus sign. 

        -    Reserves space for a minus sign.  The sign  is  only  
             printed if the number is negative. 

        *    Reserves  space for a digit(just like #,above) but  a  
             "*" is printed (rather than a space) if the  reserved  
             digit is not needed,  i.e.  PRINT using "***",2 gives  
             "**2". 

    $$ or $  Prefix $. 

        ,    Insert a comma. 

    ^^'^^    Display in exponential form.   The number of  Karats  
             corresponds to the number of digits plus "E" and  the   
             sign (+/-). 

        !    Indicates  that  the first character of a  string  is  
             Printed. The second example above results in "A!b". 

        &    The whole string is printed. 

        \.\  As many characters of the string are printed as there  
             are characters in \.\ (including back-slashes). 

        _    Treats  the next character in the format string as  a  
             character,  rather than as a format  command.   Thus,  
             the  character will be printed:  PRINT  USING  "_&&",  
             "GFA" results in "&GFA". 

        PRINT #n,  USING prints the formatted digits and character  
    strings to data channel "n",  which must have previously  been  
    opened with OPEN.  Otherwise, it is identical to PRINT USING.            
 

---------------------------
Structure Command PROCEDURE 

    HOW: PROCEDURE name [(variable list)] 

    EXAMPLE:  PRINT "main program" 
                GOSUB sub(7) 
                PRINT "backA=";A 
                PROCEDURE sub(A) 
                 PRINT"procedure A=";A 
                RETURN 
                PRINT "is disregarded" 

    PURPOSE: Marks the beginning of a Procedure (sub-routine). 

    EXPLANATION: "name" is the name of the Procedure.  In contrast  
    to  variable names,  a procedure name may begin with a  digit.   
    The other signs allowed are:   letters, digits, underscore and  
    slash. 

        "variable  list"  is variable names separated  by  commas.   
    These  variables are given the values defined in  the  command  
    GOSUB, and are always local variables in the Procedure.  There  
    is  no way to pass the values of local variables back  to  the  
    main program directly except by equating a local variable to a  
    global (nonlocal) variable.   You may,  however,  use pointers  
    (see*). 

        As  GFA BASIC does not use line numbers,  this command  is  
    necessary to mark the beginning of a Procedure (subroutine). 

        As  well as the possibility of creating  local  variables,  
    this  command  also has the beginning  of  a  procedure,  thus  
    avoiding  processing the sub-routine by mistake  (by  "falling  
    through"  from  the  main  program).    The  Interpreter  only  
    processes  a  Procedure when it is called up  by  the  command  
    GOSUB. 

        If  the  Interpreter comes across  the  Command  PROCEDURE  
    while  running the program,  it considers it to be the end  of  
    the  main  program,  so that lines after a  procedure  (except  
    another procedure) are ignored. 

        In  the above example,  at the same time as the  Procedure  
    "sub"  is  called  up,  the value 7 is  passed  to  the  local  
    Variable "A".  In order to show that this is a local variable,  
    the  content of "A" is once more given (value:0) on  returning  
    to the main program. 

    (see GOSUB, RETURN, LOCAL) 
 

--------------- 
I/O Command PUT 

    HOW:  PUT [#]n[,i] 

    EXAMPLE:  see FIELD 

    PURPOSE:  Writes a record to a random access file.    

    EXPLANATION:   "n"  is an integer expression between 0 and  99  
    which  refers  to the number of the data channel  opened  with  
    OPEN. 

        "i"  is an integer expression between 1 and the number  of  
    records in the file (max. 65535) and denotes the record number  
    of  the record to be written.   If "i" is not given  then  the  
    next record in the file will be written. 
 

--------------------------------------------------------
Commands      QSORT a(s) [,n] [,j%()]
              QSORT x$(s) OFFSET o with i() [,n [,j%()]]
              SSORT a(s) [,n] [,j%()]
              SSORT x$(s) OFFSET o with i() [,n [,j%()]]


  With the help from the comands QSORT and SSORT the elements of an array
can be sorted by the size. With SSORT the shell sort is executed, with
QSORT the quick sort is executed.

 A plus or minus symbol can be placed withinh thre brackets, before the
name of the array to be sorted. The minus = desending order and the plus
ensures ascending order.  The parameter n means that only the first n
elements of the array should be sorted. OFFSET can be set by using "o",
this is the number of characters after the beginning of the string that
are to be skipped during the sort. 

DIM x%(20)
PRINT "Unsorted:  ";
For i%=0 to 10
x%(i%)=RAND(9)+1
Print x%(i%);"   ";
NEXT i%
PRINT
QSORT x%(),11
DIM index%(20)
Print " sort incrementing:  ";
For I%=0 to 10
Print x%(i%);"  ";
index%(i%)=i%
NEXT i%
PRINT
SSORT x%(-),11,index%()
Print " Sort decrementing:  ";
For i%=1 to 10
Print x%(i%);"  ";
Next I%
Print
Print " Feild sorted with:  ";
For I%=o to 10
Print index%(i%);"  ";
Next I%

Displays one unsorted and wo sorted rows of random numbers


DIM b|(255)
For i%=o to 255
b|(i%)=ASC(UPPER$(CHR$(i%)))
Next I%
For i%=1 to 7
READ a$,b$
b|(ASC(A$))=ASC(B$)
Next i%
DATA A,b,C,d,a,B,c,D,3,2,5,4,6,5
DIM n$(3)
For I%=0 to 3
READ n$(i%)
NEXT i%
DATA Armbuster,Jones,Smith,PAPPY,PAPPY2
QSORT n$(),4
For I%=0 to 3
Print n$(i%)
Next i%
Print
Qsort n$() with b|(),4
For I%=0 to 3
? n$(i%)
Next I%

Sorts twice trhe string array n$(), onecw without WITH and once WITH


------------
Command QUIT 

    HOW: QUIT 

    EXAMPLE:   PRINT "Enter Password!" 
                 INPUT E$ 
                 IF E$<>"GFA" THEN 
                  QUIT 
                 ENDIF 

    PURPOSE: To leave the Interpreter. 

    EXPLANATION:  If the Interpreter comes across the command QUIT  
    when processing a program,  then it causes a return to the GEM  
    desktop. 

        This command is identical to the command SYSTEM. 
 

---------------
Function RANDOM 

    HOW: RANDOM(x)      random interger number between 0 and x
         RAND()         random 16-bit interger number from 0 to y-1
         RANDOMIZE      same chainof numbers will be returned each time
         RND()          random number between 0 and 1

    EXAMPLE:  REPEAT 
                 L=RANDOM(6)+1 
                 PRINT L 
                UNTIL L=3 

    PURPOSE: Returns   an   integer  random   number   between   0  
             (inclusive) and "x". 

    EXPLANATION:    "x"   can  be  any  number  (also   negative).   
    RANDOM(x)  returns  an integer between 0 (inclusive)  and  "x"  
    (exclusive).  Only integers should be used for "x". 

        RANDOM(x)=TRUNC(x*RND) 

    The example simulates a die being thrown continiously until  a  
    three appears. 
 

--------------------------
Graphics      RASTPORT adr

 Rastport are the drawing levels of the screen, windows and alert boxes.
With the commaand RASTPORT the current work rastport can be set. If the
rastport address "adr" is set then all graphics output will be to this
rastport until either a new address is set or the value 0 is set in "adr"

RASTPORT SCREEN(1)+84
OPENW 2
RASTPORT {WINDOW(2)+50}

 The rastport of the opened screen is first set as the current rastport,
pleae note the offsets 85 and 50 which specify the position ao rastport
pointers and window structure within the screen.  Without PROPER set=up
the system will CRASH!!!!!!!!!!


-------------------------------
Command        RCALL adr,reg%()

 RCALL makes it possible to set the values if registers before assembly
routine is called and to read the contents of the register after the
routine has been executed. The array reg%() is used for this purpose, this
is in elements of 4-byte intergers-types and has at least 16 elements.
before the start of the assembly routine the address of this array must be
copied to the register in the corresponding array element. The followiung
applies with OPTION BASE 0 set.

Data register     d0 through d7 in reg%(0)  through  reg%(7)
Address register  a0         a6         8                 14
User-Stack-Pointer  (a7)        in reg%(15)  (only return)

DIM r%(15)
r%(14)=_intbase
r%(8)=0
RCALL _intbase,r%()

This program calls the operating system routine DisplayBeep and
corresponding ~DisplayBeep(0)
 

--------------------------------
Command RECALL #i,x$(),n[TO z],x
        STORE #i,x$()[,n[TO z]]

 STORE serves to save a string array as a text file (with seperation
through LF). The complete string array is output through the opened
channel i, the selected paprameter n can contain the number of elements of
the string that should be saved, with n TO z a partial array can be saved
(or loaded).  RECALL serves to quickly read a string array from a text
file...n=1 read the entire array.

DIM A$(1000)
For I%=0 to 499
a$(i%)=STR$(RND)
Next i%
OPEN "O",#1,"Test.txt"
STORE #1,a$(),500
CLOSE #1
ERASE A$()
DIM B$(2000)
OPEN "I",#1,"TEST.TXT"
RECALL #1,b$(),-1,n
CLOSE
Print n


------------
Command READ 

    HOW: READ var[,var0]... 

    EXAMPLE: READ P,N$,Z% 
               PRINT P"N$"Z% 
               DATA 5,LONDON,1 

    PURPOSE: Reads values from a DATA command and assigns them  to  
             the variables "var". 

    EXPLANATION:  "var" canb e any numeric,  boolean or  character  
    string variable. 

        This command can only be used in conjunction with the DATA  
    command.  When the Interpreter comes across a READ command for  
    the first time in a program, it reads the first value from the  
    first  DATA line and assigns it to the first variable  in  the  
    READ  command.    Any  further  READ  commands  are   assigned  
    information  from any additional DATA on this  and  subsequent  
    DATA line(s) in succession. 

        There are two important points to observe: 

    *   The values read from the DATA line must be of a type which  
        corresponds to the variable in the READ command.  

    *   The  number  of values in the DATA lines must  be  greater  
        than or equal to the number of variables in the READ lines  
        (of course,  if the number is greater then the  additional  
        values are disregarded). 


-------------------
I/O Command RELSEEK 

    HOW: RELSEEK[#]n,x 

    EXAMPLE:  OPEN "O",#1,"DAT" 
                PRINT #1,"1234567890" 
                SEEK #1,8 
                RELSEEK #1,-5 
                PRINT LOC(#1) 

    PURPOSE: Moves  the file pointer "x" bytes in a file with  the  
             channel number "n". 

    EXPLANATION:   "n" is an integer expression between 0 and  99,  
    which relates to the number of a data channel opened by  OPEN.  
    "x"  is  an integer expression,  the value of  which  must  be  
    within the limits set by:  0 <=LOC(#n)+(x) <=  LOF(#n),;  that  
    is, the new value of the file pointer must not go past the end  
    of the file. 

        A file pointer (a read/write pointer),  which points to  a  
    specific  byte  in  the file,  is to be  found  in  every  dta  
    channel.  The  file pointer can be placed on any byte  in  the  
    file  by using RELSEEK.   If "x" is positive the file  pointer  
    moves  "x"  bytes  towards the end of  the  file;  if  "x"  is  
    negative, the pointer moves "x" bytes towards the beginning of  
    the file. 
 

-----------
Command REM 

    HOW: REM test 

    EXAMPLE: REM calculation of distance 
               LET S=(A*T*T)/2 

    PURPOSE: Enables remarks to be included in a program. 

    EXPLANATION:   Remarks  serve  as a reminder to the  user  and  
    facilitate  the  reading  of the  program.   The  REM  command  
    appears in teh listing of the program but is not executed. 

        REM must only be placed at the beginning of a line,  since  
    GFA BASIC considers REM a command.  To append a comment to the  
    end of another commane, use the symbol "!". 
 

--------------------------------
Structure Command REPEAT...UNTIL 

    HOW: REPEAT 
         UNTIL end 


    EXAMPLE: REPEAT 
                A=A+1 
                PRINT A 
               UNTIL A=20 

    PURPOSE: Creates a pre-defined loop 

    EXPLANATION:   The  section of the program between REPEAT  and  
    UNTIL   is  repeated  continiously  until  the  condition   is  
    fulfilled.   Unlike WHILE...WEND,  the condition is checked at  
    the  end  of the loop,  i.e.  the loop in  the  REPEAT...UNTIL  
    command has to be completed at least once. 
 

---------------
Command RESTORE 

    HOW: RESTORE [label] 

    EXAMPLE: READ A,B,C,D,E 
               RESTORE 
               READ F,G,H,I 
               RESTORE Nam 
               READ J,K,L,M 
               PRINT A'B'C'D'E"F'G'H'I'J'K'L'M 
               DATA 1,2,3 
               Nam: 
               DATA 4,5,6,7 

    PURPOSE: Places  the  DATA  pointer at the  beginning  of  the  
             program, or after the label named "label". 

    EXPLANATION:  "label"  can be any list of characters  and  can  
    contain digits, letters, underscore and slashes.  Unlike other  
    variable names it can also begin with a digit. 

        The  command  RESTORE gives repeated access to  read  data  
    from  one or more DATA lines.   This is possible  because  the  
    pointer,  which is normally positioned on the next constant to  
    be used in the DATA commands,  is set at the beginning of  the  
    program (by RESTORE) or at the beginning of a DATA line  after  
    the  line  "label" (by RESTORE label).   It  is  important  to  
    remember that the name of a label must end with a colon. 

    (see also READ and DATA) 
 

--------------
Command RESUME 

    HOW: RESUME 
         RESUME NEXT 
         RESUME label 

    EXAMPLE:  see ON ERROR GOSUB 

    PURPOSE:  Exits out of an error routine. 

    EXPLANATION:   RESUME repeats the erroneous  command.   RESUME  
    NEXT resumes program executiona fter the command which  caused  
    the error.  RESUME "label" branches to the label "label"."  If  
    the label is in the main program, the RETURN at the end of the  
    error  procedure  is  canceled and the  global  variables  are  
    restored.   If  a fatal error occurs,  only RESUME "label"  is  
    possible. 
 

------------------------
Structure Command RETURN 

    HOW: RETURN 

    EXAMPLE:  PRINT "main program" 
                GOSUB sub 
                PRINT "return" 
                PROCEDURE sub 
                 PRINT "procedure" 
                RETURN 

    PURPOSE:  Terminates a sub-routine. 

    EXPLANATION:   If  the  Interpreter comes across  the  command  
    RETURN  in  a  procedure  (sub-routine),   execution  of   the  
    subroutine  is  concluded and execution  continues  after  the  
    GOSUB command which caused the program to branch off into that  
    procedure.    Local  variables  are  deleted.    (see   GOSUB,  
    PROCEDURE, LOCAL). 
 

---------------
Function RIGHT$ 

    HOW: RIGHT$(string[,n]) 

    EXAMPLE: N$="GFA BASIC" 
               PRINT RIGHT$(N$) 
               PRINT RIGHT$(N$,5) 
               PRINT RIGHT$(N$,12) 

    PURPOSE: Returns   the  last  character  or  "n"   number   of  
             characters  (from  the right) of a  character  string  
             "string". 

    EXPLANATION:    "string"  is  a  character  string  or  string  
    variable.  "n" is an integer or a variable.  (Real numbers can  
    also be used,  in which case the Editor will only consider the  
    Integer part). 

        The  function produces a partial string of "n"  characters  
    (starting from the right) - spaces included.   If optional "n"  
    is  not used,  the function returns the last character of  the  
    character string "string".   If "n" is greater than the number  
    of  characters  in  "string" then the  whole  of  "string"  is  
    returned. If n=0, an empty string is returned. 
 

----------------------------
Commands   RINSTR(a$,b$)
           RINSTR(a$,b$,[x])
           RINSTR([x],a$,b$)

 RINSTR() searches a string like INSTR but this search begins with the
RIGHT most character in the string, or the given position within the
string.

? RINSTR("DF0:\FOLDER\TEST.GFA","\")

  Searches for the last back slash "\" in the path name and returns the
position of the character(in this case 11)


---------------------------------------
Command  ROL(x,y)  ROL&(x,y)  ROL|(x,y)
         ROR(x,y)  ROR&(x,y)  ROR|(x,y)

 The operand length and direction are the same as with the shift command.
For example, the highest bit of a byte is moved. This byte is noew routed
to the left (ROL|(128,1)). The left bit is now palced into the right part
of the byte, so that the first bit of the byte is now set. With
SHL|(128,1) the bit that was pushed out would have become zero.

x|=128+1
y%=ROR|(x|,1)
? SHL(y%,4),y%*2^4
? SHL(ROR|(128+1,1),4)

 The number 3072 is displayed on the screen three times.


----------------------
Command   ROUND(x,[n])

 ROUND returns a rounded value.

y=ROUND(-1.2)
? y,ROUND(1.7)

Displays -1 and 2

For I%=-5 to 5
? i%,ROUND(pi*100.i%)
Next i%


-----------------
I/O Command RMDIR 

    HOW: RMDIR "directory name" 

    EXAMPLE:  MKDIR "DH0:DIRECTORY" 
                FILES"DH0:*.*" 
                RMDIR "DH0:DIRECTORY" 
                FILES"DH0:*.*" 

    PURPOSE:  Deletes empty directories. 

    EXPLANATION:  "directory  name" is the name of  the  directory  
    (folder) to be deleted.  It is possible to use the hiearchical  
    file system (\) when choosing the name: 

        If  the  name within the quotes is just a  directory  name  
    (not using\),  a directory is deleted from the directory being  
    used at the time (change directory by CHDIR). 

        When deleting from a specific directory it is necessary to  
    enter  the  directory search path in front  of  the  directory  
    name.  From a root directory, this always begins with "\", for  
    example,  RMDIR  "\vehicle\driver"  would delete  a  directory  
    DRIVER  from  directory VEHICLE in  the  root  directory.   Of  
    course,  a  directory  can only be deleted if the  name  given  
    exists  in the directory and contains no files  (see  EXIST().   
    If  it is necessary to specify the disk drive  containing  the  
    directory to be deleted,  this is done by giving the letter of  
    the disk drive followed by a colon(e.g. "DH0:directory"). 
 

------------
Function RND 

    HOW: RND [(x)] 

    EXAMPLE:  FOR I=1 TO 20 
                  PRINT RND 
                 NEXT I 

    PURPOSE:  Returns a random number between 0 and 1. 

    EXPLANATION:   The optional parameter (x) is disregarded.  RND  
    returns   a  random  number  between  0  (inclusive)   and   1  
    (exclusive). 

        It is possible to create random integers between 1 and "n"  
    (both inclusive) with the following formula: 

           Z=INT(RND*n)+1 

    (see RANDOM) 
 

------------------ 
Command   RUN [f$]


 The command RUN executes the current porgam, is an additional complete
data name is given then the f$ program will be loaded and started.


  RUN "DF0:PART_2.GFA"


------------------------
Command    SAY x$[,m%()]
           TRANSLATE$()

 SAY character is "articulated" using the AMIGA phoneme code. TARNSLATE$
converts an english text into phoneme codes.

  The output of SAY can be modified using the m% varible:

m%(0) basic frequency (65-320; default=110)

m%(1) inflection (0=normal, 1=monotone; default=0)

m%(2) speech speed (40=400 words per minute; default=150)

m%(3) voice type (0=male, 1=female; default=0)

m%(4) sample frequncy(5000-28000; default=22200)

m%(5) volume (0-64: default=64)

m%(5) channel (value=channel: 0=0, 2=2, 3=3, 4=0+1, 5=0+2, 6=3+1
                7=3+2, 8=0 or 3, 9=1 or 2, 10=0 or 2 and 1 or 1
                11=0,1,2 or 2; default=10(stereo)

SAY TRANSLATE$("I AM AN AMIGA COMPUTER OWNED BY PAPPY")


---------------------
Command  SCREEN (no)
         SCREEN (adr)

 SCREEN returns the address of the screen when the screen index "no" is
given or the screen index when the screen address "adr" is given.

OPENS 1
adr%=SCREEN(1)
index%=screen(adr%)
? adr%,index%


-----------------------
I/O Command SAVE P SAVE 

    HOW: SAVE "file name" 
         PSAVE "file name" 

    EXAMPLE:  SAVE "DF0:\PROG" 
                FILES "DH0:\*.*" 

    PURPOSE:   Saves  a program file on diskette (PSAVE  is  saved  
    with list protection. 

    EXPLANATION:  "file name" is the program name.  If the program  
    file is to be saved on a specific disk drive, for example disk  
    drive  DH0,  this can be done by adding the disk  drive  letter,  
    followed by a colon (e.g. "DH0:"). 

        It  is also possible to use the hierarchical  file  system  
    with "file name",  i.e.  the command SAVE "DH0:\PROG\TEST" means  
    that  the  program will be saved under the  name  TEST.BAS  in  
    directory  "PROG"  in the root directory on  the  diskette  in  
    disk drive DH0.   (If no extension has been indicated,  .BAS  is  
    automatically assumed by GFA BASIC). 

        Programs which are saved with PSAVE are not listed but run  
    immediately after the command LOAD is given.  When the program  
    has finished,  it remains in memory and can be RUN again, even  
    though  the  edit  window remains  empty.   You  may  NOT  add  
    additional  lines to a program by typing them into the  editor  
    (this generates an "Exit without a Loop" error when you try to  
    run  the modified program).   Use NEW to clear the  unlistable  
    program from memory. 

        CAUTION!  If a program of the same name is already present  
    on the diskette it will be written over. 

        If  quotes  are  not  put  around  "file  name"  they  are  
    assumed. 
 

----------------
I/O Command SEEK 

    HOW: SEEK [#]n,x 

    EXAMPLE:   OPEN "O",#1,"DAT1" 
                 OPEN "O",#2,"DAT2" 
                 PRINT #1,"1234567" 
                 PRINT #2,"ABCDEF" 
                 SEEK #1,3 
                 SEEK #2,5 
                 PRINT LOC (#1), LOC (#2) 

    PURPOSE:  Sets the file pointer on byte number "x" of the file  
    with channel number "n". 

    EXPLANATION:   "n"  is an integer expression between 0 and  99  
    which  refers to the number of a data channel opened by  OPEN.   
    "x"  is an integer expression which has a value less  than  or  
    equal to the length of the file addresssed. 

        Every data channel has a file pointer (reading and writing  
    pointer)  which points to a specific byte in the  file.   This  
    file  pointer can be placed on any byte in the file  by  SEEK.   
    Positive  values of "x" places it at byte number "x"  counting  
    from the beginning fo the file whereas negative values of  "x"  
    cause  the pointer to be placed "x" number of bytes  from  the  
    end of the file. 
 

------------------------------------------
Commnads   SELECT x
           CASE y [TO z] or CASE y [,z...]
           CASE TO y
           CASE y TO
           DEFAULT
           ENDSELECT
           CONT

 SELECT makes the branching dependent on the value of the numerical
        expreasion x

 CASE instruction goes from top to bottom checking the current branch
      condition if found behind a CASE

 Commands between DEFAULT and ENDSELECT will be execueded as long as there
      is a DEFAULT instruction.

 CONT commnad may not be repeated within a program that has been stopped
      or restarted.

 A few examples:

 OPENW 0
 x=0
 SELECT x+2
 CASE 1
 PRINT "x equals 1"
 CASE 2 TO 4
 PRINT "x equals 2,3 or 4"
 DEFAULT
 PRINT " x does not equal 1,2,3, or 4
 ENDSELECT
 
 ---

 OPENW 0
 exit!=FALSE
 REPEAT
 KEY$=INKEY$
 SELECT Key$
 CASE "a" TO "z"
 Print " the lower case letter "+key$+" was entered"
 CASE "A" TO "Z"
 Print " the upper case letter "+key$+" was entered"
 CASE 27
 exit!=TRUE
 DEFAULT
 Print " Invalid key!"
 ENDSELECT
 Until exit!

------
 
 OPENW 0
 x=1
 SELECT x
 CASE 1
 PRINT " x equals 1"
 CONT
 CASE 2
 Print " x equals 2"
 DEFAULT
 PRINT " x does not equal 1 or 2
 ENDSELECT


-------------------------
Graphics Command SETCOLOR 
                 SETCOLOR
                 COLOUR 


   HOW:  SETCOLOR reg,r,g,b 
         SETCOLOR reg,mix
         COLOR color

    EXAMPLE:  SETCOLOR 0,0
              Opens 1,0,0,640,200,2,32

Opens a screen and sets the color to black in color reg 0
              
              
    PURPOSE:  Defines the color components red, green and blue for  
    color register "i". 
    EXPLANATION:   The number of the color registers available  
    depends on the screen resolution.

        Another way of defining the color in a register is to  use  
    the  value "n",  where "n" is calculated  as:  n=r*256+g*16+b.   
 

----------------------------------------------------
Command  SETSPEN detail_pen,block_pen         screen
         SETWPEN detail_pen,block_pen         window

 Both of these commands can be used to initialize screens, they replace
the previously set values - detail_pen set the colour number of the color
that the screen title is to appear in - block_pen set the color number of
the screen title field.


---------------
Command SETTIME 

    HOW: SETTIME timestring, datastring 

    EXAMPLE:  PRINT TIME$, DATE$ 
                SETTIME "15:30:11", "06/29/1987" 
                PRINT TIME$,DATE$ 

    PURPOSE:  Sets the time and the data. 

    EXPLANATION:    "timestring"  is  a  string  expression  which  
    contains the time.  Hours, minutes and seconds can be entered.   
    The colors are optional and two digits have to be entered  for  
    both hours and minutes.   The "seconds" can be left out.   For  
    example,  "1030 is identical to "10:30:00".  Hours are entered  
    using a 24 hour clock (1pm is "13"). 

        "datestring"  is  a character string  expression  for  the  
    data.  It  must always contain:   Month,  Day and  Year,  each  
    separated by a slash.   When using the years between 1980  and  
    2079 the first two digits can be left out.   The month and day  
    must contain two digits (these may be zeros) for the comand to  
    work properly. 

        If the format of the settime expressions are not  correct,  
    the internal clock is not altered. 

        If the format of the settime expressions are not  correct,  
    the internal clock is not altered. 

        If  you only wish to modify one item (either the  time  or  
    the data),  enter an empty string for the item you do not wish  
    to  modify:   SETTIME  "09:30","" will only modify  the  time,  
    leaving the data unchanged. 
 

------------
Function SGN 

    HOW: SGN(x) 

    EXAMPLE:  INPUT A  
                B=SGN(A)*A 
                PRINT B 

    PURPOSE:  Determines whether "x" is positive, negative or 0. 

    EXPLANATION: "x" can be any numeric expression.  SGN(x) is the  
    mathematic sign function. 

        The values -1,0 and 1 are returned as follows: 

     -  0  if  x=0 
     - +1  if  x >0 
     - -1  if  x <0 

        The  above  example simulates  the  mathematical  function  
    ABS,(see ABS). 
 

---------------------------------------------
Command        SHL(x,y)  SHL&(x,y)  SHL|(x,y)
               SHR(x,y)  SHR&(x,y)  SHR|(x,y)

 These commands shift the contents of a numeric expression x by y bytes.
Without the input of a special varible type a long word (4 bytes) will be
assumed; with & word lenght (2 bytes) will be used and | will indicate
byte length. The 3rd letter of the command corresponds to the direction of
the shift or rotation. The L indiactes left and R = right.

With word functions (&) bit 15 is copied to bits 16 through bit 31 and
with byte functions (|) bits 8 through 31 are erased

x%    SHL|(x,1)  BIN$(x%,16)       BIN$(SHL|(x%,1),16)
18    36         00000000 00010010 00000000 00100100
18    36   with &
24     6   with & ,2
  

------------
Function SIN 

    HOW: SIN(x) 

    EXAMPLE:     1) INPUT RAD 
                     PRINT SIN(RAD) 
                     INPUT GRAD 
                     PRINT SIN(GRAD*PI/180) 
 
                 2) PLOT 320,100 
                    FOR I=1 TO 5400 
                     X=I/36*COS(I*PI/180) 
                     Y=I/36*SIN(I*PI/180) 
                     DRAW TO 320+X,100+Y 
                    NEXT I 
                    DEFFILL 3,2,16 
                    FILL 320,110 

    PURPOSE: Returns the sine value of "x". 

    EXPLANATION:  "x" is a numeric expression which specifies  the  
    angle, for which the sine is calculated, in radians. 

        If the angle is in degrees,  "x" is multiplied by  :I/180.   
    In this case PI is a constant in GFA BASIC. 

        The first example calculates the value of the sine,  first  
    for an angle entered in radians and then for an angle  entered  
    in degrees.   In the second example a snail form is created by  
    using angles entered in degrees. 
 

--------------------
Command SOUND / WAVE

    HOW:  SOUND freq,duration,[,vol[,chan]]
          WAVE chan,wave()
  
    PURPOSE: Generates musical sounds. 
  
 Note    C      261.6  Freequency in hertz
         
         D      293.7
        
         E      329.6
         
         F      349.2
        
         G      392.0
       
         A      440.0

         H      493.9
       
  vol = set volume between 0 and 255, if null = middle = 127 used
  chan = channel tone, 0 and 3 = left, 1 and 2 = right default = 0


--------------- 
Function SPACE$ 

    HOW: SPACE$(x) 

    EXAMPLE: FOR I = 0 T0 20 
               PRINT SPACE$(I);I 
               NEXT I 

    PURPOSE:   Creates a character string containing "x" number of  
    blanks. 

    EXPLANATION:   "x" is a numeric expression with a value  which  
    must lie between 0 and 32767.  Only integer values of "x" will  
    be accepted. 

        This command has the same effect as PRINT STRING$ (x,""). 
 

------------
Function SPC 

    HOW: SPC(n) 

    EXAMPLE:  PRINT "GRA";SPC(10);"BASIC" 
                PRINT "herre";SPC(200);"there" 

    PURPOSE:  Produces "n" spaces in a PRINT command. 

    EXPLANATION:   "n" is an integer expression which is less than  
    256. 

    The function SPC can only be used with PRINT commands. 
 

--------------------------------
Command         SPRITE #n,data$
                SPRITE #n[,'''']
                SPRITE #n,x,y
                SPRITE ON
                SPRITE OFF

 Puts a hardware sprite on the screen, the sprite is therefore 16 points
wide abd has a selectable height, the resolution of the sprite corresponds
to thelowest screen resolution (320 x 200), each two bits of the sprite
defination yeild one screen point and define it's color. The AMIGA hard
ware sprites can be controlled using the sprite command, there as 8
spritesd with numbers 0-7, where sprite #0 is assigned to the mouse.

SPRITE #n,data$ defines the apperance of a sprite, data$ contains
therefore the bitmap of the sprite data, each row is defined by 4 bytes,
the first two bytes for the bit plane 0 and the other for the bit plane 1,
the height of the sprite is calculated by dividing the width of a string
by 4.
 
SPRITE #n frees up the relevant sprite.

SPRITE #n,x,y moves the sprite to n with coordiantes x and y

SPRITE OFF turns off all sprites including the mouse, ON = On.

OPENW 1
a$=STRING$(64,-1)
SPRITE #2,a$
SETCOLOR 23,&hF00
For i%=0 to 200
SPRITE #2,i%,i%
PAUSE 1
next I%
SPRITE #2


------------ 
Function SQR 

    HOW: SQR(x) 

    EXAMPLE:  INPUT X 
                INPUT Y 
                DIST=SQR(X*X+Y*Y) 
                PRINT DIST 

    PURPOSE:  Calculates the square root. 

    EXPLANATION:  "x" is a numeric expression with a value greater  
    than or equal to 0. 

        The above example calculates the distance from the  origin  
    of a point whoose coordinates are entered by the user. 

        If another root function is required (e.g.  the cube root)  
    then it must be calculated by using the fact that the nth root  
    of x is given by x^1/n.   For instance,  the cube root of 8 is  
    given by 8^1/3. 
 

----------------------
Command       STICK(p)
              STRIG(p)

 STICK(p) serves to the joystick position, using p=0 reports the position
of the joystick in port 0 and using p=1 in port 1.

 STRIG(p) determines the status of the fire buttons, TRUE = pressed

REPEAT
st%=STICK(1)
fire!=STRIG(1)                       5      1      9
SELECT st%                            \     |     /
CASE 4                                 \    |    /
? " Left "                              \   |   /
CASE 8                                   \  |  /
? " Right"                                \ | /
CASE 2                                     \|/
? " Down"                            4----- 0 ----- 8
CASE 1
? " Up"
ENDSELECT                            6      2       10   JOYSTICK
UNTIL fire!
WHILE STRIG(1)
WEND


------------
Command STOP 

    HOW: STOP 

    EXAMPLE:  OPEN "0",#1,"DAT" 
                STOP 
          (enter in direct mode after staring the program:) 
                PRINT #1,"BASIC" 

    PURPOSE: Stops execution of the program. 

    EXPLANATION:  The command STOP can be used at any point in the  
    program.  It differs from the END command in that it does  not  
    close  any  files (see example) and that by  typing  CONT  the  
    program can be resumed from the line immediately following the  
    STOP. 
 

-------------
Function STR$ 

    HOW: STR$(x) 

    EXAMPLE:  A=3.5E+56 
                B=&022 
                PRINT STR$(A) 
                PRINT STR$(234) 
                PRINT STR$(B) 

    PURPOSE: Transforms the value "x" into a character string. 

    EXPLANATION:  "x"  may be a number in any format (i.e. decimal  
    (without  previx) or hexadecimal (prefix & or  &H),  or  octal  
    (prefix  &0),  or binary (prefix &x),  or a  numeric  variable   
    STR$(x) transforms the value "x" into a string containing  the  
    value  "x"  in a decimal form (i.e.  in the  above  example  B  
    produces the string "18"). 
    (see also HEX$,OCT$,BIN$) 
 

----------------
Function STRING$ 

    HOW: STRING$(n,string) or 
           STRING$(n,c) 

    EXAMPLE:  Z$="A" 
                PRINT STRING$(50,Z$) 
                PRINT STRING$(50,"A") 
                PRINT STRING$(50,65) 
                PRINT STRING$(25,"AA") 

    PURPOSE:  Produces a string formed by repeating "string" or 
              CHR$(c) "n" times. 

    EXPLANATION:   "n" is a number between 0 and 32767.   "string"  
    is  any  character  string  expression.    "c"  is  a  numeric  
    expression giveing the ASCII-code of a character.   A table of  
    these  codes  and the characters they represent  is  given  in  
    Appendix C.  "c" is transformed by the interpreter into an 256  
    for  positive values,  and the formula (c+2147483648) MOD  256  
    for negative values. 

        The  length of the resulting string may not  exceed  32767  
    characters. 
 

----------------------
Arithmetic Command SUB 

    HOW: SUB var,n 

    EXAMPLE:  T=TIMER 
                FOR I%=1 TO 10000 
                 SUB A%,5 
                NEXT I% 
                PRINT (TIMER-T)/200 
                A%=0 
                T=TIMER 
                FOR I%=1 TO 10000 
                 A%=A%=5 
                NEXT I% 
                PRINT (TIMER-T)/200 

    PURPOSE:  Subtracts "n" from "var". 

    EXPLANATION:   "var"  must  be numeric variable or  a  numeric  
    array variable.  "n" is a numeric expression. 

        SUB  var,n is identical to var=var-n.   The  advantage  of  
    using SUB is the speed of execution (Try the example). The use  
    of SUB almost halves the already fast execution time. 
 

------------
Command SWAP  

    HOW: SWAP var1,var2 

    EXAMPLE:  DIM A(3),B(8) 
                ARRAYFILL B(),8 
                A$="first" 
                B$="second" 
                SWAP A$,B$ 
                SWAP A(),B() 
                PRINT A$,B$ 
                PRINT A(8),B(2) 

    PURPOSE:  Exchanges the values of "var1" and "var2". 

    EXPLANATION:   This  exchange  can  be made for  any  type  of  
    variable:   numeric,  numeric  array,  string,  string  array,  
    boolean  or boolean array.   "var1" and "var2" must be of  the  
    same variable type. 

        When swapping arrays the dimensions are also swapped  (see  
    example). 

        The variables being SWAPped must be of the same type. 


--------------
Command SYSTEM 

    HOW: SYSTEM 

    EXAMPLE:  PRINT "Enter password!" 
                INPUT E$ 
                IF E$ <> "GFA" THEN 
                 SYSTEM         
                ENDIF 

    PURPOSE: Enables an exit from the interpreter. 

    EXPLANATION:   If  the  interpreter comes across  the  command  
    SYSTEM in a program it transfers control back to GEM-desktop. 

        This command has the same effect as QUIT. 
 

------------
Function TAB 

    HOW: TAB(n) 

    EXAMPLE:  PRINT TAB (30);"GFA" 
                PRINT SPACE$(40) 
                PRINT TAB (30);"BASIC" 

    PURPOSE:  Tabs to the nth column. 

    EXPLANATION:   "n"  is an integer expression and can have  any  
    value but the value TRUNC (nMOD 256)is used.  The function TAB  
    can  only be used in conjunction with the PRINT  command.   If  
    the current position is already past the tab position "n" then  
    the TAB function sets the cursor to the nth column of the next  
    line. 
 

------------
Function TAN 

    HOW: TAN(x) 

    EXAMPLE:  INPUT RAD 
                PRINT TAN(RAD) 
                INPUT GRAD 
                PRINT TAN(GRAD*PI/180) 

    PURPOSE:  Returns the value of the tangent of "x". 

    EXPLANATION:   "x" is a numeric expression giving the angle in  
    radians for which the tangent is required. 

        If the angle is known in degrees then this must be entered  
    as GRAD*PI/180, where GRAD is the angle in degrees and PI is a  
    constant in GFA-BASIC. 

        The example calculates the value of the tangent first  for  
    an  angle entered in radians and then for an angle entered  in  
    degrees. 
 

---------------------
Graphics Command TEXT 

    HOW: TEXT x,y,[1,]string

    EXAMPLE:
               OPENW 1                     
               DO
               TEXT MOUSEX,MOUSEY,i%
               INC i%
               LOOP

  Writes a graphic text in various variations on the screen.

 Displays the character string [] as graphic text at the coordinates
x,y. This point is located at tjhe left corner of the first charater
of the string []


-------------- 
Function TIME$ 

    HOW: TIME$ 

    EXAMPLE:  DEFTEXT 1,16,0,32 
                DO 
                 PRINT AT (1,1);TIME$ 
                 TEXT 240,180,TIME$ 
                LOOP 

    PURPOSE:  Returns the system time. 

    EXPLANATION:  The function returns a string which contains the  
    system time in the following format: hh:mm:ss 
    The seconds are updated every 2 seconds. 
 

--------------
Function TIMER 

    HOW: TIMER 

    EXAMPLE: T=TIMER 
             REPEAT 
             Z=INT((TIMER=T)/2/100 
              PRINT AT (38,3);Z"" 
             UNTIL INKEY$<>"" 

    PURPOSE: Returns  the  time since switching on the  system  in  
             200ths of a second. 

    EXPLANATION:   Calling this function returns the time  elapsed  
    since  the  system was switched on in units of  1/200th  of  a  
    second.  The example simulates a stopwatch accurate to 1/100th  
    of a second. 
 

---------------------
Function   Touch [#]n

     Touch updates the time stored as part of the directory entery.

  Open "O",#1,"test.txt"
  Touch #1
  Close

 or
 
 TOUCH "dh0:*.*" all files are TOUCHed


-------------- 
Function TRUNC 

    HOW: TRUNC(x)  

    EXAMPLE:  A=3.14155  
                PRINT TRUNC(A) 
                PRINT TRUNC(-12) 
                [ROMT TRIMC)-1.99) 

    PURPOSE:  Returns the integer portion of "x". 

    EXPLANATION:  "x"  is any numeric  expression.   For  positive  
    values  of  "x"  this  function  is  identical  to  INT.   The  
    difference  is only apparent for negative values of  "x".   In  
    the example TRUNC(-1.99) gives the value -1 whereas INT(-1.99)  
    would  give  the  value  -2.   TRUNC  (and  not  INT)  is  the  
    complementary function to FRAC,  therefore,  the following  is  
    true: x=TRUNC(x)+FRAC(x). 

    The function TRUNC is identical to the function FIX. 
 

---------------
Function UPPER$ 

    HOW: UPPER$(string) 

    EXAMPLE:  A$="basic" 
                PRINT UPPER$(A$) 
                PRINT UPPER$("la") 
                PRINT UPPER$("GFA") 

    PURPOSE: Transforms all lower case letters in a string to 
             upper case. 

    EXPLANATION:   "string"  is any character  string  expression.   
    Any  characters  in  the string that are  not  letters  remain  
    unchanged. 
 

-----------
Function VAL 


    HOW: VAL(x$) 

    EXAMPLE:  A$="4000 Dusseldorf 11" 
                PRINT VAL(A$) 
                PRINT VAL ("1.E+05") 
                PRINT VAL ("GFA") 
                PRINT VAL ("&HFF") 

    PURPOSE: Transforms  the string "x$" into a numeric  value  as  
             far as is possible. 

    EXPLANATION:"x$" may be any string or string variable.   If  a  
    part  of  the string (beginning from the left)  or  the  whole  
    string  can  represent numeric expression in any  form  (i.e.,  
    decimal,  hexadecimal, octal or binary), then the decimal part  
    of  this  part of the string is returned.   In the case  of  a  
    purely alphanumeric string or any empty string the value 0  is  
    returned. 
 

-------------
Function VAL$ 

    HOW: VAL?(x$) 

    EXAMPLE:  A$="22 KG" 
                PRINT VAL?(A$) 
                PRINT VAL?("1.0E+19") 
                PRINT VAL?("1E19") 
                PRINT VAL?("1E19") 
                PRINT VAL?("&X1010011") 
                PRINT VAL?("AB123") 

    PURPOSE:  Determines the number of characters in a string that  
    can be converted into a numerical value with VAL. 

    EXPLANATION:  "x$" may be any string or string variable.   The  
    function VAL?  returns the number of characters, starting from  
    the  beginning of the string,  that can be transformed into  a  
    numeric  value  by the function VAL.   If the  string  is  all  
    letters, the first character of the string is a letter, or the  
    string is empty then the value 0 is returned. 

        The  above  example  returns  the  values  2,7,4,9  and  0  
    respectively. 
 

------------------------------
Structure Command WHILE...WEND 

    HOW: WHILE condition 
         WEND 

    EXAMPLE:  WHILE A<10 
                A=A+1 
                PRINT A 
               WEND 

    PURPOSE: Creates a conditional loop. 

    EXPLANATION:  The block of commands between WHILE and WEND are  
    repeatedly   executed  only  as  long  as  the  condition   is  
    fulfilled. As the condition is checked at the beginning of the  
    loop  it is possible (unlike REPEAT...UNTIL) that the loop  is  
    never executed. 
 

------------------------
I/O Command WRITE WRITE# 

    HOW:  WRITE[expressions][;] 
          WRITE #n[,expressions][;] 

    ABBR.: WR 

    EXAMPLE:   OPEN "0",#1,"DAT" 
               WRITE #1,"Smith","John",18 
               CLOSE #1 
               OPEN "I",#1,"DAT" 
               INPUT #1,NAME$,FIRSTN$,AGE 
               PRINT FIRSTN$"NAME$" 
               PRINT "IS" "AGE" YEARS OLD." 
               CLOSE #1 

    PURPOSE: WRITE# stores data in a sequential file to be read in  
             with  INPUT.   WRITE prints data on the screen  in  a  
             special format. 

    EXPLANATION:  "n" is an integer from 1-99 representing a  data  
    channel previously opened using OPEN.  "expressions" is a list  
    of expressions separated by commas.   Unlike output using  the  
    PRINT  command  the expressions are separated  by  commas  and  
    strings are enclosed in quotes.   This format is suited to the  
    format of the INPUT command. 

        WRITE  (without  "#n") outputs to the  screen.   The  only  
    valid  punctuation is ";" (subsequent data is printed  on  the  
    same  line  with  no spacint) and ","  (must  be  followed  by  
    another variable or constant,  and the comma will be printed).   
    Strings are printed with the quotes. 

    (see also PRINT) 


---------------------- 
Function   WINDOW(no)
           WINDOW(adr)

 WINDOW returns the window index "no" or the adress of the window
structure and, vice versa, when the adrees "adr" is given the index will
be returned.

OPENW 1
adr%=WINDOW(1)
index%=WINDOW(adr%)
Print adr%,index%

 The first window function determines the address and the seecond the
index of the window.


------------------     
Command/Function * 

    HOW: * 

    EXAMPLE: DIM A$(9) 
               FOR I=0 TO 9 
                A$(I)=STR$(RND) 
               NEXT I 
               @DSP !@isGOSUB 
               @SORT(*A$()) 
               @DSP 
               PROCEDURE DSP 
                FOR I=O TO 9 
                 PRINT A$(I) 
                NEXT I 
               RETURN 
                PROCEDURE SORT(p.sarr) !sortX$0 
                 IF TYPE(p.sarr)<>5 
                  ERROR 47  !string parameter 
                 ENDIF 
                 SWAP*p.sarr,X$()  !WORK FIELD 
                 LOCAL i%,j% 
                 "Bubblesort-slow 
                 FORi%=DIM?(X$())-2downto 0 
                  FORj%=0 TO i% 
                   IF X$(j%)>X$(j%+1) 
                  ENDIF 
                 NEXTj% 
                NEXTi% 
                SWAP*p.sarr,X$() !field return 
               RETURN 

    PURPOSE: Passes on variables and arrays indirectly 

    EXPLANATION: The  asterisk is not only for multiplication  but  
                 also  for  indirect  addressing  (see  examples).   
                 This  is  especially useful  in  procedures  with  
                 parameters  or arrays to be returned to the  main  
                 program. 
 

GOSUB  xxx(*a)does not specify the value of the  variable  a,  but  
it's  address.  *ptr=xx  changes  the variable  whose  address  is  
contained  in  ptr.   To change the value of an array  element  by  
indirect  addressing,  you must use SWAP  (see  example).   TYPE()  
shows what sort of variable is at the pointer location. 
    ptr%=*a 
    *ptr%=17            !a=17 
 
    ptr%=*a% 
    *ptr%=17            !a%=17 
 
    ptr%=*a$ 
    *ptr%="Test"        !a$="Test" 
 
    ptr%=*A() 
    swap *ptr%,x() 
    dim x(9)            !A=7+3 
    swap *ptr%,x() 
 
    @sum(*a,7,3)        !A=7+3 
    procedure sum(p.num %,x,y) 
     *p.num%=x+y 
    return 
 
    This method of indirect addressing,  which uses the address of  
variables to access them,  is the only way to return the values of  
LOCAL variables in a PROCEDURE (Including variables passed to  the  
PROCEDURE) to the main program without directly equating the LOCAL  
variables to Global variables. 

    Important:  Local variables and global variables with the same  
name are stored in the same area (the global values are saved when  
the local variable is enabled and are restored on return from  the  
procedure).   Therefore local variables may not have the name of a  
return parameter. 

    When  an  error  occurs in the use of  the  pointer  an  error  
message is returned (see TYPE). 
     

-----------
Function == 

    HOW: a==b 

    EXAMPLE:  FOR I=1 TO 1 STEP 0.1 
                   EXIT IF I --0.5 
                  NEXT I 
                  PRINT I 

    PURPOSE: Comparison operator for approx. equal. 

    EXPLANATION:   "a"  and  "b"  are  numeric  expressions.   The  
    ==operator  is  used in the same way as a  comparison  with  =  
    except  that  the  condition is true not  only  when  the  two  
    numbers are exactly equal but also when they are approximately  
    equal.   28 bits of the mantissa are compared i.e.  about  8.5  
    digits.   In  the  example  the loop is left  although  it  is  
    possible  that due to rounding errors the numeric variable  is  
    never exactly 0.5. 

    (see also DEFNUM and PRINT USING). 
 

----------------
I/O Command BGET 

    HOW: BGET [#]i,adr,cnt 

    EXAMPLE:
              OPEN#1,"0",#1,"SCR.DAT" 
              BPUT#n,adr,num
              CLOSE #1 
              CLS 
              OPEN "I",#1,"SCR.DAT" 
                SEEK #1,8000 
                BGET #n.adr.num
                CLOSE #1 

    PURPOSE: Reads from a data channel into an area of memory. 

    EXPLANATION:  "i","adr" and "cnt" are integer expressions. "i"  
    is  a  channel number (see OPEN).   "cnt" bytes are  read  and  
    stored  in  memory starting at address  "adr".   Unlike  BLOAD  
    several different areas of memory can be read as a  file.   In  
    the example,  the second quarter of a screen file is read into  
    the bottom edge of the screen. 
    (see also BPUT, BSAVE, BLOAD) 
 

-------------
Command BMOVE 
 
        BMOVE;src,dst,cnt

              src,dst,cnt: iexp

  With the help of the command BMOVE memory blocks can be copied.

         OPENS 1,0,0,320,200,1,128
         bm%=LPEEK(SCREEN(1)+88)
         bp%=LPEEK(bm%+16)
         DIM a%(1000)
         BMOVE bp%,*a%(),2000

 Copies the first 1000 bytes from the screen bit plane into the arry a%


----------------
I/O COMMAND BPUT 

    HOW: BPUT[#]i,adr,cnt 

    EXAMPLE: OPEN "0",#1,"SCR.DAT" 
               BPUT #n,adr,num
               CLOSE #1 

    PURPOSE: Reads from an area of memory out to a data channel. 

    EXPLANATION: "i","adr" and "cnt" are integer expressions.  "i"  
    is  a  channel number (see OPEN).  "cnt" bytes are  read  from  
    memory  starting at address "adr" and written out on the  data  
    channel. Unlike BSAVE several different areas of memory can be  
    sent to a file.   In the example, the top and bottom halves of  
    the screen are exchanged and written onto a diskette. 
    (see also BGET,BSAVE,BLOAD) 
 

-----------
Command CLR 

    HOW: CLR var[,var...] 

    EXAMPLE: CLR A,B,C%,D!,E$ 

    PURPOSE: Deletes variables. 

    EXPLANATION:   "var" is the name of the variable to be deleted  
    (not an array).  The example is a short form of: 

        A=0 
        B=0 
        C%=0 
        D!=0 
        E$="" 

    Arrays are deleted with ERASE. 
 

------------------------------
I/O Function       CRSCOL
                   CRSLIN 
                   POS(x)
                   TAB(n)
                   HTAB column
                   VTAB line

EXAMPLE:

Print AT(38,12);"TEST";
Print CRSCOL'CRSLIN
Print TAB(37);"TEST";
Print PAS(0)

 TEST 42 12 and TEST 41 are displayed

Print AT(4,3);"WORD 1"
HTAB 4
VTAB 2
Print " WORD 2"

  WORD 1 = 4th column of the 3rd line
  WORD 2 = 4th "             2nd


    PURPOSE: Determines the cursor position. 

    EXPLANATION:   CURSLIN  is  the line on which  the  cursor  is  
    located  (y) and CURSOL is the column on which the  cursor  is  
    located (x).   In the example the cursor position is stored in  
    0x and 0y,  text is printed and then the cursor is returned to  
    its original position. 
    (see also PRINT AT) 
 

--------------
Command DEFNUM 

    HOW: DEFNUM n 

    EXAMPLE: DEFNUM 5 
                FOR Lp=1 To 10 
                 X = RND*10 
                 PRINT X 
                 NEXT Lp 

    PURPOSE: Rounds all numbers to "n" digits before output. 

    EXPLANATION:  "n" is an integer between 3 and 11 which  states  
    to  how  many places the following numbers are to  be  rounded  
    before  output.   This is to correct any rounding errors  that  
    may have occurred.  In financial applications itis recommended  
    to  always calculate in cents as rounding errors do not  occur  
    as  often when dealing with whole numbers.   By  defining  the  
    numbers  as integer variables (var%) the speed of the  program  
    is greatly improved. 
    (see also PRINT USING) 
 

-------------
Function EVEN 

    HOW: EVEN (n) 

    EXAMPLE: REPEAT 
               INPUT "Enter an even number";N 
              UNTIL EVEN(N) 

    PURPOSE: Determines whether a number is even. 

    EXPLANATION:  "n" is a numeric expression.   EVEN(n) is -1  if  
    "n" is even or zero and 0 if "n" is odd. 
    (see ODD) 
 

---------------------
Command/Function EXEC 

    HOW: EXEC command$,in,out
            
    EXAMPLE: 
                EXEC "run clock ANALOG=100,100,200,120 seconds"
                EXEC ":clock",-1,-1
                
    PURPOSE: Loads and executes machine code programs or  compiled  
             programs from disk. 
 
   EXPLANATION:
   
    This command starts up a new CLI process. The CLI command is supplied
in "command$". The "in" and "out" are channel numbers for the standard
input and output for this CLI process. To keep the same channel use -1


--------------
Constant FALSE 

    HOW: FALSE 

    EXAMPLE: Flag!=FALSE 

    PURPOSE: Constant 0 

    EXPLANATION:   This  is simply another way of  expressing  the  
    value of a condition when it is false and is equal to 0. 
    (see also TRUE) 
 

-------------------------
I/0 Command FORM INPUT AS 

    HOW: FORM INPUT n AS var 

    EXAMPLE: XField 3$="Hello There" 
               PRINT "Change field 3" 
               PRINT AT(15,15); 
               FORM INPUT 15 AS Field3$ 

    PURPOSE: Allows  a  character string to be  changed  during  a  
             program. 

    EXPLANATION: "n" is the maximum length for the string variable  
    "var".   This  command  works in the same way  as  FORM  INPUT  
    except  that  the old contents of the string variable  is  are  
    printed out to be edited and changed. 

        You can use the left and right arrow keys to move  through  
    the string,  and the up and down keys to move to the beginning  
    or end of the string.   The backspace and delete keys work  as  
    in  FORM INPUT.   During editing you are always in the  insert  
    mode. 

    (see FORM INPUT) 
 

----------------- 
I/O Function INP? 

    HOW: INP?(n) 

    EXAMPLE:  DO 
               IF INP? (2) THEN 
                 A=INP(2) 
                 PRINT A;""; 
                ENDIF 
               LOOP 

    PURPOSE: Determines the input status of a peripheral. 

    EXPLANATION:   "n" is the number of the device.  The function returns
    a value of 0 if a byte is  
    present,  otherwise  it returns -1(or at least a  value  other  
    than 0).   The example checks to see if a key has been pressed  
    and prints out the ASCII code of the key if it has. 

    (see also OUT?) 
         

------------
Command MID$ 

    HOW: MID$(svar,a[,n])=sexp 

    EXAMPLE:  A$="ABCDEFGHIJKL" 
                MID$(A$,5)="..." 
                MID$(A$,3,1)="QWER" 

    PURPOSE: Allows parts of strings to be changed. 

    EXPLANATION:  "svar"  is  a string variable  "a" and  "n"  are  
    integer expressions.  "sexp" is a character string  expession.   
    "n"  characters  of the string variable are  changed  starting  
    from position "a" if "n" is not specified.  As many characters  
    as  "sexp"  contains are changed.   This does not  change  the  
    length of the string variable.  The example changes the string  
    to "ABQD...HIJKL". 

    (see also RSET ad LSET) 
 

---------------
Command MONITOR 

    HOW: MONITOR [n] 

    PURPOSE: Calls  a  monitor resident in memory  or  a  commands  
             extension. 
    EXPLANATION: 
              
   Can call assembly subroutines, debug programs or other utility
programs. For this purpose the illegal instruction vector (address 16)
must be rerouted to the address of the subroutine. this subroutine must
end with RTE. [n] must be written to register d0. 


------------
Function ODD 

    HOW: ODD(n) 

    EXAMPLE:  REPEAT 
                INPUT "Enter an odd number ";N 
               UNTIL ODD(N) 

    PURPOSE: Determines whether a number is odd. 

    EXPLANATION:   "n" is a numeric expression.   ODD(n) is -1  if  
    "n" is odd and 0 if "n" is even. 

    (see EVEN) 
 

---------------------------------------------------------
Command OPTION 
                                            OPTION BASE 0 
                                            OPTION BASE 1 
    HOW: OPTION BASE 0 
         OPTION BASE 1 
         OPTION ["]TEXT["] 

    EXAMPLE:  OPTION "TRAPV+" 
              OPTION BASE 1 
              DIM A$(9) 
              FOR I=1 TO 9 
               A$(I)=STR$(I) 
               PRINT A$(I) 
              NEXT I 

    PURPOSE: Changes the array base or control for the compiler. 

    EXPLANATION:  OPTION BASE 0/1 allows the lower limit for array  
    dimensioning  to  be  changed  from 0 to  1  and  vice  versa.   
    Programs which do notuse the Zero element can save some memory  
    this way.   GFA-BASIC allows only 0 or 1 to be used as a  base  
    and it applies to all arrays.   Control commands can be passed  
    to the compiler with OPTION "TEXT".  See the compiler handbook  
    for further details. 
 

---------------
Command RESERVE 

    HOW: RESERVE n 

    EXAMPLE: RESERVE 1024
             PRINT FRE(0)

    PURPOSE: Increases or decreases the amount of memory available  
             to be used.


------------------ 
Command TROFF 
        TRON
        TRACE $
        TRON proc
 
 
    EXAMPLE:  OPEN "",#99,"LPT:" 
                TRON #99 
                FOR I=1 TO 99 
                NEXT I 
                TROFF 
                CLOSE #99 
   
    PURPOSE:  Switches the trace function on and off. 

    EXPLANATION:   After  the TRON command all commands are  shown  
    prior to execution.   If "#n" is not specified then the output  
    is on the screen, otherwise it is sent out over the previously  
    opened  data  channel "n" (It is sent to the  printer  in  the  
    example).   TROFF switches this function off.  The output from  
    TRON  can  be  slowed down by pressing the  capslock  key  and  
    temporarily halted by pressing the right-hand shift key. 

    The application of TRON proc in connection with TRACE$ makes for a
    efficent error search.
 
Procedure tr_proc
Print AT(1,5) SPACE$(80)
Print AT(1,5) LEFT$(TRACE$,79)
PAUSE 20
RETURN


-------------
Constant TRUE 

    HOW: TRUE 

    EXAMPLE: Flag!=TRUE 

    PURPOSE: Constant -1 

    EXPLANATION:   This  is simply another way of  expressing  the  
    value of a condition when it is true and is equal to -1. 

    (see also FALSE) 
 
 
-------------
Function TYPE 

    HOW: TYPE(ptr) 

    EXAMPLE:  Ptr=A* 
              Print TYPE(Ptr)  !returns 0 

    PURPOSE:   Determines  the  type of the variable  at  which  a  
    pointer is set. 

    EXPLANATION:   "ptr" is an integer expression (usually  *var).   
    TYPE(ptr) returns a code according to the type of variable  to  
    which  "ptr" is  pointing.   0=var,  1=var$,  2=var%,  3=var!,  
    4=var(),  5=var$(),  6=var%(),  7=var!().   On  errors  -1  is  
    returned. 

    (see also *) 
 

------------
Command VOID 

    HOW: VOID x
         ~ x
 
  Not interested in what is returned from a function, but in the results
which are produced by the function. 

 ex: VOID WAIT will return a single bit
     ~ WAIT will return calaculates an interger


------------- 
Command VSYNC 

    HOW: VSYNC 

         OPENW 0
         t%=TIMER
         FOR i%=1 TO 100
         VSYNC
         NEXT i%
         PRINT SUB(TIMER,t%)/200

     Prints the time required for 100 screen cycles


    PURPOSE: Synchronization with the screen (waits for the 
             vertical blank). 

    EXPLANATION:   Halts the program until the next vertical blank  
    picture  synchronizing impulse is received,  i.e.,  until  the  
    picture  is complete on the screen.   This can help  to  avoid  
    flickering of the screen during animation, (e.g. with GET/PUT)  
    but  the  screen  must be modified very  quickly  (during  the  
    vertical blank).  It is equivalent to VOID XBIOS(37). 
 

 Note: this area is for MENU        brief explantions of cmds are here!

 When a pull down menu is created these entries are stored in a string
array m$() with the command MENU m$() this pull down menu is placed on the
screen, the command ON MENU GOSUB defines the procedure to be called when
the cooresponding menu entry is selected.


MENU m$()

 Menu m$() presents the pull down menus which are supported by the
commands of the section (ON MENU, MENU())

 TMENU ms() presents the pull down menu on the screen, the menu titles and
entries are contained in the character string m$(), the following format
must be used for the organization of the arrays m$()

1 title of the menu
2 list of menu entires
3 empty string to mark the end of the menu

 An additional empty string of the final menu is needed to mark the end of
the entire pull down menu.

ON MENU t
SLEEP

 The command ON MENU watches for the occourance of an event, the procedure
that is to be branched to should be set before this command is executed.
Therfors ON MENU command is usually placed in a loop.

The parameter t conatains the time in intui-ticks=tenths of a second after
which the ON MENU will be ended.
 
SLEEP is equivalent to ON MENU 1 and waits for one intui-tick or some
other event (for example menu selection), this is only generated on active
windows.

ON MENU GOSUB proc
ON MENU KEY GOSUB proc
ON MENU BUTTON GOSUB proc
ON MESSAGE GOSUB proc

 When a message is encountered the program will branch to the procedure
with the name "proc". The observation is accomplished with every ON MENU
or SLEEP command. 

ON MENU GOSUB proc a procedure will be set after the menu selection has
been made this procedure will be branched to, th emenu selection can be
determined within this procedure with th e help of MENU(0)

ON MENU KEY GOSUB proc a procedure is assigned to handling of keyboard
input, wit key code in MENU(2)

ON MENU BUTTON GOSUB proc a procedure is assigned to handling of mouse
buttons.  MENU(2) contains an indiction of a button press or release.


MENU KILL
MENU x,y
MENU x,str$
MENU KEY y,y

MENU KILL turns the pull down menu off, additionally MENU KILL turns the
ON MENU GOSUB settings off. With the command MENU x,y the x-th entry of a
basic menu can be changed, the number of the entry cooresponds to the
string index of the array, in which the pull down menu entry is found, th
enumbering begins with zero;titles and empty strings are counted!!!
 
 The second paprameter y, determines what is to be done with the x-th menu
entry, the following options are available:

y    effect
-----------
64  menu entry is displayed in inverse if selected

128 a box is drawn around the menu

192 the menu should be un-changable

256 set check mark before entry

 New text can be assigned for a menu entry using str$.

 MENU KEY assigns an ascii character (shortcut) to a menu entry.

ex:

DIM a$(100)
DO
READ a$(i%)
EXIT IF a$(i%)="*"
INC i%
LOOP
a$)i%)=""
DATA  MAIN, ABOUT, INFO, TEST,
DATA  FILE, LOAD, SAVE,----------,OPPS,
DATA *
OPENW 2,0,10,640,120,&H408,1
MENU a$()
MENU 3,"  test"
MENU KEY 6,65
ON MENU GOSUB men
ON MESSAGE GOSUB msg
ON MENU BUTTON GOSUB but
ON MENU KEY GOSUB key
DO
ON MENU
LOOP
PROCEDURE men
Print MENU(0),a$(MENU(0))
Return
Procedure msg
Print "msg:"
For i%=0 to 9
Print HEX$(MENU(i%),8)
Next I%


Print
Return
Procedure but
Print "but:"
SELECT MENU(2)
CASE &H68
? " Left mouse button pressed" 
Case &HE8
? " Left mouse button released"
CASE &H69
? " Right mouse button pressed"
Case &HE9
Print "right mouse button released"
ENDSELECT
Procedure key
Print "key:"HEX$(BCLR(MENU(2),7),2)
If BTST(MENU(2),7)
? "  released"
ELSE
? " pressed"
ENDIF
Return


 Readme GFA-Basic 3.02 AMIGA 24.2.1989

 The Run-Only-Interpreteter
 --------------------------
 The Run-Only-Interpreter GFABAS-RO is Public Domain.

 To start a GFA-Basic program with the Run-Only from Workbench,
 single click it's icon. Then select "INFO" from the Workbenchmenu
 and change the TOOL (GFABASIC) to GFABAS-RO.
 Now, when you double-click on your program's icon, the Run-Only will
 load automatically and run your program.


 BOBs-Blitter Objects
 --------------------
 Blitter object's are a special kind of sprites. You can create them
 with the Amiga-Objecteditor. Further you can use the program
 "IFF_TO_BOB" to build a Bob.

 commands:
       OBJECT.AX    object,value
       OBJECT.AY    object,value
         defines the acceleration of the Bob (pixels/sec)

       OBJECT.CLIP  x0,y0,x1,y1
         defines a frame where the Bobs are visible

       OBJECT.CLOSE [Obj [,Obj [,Obj ] ] ]
         erase Object[s]
         without parameters all objects are erased

       OBJECT.ON    [Obj [,Obj [Obj ] ] ]
       OBJECT.OFF    "     "    "
         Obj : 16 Bit object-number
         switches an object.
         without parameters all objects are switched on/off

       OBJECT.PLANES Obj [PlanePick [,PlaneOnOff ] ]
         PlanePick, PlaneOnOff : 8-Bit-Masks
         OBJECT.PLANES fixes the Bob's color.
         PlanePick defines the bitplane in which the BobInfos
         are painted. PlaneOnOff defines the used bitplanes.

       OBJECT.PRIORITY Obj,Prio
         Bobs with a higher priority are set in front of bobs
         with a lower priority.

       OBECT.SHAPE Obj,String
       OBECT.SHAPE Obj1,Obj2
         (1) The definition for Bob number <Obj> is given
             by a String from the Object-Editor or
             the "IFF_TO_BOB" program.
         (2) Obj1 uses the shape of Obj2.

       OBJECT.START [Obj [,Obj [,Obj ] ] ]
       OBJECT.STOP    "     "     "
          Start and stop of Bobs-movements.
          All objects are stopped or started if there
          are no parameters.

       OBJECT.VX    Obj,Value
       OBJECT.VY     "    "
          defines the speed of an object in pixels per sec.

       OBJECT.X     Obj,Value
       OBJECT.X      "    "
          set object number Obj at ValueX/ValueY
          Don't forget using the OBJECT.ON command to
          make the Bob[s] visible.


       ON COLLISION GOSUB proc
         proc: Procedure's name to react on collision

       Object-Functions:
       use
       ...=OBJECT.X(Obj)
          =OBJECT.Y(Obj)
          =OBJECT.VX(Obj)
          =OBJECT.VY(Obj)
          =OBJECT.AX(Obj)
          =OBJECT.AY(Obj)
       to read the position, acceleration or the speed
       of the specified Object.

       The GFA Bob-commands work similar to the AmigaBasic
       Object-commands except for:.
         - Collision ON/OFF/STOP is not possible
         - ...=COLLISION(-1) does not give number of the window


 E D I T O R   M E N U :
 -----------------------


       LOAD      Amiga-L  as F1

       SAVE      Amiga-S  as shift-F1

       New Names Amiga-N  ask for confirmation when new variables are
                          introduced (switch)

       RUN       Amiga-R  as Shift-F10

       Taskpri 0 Amiga-0  Changes taskpriority to 0.

       Taskpri 1 Amiga-1  Changes taskpriority to 1.
                          Use ~SetTaskPri(FindTask(0),n) to set other
                          taskpriorities.

       Clenup    Amiga-C  Stop Sound, stop Bobs and clear Sprites
                          Closes Screens and Windows.

       Save Icon Amiga-I  Save program with an Icon or without

       NewCli             starts a new CLI


 N E W  C O M M A N D S:
 ----------------------
 The following command are added:

   OPEN "_",#_,"COM1:[BAUDRATE [,PARITY [,LENGTH [,STOPBITS]]]]"
   with: BAUDRATE: 110/150/300/600/1200/1800/2400/4800/9600/19200
         PARITY:   "N" (no parity), "O" (odd) or "E" (even parity).
         LENGTH: the number of bits (5 to 8)
         STOPBITS: the number of stopbits to use (1 or 2)

   This command is used as in AmigaBasic. It opens a file for Input
   or Output to the serial port, and allows to configure the serial port.
   examples:

   OPEN "I",#1,"COM1:9600,N,7,1" opens for input, sets the serial port
            to 9600 Baud, No parity, 7 bits with 1 stopbit.

   OPEN"O",#1,"COM1:300,O,6,1" opens for output, sets the serial port
            to 300 Baud, Odd parity, 6 bits and 1 stopbit.

   OPEN"O",#1,"COM1:600" leaves all paramters unchanged except for the
            baudrate.

   _IOExtSer
   This is the Pointer to the extended Input Output Request Block of
   the serial Device "COM1:"

   example:
     OPEN "O",#1,"COM1:"
     PRINT "BAUD:"{IOExtSer+60}
     CLOSE 1


 - GET/PUT now use clipping

 - SGET $()/SPUT $() : They do the same as the SGET string /
   SPUT string -commands on the ST, except that they use a string-ARRAY
   instead of a string (On the Amiga a screen can use more than 32K).
   They work on screen: they take (or put) the contents of a whole screen.

 - SCROLL dx,dy,x0,y0,x1,y1 scrolls a rectangle in your window.
   i.e.: SCROLL 2,3,10,10,100,100  scrolls the rectangle (10,10)-(100,100)
   two pixels to the right, 3 pixels down, and the second parameter of
   COLOR determines the color of the borders that are scrolled in (here left
   and upper border of the rectangle).

 - Now GFABASIC also saves an Icon with your sources if you want it to.
   Therefore, the pull-down menu got an extra selection called "Save Icon",
   shortcut is "Right_Amiga_Key + I". Use this to turn this icon-save-option
   on or off.


 F O R ... N E X T
 -----------------

 FOR ...  NEXT loops are now not executed if the start value is not already
 greater than the endvalue.

 The following loops give similar results:

 FOR NEXT                 GFA-Basic V3.00      GFA-Basic V3.02

 FOR i=a TO b             i=a                  i=a
  ...                     REPEAT               WHILE i<b
                           ...                  ...
                           INC i                INC i
 NEXT i                   UNTIL i>b            WEND


 The Amiga BASIC to GFA BASIC converter.

 There's a program on this disk to convert Amiga BASIC programs to GFA BASIC.
 It is called AB2GFA.GFA. It will convert most programs. However, a few
 commands are not yet supported. These include CIRCLE, SOUND WAIT,
 SOUND RESUME, and Library calls. With a little work, these commands can be
 modified by hand to work. This conversion program is still under development.
 More complete versions will be uploaded to GEnie, BIX and CompuServe as
 they are completed. This program is Public Domain and can be freely
 circulated.

----------- END OF FILE --------------------------------------------------

                    Typed By: PAPPY  01/31/90

 Items missing are the         Library commands
                               Appendices
                               Abbrivations of commands
                               A few examples

  There is more than enough to get any person started out, I may add that
if you have GFA, the examples in the GFABASIC.ARC I have set up to the 
boards are enough to get you started where the manual is missing!
 
Have fun...Pappy signing off with dead fingers and a head ache!

PS: Ignore any spelling mistakes!

