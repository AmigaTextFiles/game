

Part Two

  Menu Options:
    Help
    Load from RDB...
    Save to RDB
    Load from File...
    Save to File...
    Quit

The  Help menu item displays help for either the Device Editor proper or
the Device Analyzer, depending on the mode selected for the editor.

The  Quit  item,  like the close gadget, unconditionally quits DiskSalv.
There  is  no  difference  between the two, though some users prefer one
method over the other.

The  Device  Editor  has  functions to read or write a disk's rigid disk
block.    The  Rigid Disk Block is a standard for Amiga disk drives that
allows  partitioning  information,  among  other  things,  to  be stored
on-disk,  in  a controller-independent fashion.  When a hard disk device
starts  up,  the  partitions found in the RDB are examined and, usually,
automatically mounted as AmigaDOS devices.

If something goes wrong with the RDB, the partition or partitions on the
disk  may be inaccessable by normal means.  DiskSalv can help here.  The
Device Analysis function can find any partitions physically present on a
disk.    These  show up in the standard Device List.  These can be saved
back  to the RDB via the Save to RDB menu item.  Alternately, the device
editor can be loaded by selecting the Load from RDB menu item.

This  function loads a device description from a disk's Rigid Disk Block
into  the  device  editor.   This can be used to edit the sttings in the
RDB,  or simply to examine them.  The name and unit number of the device
must  be  entered  in  the  device  editor  before  this function can be
selected.

This function saves the device description in the Device Editor out to a
disk's  Rigid  Disk  Blocks.  The Exec name, AmigaDOS name, unit number,
and all numeric parameters must be entered before this can be done.

The  Save  to File item brings up a standard file requester to allow the
currently  edited device to be written out to disk in DOSDrivers format.
If  no  device is entered, this item is disabled.  This is virtually the
same  as  the  Save  Device button function, except that it works on the
device  description  in  the  Device  Editor  rather  than the currently
selected input window device.

This  button  brings  up  a  standard  file requester, to allow an ASCII
device  description file to be loaded as a virtual device into DiskSalv.
Such  a  file  must be in the DOSDrivers file format.  A DOSDrivers file
contains  the description of a single device, using the same notation as
originally defined for the system-wide MountList file.  DOSDrivers files
have  been  preferred  on  the  Amiga, rather than the single MountList,
since  AmigaOS  2.00.    Rather than use the Load from File menu item, a
DOSDrivers  file  may  simply  be dropped into the Device Editor window.
This  is  virtually the same as the Load Device button function, only it
operates  on  the Device Editor only, it doesn'taffect the current input
window device.

The  object  of Device Analysis is to find any viable disk partitions on
the  given  device  and  unit.   As such, the data entered in the Device
Editor  is  not  for  a specific partition, but for the search that will
hopefully  produce  some  partitions.    The  search  can  be limited by
matching encountered volume names against a normal AmigaDOS pattern, and
also limited by the range of sectors given for the analysis.

There  are two analysis options, which differ only slightly.  The Search
option  will  stop analysis after the first volume matching the supplied
pattern  is  found.    A Search run will produce at most one new virtual
device  entry  in the Device List.  The Analyze option will find as many
partitions  matching  the  supplied  pattern  as  possible,  within  the
constraints of the supplied physical parameters.

The  Search and Analyze buttons are disabled until enough device data is
supplied.    Device  data  doesn't  have  to come entirely by hand.  The
current device description is transferred on entry to the Device Editor,
just as with a normal edit.  DOSDrivers files work as usual, too.  Icons
dropped  behave a bit differently.  The device decription resulting will
show  the  range  of all AmigaDOS devices on that particular Exec device
and  unit.    This won't necessarily cover the whole disk, but it can if
the  first  and  last partitions are known to AmigaDOS.  Note that while
the  analysis  routine  can't go beyond the limits set, it can go beyond
the  end of the disk (device drivers return an error here).  So it isn't
absolutely necessary to figure the last block properly, though errors do
slow things down.

The  Device  Analyzer produces a virtual device entry for each partition
it  finds.  These will show up in the device list as soon as analysis is
complete.    The Save Device function can write this out to a DOSDrivers
compatible MountList file.  The Device Editor can be called up to modify
anything  that's found, or to save the device description out to a Rigid
Disk Block descriptor.

The  Device  Editor fields are similar to some of the parameters used in
DOSDrivers and MountList files.  DiskSalv needs only the parameters that
are called for in the Device Editor, while these aforementioned AmigaDOS
conventions support a much greater number of parameters.

  Fields:
    Device Name
    DOS Name
    Pattern
    Unit
    Surfaces
    Sectors/Cylinder
    Low Cylinder
    High Cylinder
    Bytes/Sector
    Sectors/Block
    Flags
    Memory Type

This  is  the  name  of  the  Exec  device,  such  as  trackdisk.device,
scsi.device, etc.  This can be typed directly into the string gadget, or
it  can  be selected via a list of all devices, called up by clicking on
the  associated list gadget.  An Exec device is necessary for all Device
Editor  functions.    Naturally, not all devices in a system can be used
here,  only  arbitrary  disk-oriented  devices  can.  There is no way to
determine automatically whether a device follows this convention or not,
but DiskSalv will report any failure to open the specified device.

The  is the name of the DOS device, such as DF0:, DH1:, etc.  This field
is  present  when  the Device Editor is called up via the editor button.
All  devices  must  have  a  unique  DOS  device name specified, even if
they're just being created for use in DiskSalv.

This  is a standard AmigaDOS pattern string.  This field is present when
the Device Editor is called up via the analysis button.  This pattern is
used  as  a template for volumes enountered during the analysis run.  If
the  Search  button  is  pressed, the scan quits as soon as one match is
made.    If  the  Analyze  button  is pressed, any volumes matching this
pattern  are  added  to  the  device  list.  If no pattern is physically
entered, the AmigaDOS pattern #?  (match anything) is used by default.

This  numeric  field  specifies the unit number associated with the Exec
device  selected  above.  Most disk-oriented device drivers support more
than  one unit.  Typically, there are four floppy disk units (0..3), two
IDE  units  (0 and 1), and eight SCSI units (0..7) associated with their
respective device drivers.  A unit entry is required.

This numeric field specifies the number of surfaces physically supported
on  a  disk.    Disk  drives typically have several physicaly read/write
heads, each of which addresses a single disk surface.  Floppy disks have
two such heads, one for the top surface, one for the bottom.  Large hard
disk drives may have 15 or more active surfaces.

This numeric field specifies the number of sectors physically located on
a disk's cylinder.  For most devices this number is all but meaningless,
since  devices  are  logically  addressed.  The proper cylinder size, if
known,  can  make  some  difference  in  speed,   since   buffering   in
cylinder-sized  chunks  can increase efficiency.  This parameter is more
important  for  floppy  disks,  since  they're naturally buffered by the
Amiga  OS  and  can only be read or written to in cylinder-sized chunks.
For  SCSI  and  other  logically  addressed  devices,  its the aggregate
cylinder, surface, and sectors/cylinder numbers that are important taken
together.

This  numeric  field  specifies  the  lowest logical cylinder (sometimes
called  track) on the disk.  Nearly every kind of disk and device driver
starts  the  disk  at  location  zero.   However, when creating a single
device  description,  it is the starting sector of the logical partition
that's  really  the  object  of  concern.    Analysis  operations aren't
concerned  with  starting  or finishing at any specific point on a disk,
but  unless  the approximate location of the missing partition is known,
it  is  a good idea to start the analysis near the first cylinder of the
disk.

DiskSalv  device  scans,  and  some   other   AmigaDOS   device-oriented
operations,  express  the  start  of  the  partition  in terms of sector
number.  The relationship between cylinders and sectors is expressed as:


    Sector = Cylinder * Sectors/Cyl. * Heads@

On  physically addressed devices, like the floppy or the ancient ST-506,
these  numbers  have  significance  to the device driver, but have never
been  a real concern to anything communicating to file systems or device
drivers.

This  numeric field specifies the highest logical cylinder on the disk.
Every  disk  has a physically defined last cylinder, but when creating a
single  device  description,  it  is  the  last  cylinder of the logical
partition  that's  really  the  object  of concern.  Analysis operations
aren't  concerned  with starting or finishing at any specific point on a
disk.    If the last cylinder on the disk isn't known, an arbitrary high
value  can  be  used.    If  the  scanner  runs off the end of the disk,
DiskSalv  will  report disk errors.  At this point, the operation can be
stopped.

This  cycle  gadget specifies the number of bytes per sector.  All legal
values  are in the cycler.  All file systems in AmigaDOS 1.3 and earlier
used  512  bytes/sector,  and  that's still the most commonly used value
today.    Since  the  AmigaDOS 2.00 file system, larger values have been
possible.  Some versions of the file system had problems with very large
blocks, but this is not a problem.  When used in analysis runs, DiskSalv
will  attempt  to  reject  blocks  encountered that are formatted with a
different byte/sector value.

This  cycle  gadget  specifies  the  number  of sectors per block.  This
mechanism  is  another  way to get larger blocks in a partition.  It has
the advantage over large bytes/sector setting in that every partition on
the  disk  can  easily  have  a different logical block size.  All legal
values  are in the cycler.  All file systems in AmigaDOS 2.1 and earlier
used  one  Sector/Block,  and  that's still the most commonly used value
today.    Some  early  device  descriptions  didn't  set this to one, so
DiskSalv by default disables this field for older file systems (this can
be overridden by setting the BIGBLOCKS command parameter).

Since  the  AmigaDOS  3.0 file system, larger values have been possible.
The  analysis routine attempts to reject blocks formatted under any size
but  the  one  selected here when scanning the disk.  If a disk has been
formatted with partitions of differing settings, several analysis passes
may be necessary to find all partitions.

This  numeric  field takes a startup code that is specific to the device
driver  in use.  Most drivers don't do much with this field.  A value of
zero is the default, and recommended if there's no other value suggested
by  documentation  or copying in any mounted device (such as the current
device or one dropped in from Workbench).

Many device drivers require a specific type of memory for their buffers,
or  at  least  perform  better  with  a  particular type.  Floppies once
required  Chip  RAM,  though  work  properly  with Fast memory in recent
releases  of  the  trackdisk.device.   Most others work fine with system
default  memory.  On a 32-bit Amiga, DMA-driven Zorro II based hard disk
controllers  work  much  better with DMA-24 memory, though most will use
programmed I/O techniques to deal with other memory.

The  Disk  Scanner is the primary progress indicator for actual DiskSalv
activity.   Windows such as the input, Filter, or Device Editor are used
for  setting  up  some  kind  of  disk operation.  Once a disk operation
actually starts, DiskSalv brings up the Disk Scanner window.  This is an
informational  display  which provides a display of the current scanning
function  being  run, a tally of various objects encountered, a progress
indicator graph, and a list of major disk events.

The  look  of the scan window changes depending on several factors.  The
size  of  the  window  is  based  on the system font and the size of the
screen  being  used.  Several user options also control the look of this
window.

There are various displays within the Disk Scanner, as shown above.  The
displays  themselves  are  simple  to  explain.    The Operation display
indicates  the  current  type  of  scan being run.  Most Major Modes are
composed  of  several scanner passes.  The Device Scan display shows the
current  block, plus a count of objects: files, directories, volumes, or
errors, depending on the Major Mode and scanner operation selected.  The
bar  graph represents the progress of the scan.  In some operations, the
progress  indicated  here is an estimate.  Finally, the Scanning Results
display shows any major significant results of the scan in progress, and
can be instructed to pause on any errors encountered.

There  are  quite a few different scanning operations.  There is no need
to  understand any of these in order to use DiskSalv, but they're useful
to  anyone  interested  in  what's  going  on.   The operation types are
described below.

  Operations:
    Checking Root
    Cleaning
    Copying
    Directory Check
    Extras
    Filtering
    FS Analysis
    Hash Check
    Link Check
    List Trace
    Loose Blocks
    Paused
    Purifying
    Rehashing
    Resolving
    Salvaging
    Scanning
    Stopping...

In  any  fix-in-place  mode, the disk's directories must be certified as
correct,  or  changed  to be correct.  The root block is a special case,
since  no  fix  can  occur  if  the root block cannot be corrected.  The
operation  used  here is the same as in the Directory Check routine, but
it  is  one of the first operations run after a scan in all fix-in-place
modes.

This  operation  indicates  that  the input disk is being cleaned of all
deleted  files.    This  is the active part of the Cleanup mode.  Once a
disk  has  been  cleaned,  none  of the deleted objects remain, they are
completely wiped out and nothing can bring them back.

In  this operation, objects from the input disk are simply copied to the
output  disk.  This is the active part of the Backup mode.  The function
is  similar  to the Salvage operation, but since it runs on a presumably
good  input volume, no special tricks are necessary to achieve the copy.

This  operation  is  the actual fix-in-place function that certifies the
structure of every subdirectory on a disk.  If there's a soft error in a
directory  block, it can rebuild this subdirectory as long as there's no
physical problem with the disk.

When  the  scanner  is  started  by  the  Stream  Restore function, this
operation  is  run.    During such a run, a structured archive stream is
rebuilt on the selected output device as an AmigaDOS directory.

Some  modes  have  a small, mode-specific set of functions to run on the
scanned data set.  This operation name is a catch-all for these kinds of
functions.

When  scanning  takes place with a pattern selected, the pattern must be
applied  to  each object encountered.  Some patterns, such as file name,
file  note,  date,  size,  or  protection  comparisons,  are  completely
resolved  during the scanning project, being local to the object.  Other
patterns  can only be applied once a full scan is complete, such as full
path comparisons.  These are resolved here.

This  operation  is  run  only when the Best-Guess pseudo file system is
selected.    It  chooses the most likely file system for the given disk,
based on all of the objects encountered on that disk.

This  operation,  called  during  a fix-in-place operation, verifies the
integrity  of  every  object  as  it  appears  on-disk.  It does this by
comparing  the  internal disk model to the contents of each directory as
they  appear  on-disk.    Each file encountered is checked completely by
tracing  out  all  data and list blocks that appear as components of the
file.    Anything  that  doesn't  pass  this test is eliminated from the
active  directory  tree of the disk, but of course not physically erased
from the disk itself.

This  is  a  fix-in-place  operation that checks link objects.  The hash
check  routine  will  actually  check  that any links found are properly
formed,   and   eliminate   those   that   aren't.      In    this pass,
interdependencies between links and the file they reference are handled.
Any hard link pointing to an object that no longer exists will itself be
removed.   Symbolic links are processed for correctness, though the file
system  no  longer  supports  them.    No  check  is  done on the object
referenced by a symbolic link, since it can easily be on another volume.

Files beyond a certain length (36864 bytes in FFS with 512 bytes/sector)
use  a  linked  list  of  list  blocks  to track additional file content
blocks.   DiskSalv tracks any such list blocks encountered during a scan
in this phase, to locate possible partial files.

When  scanning  an Original File System disk, individual data blocks can
be  identified.  In this phase, any data blocks enountered that were not
assigned to a file are reconstructed as partial file nodes.

When  the  pause  button  is  on,  this is the operation displayed.  The
previous  operation  resumes  when pause is off.  Other buttons, such as
stop,  pause-on-error,  or the general kill gadget, still work while the
display and scan are paused.

This  operation  is  the first fix-in-place pass, called only for Repair
mode.    It  eliminates  from  the  disk model any object that no longer
exists  in  the  disk's  directory tree, assuming that the tree is valid
enough  to  process in this way.  This prevents deleted files from being
restored by Repair.

Directory  contents  are  presumed  sorted in block sequence by the fast
file  system.  Once the main fix-in-place operations have been run, this
function sorts the contents of all the directories on the disk.

When  a  partial  scan  of the input disk is run, it's common for parent
nodes  to  be  missed.    In this phase, any such unresolved parents are
located.

In  this phase, the input disk's contents are being reconstructed on the
output  device  selected  on  the  output  window.   This is the primary
recover-by-copy operation.

This  operation  is  the  preliminary scan of the input disk.  There are
different  scanning  funtions, depending on the Major Mode selected, but
each builds a model of the input disk during this phase.

This  operation  is  displayed  after  the user presses the stop button.
This  indicates  that DiskSalv has recognized the stop request, but must
shut down some things before it can respond.

The  Device  Scan  display is simply one kind of progress indicator.  It
shows  a number of object counts, which vary by the Major Mode selected.
Most  of  the  time,  the  current  block,  a count of files, a count of
directories,  and a count of errors will be displayed.  When the scanner
is  called  up by the Device Editor, a running count of volumes replaces
the  error  count.   During a disk remake operation, a count of warnings
and errors is kept.

In  order  to  keep  a  scan running across the input disk as fast as is
practical,  the  Device  Scan  display  is normally updated only after a
number  of block counts.  The frequency of update depends on the size of
the input disk.  Any error encountered will force an immediate update of
the display.

No  matter  the  optimizations,  it's  a simple fact that the time spent
providing  this  display,  as well as the Scanning Results display, does
take  some  time  away  from  scanning.    When the Quick Scan option is
selected from the input window's Settings menu, the scanner is opened as
a much smaller window, with less frequent Device Scan updates.  There is
a  progress  indicator, but no Scanning Results display.  In most cases,
this  has  a  noticable  effect  on  scanning speed, especially when the
system's CPU and hard disk are very fast.

The  Scanning  Results  display  chronicles every major event that takes
place  during  any  kind  of scan.  This is the same information that is
written  to  a  log  file,  if such a file has been created on the input
window.    All  the  information  can  scroll by rather quickly, but the
pause-on-error  feature button can be set to let the user see each error
or warning as it scrolls past.

Each type of event known to the scanner is given a unique four character
code.   This is especially useful in log files, since it allows a search
to be done for any event.  However, it's also of general use, in that it
completely identifies each event.  The event codes include:

	CHEK		FILE
	ROOT		DATA
	FLNK		SLNK
	DSCH		FREE
	UDIR		DELD
	GOOD		WASH
	DLNK		KILL
	????		ERR!
	LIST

This  code  marks  check  failures.   During a Check mode pass, possible
errors  are  indicated  but  nothing is done about them.  Check failures
indicated  on  directories  are  usually repaired by a subsequent Repair
mode  run.  Files, on the other hand, must be eliminated from the active
disk tree when any component block shows a check failure.

In  a scan of a disk formatted with the original file system, typed data
blocks  are  identified  by this code.  Under the fast file system, data
blocks are untyped.

Directory  cache blocks are indicated by this code during a scan.  These
are  only  meaningful  under  the  new  directory  caching file systems.
Damaged directory cache blocks are usually not a problem, since DiskSalv
can force the file system itself to rebuild them.

This code is used during fix-in-place functions to indicate objects that
have been judged as already deleted.  In Repair mode, there is no desire
to  restore  any  objects  that  are already deleted.  In Unformat mode,
DiskSalv does attempt to bring back as much as possible, deleted or not,
since it must be less trusting of the existing disk format.

Hard directory links are indicated during a scan with this code, as long
as  they're considered valid.  Like other objects, if the directory link
must  be  removed  from  the active disk tree, it will be shown with the
KILL  code  during  the  hash  check phase of the fix-in-place routines.
Links  of  all kinds are tallied with the file count for the Device Scan
display.

Any  kind  of  read  error  returned  from  the input device's driver is
reported with this code.  These are usually some kind of hard failure on
the input disk.

This code is used to mark a normal file encountered during most scanning
operations.  This just indicates the file header block, which identifies
the  file  by  name, and indicates where the first group of file content
blocks  are.    Other  components  to  a  non-empty  file will be stored
elsewhere  on the disk.  Due to the AmigaDOS disk format, it is possible
for  DiskSalv to find only part of a damaged file.  It is left up to the
user  to  determine  whether  a  partial file is of any use in any given
case.

Hard  file links are indicated during a scan with this code.  Like other
objects,  if the file link must be removed from the active disk tree, it
will  be  shown  with  the  KILL code during the hash check phase of the
fix-in-place  routines.    Links  of all kinds are tallied with the file
count for the Device Scan display.

This  code  is  displayed  during scans of original file system disks to
indicate  a  block  that  hasn't been used.  There's no way to tell on a
block-by-block basis that the block is unassigned.  Since all OFS blocks
are typed, though, any untyped block can be assumed as free.

This code is used during a fix-in-place operation when a disk object has
been  judged  properly  formed.    Directories   are   judged during the
Directory  Check  operation,  while  other objects are judged during the
Hash Check operation.

When  an  object  within the input disk's directory tree has been judged
flawed  and  unrepairable,  DiskSalv  will  remove  it  from  the active
directory  tree,  and  display  the  object with the KILL code.  This is
necessary  when  a file component or link block is damaged physically or
logically,  or  when  a  directory  block  is  damaged  physically.  The
fix-in-place  routines  can always reconstruct a directory that has been
logically  damaged,  though this may cause the undeletion of some former
files that still reside in such a directory.

This  code identifies any file list blocks that are encountered during a
scan.    An AmigaDOS file format stores a fixed number of block pointers
to  a  file's  content blocks within its header block.  When the file is
larger than this number of pointers can support, a list block (sometimes
called  an extension block) is created.  Each extension block can access
another set of file content blocks.

This code is displayed when a scan encounters a disk's root block.  Each
valid  partition  has a single root block, which is in the center of the
disk.   This block is much like a user directory block, though it stores
some volume-specific data.

A  symbolic  link  block  is  indicated  by this code.  The current file
systems  no  longer  support  symbolic  links,  but  they were partially
supported  in  earlier  releases  (AmigaOS  2.x).  DiskSalv knows how to
handle  a symbolic link based on the original specifications for it, and
it  will  attempt  to  do  so  if  it  encounters  such  an object.  The
fix-in-place  routines  can  verify  that  the  on-disk structure of any
symbolic  link  is  correct,  but  since  symbolic  links  can reference
alternate  physical  devices,  no existence check is done for the linked
object.

This  is  the  code  displayed  for any subdirectory objects encountered
during  a  scan.    DiskSalv can supply the missing data for any damaged
directory in any mode, though it can't fix a directory that's located on
a physcially bad block.

During a Cleanup operation, any object that is permanently eliminated is
indicated  by  this  code.    Only  objects  that  have been deleted are
removed, and only on a valid partition.

When  a  fast file system scan encounters an untyped block, it uses this
code.    Since FFS data blocks are untyped, there is no way to determine
if a block is assigned or not from the block itself.

The  Disk Scanner window has three option buttons.  These can be used to
control  the  progress  of  the  scan,  or  simply stop it as quickly as
possible.    Of  course,  there  is  also a standard close gadget on the
window  itself, which will stop the scan and quit DiskSalv as quickly as
possible.

  Options:
    Stop
    Pause
    Pause On Error
    Ask On Error

This button signals the scanner to stop the current operation as quickly
as  possible.    It  will  immediately  cause  the  Operation display to
indicate  Stopping...    In  many  cases,   this   causes   an immediate
termination  of  the scanning.  The initial disk scan in any mode can be
stopped  immediately,  for  instance.    In  other  cases,   the current
processing  must  continue  for  awhile  in  order to leave the input or
output  disk  in  a  proper  state.    The   fix-in-place   routines, in
particular,  must completely finish processing once they start modifying
the  input  disk.  On output to another volume, files will not be broken
up, so processing continues until the current file has been restored.

The  pause  button  simply pauses the scan where it is.  This allows the
user  to  view the Scanning Results display, check statistics, etc.  The
pause  button  is  a  toggle  button;  a single click pauses the scan, a
second click resumes the scan.  When running in pause-on-error mode, any
error will pause the scan by setting the pause button.  The pause button
does  not  lock out input; all other gadgets on the scanner display work
normally.

The  pause-on-error button controls an auto-pause feature of the scanner
window.    When  on,  any error or warning code found during a scan will
cause  the  pause button to be automatically set.  It can be toggled off
to continue the scan just as if it were turned on by a user.

The ask-on-error button controls and auto-inquire feature of the scanner
window.   When on, any error encountered during a fix-in-place scan that
requires  DiskSalv  to modify the input disk will be prompted.  The user
may decide to perform the fix or ignore it.  Clearly, if the error isn't
corrected, DiskSalv won't fix the disk.

The Output Window is brought up when DiskSalv has something that must be
recovered  by  copying.    A  recover-by-copy  operation  is the primary
function  run by Salvage or Undelete modes, and a secondary function run
by  any  fix-in-place  mode that must eliminate files in order to render
the input device format valid.

This  window allows selection of files and output device for the salvage
operation.

The  Browser is where files are selected for recovery to another device.
When  DiskSalv  enters the browser as the result of a recover-by-copy or
backup  operation,  no  files are selected.  The files present are those
that have been passed by any pattern filtering set up by the user.

The  Browser consists of two custom list views.  A view entitled "Select
Directory"  is on the right hand side of the output window, while on the
left hand side is a similar view entitled "Select Files".  The Directory
list  contains  a  structured  list  of all the directories encountered,
while  the  File list contains a flat list of all files contained in the
current  directory.  Each browser responds to an item selection, as well
as  the  selection of a number of extra function buttons along the right
hand side of the browser.

Each  list supports the notion of current and selected.  Some operations
take place on the single current item in each list, some operations take
place  on  all  selected  items in either or both lists.  The final file
recovery/copy  only  includes  those  items  that  have   been selected.
Browser operations include:

    Directory		File
    Click on Item	Click on Item
    Info     		Info
    Parent	    	Select
    Select		    Clear
    Clear   		Forget
    Forget

A  mouse  click  on  a directory browser item sets that directory as the
current  directory.   When a directory is current, its file contents are
displayed  in  the  file  browser.    A  directory  is only indicated as
selected when all of its contents are selected.

Click  here  for information on the current directory.  This information
includes  the directory's block number, date, and protection attributes.

Click  here  to  pick  the  parent  of  the current directory as the new
current directory.  This item is ghosted if the current directory is the
root directory.

Click here to select the current directory and all its children.

Click here to return all selected items in the current directory and all
its children to their unselected state.

Click  here  to  erase from working memory all currently selected items,
including directories and files.  This has no effect on what is on disk,
it's  provided  simply  as  an  aid to the user, to help in organizing a
recovery or backup.

A mouse click on a file browser item sets that file as the current file.
Clicking on a file item also toggles selectionof the file item.

Click  here  for  information  on  the  current  file  or  link.    This
information includes the file's block number, size, date, and protection
attributes.

Click  here  to  select  all  of the files in the current browser level.
This  works  only at this level, not on any other branches of the parent
directory.

Click  here to return all selected files in the current browser level to
their unselected state.  This works only at this level, not on any other
branches of the parent directory.

Click  here to erase from working memory all currently selected files at
this  browser  level.    This  has  no  effect  on what is on disk, it's
provided  simply as an aid to the user, to help in organizing a recovery
or backup.

All  disk  recovery/backup  data  must  be  written  out to an alternate
AmigaDOS  device  of  some  kind.    Devices  can  be  selected by name,
optionally  via an AmigaDOS file requester.  DiskSalv provides a special
stream  format,  which  stores a whole disk tree as a flat file,suitable
for output to a file or pipe.

Click  on the Output Path gadget to specify the output device or path as
a  string.   File system level recovery can be to any file system device
or directory, while streams can go to files, pipes, or pipe-like devices
such  as the SER: device.  DiskSalv will create the directory or file if
necessary.

Click  here  to  call  up a standard file requester to select the output
device  or  path.    This  selection will be loaded into the Output Path
Gadget when completed.

This  cycle button allows selection of the output mode, which determines
how  DiskSalv  will  treat the device entered in the Output Path Gadget.
If  a  file  system  output  is indicated, DiskSalv will output a normal
AmigaDOS  file tree structure to the indicated device.  Directories will
be  created as necessary, but output to a file or pipe will be displayed
as  an error.  If a stream output is indicated, DiskSalv will format the
recovery  data as a flat byte stream, which can be output to a file on a
valid file system device, as well as pipes and pipe-like devices such as
PIPE:, SER:, or TAPE:

The  output  window  has  a  project menu, which manages global help and
navigation to other parts of the program.

This item simply calls up the main output window help page.

Select  this  item  to  return  to the input window.  The results of the
current  scan  are erased from memory, nothing additional is done to the
input disk.

Select this to quit the DiskSalv program.


This  menu  controls  the  settings  of  several  simple   output window
parameters.

Check  this  item  to  enable  free space checking on the output device.
Some  devices, like the RAM: device, always claim to be full.  Output to
such  a  device  will fail if this item is checked.  This corresponds to
the NOSIZECHECK command parameter.

During  a  recovery,  damage  is sometimes detected to a recovered file.
When  this  item is checked, warning notes to this effect are written to
the  FileNote field of the affected file or directory.  This corresponds
to the NOWARNING command paramater.

When  this  item  is  checked,  FileNotes  are  restored  to  files  and
directories.    When  unchecked, they are ignored during recovery.  This
corresponds to the NONOTES command parameter.

When  this  item  is  checked,  file protection is restored to files and
directories.    When  unchecked,  default  protection   is   used during
recovery.  This corresponds to the NOPROTECT command parameter.

When  this  item  is  checked,  date  stamps  are  restored to files and
directories.   When unchecked, the current date is used during recovery.
This corresponds to the NODATES command parameter.

Pick this to save the selected options to the DiskSalv icon.  The update
is actually done when DiskSalv exits.

Click  here  to start the disk salvage or backup.  This button will stay
ghosted  until  at  least one item has been selected for recovery, and a
valid output device of some kind has been entered.

Additional information is available on the following topics:

DiskSalv Support Files
Glossary of Terms
Command Parameters
DiskSalv Archival Format
Memory Requirements
AmigaDOS Disk Format
DOSDrivers Files
The DiskDoctor Story

There  are  a  few  files  included with DiskSalv, which are designed to
agument its normal operation.  The files include:

DiskSalv.guide

DiskSalv  looks  for  its  online  help file, DiskSalv.guide (this file,
incidently), in its home directory.  Depending on your AmigaGuide setup,
it may be found elsewhere as well.

DiskSalv.catalog

DiskSalv looks for translation catalogs in the normal LOCALE: directory.
They  should  be  named  DiskSalv.catalog.  DiskSalv2 catalog files will
produce strange results; they can be loaded, but are not recommended.

DiskSalv  3  has  not  yet  been  translated,  so  there  is  no current
DiskSalv.catalog.

DiskSalv.pattern

DiskSalv  looks  for  a default Pattern file, named DiskSalv.pattern, in
its  home  directory.  Any number of other pattern files may be manually
loaded, via the Pattern Load button.

Important terms in the understanding of DiskSalv include:

    Device, DOS
    Device, Exec
    Disk
    File System
    Hard Erorr
    Partition
    Pattern, AmigaDOS
    Pattern, DiskSalv
    Rigid Disk Block
    Root Block
    Soft Error
    Streams
    TAPE:
    Tripos
    Volume

The  AmigaDOS  pattern  matching  language defines a flexible syntax for
defining regular expressions.  The language include:

normal
Any normal character matches itself.

'special
The quote suppresses the special action of a special character.

?
Matches any single character.

%
Matches an empty string

[normal low-normal high]
Matches a range of characters.

~expression
Specifies a pattern matching anything expression doesn't match.

#expression
Specifies a pattern matching zero or more of expression.

(expression)
Makes a sub-pattern of expression.

expression 1|expression 2
Matches expression 1 or expression 2

AmigaDOS specifies file/directory dates using the following syntax:

	day_number-month_abbrev-year_number

Examples include:

	23-May-61	May 23rd, 1961
	24-Apr-90	April 24th, 1990
	17-Jul-91	July 17th, 1991
	12-Mar-94	March 12th, 1994

Month abbrevs are: Jan, Feb, Mar, Apr, Jun, Jul, Aug, Sep, Oct, Nov, Dec

DiskSalv  extends  the  AmigaDOS  regular  expression  language  into  a
flexible pattern matching language.  DiskSalv complex patterns can match
against  directories, files, dates, file sizes, and filenotes.  They can
be used to include or exclude the matched item, and to stop the DiskSalv
scanner on a match.  See Patterns for more information.

An  AmigaDOS "device" is a often named physical disk or disk device.  If
a disk is fixed, the AmigaDOS device, partition, and physical volume all
reference the same thing.  If the disk is removable, the AmigaDOS device
name  references the physical drive mechanism, while the physical volume
references  a  particular  disk,  independently  of the particular drive
mechanism.

A DOS device, which is basically just a file system server, is concerned
with  high-level  objects  and complex commands.  DOS devices know about
files,  directories,  and  links,  and  provide functions to open, seek,
read, write, and close files, access file support data, etc.

See also AmigaDOS File System, Exec Device

An Exec device is the low-level device driver used by DiskSalv to access
an  input  disk.    DiskSalv  can  only  repair or recover from AmigaDOS
devices that are built on Exec devices.  For example, the RAM: disk is a
DOS  device,  but  it  has  no underlying Exec device.  The DF0: floppy,
however,  relies  on  the "trackdisk.device" Exec-level device to handle
low-level communications to the floppy hardware.

Exec-level  devices are concerned with low-level objects and very simple
commands.  Such devices are treated as arrays of fixed-sized blocks, and
commands  are  supplied  to  read,  write, or format such blocks.  Other
commands  can control a drive's motor and various other functions of the
physical disk drive.

See also AmigaDOS Device

A  file  system  is  a  program  that  fields  high-level commands about
AmigaDOS  structures:  Files,  Links, Directories, and the various other
accounting  data  on  a  disk.  Each AmigaDOS device is represented as a
file  system task.  So, for instance, if I have a hard disk named "DH0:"
as  seen  from  AmigaDOS,  there  will  be  a  task  running,  say,  the
L:FastFileSystem program, and that task's name will be DH0.

There  are  several  types  of  file systems in the Amiga Disk Operating
System.   Some, like the RAM: device, are of little concern to DiskSalv.
DiskSalv  is primarily concerned with standard disk-based file systems.
There  are currently six variations of the AmigaDOS file system.  A file
system can use the original, international, or directory-caching storage
mechanism,  and its block organization can be "original" or "fast".  The
original block structure is a bit more robust (e.g.  easier to repair or
recover), the fast structure is faster.

See also AmigaDOS Device

While  the  term  "disk"  can  be  a bit vague, it's generally used as a
synonym for the physical partition or device under consideration.

A  "hard  error"  is  a  physical defect of some kind on the input disk.
Hard errors are usually the result of some physical failure on the disk,
and can not be repaired by DiskSalv.  It's usually necessary to reformat
any disk that has hard errors, electing to map such blocks as "bad".

See also Soft Error

A  disk  partition  is the most general physical instance of an AmigaDOS
disk.    While  a  disk  can  be set up as a single entity, as with most
floppies,  it's  usually  more useful to divide large disks into several
subsections, or partitions.  Each partition will have an AmigaDOS device
name,  an  AmigaDOS  volume  name,  and  any  number  of logical assigns
depending on the system setup.

The  Rigid  Disk  Block,  or  RDB, is a convention for storage of useful
boot-time  AmigaDOS  data,  in  a  controller-independent  format.    By
convention,  the  first  cylinder  or  two  of  a  hard  disk  (or other
partitionable AmigaDOS device) is reserved for the RDB.  A device driver
can  simply  start  reading  this track to find data on the user-defined
partitions,  file  systems,  bad  block mappings, and other data for the
disk.   Since this was standardized reasonably early in the evolution of
Amiga  hard  disk controllers, nearly every such controller supports the
convention.    So  AmigaDOS  hard  disks can be freely mixed and matched
between system and controller, without need to configure anything on the
host system.

All  tree-oriented  disk  structures support the concept of a "root", or
top-level directory.  In AmigaDOS file systems, there is a root block on
each partition.  This block is located in the center of the disk.

A "soft error" is a logical defect of some kind on the input disk.  Soft
errors  are  usually  created when the system fails during a disk write.
This  can  be  indirectly due to a physical act: premature disk removal,
power  failure,  disk controller failure, keyboard reset, etc.  This can
also  be  due  to a failure in software, (e.g.  a program crash).  While
the  Amiga  Operating System can trap many types of software failure, it
does  not  support  memory protection and therefore cannot offer perfect
protection.    An errant program can cause the AmigaDOS file system or a
disk's  device  driver to fail, resulting in a soft error.  A soft error
may  be  repaired  by  DiskSalv,  depending on its location on the disk.
Soft  errors  rarely  result  in  any need for reformatting of the input
disk.

See also Hard Error

DiskSalv has the capability to format any recover-by-copy or backup data
as  a  flat  byte stream.  This byte stream preserves the directory tree
structure as found on the input disk by creating typed blocks within the
stream  file  for each element in the original disk tree.  Such data can
be  sent  to  any  standard  AmigaDOS  pipe or pipe-like device, such as
PIPE:, SER:, or TAPE:.

While  DiskSalv  does  not  provide  any  sort of data compression, this
mechanism  can  be  used  to  compress  this output.  For example, let's
assume the user has a hard disk, DH0:, and a problem disk DH1:, which is
too  severely  damaged  to  fix  in place.  The user runs Salvage on the
disk,  and  gets  everything  listed.    But it won't quite fit on DH0:.
Rather  than panic, or resort to copying out onto floppies, the user can
run  everything  through  a  compression  tool,  such  as compress.  Any
compression program that will accept input from a pipe (eg, the standard
input) will work.

On the output window, one would enter a named pipe, say PIPE:recover for
example, into the Output Path gadget, and specify a stream output to the
Output Mode gadget.  Now, in a separate shell, one would enter something
like:

    1> compress <PIPE:recover >DH0:dh1_stream

Once  the  recovery  is complete, the file dh1_stream should contain the
compressed  contents  recovered  from the damaged DH1: device.  Reformat
the  DH1:  device,  then  restart  DiskSalv.  In a separate shell, enter
something like:

    1> uncompress <DH0:dh1_stream >PIPE:recover

Start up DiskSalv, select the Restore Stream button.  Enter PIPE:recover
as  the  input device, the newly reformatted DH1: as the output device.
DiskSalv  will  now  restore the complete DH1: contents.  After checking
that everything's correct, the dh1_stream file can be deleted.

See also Stream Format

DiskSalv  can  support most TAPE: devices, but doesn't come with one.  A
TAPE: device is a standard AmigaDOS file handler interfaced to some kind
of  tape  backup  device.  If you buy a backup unit specifically for use
with  the Amiga, it should come with such a device, though it may have a
different  name.    With  older  systems, you add the vendor's specified
MountList  example  to your Devs:MountList file, editing it if necessary
to  specify  the  device  (most  tape drives use a SCSI controller, like
Commodore's "scsi.device") and unit number, as approproiate.

If  your  tape drive didn't come with a tape handler, you may be able to
find one that's freely redistributable.  The one I recommend is BTNtape,
by Bob Rethemeyer.  While this was originally a very basic tape handler,
as  the  "Better  Than  Nothing" monniker would imply, today it's fairly
complete.    Best  of all, it has support for a number of different tape
drives.    Unlike  hard  drives,  SCSI tape drives are a bit quirky with
respect  to  their  command  sets, so customization to the specific tape
drive  is  often  required.   BTNtape is on the Fred Fish CD-ROMs, older
versions are in the Fish floppy collection.

The Tripos Operating System is an OS that attained a reasonable level of
popularity in the UK.  Due to time constraints during the development of
the  Amiga Operating System, Metacomco Ltd.  was contracted to adapt the
DOS subsystem of Tripos to the Amiga OS.

A  "Volume"  in AmigaDOS is any logical device.  All volume names end in
":",  and  come  in  two flavors.  Physical volumes are names associated
with  particular  disks  or  disk  partitions.   If a disk is fixed, its
device  name  and  physical  volume  name reference the same item.  With
removable  disks, the device name references the physical drive (such as
DF0:),  while  a physical volume name references a particular disk (such
as  "Workbench").    Logical  volume names are created with the "Assign"
command  in  AmigaDOS,  and  can  reference an AmigaDOS device, physical
volume, or subdirectory.

Command  parameters are options specified to DiskSalv as command-line or
ToolTypes  keywords.    Different  setups  can  be  created via multiple
Project icons.

	ASKONERROR/S
	BIGBLOCKS/T	    	DEFAULTFS/K
	DISKCACHE/N		    FILESYSTEM/K
	FORCEGUIDE/S		FONT/K
	FROM/K  			INTERACTIVE/S
	KEEPDOS/S   		KILLDOS/S
	LOADDEV/K	    	LOWMEM/S
	MAKELINKS/S 		MEMCHUNK/N
	MODE/K		    	NOARCHIVE/S
	NODATES/S   		NODEEPSCAN/S
	NOGUIDE/S	    	NONOTES/S
	NOPROTECT/S 		NOSIZECHECK/S
	NOWARNING/S	    	PATHMAX/N
	PAUSEONERROR/S
	PUBSCREEN/K	    	QUICKSCAN/S
	REJECTION/N	    	RETRY/N
	SMALLWINDOW/S		TAGCHAR/K
	TO/K

This  command  parameter  presets  the Ask on Error mode of the scanner,
causing  DiskSalv  to  automatically  prompt  the user before making any
modifications to the input disk, during any fix-in-place operation.

This  lets  the  user  specifiy whether support for multiple sectors per
block  is enabled.  On pre-V39 systems, occasionally DOS devices claimed
for  some  reason  to  have  more than one sector per block.  Since real
support of this didn't appear until the V40 FileSystem, which apparently
needs V39 to run, multiple sector per block support is off by default in
on a pre-V39 system, on by default for V39 systems and above.

This  allows  the user to specify the fallback file system to use on the
input  device.    Normally,  DiskSalv  will determine a partition's file
system  from its root block, but if that root block is damaged, DiskSalv
needs  this  fallback.    Normally  this  is  the Best-Guess pseudo file
system,  but  it  can be changed here.  Please see File System Selection
for more information.

This specifies the number of blocks to be used for the disk cache (which
is  actually a pre-fetch buffer).  The default size is 8 blocks, and can
be set between 0 (no cache) and 255 blocks.

This  allows  the  user  to  specify the file system to use on the input
device.    Normally,  DiskSalv  will determine a partition's file system
from its root block.  If for some reason that information is unavailable
or  wrong,  this  allows  the file system type to be specified by force.
The supported file systems include:

	OFS 		Original File System.
	FFS	    	Fast File System.
	OFS Intl.	OFS with ISO 8-bit character support.
	FFS Intl.	FFS with ISO 8-bit character support.
	DC-OFS		OFS with directory caching.
	DC-FFS		FFS with directory caching.
	Best-Guess	This pseudo file system selects the best match.

DiskSalv can detect, but not actually process, several other file system
types,  including  some  MS-DOS types.  Please see File System Selection
for more information.

This switch is now no longer necessary.  Originally this was designed to
suppress  the  loading  of  the  DiskSalv guide file for versions of the
amigaguide.library  before  V39.    This  latest   version   of DiskSalv
incorporates  work-arounds  to  the  bugs in these older guide libraries
that  allows  safe  operation.    Both hot links from DiskSalv or direct
loading by the AmigaGuide program work fine.

This  specifies  a  font  and  point size to use, rather than the system
default  font.    DiskSalv  will  use  this  font  only if it allows the
DiskSalv  window  to  size properly.  If not, the screen and then system
defaults  will be tried, with a final drop back to topaz 8, which always
works.    On  the  CLI,  this  should  be  specified  as   font/point or
font,point.  As a tool type, font point also works.

This keyword specifies an input device, the device that will be operated
on.    This  must  be  a  true  AmigaDOS  device,  not a subdirectory or
assignment,  and  it  must  be based on one of the standard file systems
with underlying device driver.

This  forces  DiskSalv into interactive operation (eg, it waits for user
input).    When run from the CLI, DiskSalv will by default do as much as
it can non-interactively before going into interactive mode.

The  FileSystem  (eg,  AmigaDOS)  is  usually  locked out from the input
device  during  scan  and recovery operations.  This option will prevent
such  a  lockout.   Fix-In-Place operations are not affected by this, as
they absolutely requie a FileSystem lockout since they are modifying the
input  disk.    Note that allowing any writes to the input disk during a
DiskSalv  operation will almost certainly cause DiskSalv to malfunction.

This  option  forces  DiskSalv  to  do  its job without using any device
directed  DOS functions or file system packets.  Normally, DiskSalv uses
a handfull of DOS library functions on input disks.  This is designed to
make  DiskSalv  safe  for  use  on  disks  that  crash  AmigaDOS  or the
particular  file  system  in  use.  This is a somewhat dangerous option,
since  it prevents DiskSalv from locking the file system out of a device
(since  that  requires  a file system packet).  It works best on devices
that  can't be given to AmigaDOS because they're too damaged.  Note that
DOS is automatically avoided on unmounted devices.

This  argument  takes  the  name  of  a   DOSDrivers   compatible device
description  file,  which  it  will  load  and  set as the current input
device.

This  specifies  low-memory  mode.   If DiskSalv runs out of memory on a
system  in  normal  mode, it may be successful in low-memory mode.  This
automatically  causes  the  chunky allocator, file path buffer, and disk
cache  to  go  to minimum sizes.  It cuts out a number of other internal
things that generally just affect performance rather than success.

This  causes  DiskSalv  to  actually create links on the output volume.
Normally it instead creates a script file which will create the links.

This  specifies the memory chunk size for DiskSalv's chunky allocator to
use.  By default, this is 4K, and can be set between 1K and 128K.

There  are several kinds of functions that DiskSalv will run.  The modes
include Salvage, Undelete, Repair, Unformat, Check, Backup, and Cleanup.
When  running with a localization, either the built-in or localized mode
namesmay be supplied as arguments.

When in backup mode, DiskSalv normally sets the archival bit on any file
that it backs up.  This switch will prevent archive bits from being set.

This  option  will  inhibit  restoration  of  the  original file date in
Recover-by-Copy operations.

This  inhibits extra low-level processing from being done floppy disks.
Such  processing  can  recover  data not normally accessable through the
trackdisk.device, but it causes extra memory to be used.

This  inhibits  DiskSalv's  opening of the AmigaGuide.library.  A severe
bug  in  some  early  (V34)  versions  of  the  AmigaGuide library cause
undefined  behavior, including drastic system crashes, if the AmigaGuide
library attempts to open a guide file but fails.  This prevents DiskSalv
from making that attempt.

This  option  will  inhibit  restoration  of  the  original  FileNote in
Recover-by-Copy  operations (though warning notes will override original
notes).

This option will inhibit restoration of the original protection codes in
Recover-by-Copy operations.

This  inhibits  automatic size checking of the output volume.  Normally,
DiskSalv  watches the size of the output volume to have an idea ahead of
time  that  a  volume  will  fill  up.   Some devices, such as RAM:, are
dynamically sized and always indicate full when asked, so this parameter
is  mainly  intended  for  such  devices (DiskSalv actually invokes this
automatically  for  RAM:, but it would have to be specified manually for
other such devices).

DiskSalv will normally attach a warning or error message, as a FileNote,
to  any  file  it  restores  via  a  Recover-by-Copy  operation  that it
considers suspect or bad.  This option will inhibit such action.

This  specifies the maximum length of a file path.  The default value is
512 bytes, and can be set between 256 bytes and 4K.

This  command  parameter causes all scan runs to set Pause on Error mode
by default.

This  specifies the public screen, by name, for DiskSalv to start up on.
If  none  is  specified,  DiskSalv will start up on the Workbench screen
(eg, default public screen).

This specifies a faster disk scanning mode.  The speed of a disk scan is
improved  by  cutting  down  on the visual display.  DiskSalv will still
show  a  "gas-guage"  indicator,  but  it won't list objects as they are
encountered.

This  specifies  a  filter  strength,  between 1 and 10, that influences
DiskSalv's  assessment of whether or not a disk block matches a specific
block  type.   This is generally left at the default, 6.  In some cases,
adjusting  this may improve the performance of the scanner, depending on
the  disk problems at hand.  It can also make the scanner perform worse.

Technically  speaking,  this  supplies  a  normalized  adjustment to the
decision  threshold  in  the  fuzzy  disk block matching routines within
DiskSalv.    Lower  values  allow  less qualified blocks to be accepted,
while  the  full  scale  10  setting  causes  only  pefect  blocks to be
accepted.    The  main problem with very low values is that block typing
can suffer -- a directory may be seen as file, or vice-versa.

This argument changes the number of retries a device drive will run on a
read  failure.    USE  THIS OPTION WITH CAUTION!  This function uses the
convention  of  the  trackdisk.device  for  retry  count,  which   isn't
guaranteed  to  be  supported  by other device drivers.  In general, the
default  retry count is what you want to use.  When a device has a large
number  of  errors,  it  can  be  processed  much faster by setting this
parameter  as  low  as  zero,  if  the  selected  device  supports  this
convention.    If  not,  there's  a  chance  it  will cause some unknown
problem, so it's best to use only as a last resort.

This causes DiskSalv to build a minimal scanning display window, even on
large screens.

This  is maintained only for command-line compatibility with DiskSalv 2.
In  DiskSalv  2, a character could be specified to indicate objects that
are tagged in the file browser.  This was done because the standard list
gadget in AmigaOS 2.x could not do any kind of highlighting.  DiskSalv 3
uses a custom list gadget for all its lists, and can therefore highlight
selections in AmigaOS 2.x and 3.x.

This  keyword  specifies  an output device, the device that will receive
any recover-by-copy files that DiskSalv finds.  This may be any AmigaDOS
device,  volume,  or  subdirectory.    If a non-existant subdirectory is
specified, one will be generated.

The  DiskSalv  Stream  concept  was  designed  to   provide   a reliable
backup/archival  mechanism  for data processed by DiskSalv.  This format
retains  everything DiskSalv can do with recovery or backup, but puts it
in  a  more  manageable  form,  which  can  be  processed by compression
utilities or directed to tape.

The  DiskSalv  stream  format  is  based  on  tagged  512  byte  blocks,
regardless  of the block size of the input disk.  Each block starts with
its type identifier, which always a 4-byte ASCII code:

    ROOT	The archive root/start
    UDIR	User directory header
    FILE	Normal file header
    DATA	Data belonging to a file
    DLNK	Directory link header
    FLNK	File link header
    SLNK	Symbolic link header
    ERRS	An error block
    ENDA	The archive's end

This is the ROOT structure. All stream blocks are padded to 512 bytes.

   LONG     	'ROOT'			; Block type.
   LONG 		pad[2]		; Unused.
   LONG	    	parent			; The id number for the parent block.
   LONG 		id	    	; The id number for the object.
   LONG	    	checksum		; A checksum code goes here.
   char	    	name[32]		; The archive name
   DateStamp	created			; The volume's creation date.
   DateStamp	modified		; The volume's modification date.
   DateStamp	date			; The archive's creation date.
   LONG 		barcount	; A count of file objects

This is the UDIR structure. All stream blocks are padded to 512 bytes.

   LONG     	'UDIR'	    		; Block type.
   LONG 		pad[2]  	; Unused.
   LONG	    	parent	    		; The id number for the parent block.
   LONG	    	id	        	; The id number for the object.
   LONG 		checksum    	; A checksum code goes here.
   char     	filename[32]		; The File name.
   LONG	    	protect 		; The Protection field.
   DateStamp	date	    		; The File date.
   char	    	filenote[92]		; The FileNote.

This  is the FILE structure.  All stream blocks are padded to 512 bytes.

   LONG     	'FILE'  		; Block type.
   LONG 		size    	; File size in bytes.
   LONG 		count   	; File size in blocks.
   LONG 		parent  	; The id number for the parent block.
   LONG 		id       	; The id number for the object.
   LONG 		checksum    	; A checksum code goes here.
   char     	filename[32]		; The File name.
   LONG 		protect 	; The Protection field.
   DateStamp	date    		; The File date.
   char 		filenote[92]	; The FileNote.

This is the DATA structure. All stream blocks are padded to 512 bytes.

   LONG 	'DATA'		; Block type.
   LONG		size		; Byte size of the data block.
   LONG		count		; Block sequence in file.
   LONG		parent		; The id number for the parent block.
   LONG		id  		; The id number for the object.
   LONG		checksum	; A checksum code goes here.
   LONG		data[]		; The of the structure stores data.

This is the DLNK structure. All stream blocks are padded to 512 bytes.

   LONG     	'DLNK'  		; Block type.
   LONG 		pad[2]  	; Unused.
   LONG 		parent  	; The id number for the parent block.
   LONG 		id       	; The id number for the object.
   LONG 		checksum    	; A checksum code goes here.
   char     	filename[32]		; The File name.
   LONG 		protect  	; The Protection field.
   DateStamp	date    		; The File date.
   char 		filenote[92]	; The FileNote.
   LONG 		link    	; File/Directory ID to link to.
   LONG 		chain   	; Link chain, if any

This is the FLNK structure. All stream blocks are padded to 512 bytes.

   LONG     	'FLNK'  		; Block type.
   LONG 		pad[2]	    	; Unused.
   LONG 		parent  	; The id number for the parent block.
   LONG 		id      	; The id number for the object.
   LONG 		checksum    	; A checksum code goes here.
   char     	filename[32]		; The File name.
   LONG 		protect 	; The Protection field.
   DateStamp	date    		; The File date.
   char 		filenote[92]	; The FileNote.
   LONG 		link    	; File/Directory ID to link to.
   LONG 		chain   	; Link chain, if any

This  is the SLNK structure.  All stream blocks are padded to 512 bytes.

   LONG     	'SLNK'  		; Block type.
   LONG  		pad[2]	    	; Unused.
   LONG	    	parent  		; The id number for the parent block.
   LONG  		id	        ; The id number for the object.
   LONG  		checksum	; A checksum code goes here.
   char     	filename[32]		; The File name.
   LONG  		protect  	; The Protection field.
   DateStamp	date    		; The File date.
   char  		filenote[92]	; The FileNote.
   char 		link[]	    	; The link name goes here.

This is the ERRS structure. All stream blocks are padded to 512 bytes.

   LONG 	'ERRS'		; Block type.
   LONG		junk[]		; The rest is undefined.


This is the ENDA structure. All stream blocks are padded to 512 bytes.

   LONG     	'ENDA'			; Block type.
   LONG  		pad[2]		; Unused.
   LONG 		parent		; The id number for the parent block.
   LONG 		id		; The id number for the object.
   LONG 		checksum	; A checksum code goes here.
   LONG 		pad	    	; Unused
   LONG 		filecount	; Number of files in archive.
   LONG 		dircount	; Number of directories in archive.
   LONG 		linkcount	; Number of links in archive.
   LONG 		errcount	; Number of recorded errors
   LONG 		objectcount	; Total count of objects.
   DateStamp	date			; Date code for recovery set.
   LONG 		pad[2]		; Unused
   LONG 	 	dwalloc		; Total buffer size
   LONG 		pad		; Unused

DiskSalv  attempts  to  conserve  on  memory,  but  there   are definite
requirements that are fixed.  These can be simply summarized:

	Item		Memory used

	DISK OVERHEAD		2 bits per block

	FILE	     	 	8 bytes
	LINK		    	24 bytes plus file name length
	DIRECTORY, FFS		24 bytes plus file name length
	DIRECTORY, DC-FFS	28 bytes plus file name length

SECTION NOT COMPLETE

DiskSalv  can  read  and  write Amiga DOSDrivers files.  These files are
standard  device description files, used by the AmigaDOS Mount command.
The  DOSDrivers form of the mount file was originated in AmigaOS 2.1, as
a  slight  variation  of  the  MountList form.  In this file format, the
AmigaDOS  device  name  is  derived  from  the  file  name, and the file
contains a single device description.

The Save Device button on the input window and the Save to File...   can
save  the  current  device  to  a  DOSDrivers  format   file.    This is
necessarily  a  complete  file; some parameters may be determined by the
device driver type.

Similarly, a DOSDrivers file may be loaded via the Load Device button on
the  input  window  or  the  Load  from File...  menu item on the Device
Editor  window.    It may also be loaded by dropping it by icon directly
into  either  window.    The  parameters not of interest to DiskSalv are
ignored.

The  following DOSDrivers parameters are of interest to DiskSalv.  These
are  used by DiskSalv to build internal device descriptions, and they're
written out when DiskSalv creates a DOSDrivers file.

    Parameter		Explanation

    Name		Taken from the file name

    BlocksPerTrack	Size of a track, in blocks
    BlockSize		Longword size of a block
    BufMemType		Type of memory, 0 for anything, 3 for chip
    Device	    	Device driver name, like "scsi.device"
    DosType   		32-bit DOS type identifier
    Flags   		Flags for the OpenDevice() call
    HighCyl  		Highest cylinder on the partition
    LowCyl  		Lowest cylinder on the partition
    Reserved		Number of blocks reserved on a partition
    SectorsPerBlock	Number of sectors in a block
    SectorsPerTrack	Size of a track, in sectors
    SectorSize		Longword size of a sector
    Surfaces		Number of active disk surfaces, or heads
    Unit    		Device driver's unit number

Note  that  older file systems don't support multiple sectors per block,
and  don't  understand sector-based parameters.  DiskSalv saves in terms
of  SectorsPerTrack  and  SectorSize if the SectorsPerBlock parameter is
other  than  1.   Otherwise, it uses the better supported BlocksPerTrack
and BlockSize parameters.

DiskSalv's First Competition

When  the Amiga was first introduced, much was made of the robustness of
its  file  system.    In  the process of working my first Amiga software
project,  I ran into a disk error.  Unfortunately, no tool was available
at  the  time  that  would  do  anything  about this error, so I started
writing DiskSalv.

Shortly  thereafter,  the  DiskDoctor program was introduced.  Unlike my
original  DiskSalv, this program claimed to fix disks in-place rather by
copying  out  to another volume.  With floppy disks, the recover by copy
mechanism  wasn't much of a problem, but once hard disks became popular,
the fix-in-place solution was the solution of choice.

Unfortunately,  DiskDoctor was flawed.  While it could repair a disk, it
could  also cause damage to a disk's structure.  It did improve over the
years,  but  was  never  considered  to  be reliable.  Eventually it was
removed from the Workbench entirely.

The Demise of the DiskDoctor

The  story I was told goes something like this.  The software folks were
not  quite sure whether DiskDoctor should be dumped or improved, so they
decided  to  leave  it up to DiskDoctor itself.  They put the DiskDoctor
sourced on an old floppy, then ran DiskDoctor on it.  As often happened,
DiskDoctor  damaged this undamaged disk.  So, while it's often said that
DiskDoctor  was  "sued for malpractice", it's more correct to state that
DiskDoctor committed suicide.



----------------------------------END-------------------------------------

