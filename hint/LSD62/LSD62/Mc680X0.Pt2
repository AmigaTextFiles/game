
                                 PART TWO


NAME
	cpTRAPcc -- Exception generation on coprocessor condition

SYNOPSIS
	cpTRAPcc
	cpTRAPcc	#<data>

	No size specs, or size of data: (Word, Long).

FUNCTION
	If specified coprocessor condition is true, exception vector n°7
	is generated. Value of saved PC is next instruction one (return
	address).
	If given condition is false, PC takes the value of next instruction.
	Immediate data placed at instruction end is an information which can
	be used by the exception sub-routine.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|---|---|---|---|---|-----------|
	| 1 | 1 | 1 | 1 | CP-ID =! 0| 0 | 0 | 1 | 1 | 1 | 1 |  OP-MODE  |
	|---|---|---|---|-----------|---|---|---|-----------------------|
	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |COPROSSESSOR CONDITION |
	|---------------------------------------------------------------|
	|              OPTIONAL COPROCESSOR EXTENSION WORD              |
	|---------------------------------------------------------------|
	|                            16 BITS DATA or                    |
	|---------------------------------------------------------------|
	|	          32 BITS DATA (LOW WEIGHT PART)                |
	-----------------------------------------------------------------

OP-MODE
	010->instruction contains a 16 bits operand.
	011->instruction contains a 32 bits operand.
	100->instruction has no operands.

	CP-ID field identify coprocessor (1 to 7). If CP-ID=0,
	"line emulation F" exception is generated.

	"COPROSSESSOR CONDITION" field, specifies condition to test.
	This condition is addressed to coprocessor which, after examining
	this one, address directives to processor in order to execute
	the instruction.

RESULT
	Not affected.

SEE ALSO
	CPDBCC

***********************************************************


NAME
	DBcc -- Decrement and branch conditionally

SYNOPSIS
	DBcc	Dn,<label>

	Size of offset = (Word)

FUNCTION
	Controls a loop of instructions. The parameters are: a
	condition code, a data register (counter), and an offset value.
	The instruction first tests the condition (for termination); if it
	is true, no operation is performed. If the termination condition is
	not true, the low-order 16 bits of the counter are decremented by
	one. If the result is -1, execution continues at the next
	instruction, otherwise, execution continues at the specified
	address.

	Condition code 'cc' specifies one of the following:
0000 F  False            Z = 1      1000 VC oVerflow Clear   V = 0
0001 T  True             Z = 0      1001 VS oVerflow Set     V = 1
0010 HI HIgh             C + Z = 0  1010 PL PLus             N = 0
0011 LS Low or Same      C + Z = 1  1011 MI MInus            N = 1
0100 CC Carry Clear      C = 0      1100 GE Greater or Equal N (+) V = 0
0101 CS Carry Set        C = 1      1101 LT Less Than        N (+) V = 1
0110 NE Not Equal        Z = 0      1110 GT Greater Than     Z + (N (+) V) = 0
0111 EQ EQual            Z = 1      1111 LE Less or Equal    Z + (N (+) V) = 1


	Keep the following in mind when using DBcc instructions:
	1. A DBcc acts as the UNTIL loop contruct in high level
	   languages. E.g., DBMI would be "decrement and branch until
	   minus".
	2. Most assemblers accept DBRA or DBF for use when no condition
	   is required for termination of a loop.


        The DBcc will, unlike the Bcc instruction, take the branch only if
        the set of conditions are NOT satified. The loop will be terminated
        if the condition is true, or the counter is zero BEFORE a decrement,
        and wrap to -1. This mean that if you execute code like:

	move.w	#30,d0

.Loop
	move.l	(a0)+,(a1)+
	dbf	d0,.Loop

        then the copy will be executed *31* times, and 124 bytes of memory
        will be copied, not 120.

        A good practice is therefore to write:

	move.w	#31-1,d0

.Loop
	move.l	(a0)+,(a1)+
	dbf	d0,.Loop

        To compare two strings that may be in excess of 64k length for
        beeing equal, you could execute the following code:
	...

	move.l	#$53452-1,d0
	beq.s	.NoLength	; Zero length!
	bra.s	.StartOuterLoop	; The upper word contain count of 65536's...

.OuterLoop
	swap	d0

.InnerLoop
	cmp.b	(a0)+,(a1)+
	dbne	d0,.InnerLoop	; Remember, drop trough on condition TRUE.

.StartOuterLoop		        ; d0 will be $FFFF on 2.+ run-through
	bne.s	.NotEqual	; Dropped through due to Not Equal?
	swap	d0		; Get upper part of word...	
	dbf	d0,.OuterLoop
	...

        It would not be possible to use two sets of DBNEs, as SWAP
        changes the condition codes - and we don't want the drop-
        though to be on account of D0, instead of the compares...

        Another neat trick is to use instruction as a conditional
        decrementer; this code will decrement d0.w if the last
        instruction returned NOT EQUAL:
	...
	dbeq	d0,.Next

.Next
	...

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---------------|---|---|---|---|---|-----------|
	| 0 | 1 | 0 | 1 |   CONDITION   | 1 | 1 | 0 | 0 | 1 | REGISTER  |
	|---------------------------------------------------------------|
	|                      16 BITS OFFSET (d16)                     |
	-----------------------------------------------------------------

	"CONDITION" is one of the condition code given some lines before.
	"REGISTER" is the number of data register.
	Offset is the relative gap in byte to do branching.

RESULT
	Not affected.

SEE ALSO
	BCC SCC

***********************************************************


NAME
	DIVS, DIVSL -- Signed divide

SYNOPSIS
	DIVS.W	<ea>,Dn     32/16 -> 16r:16q
	DIVS.L	<ea>,Dq     32/32 -> 32q      (68020+)
	DIVS.L	<ea>,Dr:Dq  64/32 -> 32r:32q  (68020+)
	DIVSL.L	<ea>,Dr:Dq  32/32 -> 32r:32q  (68020+)

	Size = (Word, Long)

FUNCTION
	Divides the signed destination operand by the signed source
	operand and stores the signed result in the destination.

	The instruction has a word form and three long forms. For the
	word form, the destination operand is a long word and the source
	operand is a word. The resultant quotient is placed in the lower
	word of the destination and the resultant remainder is placed in the
	upper word of the destination. The sign of the remainder is the
	same as the sign of the dividend.

	In the first long form, the destination and the source are both
	long words. The quotient is placed in the longword of the destination
	and the remainder is discarded.

	The second long form has the destination as a quadword (eight bytes),
	specified by any two data registers, and the source is a long word.
	The resultant remainder and quotient are both long words and are
	placed in the destination registers.

	The final long form has both the source and the destination as long
	words and the resultant quotient and remainder as long words.

FORMAT
	In the case of DIVS.W:
	~~~~~~~~~~~~~~~~~~~~~                              <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|---|---|-----------|-----------|
	| 1 | 0 | 0 | 0 | REGISTER  | 1 | 1 | 1 |    MODE   | REGISTER  |
	-----------------------------------------------------------------

	"REGISTER" indicates the number of data register.

	In the case of DIVS.L and of DIVL.L:
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                <ea>
	-----------------------------------------=========================
	|15 |14 |13 |12 |11 |10  | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|----|---|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | 1 | 1  | 0 | 0 | 0 | 1 |    MODE   | REGISTER  |
	|---|-----------|---|----|---|---|---|---|-----------|-----------|
	| 0 |Dq REGISTER| 1 |SIZE| 0 | 0 | 0 | 0 | 0 | 0 | 0 |Dr REGISTER|
	------------------------------------------------------------------

	"Dq REGISTER" indicates the number of data register for destination
	operand. This register first contains 32 bits of low weight of
	dividend, and after the value of quotient on 32 bits.

	"SIZE" specifies if dividend is on 32 or 64 bits:
	0-> 32 bits dividend placed in Dq.
	1-> 64 bits dividend placed in Dr:Dq.

	"Dr REGISTER" indicates the number of data register for destination
	operand. This register first contains 32 bits of upper weight of
	dividend if "SIZE" = 1, and after the value of rest on 32 bits.

	If Dr and Dq represents the same register, only quotient on 32 bits
	is put in Dq.

	<ea> field specifies source operand, allowed addressing modes are:

	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N° reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      |111 |  100   |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	X - Not affected
	N - Set if the quotient is negative, cleared otherwise. Undefined if
	    overflow or divide by zero occurs.
	Z - Set if the quotient is zero, cleared otherwise. Undefined if
	    overflow or divide by zero occurs.
	V - Set if overflow occurs, cleared otherwise. Undefined if divide by
	    zero occurs.
	C - Always cleared.

	Notes:
	1. If divide by zero occurs, an exception occurs.
	2. If overflow occurs, neither operand is affected.

SEE ALSO
	DIVU MULS MULU

***********************************************************


NAME
	DIVU, DIVUL -- Unsigned divide

SYNOPSIS
	DIVU.W	<ea>,Dn     32/16 -> 16r:16q
	DIVU.L	<ea>,Dq     32/32 -> 32q      (68020+)
	DIVU.L	<ea>,Dr:Dq  64/32 -> 32r:32q  (68020+)
	DIVUL.L	<ea>,Dr:Dq  32/32 -> 32r:32q  (68020+)

	Size = (Word, Long)

FUNCTION
	Divides the unsigned destination operand by the unsigned
	source operand and stores the unsigned result in the destination.

	The instruction has a word form and three long forms. For the
	word form, the destination operand is a long word and the source
	operand is a word. The resultant quotient is placed in the lower
	word of the destination and the resultant remainder is placed in the
	upper word of the destination. The sign of the remainder is the
	same as the sign of the dividend.

	In the first long form, the destination and the source are both
	long words. The quotient is placed in the longword of the destination
	and the remainder is discarded.

	The second long form has the destination as a quadword (eight bytes),
	specified by any two data registers, and the source is a long word.
	The resultant remainder and quotient are both long words and are
	placed in the destination registers.

	The final long form has both the source and the destination as long
	words and the resultant quotient and remainder as long words.

FORMAT
	In the case of DIVU.W:
	~~~~~~~~~~~~~~~~~~~~~                              <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|---|---|-----------|-----------|
	| 1 | 0 | 0 | 0 | REGISTER  | 0 | 1 | 1 |    MODE   | REGISTER  |
	-----------------------------------------------------------------

	"REGISTER" indicates the number of data register.

	In the case of DIVU.L and of DIVUL.L:
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~               <ea>
	-----------------------------------------=========================
	|15 |14 |13 |12 |11 |10  | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|----|---|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | 1 | 1  | 0 | 0 | 0 | 1 |    MODE   | REGISTER  |
	|---|-----------|---|----|---|---|---|---|-----------|-----------|
	| 0 |Dq REGISTER| 0 |SIZE| 0 | 0 | 0 | 0 | 0 | 0 | 0 |Dr REGISTER|
	------------------------------------------------------------------

	"Dq REGISTER" indicates the number of data register for destination
	operand. This register first contains 32 bits of low weight of
	dividend, and after the value of quotient on 32 bits.

	"SIZE" specifies if dividend is on 32 or 64 bits:
	0-> 32 bits dividend placed in Dq.
	1-> 64 bits dividend placed in Dr:Dq.

	"Dr REGISTER" indicates the number of data register for destination
	operand. This register first contains 32 bits of upper weight of
	dividend if "SIZE" = 1, and after the value of rest on 32 bits.

	If Dr and Dq represents the same register, only quotient on 32 bits
	is put in Dq.

	<ea> field specifies source operand, allowed addressing modes are:

	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N° reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      |111 |  100   |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT

	X - Not affected
	N - See below.
	Z - Set if the quotient is zero, cleared otherwise. Undefined if
	    overflow or divide by zero occurs.
	V - Set if overflow occurs, cleared otherwise. Undefined if divide by
	    zero occurs.
	C - Always cleared.

	Notes:
	1. If divide by zero occurs, an exception occurs.
	2. If overflow occurs, neither operand is affected.

	According to the Motorola data books, the N flag is set if the
	quotient is negative, but in an unsigned divide, this seems to
	be impossible.

SEE ALSO
	DIVS MULS MULU

***********************************************************


NAME
	EOR -- Exclusive logical OR

SYNOPSIS
	EOR	Dn,<ea>

	Size = (Byte, Word, Long)

FUNCTION
	Performs an exclusive OR operation on the destination operand
	with the source operand.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|-----------|-----------|-----------|
	| 1 | 0 | 1 | 1 |  REGISTER |  OP-MODE  |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                  <ea>

OP-MODE
	100	8 bits operation.
	101	16 bits operation.
	110	32 bits operation.

REGISTER
	The data register specifies source Dn.
	<ea> specifies destination operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N° reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	X - Not Affected
	N - Set to the value of the most significant bit.
	Z - Set if the result is zero.
	V - Always cleared
	C - Always cleared
	
SEE ALSO
	EORI BCHG

***********************************************************


NAME
	EORI -- Exclusive OR immediate

SYNOPSIS
	EORI	#<data>,<ea>

	Size = (Byte, Word, Long)

FUNCTION
	Performs an exclusive OR operation on the destination operand
	with the source operand.

FORMAT
	                                                  <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|-------|-----------|-----------|
	| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | SIZE  |    MODE   | REGISTER  |
	|-------------------------------|-------------------------------|
	|   16 BITS IMMEDIATE DATA      |     8 BITS IMMEDIATE DATA     |
	|---------------------------------------------------------------|
	|                     32 BITS IMMEDIATE DATA                    |
	-----------------------------------------------------------------

SIZE
	00->8 bits operation.
	01->16 bits operation.
	10->32 bits operation.

REGISTER
	Immediate data is placed behind the word of operating code of
	the instruction on 8, 16 or 32 bits.

	<ea> specifies destination operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N° reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	X - Not Affected
	N - Set to the value of the most significant bit.
	Z - Set if the result is zero.
	V - Always cleared
	C - Always cleared
	
SEE ALSO
	EOR  EORI TO CCR EORI TO SR
	BCHG

***********************************************************


NAME
	EORI to CCR -- Exclusive OR immediate to the condition code register

SYNOPSIS
	EORI	#<data>,CCR

	Size = (Byte)

FUNCTION
	Performs an exclusive OR operation on the condition codes
	register with the source operand.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |
	|---|---|---|---|---|---|---|---|-------------------------------|
	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |     8 BITS IMMEDIATE DATA     |
	-----------------------------------------------------------------

RESULT
	X - Changed if bit 4 of the source is set, cleared otherwise.
	N - Changed if bit 3 of the source is set, cleared otherwise.
	Z - Changed if bit 2 of the source is set, cleared otherwise.
	V - Changed if bit 1 of the source is set, cleared otherwise.
	C - Changed if bit 0 of the source is set, cleared otherwise.
	
SEE ALSO
	EOR  EORI EORI TO SR

***********************************************************


NAME
	EORI to SR -- Exclusive OR immediated to the status register (PRIVILEGED)

SYNOPSIS
	EORI	#<data>,SR

	Size = (Word)

FUNCTION
	Performs an exclusive OR operation on the status register
	with the source operand.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 0 |
	|---------------------------------------------------------------|
	|                     16 BITS IMMEDIATE DATA                    |
	-----------------------------------------------------------------

RESULT
	X - Changed if bit 4 of the source is set, cleared otherwise.
	N - Changed if bit 3 of the source is set, cleared otherwise.
	Z - Changed if bit 2 of the source is set, cleared otherwise.
	V - Changed if bit 1 of the source is set, cleared otherwise.
	C - Changed if bit 0 of the source is set, cleared otherwise.
	
SEE ALSO
	EOR  EORI EORI TO CCR

***********************************************************


NAME
	EXG -- Register exchange

SYNOPSIS
	EXG	Rx,Ry

	Size = (Long)

FUNCTION
	Exchanges the contents of any two registers.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|-------------------|-----------|
	| 1 | 1 | 0 | 0 |Rx REGISTER| 1 |       OP-MODE     |Ry REGISTER|
	-----------------------------------------------------------------

	"Rx REGISTER" specifies a data or address register. If it's an
	exchange between a data register and an address register, this field
	define the data register.

	"Ry REGISTER" specifies a data or address register. If it's an
	exchange between a data register and an address register, this field
	define the address register.

OP-MODE
	01000->Exchange between data registers.
	01001->Exchange between address registers.
	10001->Exchange between data and address registers.

RESULT
	None.

SEE ALSO
	SWAP

***********************************************************


NAME
	EXT, EXTB -- Sign extend

SYNOPSIS
	EXT.W	Dn	Extend byte to word
	EXT.L	Dn	Extend word to long word
	EXTB.L	Dn	Extend byte to long word	(68020+)

	Size = (Word, Long)

FUNCTION
	Extends a byte to a word, or a word to a long word in a data
	register by copying the sign bit through the upper bits. If the
	operation is from byte to word, bit 7 is copied to bits 8 through
	15. If the operation is from word to long word, bit 15 is copied
	to bits 16 through 31. The EXTB copies bit 7 to bits 8 through 31.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|-----------|---|---|---|-----------|
	| 0 | 1 | 0 | 0 | 1 | 0 | 0 |  OP-MODE  | 0 | 0 | 0 | REGISTER  |
	-----------------------------------------------------------------

	"REGISTER" specifies a data register.

OP-MODE
	010->Extending from 8 bits to 16 bits.
	011->Extending from 16 bits to 32 bits.
	111->Extending from 8 bits to 32 bits.

RESULT
	X - Not affected
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Always cleared
	C - Always cleared

SEE ALSO
	BFEXTS	BFEXTU

***********************************************************


NAME
	ILLEGAL -- Illegal processor instruction

SYNOPSIS
	ILLEGAL

FUNCTION
	This instruction forces an Illegal Instruction exception,
	vector number 4. All other illegal instruction bit patterns,
	including, but not limited to, $fxxx and $axxx, are reserved for
	future expansion.
        The Hexa-decimal code of this instruction is: $4AFC 

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 1 | 0 | 0 | 1 | 0 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 |
	-----------------------------------------------------------------

RESULT
	None.

SEE ALSO
	BKPT

***********************************************************


NAME
	JMP -- Unconditional far jump

SYNOPSIS
	JMP	<ea>

FUNCTION
	Program execution continues at the address specified by
	the operand.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 1 | 1 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                   <ea>
REGISTER
	<ea> specifies address of next instruction.
	Allowed addressing modes are:

	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |    -     | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     | -  |    -     | |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      | -  |    -     | |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	None.

SEE ALSO
	BRA JSR

***********************************************************


NAME
	JSR -- Jump to far subroutine

SYNOPSIS
	JSR	<ea>

FUNCTION
	Pushes the long word address of the instruction immediately
	following the JSR instruction onto the stack. The PC contains
	the address of the instruction word plus two. Program execution
	continues at location specified by <ea>.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 1 | 0 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                   <ea>
REGISTER
	<ea> specifies address of next instruction.
	Allowed addressing modes are:

	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |    -     | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     | -  |    -     | |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      | -  |    -     | |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	None.

SEE ALSO
	BSR BRA
	RTS RTD RTR 

***********************************************************


NAME
	LEA -- Load effective address

SYNOPSIS
	LEA	<ea>,An

	Size = (Long)

FUNCTION
	Places the specified address into the destination address
	register. Note: All 32 bits of An are affected by this instruction.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | REGISTER  | 1 | 1 | 1 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                   <ea>
REGISTER
	"REGISTER" indicates the number of address register

	<ea> specifies address which must be loaded in the address register.
	Allowed addressing modes are:

	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |    -     | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     | -  |    -     | |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      | -  |    -     | |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	None.

SEE ALSO
	MOVEA ADDA  SUBA 

***********************************************************


NAME
	LINK -- Create local stack frame

SYNOPSIS
	LINK	An,#<data>

	Size = (Word)
	Size = (Word, Long)		(68020+)

FUNCTION
	This instruction saves the specified address register onto
	the stack, then places the new stack pointer in that register. It
	then adds the specificed immediate data to the stack pointer. To
	allocate space on the stack for a local data area, a negative value
	should be used for the second operand.

	The use of a local stack frame is critically important to the
	programmer who wishes to write re-entrant or recursive functions.
	The creation of a local stack frame on the MC680x0 family is done
	through the use of the LINK and UNLK instructions. The LINK
	instruction saves the frame pointer onto the stack, and places a
	pointer to the new stack frame in it. The UNLK instruction
	restores the old stack frame. For example:

		link	a5,#-8		; a5 is chosen to be the frame
					; pointer. 8 bytes of local stack
					; frame are allocated.
		...
		unlk	a5		; a5, the old frame pointer, and the
					; old SP are restored.

	Since the LINK and UNLK instructions maintain both the frame pointer
	and the stack pointer, the following code segment is perfectly
	legal:

		link	a5,#-4

		movem.l	d0-a4,-(sp)
		pea	(500).w
		move.l	d2,-(sp)
		bsr.b	Routine

		unlk	a5
		rts

FORMAT
	For Word size:
	~~~~~~~~~~~~~
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|-----------|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 0 | 1 | 0 | REGISTER  |
	|---------------------------------------------------------------|
	|                        16 BITS OFFSET (d)                     |
	-----------------------------------------------------------------

	For Long size:
	~~~~~~~~~~~~~
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|-----------|
	| 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | REGISTER  |
	|---------------------------------------------------------------|
	|          32 BITS OFFSET (d) (16 bits of lower weight)         |
	|---------------------------------------------------------------|
	|          32 BITS OFFSET (d) (16 bits of upper weight)         |
	-----------------------------------------------------------------

	"REGISTER" indicates the number of address register.
	OFFSET is a signed value, generally negative, which enables to move
	the stack pointer.

RESULT
	None.

SEE ALSO
	UNLK

***********************************************************


NAME
	LSL, LSR -- Logical shift left and logical shift right

SYNOPSIS
	LSd	Dx,Dy
	LSd	#<data>,Dy
	LSd	<ea>
	where d is direction, L or R

	Size = (Byte, Word, Long)

FUNCTION
	Shift the bits of the operand in the specified direction.
	The carry bit set set to the last bit shifted out of the operand.
	The shift count for the shifting of a register may be specified in
	two different ways:

	1. Immediate - the shift count is specified in the instruction (shift
	               range 1-8).
	2. Register  - the shift count is contained in a data register
	               specified in the instruction (shift count mod 64)

	For a register, the size may be byte, word, or long, but for a memory
	location, the size must be a word. The shift count is also restricted
	to one for a memory location.

	LSL:              <--  
	      C <------ OPERAND <--- 0
	            |
	            |    (V = 0)
	      X <---'
	       

	LSR:
                 -->
	0 ---> OPERAND -------> C
                          |
	                  |
	                  `---> X

FORMAT
	In the case of the shifting of a register:
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|-------|---|---|---|-----------|
	| 1 | 1 | 1 | 0 |  NUMBER/  |dr |  SIZE |i/r| 0 | 1 | REGISTER  |
	|   |   |   |   |  REGISTER |   |       |   |   |   |           |
	-----------------------------------------------------------------

	In the case of the shifting of a memory area:
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 1 | 1 | 1 | 0 | 0 | 0 | 1 |dr | 1 | 1 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                  <ea>

NUMBER/REGISTER
	Specifies number of shifting or number of register which contents
	the number of shifting.
	If i/r = 0, number of shifting is specified in the instruction as
	immediate data
	If i/r = 1, it's specified in the data register.
	If dr = 0, right shifting
	If dr = 1, left shifting

SIZE
	00->one Byte operation
	01->one Word operation
	10->one Long operation

REGISTER
	For a register shifting:
	Indicates the number of data register on which shifting is applied.

	For a memory shifting:
	<ea> indicates operand which should be shifted.
	Only addressing modes relatives to memory are allowed:

	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |     -    | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |     -    | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	X - Set according to the last bit shifted out of the operand.
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Always cleared
	C - Set according to the last bit shifted out of the operand.

SEE ALSO
	ASL, ASR	ROL, ROR

***********************************************************


NAME
	MOVE -- Source -> Destination

SYNOPSIS
	MOVE	<ea>,<ea>

	Size = (Byte, Word, Long)

FUNCTION
	Move the content of the source to the destination location.
	The data is examined as it is moved, and the condition codes
	set accordingly.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|-------|-----------|-----------|-----------|-----------|
	| 0 | 0 |  SIZE |  REGISTER |    MODE   |    MODE   | REGISTER  |
	----------------************************=========================
	                    destination <ea>           source <ea>

REGISTER
	Destination <ea> specifies destination operand, addressing modes
	allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N° reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |     -    | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

	Source <ea> specifies source operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N° reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An *     |001 |N° reg. An| |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      |111 |  100   |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------
	 * Word or Long only.

SIZE
	01->Byte
	11->Word
	10->Long

RESULT
	X - Not affected.
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Always cleared.
	C - Always cleared.

SEE ALSO
	MOVEA

***********************************************************


NAME
	MOVEA -- Source -> Destination

SYNOPSIS
	MOVEA	<ea>,An

	Size = (Word, Long)

FUNCTION
	Move the contents of the source to the destination address
	register. Word sized operands are sign extended to 32 bits
	before the operation is done.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|-------|-----------|---|---|---|-----------|-----------|
	| 0 | 0 |  SIZE |  ADDRESS  | 0 | 0 | 1 |    MODE   | REGISTER  |
	|   |   |       |  REGISTER |   |   |   |           |           |
	----------------------------------------=========================
	                                              source <ea>

REGISTER
	"ADDRESS REGISTER" specifies the number of destination address
	register.

	Source <ea> specifies source operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N° reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An *     |001 |N° reg. An| |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      |111 |  100   |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------
	 * Word or Long only.

SIZE
	11->Word, 32 bits of address register are altered by sign extension.
	10->Long

RESULT
	None.

SEE ALSO
	MOVE LEA 

***********************************************************


NAME
	MOVE from CCR -- CCR -> Destination

SYNOPSIS
	MOVE	CCR,<ea>

	Size = (Word)

FUNCTION
	The content of the status register is moved to the destination
	location. The source operand is a word,	but only the low order
	byte contains the condition codes. The high order byte is set
	to all zeros.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | 0 | 0 | 1 | 0 | 1 | 1 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                  <ea>

REGISTER
	<ea> specifies destination operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N° reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	None.

SEE ALSO
	MOVE TO CCR

***********************************************************


NAME
	MOVE to CCR -- Source -> CCR

SYNOPSIS
	MOVE	<ea>,CCR

	Size = (Word)

FUNCTION
	The content of the source operand is moved to the condition codes.
	The source operand is a word, but only the low order byte is used
	to update the condition	codes. The high order byte is ignored.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 1 | 1 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                  <ea>

REGISTER
	<ea> specifies source operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N° reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      |111 |  100   |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	X - Set the same as bit 4 of the source operand.
	N - Set the same as bit 3 of the source operand.
	Z - Set the same as bit 2 of the source operand.
	V - Set the same as bit 1 of the source operand.
	C - Set the same as bit 0 of the source operand.

SEE ALSO
	MOVE FROM CCR

***********************************************************


NAME
	MOVE from SR -- Move from status register (privileged)

SYNOPSIS
	MOVE	SR,<ea>

	Size = (Word)

FUNCTION
	The content of the status register is moved to the destination
	location. The operand size is a word.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                  <ea>

REGISTER
	<ea> specifies destination operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N° reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	None.

SEE ALSO
	MOVE TO SR

***********************************************************


NAME
	MOVE to SR -- Move to status register (PRIVILEGED)

SYNOPSIS
	MOVE	<ea>,SR

	Size = (Word)

FUNCTION
	The content of the source operand is moved to the
	status register. The source operand size is a word
	and all bits of the status register are affected.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | 0 | 1 | 1 | 0 | 1 | 1 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                  <ea>

REGISTER
	<ea> specifies source operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N° reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      |111 |  100   |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT

	X - Set the same as bit 4 of the source operand.
	N - Set the same as bit 3 of the source operand.
	Z - Set the same as bit 2 of the source operand.
	V - Set the same as bit 1 of the source operand.
	C - Set the same as bit 0 of the source operand.

SEE ALSO
	MOVE TO CCR	MOVE FROM SR

***********************************************************


NAME
	MOVE USP -- Move to/from user stack pointer (privileged)

SYNOPSIS
	MOVE	USP,An
	MOVE	An,USP

	Size = (Long)

FUNCTION
	The contents of the user stack pointer are transfered either to
	or from the specified address register.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|-----------|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 0 |dr | REGISTER  |
	-----------------------------------------------------------------

	"REGISTER" indicates the number of address register.

	dr specifies move direction:
	0->An to USP
	1->USP to An

RESULT
	None.

SEE ALSO
	MOVE FROM CCR	MOVE TO CCR
	MOVE FROM SR	MOVE TO SR

***********************************************************


NAME
	MOVEC -- Move to/from control register

SYNOPSIS
	MOVEC	Rc,Rn
	MOVEC	Rn,Rc

	Size = (Long)

FUNCTION
	Copy the contents of the specified control register to the specified
	general register or copy from the general register to the control
	register. This is always a 32-bit transfer even though the control
	register may be implemented with fewer bits.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 1 |dr |
	|---|-----------|-----------------------------------------------|
	|A/D| REGISTER  |                CONTROL REGISTER               |
	-----------------------------------------------------------------

	A/D indicates type of Rn register:
	0->Rn=Dn
	1->Rn=An

	"REGISTER" indicates the number of Rn register.

	dr specifies direction of move:
	0->Rc to Rn.
	1->Rn to Rc.

	"CONTROL REGISTER" specifies one of the control registers:

	Hexa value	Control Register
	~~~~~~~~~~	~~~~~~~~~~~~~~~~
	000       	SFC
	001       	DFC
	002       	CACR
	800       	USP
	801       	VBR
	802       	CAAR
	803       	MSP
	804       	ISP

	All others hexa codes generates an exception: illegal instruction.

RESULT
	None.

SEE ALSO
	MOVE TO/FROM USP

***********************************************************


NAME
	MOVEM -- Move multiple registers

SYNOPSIS
	MOVEM	<register list>,<ea>
	MOVEM	<ea>,<register list>

	Size = (Word, Long)

FUNCTION
	Registers in the register list are either moved to or
	fetched from consecutive memory locations at the specified
	address. Data can be either word or long word, but if
	the register list is destination and the size is word,
	each register is filled with the source word sign extended
	to 32-bits.

	Also, in the case that the register list is the destination,
	register indirect with predecrement is not a valid source
	mode. If the register list is the source, then the
	destination may not be register indirect with postincrement.

		MOVEM.L	D0/D1/A0,(A2)+		;invalid
		MOVEM.W	-(A1),D5/D7/A4		;invalid

	The register list is accessed with D0 first through D7, followed
	by A0 through A7.

FORMAT
	                                                  <ea>
	-----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6  | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|----|-----------|-----------|
	| 0 | 1 | 0 | 0 | 1 |dr | 0 | 0 | 1 |SIZE|    MODE   | REGISTER  |
	|----------------------------------------------------------------|
	|                    MASK FROM REGISTER LIST                     |
	------------------------------------------------------------------

	dr specifies move direction:
	0->registers to memory
	1->memory to registers

	MASK FROM REGISTER LIST specifies registers which must be moved and
	indicates their move order.

	For pre-decrementing, mask has the following format:
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	|D0 |D1 |D2 |D3 |D4 |D5 |D6 |D7 |A0 |A1 |A2 |A3 |A4 |A5 |A6 |A7 |
	------------------------------------------------------------=====
	                                                              |
	First register to be moved------------------------------------'

	For post-incrementing, mask has the following format:
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	|A7 |A6 |A5 |A4 |A3 |A2 |A1 |A0 |D7 |D6 |D5 |D4 |D3 |D2 |D1 |D0 |
	------------------------------------------------------------=====
	                                                              |
	First register to be moved------------------------------------'

SIZE
	0->16 bits.
	1->32 bits.

REGISTER
	<ea> specifies memory address of move.

	Move from registers to memory, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |    -     | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     | -  |    -     | |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

	Move from memory to registers, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |    -     | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     | -  |    -     | |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	None.

SEE ALSO
	MOVE 	MOVEA	MOVEP

***********************************************************


NAME
	MOVEP -- Move peripheral data

SYNOPSIS
	MOVEP	Dx,(d,Ay)
	MOVEP	(d,Ay),Dx

	Size = (Word, Long)

FUNCTION
	Data is transfered between a data register and ever-other
	byte of memory at the selected address.
	Transfer is made between a data register and alterned bytes of memory
	at the selected address, must be specified in indirect mode to An with
	a 16 bits displacement.
	This instruction is of use with 8 bits peripheral programing.

	Example:
	~~~~~~~
		LEA	port0,A0	; A0 -> $FFFFFFFFFFFFFFFF
		MOVEQ	#0,D0
		MOVEP.L	D0,(0,A0)	; A0 -> $FF00FF00FF00FF00
		MOVE.L	#$55554444,D0
		MOVEP.L	D0,(1,A0)	; A0 -> $FF55FF55FF44FF44

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|-----------|---|---|---|-----------|
	| 0 | 0 | 0 | 0 |Dx REGISTER| OP-MODE   | 0 | 0 | 1 |Ay REGISTER|
	|---------------------------------------------------------------|
	|                        16 BITS OFFSET                         |
	-----------------------------------------------------------------

OP-MODE
	100->16 bits move, memory to register
	101->32 bits move, memory to register
	110->16 bits move, register to memory
	111->32 bits move, register to memory

REGISTER
	Dx register specifies the number of data register.
	Ay register specifies the number of address register which takes place
	in indirect addressing with displacement.

RESULT
	None.

SEE ALSO
	MOVEM

***********************************************************


NAME
	MOVEQ -- Move signed 8-bit data quick

SYNOPSIS
	MOVEQ	#<data:8>,Dn

	Size = (Long)

FUNCTION
	Move signed 8-bit data to the specified data register.
	The specified data is sign extended to 32-bits before
	it is moved to the register.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|-------------------------------|
	| 0 | 1 | 1 | 1 | REGISTER  | 0 |        IMMEDIATE DATA         |
	-----------------------------------------------------------------

	"REGISTER" is one of the 8 datas registers. 

RESULT
	X - Not affected.
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Always cleared.
	C - Always cleared.

SEE ALSO
	MOVE 	MOVEA	LEA

***********************************************************


NAME
	MOVES -- Move address space (PRIVILEGED)

SYNOPSIS
	MOVES	Rn,<ea>  (68010+)
	MOVES	<ea>,Rn  (68010+)

        Size = (Byte, Word, Long)

FUNCTION
        Moves contents (Byte, Word, Long) of register Rn to the addressed
        space by effective address in the addressable space specified by DFC.

	If destination is an address register, there's extension of operand
	sign to 32 bits.

FORMAT
	                                                   <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|-------|-----------|-----------|
	| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 0 | SIZE  |   MODE    | REGISTER  |
	|---|-----------|---|---|---|---|-------|-----------|-----------|
	|A/D|Rn REGISTER|dr | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
	-----------------------------------------------------------------

	A/D indicates type of Rn register:
	0->Rn=Dn
	1->Rn=An

	"REGISTER" indicates the number of Rn register.

	dr specifies direction of move:
	0->memory to register.
	1->register to memory.

SIZE
	00->Byte
	01->Word
	10->Long

REGISTER
	<ea> specifies place of source or destination, allowed addressing
	modes are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |    -     | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	None.

SEE ALSO
	MOVE FROM CCR 	MOVE TO CCR
	MOVE FROM SR	MOVE TO SR
	MOVE TO/FROM USP	MOVEM
	MOVEC	MOVEP

***********************************************************


NAME
	MULS -- Signed multiply
	MULU -- Unsigned multiply

SYNOPSIS
	MULS.W	<ea>,Dn		16*16->32
	MULS.L	<ea>,Dn		32*32->32	68020+
	MULS.L	<ea>,Dh:Dl	32*32->64	68020+

	MULU.W	<ea>,Dn		16*16->32
	MULU.L	<ea>,Dn		32*32->32	68020+
	MULU.L	<ea>,Dh:Dl	32*32->64	68020+

	Size = (Word)
	Size = (Word, Long)			68020+

FUNCTION
	Multiply two signed (MULS) or unsigned (MULU) integers
	to produce either a signed or unsigned, respectivly,
	result.

	This instruction has three forms. They are basically
	word, long word, and quad word. The first version is
	the only one available on a processore lower than a
	68020. It will multiply two 16-bit integers are produce
	a 32-bit result. The second will multiply two 32-bit
	integers and produce a 32-bit result.

	The third form needs some special consideration. It
	will multiply two 32-bit integers, specified by <ea>
	and Dl, the result is (sign) extended to 64-bits with
	the low order 32 being placed in Dl and the high order
	32 being placed in Dh.

FORMAT
	In the case of MULS.W:
	~~~~~~~~~~~~~~~~~~~~~                              <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|---|---|-----------|-----------|
	| 1 | 1 | 0 | 0 | REGISTER  | 1 | 1 | 1 |    MODE   | REGISTER  |
	-----------------------------------------------------------------

	In the case of MULS.L:
	~~~~~~~~~~~~~~~~~~~~~                               <ea>
	-----------------------------------------=========================
	|15 |14 |13 |12 |11 |10  | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|----|---|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | 1 | 1  | 0 | 0 | 0 | 0 |    MODE   | REGISTER  |
	|---|-----------|---|----|---|---|---|---|-----------|-----------|
	| 0 |Dq REGISTER| 1 |SIZE| 0 | 0 | 0 | 0 | 0 | 0 | 0 |Dr REGISTER|
	------------------------------------------------------------------

	In the case of MULU.W:
	~~~~~~~~~~~~~~~~~~~~~                              <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|---|---|-----------|-----------|
	| 1 | 1 | 0 | 0 | REGISTER  | 0 | 1 | 1 |    MODE   | REGISTER  |
	-----------------------------------------------------------------

	In the case of MULU.L:
	~~~~~~~~~~~~~~~~~~~~~                               <ea>
	-----------------------------------------=========================
	|15 |14 |13 |12 |11 |10  | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|----|---|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | 1 | 1  | 0 | 0 | 0 | 0 |    MODE   | REGISTER  |
	|---|-----------|---|----|---|---|---|---|-----------|-----------|
	| 0 |Dq REGISTER| 0 |SIZE| 0 | 0 | 0 | 0 | 0 | 0 | 0 |Dr REGISTER|
	------------------------------------------------------------------

	"REGISTER" indicates the number of data register.

	"Dq REGISTER" indicates the number of data register for destination
	operand. This register first contains 32 bits of low weight of
	dividend, and after the value of quotient on 32 bits.

	"SIZE" specifies if dividend is on 32 or 64 bits:
	0-> 32 bits dividend placed in Dq.
	1-> 64 bits dividend placed in Dr:Dq.

	"Dr REGISTER" indicates the number of data register for destination
	operand. This register first contains 32 bits of upper weight of
	dividend if "SIZE" = 1, and after the value of rest on 32 bits.

	If Dr and Dq represents the same register, only quotient on 32 bits
	is put in Dq.

	<ea> field specifies source operand, allowed addressing modes are:

	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N° reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      |111 |  100   |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	X - Not affected.
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Set if overflow. Cleared otherwise.
	C - Always cleared.

SEE ALSO
	DIVS	DIVU

***********************************************************


NAME
	NBCD -- Negate binary coded decimal with extend

SYNOPSIS
	NBCD	<ea>

	Size = (Byte)

FUNCTION
	The specified BCD number and the extend bit are subtracted
	from zero. Therefore, if the extend bit is set a nines
	complement is performed, else a tens complement is performed.
	The result is placed back in the specified <ea>.

	It can be useful to set the zero flag before performing
	this operation so that multi precision operations can
	be correctly tested for zero.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                   <ea>

RESULT
	X - Set the same as the carry bit.
	N - Undefined.
	Z - Cleared it the result is non-zero, unchanged otherwise.
	V - Undefined.
	C - Set if a borrow was generated, cleared otherwise.

SEE ALSO
	NEG NEGX

***********************************************************


NAME
	NEG -- Negate

SYNOPSIS
	NEG	<ea>

	Size = (Byte, Word, Long)

FUNCTION
	The operand specified by <ea> is subtracted from
	zero. The result is stored in <ea>.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|-------|-----------|-----------|
	| 0 | 1 | 0 | 0 | 0 | 1 | 0 | 0 | SIZE  |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                   <ea>

SIZE
	00->Byte.
	01->Word.
	10->Long.

REGISTER
	<ea> specifies destination operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N° reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	X - Set the same as the carry bit.
	N - Set if the result is negative, otherwise cleared.
	Z - Set if the result is zero, otherwise cleared.
	V - Set if overflow, otherwise cleared.
	C - Cleared if the result is zero, otherwise set.

SEE ALSO
	NBCD	NEGX

***********************************************************


NAME
	NEGX -- Negate with extend

SYNOPSIS
	NEGX	<ea>

	Size = (Byte, Word, Long)

FUNCTION
	Perform an operation similar to a NEG, with the
	exception that the operand and the extend bit are both
	subtracted from zero. The result then is being placed in
	the given <ea>.

	As with ADDX, SUBX, ABCD,
	SBCD, and NBCD, it can be useful to set
	the zero flag before performing this operation so that
	multi precision operations can be tested for zero.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|-------|-----------|-----------|
	| 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | SIZE  |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                   <ea>

SIZE
	00->Byte.
	01->Word.
	10->Long.

REGISTER
	<ea> specifies destination operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N° reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	X - Set the same as the carry bit.
	N - Set if the result is negative, otherwise cleared.
	Z - Cleared if the result is non-zero, otherwise unchanged.
	V - Set if an overflow is generated, cleared otherwise.
	C - Set if a borrow is generated, otherwise cleared.

SEE ALSO
	NEG NBCD ADDX SUBX

***********************************************************


NAME
	NOP -- No operation

SYNOPSIS
	NOP

FUNCTION
	Nothing happens! This instruction will basically wait until
	all pending bus activity is completed. This allows
	synchronization of the pipeline	and prevents instruction overlap.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 0 | 1 |
	-----------------------------------------------------------------

RESULT
	None.

SEE ALSO

***********************************************************


NAME
	NOT -- Logical complement

SYNOPSIS
	NOT	<ea>

	Size = (Byte, Word, Long)

FUNCTION
	All bits of the specified operand are inverted and placed
	back in the operand.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|-------|-----------|-----------|
	| 0 | 1 | 0 | 0 | 0 | 1 | 1 | 0 | SIZE  |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                   <ea>

SIZE
	00->Byte.
	01->Word.
	10->Long.

REGISTER
	<ea> specifies destination operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N° reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	X - Not affected.
	N - Set if the result is negative, otherwise cleared.
	Z - Set if the result is zero, otherwise cleared.
	V - Always cleared.
	C - Always cleared.

SEE ALSO
	NEG

***********************************************************


NAME
	OR -- Logical OR

SYNOPSIS
	OR	<ea>,Dn
	OR	Dn,<ea>

	Size = (Byte, Word, Long)

FUNCTION
	Performs an OR operation on the destination operand
	with the source operand.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|-----------|-----------|-----------|
	| 1 | 0 | 0 | 0 | REGISTER  |  OP-MODE  |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                   <ea>

OP-MODE
	Byte	Word	Long	Operation
	~~~~	~~~~	~~~~	~~~~~~~~~
	000	001	010	<ea> OR <Dn> --> <Dn>
	100	101	110	<Dn> OR <ea> --> <ea>

REGISTER
	If <ea> specifies destination operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |    -     | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

	If <ea> specifies source operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N° reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      |111 |  100   |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	X - Not Affected
	N - Set to the value of the most significant bit.
	Z - Set if the result is zero.
	V - Always cleared
	C - Always cleared
	
SEE ALSO
	ORI BSET

***********************************************************


NAME
	ORI -- Logical OR immediate

SYNOPSIS
	ORI	#<data>,<ea>

	Size = (Byte, Word, Long)

FUNCTION
	Performs an inclusive OR operation on the destination operand
	with the source operand.

FORMAT
	                                                   <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|-------|-----------|-----------|
	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | SIZE  |    MODE   | REGISTER  |
	|-------------------------------|-------------------------------|
	|    16 BITS IMMEDIATE DATA     |     8 BITS IMMEDIATE DATA     |
	|---------------------------------------------------------------|
	|                    32 BITS IMMEDIATE DATA                     |
	-----------------------------------------------------------------

SIZE
	00->Byte.
	01->Word.
	10->Long.

REGISTER
	<ea> specifies destination operand, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N° reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	X - Not Affected
	N - Set to the value of the most significant bit.
	Z - Set if the result is zero.
	V - Always cleared
	C - Always cleared
	
SEE ALSO
	OR   ORI TO CCR ORI TO SR
	BSET

***********************************************************


NAME
	ORI to CCR -- Logical OR immediate to the condition code register

SYNOPSIS
	ORI	#<data>,CCR

	Size = (Byte)

FUNCTION
	Performs an OR operation on the condition codes
	register with the source operand.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |
	|---|---|---|---|---|---|---|---|-------------------------------|
	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |     8 BITS IMMEDIATE DATA     |
	-----------------------------------------------------------------

RESULT
	X - Set if bit 4 of the source is set, cleared otherwise.
	N - Set if bit 3 of the source is set, cleared otherwise.
	Z - Set if bit 2 of the source is set, cleared otherwise.
	V - Set if bit 1 of the source is set, cleared otherwise.
	C - Set if bit 0 of the source is set, cleared otherwise.
	
SEE ALSO
	OR  ORI ORI TO SR

***********************************************************


NAME
	ORI to SR -- Logical OR immediated to the status register (PRIVILEGED)

SYNOPSIS
	ORI	#<data>,SR

	Size = (Word)

FUNCTION
	Performs an OR operation on the status register with
	the source operand, and leaves the result in the status
	register.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 0 |
	|---|---|---|---|---|---|---|---|-------------------------------|
	|                     16 BITS IMMEDIATE DATA                    |
	-----------------------------------------------------------------

RESULT
	X - Set if bit 4 of the source is set, cleared otherwise.
	N - Set if bit 3 of the source is set, cleared otherwise.
	Z - Set if bit 2 of the source is set, cleared otherwise.
	V - Set if bit 1 of the source is set, cleared otherwise.
	C - Set if bit 0 of the source is set, cleared otherwise.
	
SEE ALSO
	OR  ORI ORI TO CCR

***********************************************************


NAME
	PACK -- Pack binary coded decimal	(68020+)

SYNOPSIS
	PACK	-(Ax),-(Ay),#<adjustment>
	PACK	Dx,Dy,#<adjustment>

        Size = (Byte, Long)

FUNCTION
	Convert byte-per-digit unpacked BCD to packed two-digit-
	per-byte BCD.
	When operand is in a data register, 16 bits adjustment is added
	to source operand (16 bits). Then, bits 8 to 11 and 0 to 3 are
	packed and placed in the bits 0 to 7 of destination register.
	Others bits of this register are not altered.

	When operand is in memory, there's a research by pre-decrementing
	of the two bytes placed at given address. The two bytes are
	linked together, then adjustment is added, and the compacted result
	is stored at destination's place.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|---|---|---|---|---|-----------|
	| 1 | 0 | 0 | 0 |   Dy/Ay   | 1 | 0 | 1 | 0 | 0 |R/M|   Dx/Ax   |
	|---------------------------------------------------------------|
	|                    16 BITS ADJUSTMENT                         |
	-----------------------------------------------------------------

	R/M = 0 -> Direct addressing by data register.
	R/M = 1 -> Addressing by pre-decrementing.
	Register Dy/Ay specifies destination register.
	Register Dx/Ax specifies source register.
	"16 BITS ADJUSTMENT" is an immediate value added to source operand.

RESULT
	None.

SEE ALSO
	UNPK

***********************************************************


NAME
	PEA -- Push effective address

SYNOPSIS
	PEA	<ea>

	Size = (Long)

FUNCTION
	Effective address is stored to stack. Stack is decreased.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 1 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                   <ea>

REGISTER
	<ea> specifies destination operand, allowed addressing modes are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |    -     | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     | -  |    -     | |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      | -  |    -     | |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	None.

SEE ALSO
	LEA

***********************************************************


NAME
	PFLUSH -- Invalidate one or several entries in the ATC	(PRIVILEGED)

SYNOPSIS
	PFLUSHA
	PFLUSH	<FC>,#<FC validation>
	PFLUSH	<FC>,#<FC validation>,<ea>
	
	No size specs.

FUNCTION
	Those three instructions are used to invalidate one or several entries
	of the ATC (PMMU cache), i.e. to set the validation bits followings to
	those zero entries.

	PFLUSHA invalidate all the 22 entries of cache.

	PFLUSH <FC>,#<FC validation> invalidate entry which follows mentionned
	Function Codes.

	PFLUSH <FC>,#<FC validation>,<ea> invalidate entry which address is
	specified in the destination, of course in taking care of Function
	Codes.

	FC validation bits allow to take care of 3 FC bits else only some of
	these bits.
	The status register of the PMMU, MMUSR, isn't affected by this
	instruction.

	<FC> operand can be mentioned:
	·in immediate.
	·by the three lower bits of a data register.
	·by the register SFC or DFC.

FORMAT
	                                                   <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |    MODE   | REGISTER  |
	|---|---|---|-----------|---|---|-------------------------------|
	| 0 | 0 | 1 |    MODE   | 0 | 0 |    FC     |         FC        | 
	|   |   |   |           |   |   |VALIDATION |                   |
	-----------------------------------------------------------------

	MODE field indicates the type of PFLUSH:
	001->invalidation of all entries.
	100->invalidation by Function Codes.
	110->invalidation by the Function Codes and <ea>.

	FC VALIDATION field indicates the FC bits to take care of.
	FC field indicates value of Function Codes of the entry to
	invalidate.

	10XXX	The Function Codes are XXX.
	01DDD	The Function Codes are the bits 2 to 0 of a DDD data register.
	0000	The Function Codes are specified in SFC.
	0001	The Function Codes are specified in DFC.

REGISTER
	<ea> specifies address to invalidate, allowed addressing modes are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |    -     | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     | -  |    -     | |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      | -  |    -     | |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	Not affected.

SEE ALSO
	PLOAD

***********************************************************


NAME
	PLOAD -- Load of an entry in the ATC (PRIVILEGED)

SYNOPSIS
	PLOADR	<FC>,<ea>
	PLOADW	<FC>,<ea>
	
	No size specs.

FUNCTION
	Those instructions are used to load in the ATC (PMMU cache), one entry
	following to logic specified <ea>. A research in table  is made for
	this cache modification and attributes of final descriptor are updated
	(bits U and M for PLOADW, bits U for PLOADR) according to the executed
	instruction. PLOADR makes a loading of an entry in the ATC, as if a
	read cycle was made. PLOADW makes a loading of an entry in the ATC,
	as if a write cycle was made.

	The status register of the PMMU, MMUSR, isn't affected by this
	instruction.

	<FC> operand can be mentioned:
	·in immediate.
	·by the three lower bits of a data register.
	·by the register SFC or DFC.

FORMAT
	                                                   <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |    MODE   | REGISTER  |
	|---|---|---|---|---|---|---|---|---|---|-----------------------|
	| 0 | 0 | 1 | 0 | 0 | 0 |R/W| 0 | 0 | 0 | 0 |         FC        | 
	-----------------------------------------------------------------

	R/W field indicates type of access used for research:
	0->write access.
	1->read access.

	FC field indicates value of Function Codes of the entry to
	invalidate.

	10XXX	The Function Codes are XXX.
	01DDD	The Function Codes are the bits 2 to 0 of a DDD data register.
	0000	The Function Codes are specified in SFC.
	0001	The Function Codes are specified in DFC.

REGISTER
	<ea> specifies logic address to load, allowed addressing modes are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |    -     | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     | -  |    -     | |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      | -  |    -     | |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	Not affected.

SEE ALSO
	PMOVE

***********************************************************


NAME
	PMOVE -- Move from or to PMMU registers (PRIVILEGED)

SYNOPSIS
	PMOVE	MMU-reg,<ea>
	PMOVE	<ea>,MMU-reg
	PMOVEFD	<ea>,MMU-reg
	
	Size = (Word, Long, Quad).

FUNCTION
	This instruction is used to read or write PMMU registers.
	Transfert on CRP or SRP is for a Quadruple word (64 bits), TC, TT0,
	TT1 one's is for a Long word, and MMUSR one's is for a Word.

	PMOVEFD instruction does a move with invalidation or not  of PMMU
	cache. If FD bit is set in the instruction, the ATC isn't invalidated;
	if FD bit is cleared, ATC is invalidated.

	If value loaded in CRP or SRP follows to a not valid descriptor,
	the value is loaded but an exception of configuration error of PMMU
	is generated.

	For the TC register, a checking  on fields PS, IS, and TIx is made;
	if there's error on the total of mentioned bits, operand is loaded
	but an exception of configuration error of PMMU is generated.

	MMUSR isn't affected by those transferts, else it is placed in
	destination!!

FORMAT
	For CRP, SRP, TC registers:
	~~~~~~~~~~~~~~~~~~~~~~~~~~
	PMMU-reg field specifies PMMU register:
	000->TC
	010->SRP
	011->CRP
                                                          <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |    MODE   | REGISTER  |
	|---|---|---|-----------|---|---|---|---|-----------------------|
	| 0 | 1 | 0 |  MMU-reg  |R/W|FD | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
	-----------------------------------------------------------------

	For TT0, TT1, registers:
        ~~~~~~~~~~~~~~~~~~~~~~~
	PMMU-reg field specifies PMMU register:
	010->TT0
	011->TT1

	FD bit: allows or not ATC invalidation:
	0->ATC invalidated.
	1->ATC NOT invalidated.

                                                          <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |    MODE   | REGISTER  |
	|---|---|---|-----------|---|---|---|---|-----------------------|
	| 0 | 0 | 0 |  MMU-reg  |R/W|FD | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
	-----------------------------------------------------------------

	For MMUSR register:
	~~~~~~~~~~~~~~~~~~
                                                         <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |    MODE   | REGISTER  |
	|---|---|---|---|---|---|---|---|---|---|-----------------------|
	| 0 | 1 | 1 | 0 | 0 | 0 |R/W| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
	-----------------------------------------------------------------

	R/W field indicates type of access used for research:
	0->Memory to PMMU register.
	1->PMMU register to memory.

REGISTER
	<ea> specifies memory address, allowed addressing modes are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |    -     | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     | -  |    -     | |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      | -  |    -     | |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	Not affected.

SEE ALSO
	PTEST

***********************************************************


NAME
	PTEST -- TESTs a logic address (PRIVILEGED)

SYNOPSIS
	PTESTR	<FC>,<ea>,#<level>
	PTESTR	<FC>,<ea>,#<level>,An
	PTESTW	<FC>,<ea>,#<level>
	PTESTW	<FC>,<ea>,#<level>,An
	
	No size specs.

FUNCTION
	This instruction examines the ATC, if level is equal to zero,
	a research in the translation tables is made, if level is different
	of zero (1 to 7), then sets MMUSR bits.
	This instruction can also store, in an address register An, physical
	address encountred to last level of its research.

	PTESTR or PTESTW version is used to simulate a read or write cycle and
	like this, according to the informations founds, exactly set MMUSR.

	MMUSR bits are set of the following manner:

	MMUSR bits  |   PTEST level 0        |  PTEST level > 0
	~~~~~~~~~~  |   ~~~~~~~~~~~~~        |  ~~~~~~~~~~~~~~~
	B (bit 15)  | This bit is set if the |This bit is set if a bus error
	            | bit "Error Bus (B)" of |is generated during research in
	            | the ATC is set.        |the tables.
	----------------------------------------------------------------------
	L (bit 14)  | This bit is cleared    | This bit is set if an index
	            |                        |overflow a limit during a
	            |                        |research.
	----------------------------------------------------------------------
	S (bit 13)  | This bit is cleared    | This bit is set for indicating
	            |                        |a privilege violation: if S bit
	            |                        |of one of the descriptors met
	            |                        |is set and the FC2 bit mentioned
	            |                        |in the instruction is cleared
	            |                        |(user access). S isn't defined
	            |                        |if the bit I of MMUSR is set.
	----------------------------------------------------------------------
	W (bit 11)  | This bit is set if the | This bit is set if WP bit of
	            | bit WP in entry of the |one of the descriptors
	            | examined ATC is set.   |encountred is set. Undefined
	            | Undefined if I is set. |if I is set.
	----------------------------------------------------------------------
	I (bit 10)  | This bit is set if     |This bit is set if one of the
	            | required logic address |descriptors encountred isn't
	            | isn't in the ATC or if |valid (DT = 0) or if B or L of
	            | the bit B of this entry|MMUSR are set during research.
	            | is set.                |
	----------------------------------------------------------------------
	M (bit 9)   | This bit is set if the |This bit is set if the encountred
	            | bit M of designed entry|page descriptor has its bit M
	            | is set. Undefined if I |set. Undefined if I is set.
	            | is set.                |
	----------------------------------------------------------------------
	T (bit 6)   | This bit is set if     | This bit is cleared.
	            | mentioned logic address|
	            | is part of defined     |
	            | window by TT0 and/or   |
	            | TT1.                   |
	----------------------------------------------------------------------
	N (bits     |This field is cleared   | This field represents the number
	   2 to 0)  |                        | of level accessed during table
	            |                        | research.
	----------------------------------------------------------------------

	<FC> operand can be mentioned:
	·in immediate.
	·by the three lower bits of a data register.
	·by the register SFC or DFC.

FORMAT
	                                                   <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |    MODE   | REGISTER  |
	|---|---|---|-----------|---|---|-------------------------------|
	| 1 | 0 | 0 |   LEVEL   |R/W| A |    REG    |         FC        | 
	-----------------------------------------------------------------

	R/W field indicates type of access used for research:
	0->write access.
	1->read access.

	FC field indicates value of Function Codes of the address to test

	10XXX	The Function Codes are XXX.
	01DDD	The Function Codes are the bits 2 to 0 of a DDD data register.
	0000	The Function Codes are specified in SFC.
	0001	The Function Codes are specified in DFC.

	Bit A specifies address register option:
	0-> no address register
	1-> address of last accessed descriptor is put in the register
	specified by REG.

	REG field indicates, if A = 1 the number of address register. Else
	if A = 0, REG = 0.

	LEVEL field indicates the highest logic level to go during research;
	if test in the ATC, LEVEL = 0.

REGISTER
	<ea> specifies logic address to test, allowed addressing modes are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |    -     | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     | -  |    -     | |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      | -  |    -     | |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	Not affected.

SEE ALSO
	PLOAD

***********************************************************


NAME
	RESET -- Reset external devices

SYNOPSIS
	RESET

FUNCTION
	RESET line is set, then external circuitery is reset.
	Processor state isn't modified, except PC, which allows restart
	of execution to the next instruction.
	If processor is NOT in supervisor state, there's generation of
	exception "privilege violation", vector n°8.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |
	-----------------------------------------------------------------

RESULT
	None.

SEE ALSO
	STOP

***********************************************************


NAME
	RESET -- Reset external devices

SYNOPSIS
	RESET

FUNCTION
	RESET line is set, then external circuitery is reset.
	Processor state isn't modified, except PC, which allows restart
	of execution to the next instruction.
	If processor is NOT in supervisor state, there's generation of
	exception "privilege violation", vector n°8.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |
	-----------------------------------------------------------------

RESULT
	None.

SEE ALSO
	STOP

***********************************************************


NAME
	ROL, ROR -- Rotate left and rotate right

SYNOPSIS
	ROd	Dx,Dy
	ROd	#<data>,Dy
	ROd	<ea>
	where d is direction, L or R

	Size = (Byte, Word, Long)

FUNCTION
	Rotate the bits of the operand in the specified direction.
	The rotation count may be specified in two different ways:

	1. Immediate - the rotation count is specified in the instruction

	2. Register  - the rotation count is contained in a data register
	               specified in the instruction

	For a register, the size may be byte, word, or long, but for a memory
	location, the size must be a word. The rotation count is also
	restricted to one for a memory location.

                  .-------->--------.
	ROL:      |                 |
	      C <------ OPERAND <---'
	                  <---	       

	ROR:     ,-------<-------.
	         |               |
	         `--> OPERAND -----> C
	                --->

FORMAT
	In the case of the rotating of a register:
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|-------|---|---|---|-----------|
	| 1 | 1 | 1 | 0 |  NUMBER/  |dr |  SIZE |i/r| 1 | 1 | REGISTER  |
	|   |   |   |   |  REGISTER |   |       |   |   |   |           |
	-----------------------------------------------------------------

	In the case of the rotating of a memory area:
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 1 | 1 | 1 | 0 | 0 | 1 | 1 |dr | 1 | 1 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                  <ea>

NUMBER/REGISTER
	Specifies number of rotating or number of register which contents
	the number of rotating.
	If i/r = 0, number of rotating is specified in the instruction as
	immediate data
	If i/r = 1, it's specified in the data register.
	If dr = 0, right rotating
	If dr = 1, left rotating

SIZE
	00->one Byte operation
	01->one Word operation
	10->one Long operation

REGISTER
	For a register rotating:
	Indicates the number of data register on which rotating is applied.

	For a memory rotating:
	<ea> indicates operand which should be rotated.
	Only addressing modes relatives to memory are allowed:

	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |     -    | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |     -    | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	X - Not affected
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Always cleared
	C - Set according to the last bit shifted out of the operand.

SEE ALSO
	ROXL, ROXR	ASL, ASR	LSL, LSR

***********************************************************


NAME
	ROXL, ROXD -- Rotate left with extend and rotate right with extend

SYNOPSIS
	ROXd	Dx,Dy
	ROXd	#<data>,Dy
	ROXd	<ea>
	where d is direction, L or R

	Size = (Byte, Word, Long)

FUNCTION
        A rotation is made on destination operand bits.
        Rotation uses bit X.

                  .-------->-----------.
	ROXL:     |                    |
	      C <------ OPERAND <- X --'
	                  <---	       

	ROXR:    ,---------<-------.
	         |                 |
	         `-- X -> OPERAND -----> C
	                   --->

FORMAT
	In the case of the rotating of a register:
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|-------|---|---|---|-----------|
	| 1 | 1 | 1 | 0 |  NUMBER/  |dr |  SIZE |i/r| 1 | 0 | REGISTER  |
	|   |   |   |   |  REGISTER |   |       |   |   |   |           |
	-----------------------------------------------------------------

	In the case of the rotating of a memory area:
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 1 | 1 | 1 | 0 | 0 | 1 | 0 |dr | 1 | 1 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                  <ea>

NUMBER/REGISTER
	Specifies number of rotating or number of register which contents
	the number of rotating.
	If i/r = 0, number of rotating is specified in the instruction as
	immediate data
	If i/r = 1, it's specified in the data register.
	If dr = 0, right rotating
	If dr = 1, left rotating

SIZE
	00->one Byte operation
	01->one Word operation
	10->one Long operation

REGISTER
	For a register rotating:
	Indicates the number of data register on which rotating is applied.

	For a memory rotating:
	<ea> indicates operand which should be rotated.
	Only addressing modes relatives to memory are allowed:

	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |     -    | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |     -    | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	X - Set by the last bit out of operand.
            Not changed if rotation is zero.
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Always cleared
	C - Set according to the last bit shifted out of the operand.

SEE ALSO
	ROL, ROR	ASL, ASR	LSL, LSR

***********************************************************


NAME
	RTD -- Return and deallocate parameter stack frame	(68010+)

SYNOPSIS
	RTD	#<offset>

FUNCTION
	PC is subtracted from stack and replace old PC address.
	Then offset is added to SP value.

	This instruction is useful to restore reserved space memory of
	stored arguments at time sub-routine is called.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 1 | 0 | 0 |
	|---------------------------------------------------------------|
	|                        16 BITS OFFSET                         |
	-----------------------------------------------------------------

	"16 BITS OFFSET" is a signed 16 bits value to add to SP.

RESULT
	None.

SEE ALSO
	RTS	RTE	RTM

***********************************************************


NAME
	RTE -- Return from exception (PRIVILEGED)

SYNOPSIS
	RTE

FUNCTION
	SR and PC are restored by SP. All SR bits are affected.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 |
	-----------------------------------------------------------------

RESULT
	SR is set following to the restored word taken from SP.

SEE ALSO
	RTS	RTD	RTM

***********************************************************


NAME
	RTM -- Return from process module	(68020 ONLY)

SYNOPSIS
	RTM	Rn

FUNCTION
	Return from a process module called with CALLM.
	This instruction is 68020 ONLY and is used with, for cooperation
	with the PMMU MC68851. Be carreful, it's not available on 68030+.
        
RESULT
	Don't know!

SEE ALSO
	RTS	RTE	RTD

***********************************************************


NAME
	RTR -- Return and restore condition code register

SYNOPSIS
	RTR

FUNCTION
	CCR and PC are restored by SP.
	Supervisor byte of SR isn't affected.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 1 | 1 | 1 |
	-----------------------------------------------------------------

RESULT
	SR is set following to the restored word taken from SP.

SEE ALSO
	RTS	RTE	RTD

***********************************************************


NAME
	RTS -- Return from subroutine

SYNOPSIS
	RTS

FUNCTION
	PC is restored by SP.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 1 | 0 | 1 |
	-----------------------------------------------------------------

RESULT
	None.

SEE ALSO
	RTM	RTE	RTD

***********************************************************


NAME
	SBCD -- Subtract binary coded decimal with extend

SYNOPSIS
	SBCD	Dy,Dx
	SBCD	-(Ay),-(Ax)

	Size = (Byte)

FUNCTION
	Subtracts the source operand to the destination operand along with
	the extend bit, and stores the result in the destination location.
        The subtraction is performed using binary coded decimal arithmetic.
        The operands, which are packed BCD numbers, can be addressed in two
        different ways:

	1. Data register to data register: The operands are contained in the
	   data registers specified in the instruction.

	2. Memory to memory: The operands are addressed with the predecrement
	   addressing mode using the address registers specified in the
	   instruction.

	Normally the Z condition code bit is set via programming before the
	start of an operation. That allows successful tests for zero results
	upon completion of multiple-precision operations.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|---|---|---|---|---|-----------|
	| 1 | 0 | 0 | 0 |Ry REGISTER| 1 | 0 | 0 | 0 | 0 |R/M|Rx REGISTER|
	-----------------------------------------------------------------

	Ry specifies destination register.
	Rx specifies source register.
	If R/M = 0: Rx and Ry are datas registers.
	If R/M = 1: Rx and Ry are address registers used  for the pre-
	decrementing.

RESULT
	X - Set the same as the carry bit.
	N - Undefined
	Z - Cleared if the result is non-zero. Unchanged otherwise.
	V - Undefined
	C - Set if a decimal carry was generated. Cleared otherwise.

SEE ALSO
	SUB  ADDI ADDQ
	ADDX
	ADD  SUBI SUBQ
	ABCD SUBX

***********************************************************


NAME
	Scc -- Conditional set

SYNOPSIS
	Scc	<ea>

        Size = (Byte)

FUNCTION
        If condition is true then byte addressed by <ea> is set to $FF,
        else byte addressed by <ea> is set to $00.

	Condition code 'cc' specifies one of the following:
0000 F  False            Z = 1      1000 VC oVerflow Clear   V = 0
0001 T  True             Z = 0      1001 VS oVerflow Set     V = 1
0010 HI HIgh             C + Z = 0  1010 PL PLus             N = 0
0011 LS Low or Same      C + Z = 1  1011 MI MInus            N = 1
0100 CC Carry Clear      C = 0      1100 GE Greater or Equal N (+) V = 0
0101 CS Carry Set        C = 1      1101 LT Less Than        N (+) V = 1
0110 NE Not Equal        Z = 0      1110 GT Greater Than     Z + (N (+) V) = 0
0111 EQ EQual            Z = 1      1111 LE Less or Equal    Z + (N (+) V) = 1

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---------------|---|---|-----------|-----------|
	| 0 | 1 | 0 | 1 | cc CONDITION  | 1 | 1 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                   <ea>

REGISTER
	<ea> specifies operand to set, addressing modes allowed are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N° reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |    -     | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	None.

SEE ALSO
	BCC	DBCC

***********************************************************


NAME
	STOP -- Stop processor execution (PRIVILEGED)

SYNOPSIS
	STOP	#<data:16>

FUNCTION
	Immediate data is moved to SR. PC is set to next instruction,
	and the processor stops fetch and execution of instruction.
	Execution restarts if if a TRACE exception, an interruption, or
	a RESET takes place.
	When STOP is executed, a TRACE exception is generated (if T = 1).
	An interruption is allowed if it level is higher than current one.
	An external RESET always will generate a RESET exception.
	If bit S is set to zero by the immediate data, execution of this
	instruction will generate a "privilege violation".

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
	| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 0 |
	|---------------------------------------------------------------|
	|                    16 BITS IMMEDIATE DATA                     |
	-----------------------------------------------------------------

RESULT
	SR is set according to immediate data.

SEE ALSO
	RESET

***********************************************************


NAME
	SUB -- Subtract

SYNOPSIS
	SUB	<ea>,Dn
	SUB	Dn,<ea>

	Size = (Byte, Word, Long)

FUNCTION
        Subtracts source operand to destination operand.
        Result is stored to destination's place.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|-----------|-----------|-----------|
	| 1 | 0 | 0 | 1 |  REGISTER |  OP-MODE  |    MODE   |  REGISTER |
	----------------------------------------=========================
                                                          <ea>

OP-MODE
	Byte	Word	Long
	~~~~	~~~~	~~~~
	000	001	010	(Dn) - (<ea>) -> Dn
	100	101	110	(<ea>) - (Dn) -> <ea>

REGISTER
	One of the 8 datas registers

	If <ea> is source, allowed addressing modes are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N° reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An *     |001 |N° reg. An| |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d16,An)    |101 |N° reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      |111 |  100   |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------
	 * Word or Long only

	If <ea> is destination, allowed addressing modes are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       | -  |     -    | |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |     -    | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------
	When destination is an Address Register, SUBA instruction is used.

RESULT
	X - Set the same as the carry bit.
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Set if an overflow is generated. Cleared otherwise.
	C - Set if a carry is generated. Cleared otherwise.

SEE ALSO
	ADDI ADDQ ADDX
	ADD SUBI SUBQ
	SUBX

***********************************************************


NAME
	SUBA -- Subtract address

SYNOPSIS
	SUBA	<ea>,An

	Size = (Word, Long)

FUNCTION
        Subtracts source operand to destination operand.
        Source operand with a Word size is extended to 32 bits before
        operation. Result is stored to destination's place.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|-----------|-----------|-----------|
	| 1 | 0 | 0 | 1 |  REGISTER |  OP-MODE  |    MODE   |  REGISTER |
	----------------------------------------=========================
                                                          <ea>
OP-MODE
	Indicates operation lenght:
	011->one Word operation: source operand is extended to 32 bits
	111->one Long operation

REGISTER
	<ea> is source, allowed addressing modes are:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N° reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       |001 |N° reg. An| |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    |111 |  010   |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  |111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d16,An)    |101 |N° reg. An| |([bd,PC,Xi],od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)|111 |  011   |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      |111 |  100   |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
        None.

SEE ALSO
	ADDA SUBI
        SUBQ SUBX

***********************************************************


NAME
	SUBI -- Subtract immediate

SYNOPSIS
	SUBI	#<data>,<ea>

	Size = (Byte, Word, Long)

FUNCTION
	Subtracts the immediate data to the destination operand, and
	stores the result in the destination location. The size of the
	operation may be specified as byte, word, or long.
        The size of the	immediate data matches the operation size.

FORMAT
                                                          <ea>
	----------------------------------------=========================
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|-------|-----------|-----------|
	| 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | SIZE  |   MODE    |  REGISTER |
	|---------------------------------------------------------------|
	| 16 BITS DATA (with last Byte) |          8 BITS DATA          |
	|---------------------------------------------------------------|
	|             32 BITS DATA (included last Word)                 |
	-----------------------------------------------------------------

SIZE
	00->one Byte operation
	01->one Word operation
	10->one Long operation

REGISTER
	<ea> is always destination, addressing modes are the followings:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N° reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |     -    | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	X - Set the same as the carry bit.
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Set if an overflow is generated. Cleared otherwise.
	C - Set if a carry is generated. Cleared otherwise.

SEE ALSO
	ADD  ADDQ ADDX
	SUB  ADDI SUBQ
	SUBX

***********************************************************


NAME
	SUBQ -- Subtract 3-bit immediate quick

SYNOPSIS
	SUBQ	#<data>,<ea>

	Size = (Byte, Word, Long)

FUNCTION
	Subtracts the immediate value of 1 to 8 to the operand at the
	destination location. The size of the operation may be specified as
	byte, word, or long. When subtracting to address registers,
        the condition codes are not altered, and the entire destination
        address register is used regardless of the operation size.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|-------|-----------|-----------|
	| 0 | 1 | 0 | 1 |    DATA   | 1 | SIZE  |    MODE   |  REGISTER |
	----------------------------------------=========================
                                                          <ea>

DATA
	000        ->represent value 8
	001 to 111 ->immediate data from 1 to 7

SIZE
	00->one Byte operation
	01->one Word operation
	10->one Long operation

REGISTER
	<ea> is always destination, addressing modes are the followings:

	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N° reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An *     |001 |N° reg. An| |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------
	 * Word or Long only.

RESULT
	X - Set the same as the carry bit.
	N - Set if the result is negative. Cleared otherwise.
	Z - Set if the result is zero. Cleared otherwise.
	V - Set if an overflow is generated. Cleared otherwise.
	C - Set if a carry is generated. Cleared otherwise.

SEE ALSO
	ADD  ADDI
	SUB  SUBI ADDQ

***********************************************************


NAME
	SUBX -- Subtract with extend

SYNOPSIS
	SUBX	Dy,Dx
	SUBX	-(Ay),-(Ax)

	Size = (Byte, Word, Long)

FUNCTION
	Subtracts the source operand to the destination operand along with
	the extend bit, and stores the result in the destination location.
        The subtraction is performed using binary coded decimal arithmetic.
        The operands, which are packed BCD numbers, can be addressed in two
        different ways:

	1. Data register to data register: The operands are contained in the
	   data registers specified in the instruction.

	2. Memory to memory: The operands are addressed with the predecrement
	   addressing mode using the address registers specified in the
	   instruction.

	The size of operation can be specified as byte, word, or long.

	Normally the Z condition code bit is set via programming before the
	start of an operation. That allows successful tests for zero results
	upon completion of multiple-precision operations.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|-----------|---|-------|---|---|---|-----------|
	| 1 | 0 | 0 | 1 |    Rx     | 1 | SIZE  | 0 | 0 |R/M|    Ry     |
	-----------------------------------------------------------------

	R/M = 0 -> data register
	R/M = 1 -> address register
	Rx:   destination register
	Ry:   source register

SIZE
	00->one Byte operation
	01->one Word operation
	10->one Long operation

RESULT
	X - Set the same as the carry bit.
	N - Set if the result is negative. Cleared otherwise.
	Z - Cleared if the result is non-zero. Unchanged otherwise.
	V - Set if an overflow is generated. Cleared otherwise.
	C - Set if a carry is generated. Cleared otherwise.

SEE ALSO
	ADD ADDI
	SUB SUBI ADDX

***********************************************************


NAME
	SWAP -- Swap register upper and lower words

SYNOPSIS
        SWAP	Dn

        Size = (Word)

FUNCTION
        Swaps between 16 low bits and 16 high bits of register.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|---|---|---|-----------|
	| 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | REGISTER  |
	-----------------------------------------------------------------

	"REGISTER" indicates the number of register on which swap is made.

RESULT
	X - Not affected
	N - Set if the most-significant bit of the result was set. Cleared
	    otherwise.
	Z - Set if the 32 bits result was zero. Cleared otherwise.
	V - Always cleared.
	C - Always cleared.

SEE ALSO
	EXG

***********************************************************


NAME
	TAS -- Test and set operand

SYNOPSIS
	TAS	<ea>

	Size = (Byte)

FUNCTION
	Test of a byte addressed by <ea>, bits N and Z of SR are set
	according to result of test.
	Bit 7 of byte is set to 1. This instruction uses read-modify-write
	cycle, which is not dividable and allows synchronisation of several
	processors. But this instruction is NOT ALLOWED ON AMIGA!
	This instruction can easily be substituted by BSET.

FORMAT
	-----------------------------------------------------------------
	|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	|---|---|---|---|---|---|---|---|---|---|-----------|-----------|
	| 0 | 1 | 0 | 0 | 1 | 0 | 1 | 0 | 1 | 1 |    MODE   | REGISTER  |
	----------------------------------------=========================
	                                                   <ea>

REGISTER
	<ea> is destination, addressing modes are the followings:
	--------------------------------- -------------------------------
	|Addressing Mode|Mode| Register | |Addressing Mode|Mode|Register|
	|-------------------------------| |-----------------------------|
	|      Dn       |000 |N° reg. Dn| |    Abs.W      |111 |  000   |
	|-------------------------------| |-----------------------------|
	|      An       | -  |     -    | |    Abs.L      |111 |  001   |
	|-------------------------------| |-----------------------------|
	|     (An)      |010 |N° reg. An| |   (d16,PC)    | -  |   -    |
	|-------------------------------| |-----------------------------|
	|     (An)+     |011 |N° reg. An| |   (d8,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    -(An)      |100 |N° reg. An| |   (bd,PC,Xi)  | -  |   -    |
	|-------------------------------| |-----------------------------|
	|    (d16,An)   |101 |N° reg. An| |([bd,PC,Xi],od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (d8,An,Xi)  |110 |N° reg. An| |([bd,PC],Xi,od)| -  |   -    |
	|-------------------------------| |-----------------------------|
	|   (bd,An,Xi)  |110 |N° reg. An| |    #data      | -  |   -    |
	|-------------------------------| -------------------------------
	|([bd,An,Xi]od) |110 |N° reg. An|
	|-------------------------------|
	|([bd,An],Xi,od)|110 |N° reg. An|
	---------------------------------

RESULT
	X - Not affected.
	N - Set if MSB of byte is set. Cleared otherwise.
	Z - Set if byte is zero. Cleared otherwise.
	V - Always cleared.
	C - Always cleared.

SEE ALSO

***********************************************************

                              END OF PART TWO


