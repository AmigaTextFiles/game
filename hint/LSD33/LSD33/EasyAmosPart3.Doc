/#########################################################################\
|#####...####..######..######......####...####..#####..##......##......###|
|####.....###..######..########..#####.....###...####..##..######..#######|
|###..###..##..######..########..####..###..##....###..##..######..#######|
|###..###..##..######..########..####..###..##..#...#..##..######......###|
|###.......##..######..########..####.......##..##.....##..######..#######|
|###..###..##..######..########..####..###..##..###....##..######..#######|
|###..###..##...#####...#######..####..###..##..####...##..######..#######|
|###..###..##......##......##......##..###..##..#####..##......##......###|
|#########################################################################|
|####################################################################{RB}#|
|=========================================================================|
|									  |
|		           ----> PRESENTS <----				  |
|									  |
|			EASY AMOS - COMPLETE MANUAL		          |
|								          |
|			          PART 3                                  |
|									  |
|		     SCANNED AND EDITED BY : RAZOR BLADE		  |
|									  |
|-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-|
| 		CALL THE ALLIANCE WORLD HQ -> THE PLACE TO BE             |
|       UNKNOWN PLEASURES --> +44 (0) 823 322 891 --> SYSOP: BARBARIAN    |
|_________________________________________________________________________|


			Chapter 15

		       HANDLING DATA


Using Easy AMOS for nothing but computer games is a
bit like using a violin as a baseball bat: it's great fun, but
you're missing out on the full potential. This Chapter
deals with some of the more practical ways Easy AMOS
can be used to handle the information that we call "data".

Let's start by learning how to place items of data in an
Easy AMOS program.


Placing Data
-------------
DATA

A Data statement lets you include whole lists of useful
information in your programs. Each item in the list must
be separated by a comma, like this:


Reading Data
-------------
READ

Once you've put your data into the program, you can
then tell the computer to Read this type of stored
information, one item at a time, and then load it into
your variables. For example:         -

    N=Rnd(100)

    Read A$,B,C,D$

    Print A$,B,C,D$

    Data "Text string",100,N, "Easy "+ "AMOS"

We'll come back to that example in a moment. When a
program reads data, a special marker jumps to the first
item in the first Data statement in the listing. As soon as
this item of data has been read, the marker moves on to
the next item in the list.

The main rule to remember is that the variables to be
read must be of exactly the same type as the data held at
the current position. Look at that last example again to
see how the different types match up. If you match up
one type of stored data with a different type of variable


			-=- 252 -=-


after a Read command, an error message will pop up on
screen to tell you there's been a mismatch. Experiment
and Read a few of your own Data statements now.

The other rule to remember is that a Data statement must
be the only statement on the current line, because
anything that follows it will be ignored! Try this example
to prove it:

Read A$ : Print A$

Data "I am OK"  : Print "But I'm not"

You can put Data statements anywhere you like in your
programs, but if data is stored inside an Easy AMOS
procedure it will NOT be accessible from the main
program. On the other hand, a procedure can have its
own setof Data statements, which are treated completely
separately from the rest of the program. Here's an
example:

EXAMPLE : Read A$ : Print A$

Data "I am main program data"

Procedure EXAMPLE

   Read B$ : Print B$

   Data I am procedure data only

End Proc


Restoring Data
--------------
RESTORE

If you want to change the order in which your data is
read from the order in which it was originally stored,
you can change the point where a Read operation will
expect to find the next Data statement. The Restore
command sets the position of this pointer, by referring to
a particular label or line number. For example:

Restore Label

			-=- 253 -=-

The name of the label can also be calculated as part of an
expression, like this:

  Restore "LA"+"BELL"

In the same way, you can Restore to a proper line
number or a line number that has been set up as an
expression, like this:

  Restore LABEL+5

Restore is one of the tricks used by programmers to
make the computer select information, depending on
the actions of the user. It can be used for question and
answer quizzes, ad venture games or teaching programs.

As well as allowing you to store and retrieve data inside
a single program or file, Easy AMOS can manipulate a
whole disc full of information files! Don't forget that
files are simply packages of information stored together
at a particular location on a disc.

Your Amiga uses two types of disc files: "sequential"
files, and "random access" files. Here's how Easy AMOS
can get the best out of them.


Sequential files
----------------
A sequential file is one that allows you to read your
information ONLY in the sequence in which it was
originally created. Normally with an Amiga, if you
want to change a single item of data in the middle of a
sequential file, you have to call up that file from the disc,
read the whole file up to and including the item of data
you want to alter, change the data and then write the
whole file back to the disc!

			-=- 254 -=-

Easy AMOS lets you have access to sequential files either
for reading data, or for writing it, but never for both at
the same time. Before we get on to the theory and a
whole host of new commands, let's have a little practice.
Use the disc that we recommended you to prepare,
labelled "My Programs". Type in this example, which
opens a file called SEQUENTIAL.ONE, allows you to
input some data, then closes the file:


  Open Out 1, "sequential.one"

  Input "Please tell me your name ";N$

  Print #l, NS

  Close 1

Now let's read back the information stored in our file.
Try out this example:

  Open In 1, sequential.one

  Input #1, N$
 
  Print "I remember you ! Hello ";N$
 
  Close 1

Every time you want to access a sequential file, you have to
open it, then access the information and then dose it. Those
three steps must be done in exactly that order. Here's the list
of commands you can use for handling sequential files.


Opening Sequential Files
------------------------
OPEN OUT

Use this command when you want to open a sequential file
and write some data into it. Before you give the fileaname,you
must give it a number between 1and 10 which is the "channel"
used to identify your new file when you input or print
information to it. If the file name already exists, it will be
erased! You have already used the example:

  Open Out 1,"sequential.one"

			-=- 255 -=-

                              255
Adding to files
---------------
APPEND

This works like Open Out, but it allows you to add to your files
at any time AFTER they've been defined. If the filename
already exists, your new data will be "appended" to it, in other
words it will be added on to the end of that file.

        Append 1,"sequential.one"

Preparing files 
---------------
OPENIN

Use this to get a file ready for reading data from it. If the
filename doesn't already exist, Easy AMOS will report the
message "Fle not found".

Closing Files
-------------
CLOSE

Don't forget, you MUST always close a file after you've
finished with it. If you forget to use the close instruction, any
changes you have made to the file will be lost!

Loading Data
-------------
PRINT #

Use this command in the same way you use a normal Print
instruction, but instead of printing information on your screen
it puts it into one of your files. Remember to tell Easy AMOS
which channel you want to use, then the name of the file to be
created, and don't forget to Close the file's channel number
afterwards.

   Open Out 2,"sequential.two"

   Print #2,"Just testing"


When you [Run] that example, nothing appears on screen and
the data is printed directly to the file. Now delete the three 
lines of your example and [Run] this:

  Open In 2,"sequential.two"

  Input #2,A$

  Print A$

  Close 2

			-=- 256 -=-


The data should now appear on screen after it has been
retrieved, using the Input# command. Here's how it
works.

INPUT #

This command reads information from a sequential file,
and loads these values into a set of variables. As with a
normal Input, each value in the list must be separated by
a comma.

You can find more information about sequential files in
the Glossary, where the following keywords are
explained:

LINE INPUT #, SET INPUT, =INPUT$, =EOF, LOF, POF

Are you ready for some more Easy AMOS magic? Random
access files are amazingly useful, because they let you get at the
data stored on a disc in any random order you want. A
random access file is made up of chunks of data called
"records", and each record has its own identification number.
Every re~rd can be split up into as many smaller chunks as
you like, and we call these sections "fields". Each field is used
to hold a single item of data.

The big difference between sequential files and random access
files is that you must tell Easy AMOS the maximum size of a
"field" in advance, before you make use of it.
A field can hold all sorts of data, like a password, or a telephone
number or even a line of a poem, and you are welcome to use
your imagination to adapt a ready-made program for your
own purposes at the end of this Chapter.
Let's say you want to create an electronic phone book. You
might choose the following fields, with the following maximum
lengths of characters in each:

Field     Maximum length
NAME$		25
TEL$		12

			-=- 257 -=-


Structuring random access files
-------------------------------
If you are happy with the fields you want to manipulate
and the length of each field, you can set up the structure
for your electronic record or database.

OPEN RANDOM

This command is used to open a channel to a random
access file, like this:

  Open Random 1, "ADDRESS"

FIELD

Now the record structure must be set up, and you use
the Field instruction to do this. After stating the channel
number, give the maximum number of characters you
are catering for in a field followed by its name, like this:

  Field 1,25 As NAME$,12 As TEL$

You can now place some records in the strings set up by
the Field command, for example:

  NAME$= AMOS

Placing Records
---------------
PUT

Once a record has been placed into a string, you can
move it from the Amiga's memory into a "recordnumber"
of your random access file. Still using channel 1, your
first record would be Put into the random access file like
this:

  Put 1,1

The next record will become Record 2, and so on until
you fill up your address book. Let's try out all of this
theory and put it into practice with a phonebook. When
you have created enough records, type in "exit" when
asked to enter a name.


			-=- 258 -=-


	Open Random 1, "ADDRESS"

        Field 1,25 As NAMES,12 As TELS

        INDEX=1

  	Do

  	Input "Enter a name  ";NAME$

	If NAME$= "exit" Then Exit

	Input "Enter the phone number ";TEL$

	Put 1,INDEX

        INDEX=INDEX+l

        Loop

        Close 1

Having created your phone book, you'll want to use it.


Reading Records
---------------
GET

This instruction reads a record stored in a random access file,
when you tell it which channel to use, and the number of the
record to be read. For example, to read the first record, use this:

 Get 1,1

It then loads this record into your field strings, and these
strings can be manipulated as you like. Obviously you can
only Get record numbers that have been Put onto the disc.
Here's an example to try out:

  Open Random 1, "ADDRESS"

  Field 1,25 As NAME$,12 As TEL$

  Do

   Input "Enter Record number  ";INDEX

   If INDEX=0 Then Exit

   Get 1,INDEX

   Print NAME$ : Print TEL$

  Loop

  Close 1

			-=- 259 -=-

MAKING A DATABASE
-----------------
The most satisfying home grown programs are those that can
be adapted for an unlimited number of uses. If you have
programmed Easy AMOS to act as an electronic telephone
directory, you can transform the same routines to act as a sort
of "card index" database for any other purpose: whether you
catalogue your stamp collection or draw up a schedule of all
your worldly possessions for an insurance policy.


The Easy Database
-----------------
You'll be pleased to learn that we've prepared a ready-made
database for you to learn from and adapt It has been specially
written by Andrew Forrest Select it off your "Easy AMOS
Examples" disc now by loading the following file:

  Easy_Database.AMOS

Take a quick look through the listing to see how many of the
routines you already recognise and then [Run] the program,
which will display the file selector to kick off the proceeding_c.
You will be asked for the name of a file to load or create, so type
in something like "Address_book.DBS".

			-=- 260 -=-


This electronic database holds records like a card index,
except for the fact that it's smart! Each screen represents
one record or card in the index, and the record number
is displayed at the top right of screen. The name of the
current file is at the top left.

Below this identification line are five "fields" of data, set
up to act as a page in an address book, as follows:

  1 Name

  2 Address

  3 Postcode

  4 Age

  5 Phone number


Entering Field data
--------------------
Each of these five "fields" is waiting for you to input some
data, and to put text into the database all you have to do
is click on one of the "fields" with the mouse, then type in
some text via the keyboard, pressing [Return] when
you've completed each entry. You can use the backspace
key to delete any mistakes. Enter some data now in each
of the five fields.

At the bottom of the screen is a row of graphic "icons",
which are your smart option boxes, triggered by the
mouse.

SEARCH
------
Supposing you know the name of the street where
somebody lives, bu t you can't remember their name. Or
supposing you want to call up everyone you know of the
same age. No problem! After selecting the Search icon,
type in the characters to be searched for: a name, or a
number or part of an address. Once it's been found you
can continue searching by entering "Y", or stop the
search by entering "N" when prompted.

			-=- 261 -=-

SORT

The Sort option looks through all of your data, and
organises it in any way you want! When you select this
option, you'll be asked to specify a field to be used as the
basis of the sort. Simply enter the number corresponding
to the field you are interested in. For example, to
reorganise your database in alphabetical order by name,
enter "1".


GO TO FIRST RECORD

When you trigger this option, a search is made for the
very first record that has been stored in your database,
ùd it is displayed on screen.


GO TO PREVIOUS RECORD

This calls up and displays the previous entry in your
electronic card index, and it can be used as many times
, you like to flick back through your data.

GO TO NEXT RECORD

The next page of your address book is revealed every
time you select this option.

GO TO LAST RECORD

By triggering this icon, the program jumps straight to
the very last record held on file and displays it on screen.

PRINT RECORD

If you are lucky enough to have a printer, the [PRINT]
button is used to output the current record to the printer.



			-=- 262 -=-


ADD A RECORD
------------
Use this to create a new record in your filing system.
Add one now after the last record in your Database.


HELP
----
As you would expect from us, a [Help] option is supplied,
just in case you need reminding how this program
works. The Help Screen has a synopsis of these
instructions. Press any key to return to the program.

EXIT
-----
This option quits the program and returns to the Easy
AMOS Editor.


Add as many records as you like, and try out each of the
options. Data is written to the file as you enter your
records, and when you [Exit] from the program the file
is closed, which makes sure that all of your data has been
saved . When you've built up your own database, trigger
[Exit] to take another look at the listing. As usual,
everything has been fully commented in the listing to
help you as much as possible. Go through the program
now, read the notes and identify exactly what each
routine does and how it works.

How about using all of your new knowledge to improve
this program? Here is a list of suggestions that you
might like to try out:

- Add sound effects or speech, every time you
  trigger an option or enter some data.

- Change the titles of the five fields, and create a
  database for a library, a music collection, or
  anything that takes your fancy.

			-=- 263 -=-


- Design your own Welcome Screen, and make it
  appear every time you load your Database. Leave
  it displayed for a few seconds, fade it, and then
  reveal the Database screen.

- Make the program automatically remove any
  commas from the fields, after they have been
  entered.

- Create a screen prompt that asks you if you are
  sure you want to quit, after clicking the [Exitl
  option.

- Limit the number of characters that can be typed
  into each field, by writing a procedure to replace
  the Input command.

- Try to include a new [Delete] option that erases a
  record, which may sound easy,but requires some
  careful thought.


Finally, remember that your Database files will be created
on the Ram disc, so copy your database onto a suitable
floppy disc or hard drive, using the [Easy disc] option.
This will call up the Amazing Easy AMOS Disc Editor,
which is waiting to be introduced to you in the next
Chapter.

			-=- 264 -=-


			Chapter 16


             PERIPHERALS, DRIVES AND DISCS


This chapter deals with the various devices that can be
connected to your computer, often called "peripherals"
or "add-ons". This includes joysticks, mouse controllers
and printers. It will also cover all the instructions for
gaining access to disc drives, disc directories and files.


JOYSTICKS
---------
A joystick can be used to control movement around the
screen by pushing its handle in the required direction,
and to trigger all sorts of actions by pressing one or more
fire-buttons built in to its mechanism. There are two
sockets in the back of an Amiga computer, marked "1
JOYSTICK" and "2 JOYSTICK", either of which will
happily accept a joystick plug. If two users want to
control one joystick each for specially written programs,
both ports can be used.

To make a joystick interact with your programs, the
computer needs to be able to read its movements. Easy
AMOS has two useful functions that do just that.

=JOY
----
This inspects what's happening to the joystick and makes
a report. You have to tell the computer which port the
joystick is plugged into. If it's plugged into the joystick
port, the computer will expect to look at number (1), and
if you are using the mouse port, call that number (0), for
example:

    Do
     J=Joy (1)
     Print Bin$ (J,5),J
    Loop

Try running that routine now, and see what reports are
given when you move the joystick and press its fire-
button. The report you get back is given as a "binary"
pattern, in other words, it's made up of a pattern of zeros
andones. If any of the bits in the report is shown as a one,


			-=- 266 -=-

it means that the pystick has been moved in the direction
that relates to that bit. Here's a list of those bits, and what
each of them means:

Bit number      Meaning
~~~~~~~~~~~~~   ~~~~~~~~~~~~~~
0		Joystick has been moved Up
1		Joystick has been moved Down
2		Joystick has been moved Left
3		Joystick has been moved Right
4		Fire-button has been pressed


=FIRE
-----
If you just want to set up a test to see if the fire-button has
been pressed, use the Fire function followed by the
joystick port number. A value of -1 will be given only if
the fire button on the relevant joystick has been pressed.

  Do
    F=Fire(1)
    If F=-1 Then Centre "Bang!"  : Shoot
    Print
  Loop


The MOUSE
---------
Joysticks have become associated with playing computer
games, whereas the mouse is more often used in practical
programming, but they both do much the same thing.

The mouse cursor has been programmed to look like a
pointer arrow, but if you don't like its appearance you
are most welcome to change its shape. There are three
standard shapes to choose from, with index numbers
from 1 to 3, as follows:

			-=- 267 -=-



Number  Shape of cursor
~~~~~~~ ~~~~~~~~~~~~~~~~ 
  1     Arrow pointer
  2     Cross-hair
  3     Clock                       


CHANGE MOUSE
------------
To change the shape of the pointer arrow, use this
command followed by the number of the shape you
want, for example:                  

   Do
    For N=1 To 3
      Change Mouse N
      Wait 50
    Next N
   Loop

There is no need to restrict your choice to these three
shapes. If you select an image number greater than
three, Easy AMOS will look at whatever Bobs are sitting
in their bank, and use one of them. The first image in the
bank can be called up by using Change Mouse 4, the
second by specifying number 5, and so on.

To use Bobs effectively, they must contain no more than
four colours, and they have to be exactly 16 pixels wide,
although any height is allowed.

HIDE
HIDE ON
-------
Use this to hide the mouse pointer completely, by making
it invisible. It is still working and sending back reports,
but you can't see it. Easy AMOS will automatically


			-=- 268 -=-


count the number of times you use the Hide command,
and use this number to SHOW the mouse pointer again
at your command. If you prefer to keep the mouse
pointer invisible all the time, you can use a special
version of the Hide command that is always On, like
this:

  Hide on


SHOW
SHOW ON
----------
This makes the mouse pointer visible again. The system
counts the number of times the Hide command has been
used, and shows the pointer on screen again, when the
number of Shows equals the number of Hides. To
bypass the counting system, and reveal the mouse pointer
immediately, use Show On.

   Hide
   Wait 100
   Show

Whether the mouse pointer is visible or not, the computer
has to know two things in order to make any use of the
mouse. It must know where the mouse pointer is at any
time, and if any of the mouse buttons have been pressed.

=X MOUSE
=Y MOUSE

This pair of functions report the current location of the x
or y-coordinate of the mouse pointer. Because movement
is controlled by the mouse rather than by software,
coordinates are given in what is known as "hardwareR
notation. So, if you need to know the x-coordinate of the
mouse, for example, use X Mouse like this:

 Print X Mouse


			-=- 269 -=-


You can also use these functions to set a new coordinate
position for the mouse pointer, simply by giving X
Mouse or Y Mouse a coordinate value. For example, if
you want to change the existing y-coordinate, use
something like this:

 Y Mouse=150

 Print Y Mouse


=MOUSE KEY
-----------
The Mouse Key function reads the status of the mouse
buttons, and reports back with a binary pattern made up
of these elements:

  Pattern  Report
  -------- -----------------------
  Bit 0    Left button
  Bit 1    Right button
  Bit 2    Third button, if it exists

As usual, the numbers zero and one make up the report,
and the bit will report back by displaying a one if the
relevant button has been pressed, otherwise it will display
a zero. Try this routine:

   Curs Off

    Do

      Locate 0,0

      M=Mouse Key

      Print "Bit Pattern ";Bin$(m,8); "Number ",M

   Loop

Supposing you want to set up a control panel on your
screen, and don't want the mouse pointer to go
wandering outside the area of that panel.


			-=- 270 -=-

LIMIT MOUSE
-----------
This sets up a rectangle for the mouse pointer to move
around, and traps it inside the area set by hardware
coordinates, from the rectangle's top left To bottom
right-hand corner. For example:

 Limit Mouse 5,5 To 205,105

If you need to give the mouse pointer freedom to move
around the entire screen, use the Limit Mouse command
on its own without any coordinates, like this:

 Limit Mouse


PRINTERS
--------
Printing text and graphics on screen and looking through
your programs during editing is easily done, but if you
are lucky enough to use a printer it's just as simple to
print out listings on paper.


LPRINT
------
This is used in exactly the same way as the Print
command, but it sends a list of variables to a printer
instead of the screen. If you have a printer connected, try
this:

 Lprint "Print me on paper"

To print out program listings, first go into the Blocks
Menu. Now make a block of the program or of any part
of it that you want to print out, by clicking on the [Block
Start] and [Block End] icons. Then all you have to do is
click on the [Block Print] option.

To print all of an edited file, use [Ctrl]+[A] to make a
block of the whole file, and then [Block Print].

			-=- 271 -=-

DISC DRIVES
-----------
Easy AMOS contains a whole host of features for creating,
sorting and using the Amiga's electronic filing system,
including the Amazing Easy AMOS Disc Editor. As you
know, the Amiga normally has one built-in drive that
uses 3.5-inch floppy discs, and additional disc drives
can be connected to the machine using the correct sockets.

Each disc drive used by your computer is referred to by
a simple three letter code, followed by the colon character.
The internal floppy disc drive is identified like this:

Df0:

If you use additional floppy drives, they will be called
Df1:, then Df2: and so on.

Hard disc drives are identified by a similar code, with
the fist hard drive carrying a zero, the second a one, and
so on.

Dh0:

The Amiga is quite happy to refer to an individual disc
by name instead of looking for a disc drive code, as long
as the disc name carries the colon character, like this:

EASY AMOS:


The titles of discs are known as "volume" names, which
has nothing to do with sound levels, but is the equivalent
of the title of a written volume in a library. Whenever a
new blank disc is prepared, it is automatically given the
name "Empty", waiting for you to rename it with a
suitable title. It is not good practice to give several discs
the same name, as both the Amiga and its operator can
get confused by sloppy naming.

			-=- 272 -=-


FILES
-----
As explained, you can think of a disc as a "volume" in a
library. That volume can contain one or more "folders"
of information, and each folder can hold all sorts of
"files".

You should be familiar with sequential files and random
access files, which were dealt with in the last Chapter.
This section explains all the ways to manage your files
on disc from inside your programs, and then the last part
of this chapter will explain the Amazing Easy AMOS
Disc Editor.

Lising Files
------------
Before any file can be accessed and used, it has to be
found in the file directory of its disc. Easy AMOS offers
some simple short cuts used to search the contents of a
disc and report back the findings.

DIR
---
This tells Easy AMOS to look through the directory of
the current disc and list all the files there. Try it now:

 Dir

DIR/W
-----
performs exactly the same task, but displays the list of
files in two columns across the screen. So by using this
double width you can show twice as many filenames on
screen at any one time.

 Dir/W


Paths
-----
There's no need for the Dir command to list every file on
the disc. Certain groups of files can be extracted by
telling Dir to search along particular "pathways".

			-=- 273 -=-


The broadest of these paths gives the name of a disc or
the drive to be examined. Always add a colon to the disc
name to prevent any confusion with the names of files,
ike this:

  Dir "FONTS:"

  Dir "Df0:"

The next selective category that can be defined is a single
folder of filenames to be listed. For Example:

  Dir"Songs/"

  Dir "Easy_Examples:Songs/"


The path for listing can be even further narrowed,
by setting up a set of conditions that must be
satisfied by each file to be printed. Each character
in the filename must match the characters in your
request exactly. Or if you want to make a more
general search, you can use the asterisk character
"*" to stand for the instruction "please match this up
with any list of characters in the filenames up to the
next control character." So that a file named "Music"
will be searched for if you command this:

  Dir "Music"

But the use of an asterisk would have a different
effect, for example:

  Rem List all files starting with M

  Dir "M*"

That could give the following directory listing:

  Music

  Mel
 
  Malapropisms

			-=- 274 -=-



Similarly, the full-stop character "." matches a
filename extension, and is often used with the
asterisk character to list all the files in a directory
with a particular extension, like this:

   Dir "Music.*"
   Dir "*.Mel"
   Dir "*.*"

Finally, you can use the question-mark character
"?" to match up with any single character in a
filename. For example:

   Dir"EUROP???~"


That would list the following filenames if they
were in the current directory:

   EUROPRESS

   EUROPEANS

But it would ignore these filenames, either because
the first five characters did not match, or the name
was longer than nine characters:

   EUROPRESSES

   EURIPIDES

   EUROPA1 9 92


Any of these listing processes can be stopped and
restarted by pressing the [Spacebar]. If any folders
appear in the listing, they will automatically be
marked with an asterisk, like this:


   * AMOS

			-=- 275 -=-


Because some filenames can be too long to fit neatly
on a display listing, especially if you are using the
Dir/W option, Easy AMOS offers a simple way of
setting the style of the directory commands.


SET DIR
-------
This command must be followed by a number
ranging from one to 100, which sets the number of
characters in each filename that will be displayed.
There is no effect at all on the names themselves,
only the way in which they are displayed. For
example:

    Set Dir 6

    Dir

You can add a string to a Set Dir command, which
has the effect of filtering out pathnames from the
directory search. All filenames that match up with
this filter will be completely ignored. Supposing
your directory began like this:

  AMO.IFF

  AMAS

  AMAT.IFF

  AMINIBUS

  AMINOACID

  AMENSROOM.IFF

  AMULET


If this Set Dir command was used, it would have
the following effect:

			-=- 276 -=-


  Set Dir 3,"*.IFF"

  AMA

  AMI

  AMI

  AMU


Checking for Files
------------------
Some programmers have tidy minds and tidy desks.
They probably keep up-to-date labels on all of their
disks, and know exactly when they updated a file
and where they put it. On the other hand, they
could be normal. Anyone can lose track of
information, and Easy AMOS is ready and able to
help your memory. There are three different ways
to check and see if a file exists.


=EXIST
------
This looks through the current directory of
filenames and checks it against whatever filename
you are seeking. If the names match up, then the
file exists and a report of -1 will be given for ~trueU.
If the file does not exists a zero will be reported,
meaning "false'.

As well as individual filenames, Exist will happily
check out all sorts of search requests, such as
checking to see if a disc drive is connected and
ready for operation or whether a particular disc is
available for use. It will also look for gibberish
without flinching. Here are some examples:

Print Exist(Df1) : Rem External drive

Print Exist(" don't feel very well")

Print Exist("MUSIC:") Rem Music disc

			-=- 277 -=-

Here is a practical example:

  If Exist("AMOS_Disc.AMOS") Then Edit


=DIR FIRST$
-----------
This function provides a string containing the name
and the length of the first file on the current disc
that matches up with your chosen search path. For
example, the next routine would tell you the name
of the first file or folder in the directory, followed
by the name of the first IFF file in the directory.
Obviously this could be the same file.

  Print Dir First$(*.*)

  Print Dir First$(*.IFF)

Every time you use Dir First$, the whole directory
listing gets loaded into memory, so you can go on
to discover the name of the next file in the current
directory with the following function.


= DIR NEXT$
-----------
Will return the name that comes after the file or
folder found by the previous Dir First$ search. If
there are no more files to come, a string containing
nothing will be given, so you would see this "".
Once the last filename has been found, Easy AMOS
will automatically grab back the memory that has
been used by these routines, and release it for the
rest of your program to use. This example will
print every file in the current directory:

F$=Dir First$(*.*)

While F$<>""

   Print F$ : Wait 50

   F$=Dir Next$

Wend

			-=- 278 -=-

			
Selecting a file
----------------
=FSEL$

This is the file selection function that lets you
choose the files you want straight from disc, using
the normal Easy AMOS file selector. In its simplest
form, it can work like this:

  FS=Fsel$(*.IFF)

The string given in brackets is a "path" which sets a
searching pattern, in this case any IFF file. You
may also include the following options when using
Fsel$:

      F$=Fsel$(path$,default$,titlel$,title2$)

The default string is used to choose a filename
which will be automatically selected if you press
[Return] and abort the process.

Titlel$ and Title2$ are optional text strings that set
up a title to be displayed at the top of your file
selector. For Example:


  F$=Fsel$("Easy_Examples:Bobs/*.*","","Bobs")

  Rem Return to editor if no file selected

  If F$=""  Then Edit

  Rem Load file and display first Bob

  Load F$,0

  Bob 1,100,100,1 : Get Bob Palette : Wait Vbl


Naming files
------------
To create a new folder that can be used to hold a file
of computer data, a suitable disc should be ready in
the appropriate drive.

			-=- 279 -=-

MKDIR
-----
This makes a new folder on the current disc, and
gives it the filename of your choice. For example:

  Mkdir Df0:DIETCHART


RENAME
------
This command is used to change the name of a file
from an old name To a new name. If your choice of
new filename already exists, Easy AMOS will
remind you with a "file already exists" error
message. Rename a file like this:


     Rename "Oldnamestring" To "Newnamestring"


KILL
----
Be careful with this one. It obliterates the named
file from the current disc, once and for all. The file
that is erased with this command cannot be brought
back.

Kill "Filenamestring"


Running programs from disk
--------------------------
RUN

Aswell as the [Run] or [F1] facility for executing your programs
from the Edit Screen, you can type in the Run command from
Direct Mode.

When followed by a file name and used in your program
listings, this command is incredibly useful. Supposing you
have written a huge computer game that uses all different
levels of play, talking up the whole of one disc and using much
more memory than is available in your Amiga. Each level of
play can be written as a separate program, and then saved as a
different file name, then at the end of one level your next stage
of play can be automatically loaded from the disc, like this:

   Run "Nextlevel.AMOS"

			-=- 280 -=-


This method is known as "chaining" programs together. When
programs are run like this, data screens will be kept, allowing
you to display a screen of graphics while the next level is
loading but the last program will be erased to make room for
the next program so any variables will be lost.


COMMAND LINE$
-------------
In fact, Easy AMOS does allow you to pass data fit on one
program to another by making use of "Command Lines", so that
hiscores, names and messages can be carried through to the
next level of a computer game. Following are two example
programs. Type in Program 1 and then save it on your
"My Programs" disc, giving it the following name:

  Programl.AMDS

  Screen Open 0,640,200,4,Hires

  Rem Greetings sent by previous program

  Print "Greetings from2:" ;CommandLine$

  Input "greetings!";A$

  Command Line$=A$

  Print "Running program 2!"

  Wait 100
  
  Run My Programs:Program2.AMOS

When you have saved that, change your program as
follows:

			-=- 281 -=-


   Rem Program 2

   Screen Open 0,640,200,4,Lowres

   Rem Greetings sent by previous program

   Print "Greetings from1":;CommandLineS

   Input "greetings!";A$

   Command Line$=A$

   Print "Running program 1!"

   Wait 100

   Run My Programs:Programl.AMOS


Save Program 2, and call it:

  Program2.AMOS


Now run Program 2, which is still in memory. After the
first blank greeting, the two programs will greet each
other until you break with [Ctrl]+[C].


If you've used the File Selector, and Bob Editor and
Sample Bank Maker, you already know that Easy AMOS
has packed an incredible amount of useful material onto
its Programs Disc. There's more! What if all your disc
editing needs could be catered for by calling up another
Easy AMOS edit screen? Here it comes.


The last part of this chapter is a guided tour of the
Amazing Easy AMOS Disc Editor. Call up the System
Menu from the Edit Screen now, by pressing the right
mouse button, or holding down a [Shift] key, and select
[Easy Disc], or press [Shift] and [F8] together.


			-=- 282 -=-


THE AMAZING EASY AMOS DISC EDITOR!
----------------------------------
You'll probably be able to use the Disc Editor without
much help from another guided tour, but read through
this as you go along to get the most out of all the features.

The Amazing Easy AMOS Disc Editor is a superfast way
of organising all the files on your discs. If you've
upgraded to an extra disc drive it is incredibly useful,
but single-drive users will find it a superb tool as well.
The main concept that you have to understand is that all
the files on a SOURCE disc can be reorganised and
copied to a DESTINATION disc. 

			-=- 283 -=-


The screen has two main display zones, clearly headed
~Source" and "Destination", with all the Disc Editor control
buttons in a stack, between the the two zones. The zone
that is currently active has a red bar highlighting its path
name, and information about this active path is displayed
in a line at the bottom of the screen. Nothing will be
displayed here if the path name is not valid. As usual,
your mouse is used to control the buttons and sliders.

Click on either the [Source] or [Destination] headings to
select one of these zones, or simply click anywhere in
either of the large display zones which display a list of
any directories and files on your Source and Destination
discs.


Entering a path name
--------------------
To enter a path name, click on the appropriate name
panel, then type in your string of characters from the
keyboard. If an empty string is entered, the current
directory is used as the path name. To abort the process,
press [Esc].


The path names of your Source and Destination MUST
be different, and it is always good practice to give each
of your discs a different name to avoid confusion.


Next to the path name panels you can find up/down
buttons for displaying any lists of files that are too long
to fit into the Source or Destination windows. Below
these buttons are normal sliders, if you prefer to use
them. You can get a continuous scroll of file names
towards the mouse cursor, by using the RIGHT mouse
button.

			-=- 284 -=-


You've already come across a [PARENT] option in the
Easy AMOS File Selector, and each path has its own
parent button to allow rapid access back to a parent
folder after searching through its files. To get into a sub-
directory, all you have to do is make two clicks on the
folder name you want to open.

Another similarity to the File Selector is the way you
display the ~device" list, by clicking with the RIGHT
mouse button in the active path panel. The available
devices (equipment for communicating with your Amiga,
such as disc drives) will be listed at the top of the
window zone. One more click with the RIGHT mouse
button will make the device names disappear. To select
a device for use, simple click on its name.


Selecting Files
---------------
To select a file or a directory, place your mouse cursor
over its name and click. That's it. De-select by clicking
on another file or folder.

The vertical panel of control buttons is used to handle
files. here's how.

[ALL] is a short-cut button that selects all of the files
listed in the active path, ready for handling.

[CLEAR] performs the opposite task to [ALL]. It de-
selects all of the files in the active path.


There can be files on your disc that end with an ~ .inform tag
and the [Info] button acts as a switch to turn them on or
off in the zone window. You can still copy these files,
even if they're not on display, for example, if you are
copying entire discs.

			-=- 285 -=-


[Size] Files are displayed by name, followed by their length in
bytes. If you want to turn off the display of their lengths
because the file names are too long for example, the
[Size] button acts as a switch to turn them off and on.
Even if a file name is shortened in the display, names of
up to 64 characters long are still valid. Click on it now,
and then redisplay the file lengths with another click.


[Flip] The little [Flip] button docs a big job. It flips both
directories over, so that Source becomes Destination,
and the old Destination directory becomes the new
Source. Try it out now. Note that the active path stays
active after a flip.


[???] Pressing the information button [???] will display the
EASY Disc credits.

Copying files
-------------
Now let's get down to the business of using the Amazing
Easy AMOS Disc Editor for handling files. To copy one
or more files or directories, first go to the Source directory
and select one or more of the filenames you are interested
in. Don't forget, if the files you want to copy are
currently displayed in the Destination directory, use the
[Flip] button to swap it into your Source.

[Copy]

Now click on the [COPY] button. The Disc Editor will
tell you how many files and directories are to be copied,
and it will also calculate if there is enough space available
in the Destination directory. It does NOT take into
account any space that might be saved by files that you
want to overwrite. A Ram disc grabs memory when it
needs space, so you can ignore any reports on disc space
in this case.                       

			-=- 286 -=-


Pressing [Copy] again will kick off the copying process.
The Disc Editor will create any directories needed on the
Destination disc, then it loads up as many files as it can
from the Source disc into the computer's memory, before
saving them on the Destination disc.

If you are using more than one disc drive, the process is
incredibly easy. For those of you only using the internal
floppy disc drive "Df0:", your screen will tell you when
to swap over your discs.

The Disc Editor is not just concerned with copying files
from one disc to another. It can perform much simpler
tasks. Suppose you want to change the names of one or
more files. Select them with your mouse and then click
on the [RENAME] button. You will be asked to type in
and enter the new file names one by one through your
selected list. Press the [Esc] key to halt the process at any
time.

To erase one or more files from the disc, select their
names in the usual way and click on [DELETE]. A menu
will appear, showing the files and directories to be
deleted. You now have the following choices:

[DELETE] erases the next file only.

[SKIP] jumps over the next file, leaving it on your disc.

[DEL ALL] will get rid of all the selected files, so be
careful when using this very powerful option. You can
stop the deleting process with a click of the mouse
button.

[ABORT] halts the deleting process, and takes you back
to the Disc Editor screen.

This is a very simple way of making a new directory.
Click on [MAKE DIR] and then type in the name of the
new directory you wish to create.


			-=- 287 -=-


To find out the size of files and directories, select their
names and click on the [HOW BIG?] button. You will
now be told exactly how big the selected files and
directories are, in total bytes.

Examining files
---------------
This is a brilliant service, brought to you as part of the
Amazing Easy AMOS Disc Editor, and you must try it
out now. Select as many different files as you like, and
click on [EXAMINE]. Easy AMOS will now take a look
at each file in turn and see if it can recognise them.

It does this by loading a part of each program, and as
soon as it gets recognised you will be presented with
different options to either [DISPLAY], [HEAR], [READ]
or [PRINT] the file, depending on what type it is. This
will help you to examine the contents of your discs very
quickly, while you are reorganising your discs or just
browsing through them. Here's a list of the types of files
that will be recognised.

IFF pictures and Easy AMOS packed pictures:

When these sorts of pictures are recognised, you are
given the option to [DISPLAY] them. The displayed
picture will remain on the screen until you press a
mouse button.

Bob banks:

If you choose to [DISPLAY] a Bob bank on the screen, it
will appear in a reduced size on the screen to remind you
of all the images stored in the bank.

Ascii text files:

Two choices are offered here. You can either [READ] a
text that has been saved in this format, or [PRINT] out
the file.


			-=- 288 -=-

IFF samples, Easy AMOS music and sample banks,
Soundtracker modules:

If any of these are recognised, you will be asked if you
want to [HEARl them. IFF samples will be played at
their original frequency, but you can set a new frequency
if you wish. Music banks will be played exactly as they
were saved. When you IHEAR] a sample bank, the
samples will be played one after the other, although you
can select any individual sample and change its playing
speed. Soundtracker modules will be recognised as well
as most raw samples.

There are no options provided for the following sorts of
files:

IFF music, Amiga Dos executable programs, AMOS banks
or programs.


Formatting Disks
-----------------
Obviously, Easy AMOS has been designed to cater for
all your programming needs without ever having to
leave the system and go wandering off to less friendly
regions like the Workbench. All the wayback at the Easy
AMOS installation process, you were asked if you wanted
to format a blank disc, and now you are given the
opportunity to format discs any time you like. When
[FORMAT] is selected, you will prepare your new disc
in this logical order:

[NAMEl: click on this, and then set the name of your new
disc.

[DFx]: choose the name of the drive you want to use for
formatting the disc. For example, if you are using the
internal floppy drive, select "Df0".

[VERIFY ON] or [VERIFY OFF]. To make sure that your
new disc has been formatted perfectly, it will be "verified "
after formatting. You can switch this process off if you
like, and disc formatting will be twice as fast.

                             -=- 289 -=-


[FORMAT]: now everything is set up, simply click on
this option to format your disc. You can [ABORT] the
process at any time.

A disc that can be loaded and run as soon as it is popped
into a disc drive has to be "installed" first, otherwise you
will need a separate program to "boot" it up. You can do
this from the Amiga's CLI, but we want you to stay
inside the Easy AMOS system instead. That's why
advanced users have been provided with the
[BOOTABLE] option.


Copying disks
-------------
As well as providing you with the easiest possible disc
formatting, Easy AMOS allows you to make as many
copies as you like of entire discs, in much the same way.
After [DISC-COPY] is selected, these are the steps for
making exact copies of whole discs.

First select the name of the disc drive you want to use as
the SOURCE. Next, choose the DESTINATION drive
where the new copies will be made. Obviously if you've
only got the one internal drive at your disposal both of
these names will be the same!

Now choose the number of new copies you want to
make of the original Source disc. The Disc Editor will
ask for a new Destination disc after each copy has been
made, until all of your copies are done.

Select VERIFY ON or OFF, just like in the formatting
process. If the verification is ON, then the copying
process will be shown in blue on your screen and take
twice as long as with verification set to OFF.


			-=- 290 -=-



Finally, hit the [DlSC-COPY] button and follow the
screen prompts. You'll be pleased to learn that the
Amazing Easy AMOS Disc Editor crunches down the
disc "tracks" into the computer's memory, to try and save
you the time and trouble of swapping over discs more
than necessary.

When you have explored the Amazing Easy AMOS Disc
Editor, and you are ready to move on, all you have to do
is [QUIT]. But before you quit this Chapter, there's one
more feature that needs explaining. How to change
directories while editing your programs.


Changing Current Directory
--------------------------
=DIR$

Infact,this keyword is a function as well as an instruction.
Dir$ can hold the directory name that will be used as the
starting point for further disc operations, like this:

    Dir$= Df0:Sounds/

    Print Dir$

This makes life easier, allowing you to Set directories
from direct mode.

			-=- 291 -=-


			Chapter 17

			  MEMORY

COMPUTER MEMORY
---------------
Computers have brains like new-born puppies. They
come to life with a few instinctive habits and remember
nothing, because their memories are blank. But
computers learn much faster than puppies. Theirbrains
are highly organised and ready to receive instant chunks
of information that can be handled in any order you like.


ROM and RAM
-----------
Computer memory uses two types of brain cells. In the
first type, instinctive habits are inherited at the factory
and buried in special memory cells. You can read what's
in these cells but you can't change the contents, so they
are known as Read Only Memory, or ROM for short. The
second type of brain cells are empty and waiting to learn
something new. This is where you plant fresh program
ideas and gain access to them as you choose, which is
why it is called the Random Access Memory, or RAM for
short. This type of memory gets erased every time the
machine is switched off.


Memory Gobblers
----------------
The more you write Easy AMOS programs, the more
you'll appreciate that your talent is not restricted by
creativity, but by your computer's memory. Complex
Basic routines use a surprisingly small amount of
memory,butfull colourgraphicsscreensand hi-fi sound
samples gobble up great lumps of the stuff. When Easy
AMOS recognises a command, it only takes the equivalent
of two characters' storage space, and all functions are
stored as two characters in memory, but other needs are
not so economic. Luckily, Easy AMOS helps you to
make the best possible use of the memory provided for
other sorts of information.


			-=- 294 -=-


Addresses, bytes and bits
-------------------------
Puppies come equipped with memory storage units in
the form of brain cells, but it's difficult to gain access to
specific cells and use them for specific tasks such as
fetching sticks. Your Amiga has a more organised brain,
with each unit of memory living behind a numbered
door, called its 'address'.

Obviously, you need to know the correct door number
of the address to make contact with the data that lives
there. Address numbers start at zero, and go up to the
highest number in available memory. If no unit of data
has moved in to be stored there, the address remains
empty.

One unit of data living at an address in memory is
known as a 'byte'. Each byte can hold a number between
O and 255, which has nothing to do with the number of
its address, but gives the byte its own characteristics.
Every byte is made up of eight smaller units of memory
called 'bits', and a bit is the smallest speck of data that can
be represented in a computer's memory by a 1 or a 0.
Every computer leaves its puppy farm with a particular
size of brain, whose size is measured in "kilobytes", or k
for short. In actual fact,t, one k represents 1,024 bytes of
memory. So, for example, a machine that is said to have
512k on board is equipped with 524,288 bytes of memory
in its brain.


Available Memory
----------------
Every time you go into the Easy AMOS Edit Screen,
there are three numbers in the middle of the information
line concerning the memory available for use. The
whole line looks something like this:


I  L:1  C:1  Text:32766  Chip:383416  Fast:240264  Edit:

			-=- 295 -=-


TEXT shows how much memory has been assigned to
the Text Buffer, in other words, how many bytes have
been allowed for the editor window. You can change
this allowance by clicking on the SEARCH MENU in the
top right-hand corner of the edit screen, followed by SET
TEXT Buffer. Simply type in the new amount of memory
to be allocated.

CHIP tells you how much memory can be directly
accessed by the Amiga's special brain cells held in
custom silicon chips. There are ways to increase this
value, which will be explained a little later.

FAST displays how much memory your computer has
been given for special rapid access. Easy AMOS will
always try and use this FAST memory before examining
chip memory.



Memory Alerts
-------------
When using the Bob Editor, Easy AMOS displays helpful
messages in the menu screen information line if the
available memory is getting low. Everything remains
normal as long as there is 32k free. Between 24k and 32k,
a low-memory, three line, two colour file selector comes
into play. A constant alert message is displayed under
the editor from 12k to 24k. No drawing is allowed at all
if there is less than 12k of memory free, because Easy
AMOS does not want you to run out of memory!


Allocating memory
-----------------
One of the most frustrating things about training puppies
is their haphazard memory. Sometimes the Amiga can
be just as daft. It may display a message saying "Out of
memory", when it's plain to see from the information
line that there is plenty left. Just as the best way to train
your puppy is to begin the training session again, you
have to switch off your Amiga to unscramble its memory
before you can carry on. This is very annoying, so
always allocate enough memory before you begin to
program.

			-=- 296 -=-


Setting the size of the variable area
--------------------------------------
SET BUFFER

To reserve the maximum space for memory banks and
screens, Easy AMOS allocates a modest 8k for all your
variables. This can be increased to any level, depending
on how much memory your Amiga has on board. The
variable area must be set aside with Set Buffer as the very
first instruction in your program, followed by the number
of kilobytes you need. For example, if you want to
increase the variable area from 8K to 13k, make the first
line of your program:

  Set Buffer 13


=FREE
-----
To check how many bytes are left free to hold variables,
use the Free function:

 Print Free

Whenever FREE is called, Easy AMOS sets about cleaning
up the variable area to provide you with maximum
space. This is called "garbage collection", and is normally
done instantly. However, if the variable area is enormous,
garbage collection can take a few seconds, so don't use
FREE where it can interfere with the rapid execution of
your program.

=FAST FREE
----------
This function is called up to find out how many bytes in
the special Fast memory are still free to be used.

 Print Fast Free

=CHIP FREE

Gives the amount of free chip memory.

			-=- 297 -=-

=DFREE

Returns the total amount of free space left on your
current disc, also measured in bytes.

 Print Dfree

Saving memory
-------------
If you are lucky enough to have an extra 3.5-inch disc-
drive plugged in to your Amiga, you are unlucky enough
to be handing over about 30k of memory for its use.
Obviously this memory can be grabbed back by
deactivating the external drive before using your
computer. But be warned, turning off this drive while
the Amiga is switched on will have no affect on memory
whatsoever.


CLOSE EDITOR
-------------
You can save 28k of memory without affecting your
listings simply by closing the editor window while your
program is running. If there is not enough memory left
to reopen the window after you Close Editor, the current
display will be erased and the Default screen shown.
Simply hit the [Escape] key to get back to the Editor.

Memory Banks
------------
You have already been warned that graphics and sound
routines are memory gobblers. Their data has to be
stored along with the rest of your program, so Easy
AMOS has prepared 15 special chunks of memory for
their use. These are known as "memory banks".

Permanent and Temporary Banks
-----------------------------
There are two types of memory bank. Permanent banks
are defined once only, and are then always saved along
with your program. Temporary banks are freshly defined
every time you run a program. Here is a list of these
memory banks, numbered 1 to 15. The left-hand column
tells what sort of data can live there. The middle column
shows the number of the bank, and you can see that
certain items of data can only be held in banks 1 to 4 . The
right-hand column indicates if the memory bank is
Permanent (P) or Temporary (T).


			-=- 298 -=-


Data			Bank		State
~~~~~~~~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~
Bob definitions		Bank 1 only	P
AMOS music data		Bank 3 only	P
Sample data		Bank 5 default  P
Chip workspace          Banks 1 to 15   T
Chip Data workspace     Banks 1 to 15   P
Fast Memory workspace   Banks 1 to 15   T
Fast Memory Data wspace Banks 1 to 15   P
Tracker music data      Banks 1 to 15   P


You may remember learning how to allocate memory
for detecting movement using Reserve Zone in Chapter
9. In much the same way, a memory bank must be
reserved before it can be used. EasyAMOS automatically
allocates certain banks, but the Reserve As command
allows you to create any other memory banks you need.
Each of the following commands must be followed by
the number of the memory bank, a comma, then the
length you want in bytes.

RESERVE AS WORK banknumber, length

reserves the stated number of bytes for use as a temporary
workspace. Easy AMOS always tries to allocate Fast
memory for this job, so avoid bringing it into contact
with any instructions that need to access the Amiga's
blitter chip.

RESERVE AS DATA banknumber, length

reserves a permanent bank of memory of the required
length. This area of data will be allocated to Fast memory
where possible.


			-=- 299 -=-


RESERVE AS CHIP WORK banknumber,length

allocates a workspace of the number of bytes you need
using chip memory.

 
RESERVE AS CHIP DATA banknumber,length

reserves the length of bytes of memory required from
chip memory. The bank will be saved along with AMOS
programs automatically.


LIST BANK

Use this instruction to find out which memorybanks are
currently reserved, what type they are, the start of their
location and their length. The start and length are given
in a number code known as "hexadecimal", which is
explained later on, and your listing will look something
like this:


 Number Type       Start       Length
~~~~~~~ ~~~~~~~~~~ ~~~~~~~~~~  ~~~~~~~~~~~
1 -     Bobs       s:$040f60   l:$00002f
2 -     Work       S:$050F7A0  l:$014000


Erasing a bank
--------------
Some people say that you can't teach an old dog new
tricks, but there is no such problem when your puppy
programs begin to grow up. If you need to clear any
memory banks in order to load in new data, use this
command followed by the number of the bank to be
erased from 1 to 15, like so:

	Erase 9

			-=- 300 -=-


Saving memory banks
-------------------
Before clearing out memory banks and loading in new
data, you will want to store your old data and keep it
safe, so try saving memory banks onto disc. To show
that this sort of file contains a memorybank, always stick
"ask" on the end of the file name, which is short for Easy
AMOS memory BanK:

  Save "filename.abk"

This will take all of the currently defined memory banks
and save them to one file on your disc. If you want to
save one particular memory bank, simply add its bank
number after a comma, like this:

  Save "filename.abk",n


LOAD

Now you need to learn how to load up new memory
banks, and as you would expect, AMOS makes it easy.

  Load filename.abk

will erase all current memory banks and replace them
with all of the banks held in the named file. If there is
only one bank held in the named file, then thatbank will
be replaced and the others left alone. To insert new data
into a particular memory bank, add the number of the
bank that is your new target destination, like this:

  Load "filename.abk",n

If you leave out the number of a target memory bank, the
replacement data will be automatically loaded into the
bank from where it originated. Bob banks are treated
differently. If the bank number n is zero, or left out
altogether, the new sprite data will overwrite all of the
old sprite data. If any of the bank numbers from 1 to 15
is used, the old data will be kept and the new data will
be added to it. In this way, several sprite files can be
combined.

			-=- 301 -=-


Finding Bank Parameters
-----------------------
to data held in memory banks, and Easy AMOS is
willing to help out.

=START

reveals the address in memory where the bank starts.
For example:

	Reserve As Work 3,2000

        Print Strt(3)

        List Bank

=LENGTH

returns the length of a specified memory bank, in bytes:

 Print Length(3)

If a result of zero is returned, then the bank does not
exist. If it contains sprites, then the number of sprites
will be returned instead of its length.


Machine Code
------------
Huge amounts of memory can be saved and programs
can be speeded up if Basic keywords and routines are
bypassed, and direct communication established with a
computer's brain. The set of instructions used by
microprocessor chips is called 'Machine Code', and
programs can be written for these chips in 'assembly
language'. This type of program has to be coded into a
sequence of bytes using an 'assembler', and there are
loads of ready-made software packages on the market.
If you want to code them yourself, there are several
excellent books that will teach you how, and this isn't
one of them! But Easy AMOS is quite prepared to cater
for your needs if ever you become a Machine Code
expert.

			-=- 302 -=-


You can safely ignore the rest of this chapter until the 
time ever comes when your puppies grow into wise old 
dogs.

Converting Numbers
------------------
Easy AMOS can convert familiar numbers into two
other forms that are recognised ky more advanced
computer programs. Because human beings have got
hands with ten digits, we have developed a system of
counting using ten as the base. But computers sometimes
use a system with a base of 16 using letters as well as
numbers, and this is known as "hexadecimal" notation.
Alternatively, there is a system that uses a base of only
2 (either O or 1), called "binary" notation.

=HEX$

converts an integer into hexadecimal. You can specify
the number of characters to be returned by following the
integer with that number. Here are some examples:

  Print Hex$(65536)

  Print Hex$(65536,8)

  Print Hex$(Colour(1),3)

=BIN$

converts a number into a binary string. You can choose
whether to output all the digits of the number or only a
few, from 1 up to 32 digits. Binary numbers are given the
% character as a prefix. Try these:

  Print Bin$(255)

  Print Bin$(255,16)


			-=- 303 -=-


Saving binary memory blocks
---------------------------
BSAVE

saves an unformatted block of memory in binary format.
It is used like this:

Bsave "filename" ,Start(15)+Length(15)

so that the memory stored between Start and the end of
Length is saved to "filename", in this case the data in
memory bank 15. Bsave must not be used for sprite or
icon banks, because their data is not stored as a single
block of memory.

BLOAD

loads a file of binary data off disc without affecting the
data in any way. It can load data to any given address,
or to any numbered memory bank, provided that the
memory bank has been reserved and contains enough
memory.

Bload file$, address
Bload file$, bank


Peeking and Poking
------------------
The process of discovering which byte is living at a
particular address is called taking a "peek", and always
gives a result from 0 to 255. Similarly, changing the
value of a byte at a specific address is known as having
a "poke". This is a rapid but often dangerous way of
manipulating memory.

=PEEK

returns the byte stored at a given address:

	Print Peek (address)

POKE
----
shoves a number between 0 and 255 into the specified
address:

   Poke address, number


			-=- 304 -=-

Deep peeking
and long
poking
------------

=DEEK
reads a two-byte word living at an EVEN address number
only.

  Print Deek (even numbered address)


DOKE
loads a two-byte number between O and 65535 into the
memory location at a given address.

  Doke address, number

=LEEK
works in the same way as DEEK, but returns a four-byte
word.

  Print Leek (even numbered address)

LOKE
copies a four-byte number to a specified address.

Loke address, number.

Needless to say, inexperienced programmers should
take great care when poking, doking and loking.


Finding the address of a variable
---------------------------------

=VARPTR

will return the address of the three types of Basic variable.
String variables: the address points to the first character
of the string.

Integers: the address of the four bytes containing the
variable IS given.

Floating point numbers: the address of the four byte
"Fast Floating Point Format" is given.

			-=- 305 -=-


USING MACHINE CODE
------------------
We think that Easy AMOS is so powerful, you will not
need to complicate things by using assembly language.
The commands are hazardous to use and should be
avoided. But if you insist on being reckless, the final
section of this chapter has been provided. To combine
assembly language routines with your AMOS programs,
you are welcome to wade through what may seem like
gibberish. You have been duly warned!

PLOAD

is used to reserve a specified memory bank and load it
with a machine code program:

          PLOAD "machine code filename", bank

The code can contain almost anything, provided that it
is completely relocatable and ended by a single RTS
instruction.


CALL

calls up and then executes machine code from an address
or a memory bank.

  Call address,parameters

  Call bank,parameters

The address can be a specific location or the number of
a memory bank already created with Pload . Get back to
Easy AMOS Basic using an RTS instruction.

'Parameters' refers to those parameters which will be
pushed into the stack, and because they will be pulled
out in reverse order remember that the last parameter
you enter will be the first one on the stack!


			-=- 306 -=-


Talking to registers
--------------------
AREG

is an array of three pretend variables used to pass on
information to the computer's address registers.
Whenever Call is used, the contents of this array is
loaded into address registers AO to A2. When the
function is over, they are saved back along with any new
information that has been placed in these registers.
Registers r can ran~e from O to 6, as in:

 a =AREG(r)

 AREG(r)=a

DREG

is an array of eight integers that holds a copy of the data
registers, wi th r referring to the register number ranging
from O to 7 (D1 to D7 respectively.) It can be taken for
walkies like this:

 d=DREG ( r)

 DREG (r) =d


			-=- 307 -=-


			Chapter 18
		
		     DEBUGGING ERRORS


BUGS
----
Some people call them glitches, or gremlins, but most of
us call programming mistakes 'bugs'. These little devils
are the software errors that are responsible for messing
up our programs. They may be a simple keystroke that
has been typed in by mistake, or a command that we
forgot to include, or some crazy task that the computer
cannot cope with. It is up to us to identify exactly where
they are lurking and what they are doing before we can
obliterate them. This is known as 'debugging': the
process by which we trap errors in our programs.


Spotting Mistakes
-----------------
Whenever a mistake is made in Easy AMOS
programming, or when you ask your Amiga to do the
impossible, Easy AMOS does its very best to offer first
aid, automatically. Easy AMOS not only helps you to
spot the error but also tries to explain what it is, where
it is, what problems are being caused and how to find the
solution. Special messages appear on your screen to
point out what is going wrong and where the error is, in
the form of an error message followed by the line number
where the error lives. If this happens while you are
programming, you can try to cure the bug immediately.
If it happens while you are testing or running your
program, Easy AMOS will take you straight to the
offending line as soon as you edit.

HELP
----
In the next Chapter you can learn all about the Easy
AMOS TUTOR program, which has been carefully
designed to help Easy AMOS programming. You can
also ask for [Help] while editing your programs, as
explained way back in Chapter 3. When you ask for
[Help], Easy AMOS will tell you about the current
instruction in an information window on your screen. If
you prefer, you can read exactly the same information
by looking up any Easy AMOS instruction in Chapter 20:
the Glossary.


			-=- 310 -=-

TRAPPING ERRORS
---------------
ON ERROR

You can lay plans for handling program errors by telling
Easy AMOS that if a mistake crops up then it should go
to a special error-handling routine and trap the bug.
Error trapping swings into action with the ON ERROR
command, and is called up like this:

  ON ERROR GOTO label

Whenever a bug occurs in your Basic program, Easy
AMOS will jump straight to whatever label you have
defined, and this will act as the starting point for your
own error correction routine. You can then fix the bug
and return safe and sound to yourmain program. In this
way, mistakes can be repaired without the bother of
returning to the editor window. You must use RESUME
to get back to your program, and this is explained a little
later. Take a look at this simple routine:

  Do
   Input "Type in two numbers ";A,B
   Print A;" divided by ";B;" is ";A/B
  Loop


This will work perfectly until you try to enter a value of
zero for B, and Easy AMOS discovers that it is impossible
to divide A by zero. Similar problems can be catered for
in advance by setting an error trap, like that on the
following page:

			-=- 311 -=-


On Error Goto HELP

AGAIN:

Do

 Input "Type in two numbers"; A, B

 Print A;" divided by ";B;"  is  ";A/B

Loop

Rem Error Handler

HELP:

Print

Print  "I'm afraid you are trying to"

Print "divide your number by zero."

Resume AGAIN: Rem Go back to input

If you are ever unfortunate enough to write an error
inside your own error trapping routine, Easy AMOS
will grind to a halt in revenge! There are two ways to
deliberately disable ON ERROR GOTO. Either use ON
ERROR GOTO 0 or call it without any parameters, like
this:

  On Error:Rem disable error trap

RESUME
------
Never use GOTO to get back to your Basic program after
an error handler, the correct method is the use of
RESUME. On its own, RESUME will jump back to the
statement which caused theerror and try it again. If you
specify a line number after RESUME, as in the above
example, RESUME will jump back to that line.

			-=- 312 -=-


ON ERROR PROC

You can also trap an error using a procedure. ON
ERROR PROC selects a named procedure which is
automatically called if there's an error in the main
program. In fact, it is a structured version of the ON
ERROR GOTO command.
Your procedure must be terminated by an END PROC in
the usual way, and then you'll need to return to the main
program with an additional call to RESUME, which can
be placed just before the final END PROC statement.
Here is an example:

On Error Proc HELP

Do

 Input "Type in two number";A,B

 Print A;"  divided by ";B;"  is  ";A/B

Loop

Rem Error Handler

Procedure HELP

 Print

 Print "I'm afraid you are trying to"

 Print "divide your number by zero."

 Resume Next: Rem Go back to input

End Proc


			-=- 313 -=-



=ERRN

If you use ON ERROR to create your own error handling
routines, you will want to know exactly what sort of
error has happened in the main program. Errors
discovered while your program is running each have
their own ERRor Number, and the number of the last
error to be spotted will be returned with the use of the
ERRN function in your routine:

  n=ERRN

All these errors and their numbers are listed below.


ERROR MESSAGES
--------------
Easy AMOS uses three sets of error messages to help you
correct your programming mistakes. Editing messages
may appear while you are in the middle of programming.
Program messages can crop up when you test your
work. Run time messages come complete with their
own number code, and they pinpoint errors while your
program is up and running. Here is a list of all the error
messages that Easy AMOS may try and help you with,
as soon as a programming mistake is picked up.


			-=- 314 -=-


EDITING ERROR MESSAGES
----------------------
While you are editing programs, the following messages may appear on the
information line of your screen to help you.

Bottom of text:
The text cursor has come to the last line of the current program.

Can't fit program into editor buffer:
There is not enough space in memory to load the current program. When Easy
AMOS asks you for a response, select NO to abort the load and the 
information line will display the minimum buffer space that is needed, 
or YES will set the text buffer to the exact size of the program you are 
trying to load . Alternatively, use S.BUFFER in the SEARCH menu to expand 
the text buffer.

Line too long:
The maximum number of characters in a line is 255.

No errors:
Plain and simple: no errors have been detected in the current program during
the testing process.

Not found:
The last search command has failed to find what it was seeking.

Not marked:
You are trying to move to a marker, but have failed to set it in advance.

Not a procedure:
You are trying to use FOLD/UNFOLD, but the text cursor is not positioned
over a procedure.

Out of buffer space:
There is no space left in the editor area. SAVE your program 
first, and then use S.BUFFER in the SEARCH menu to expand the buffer. 
Overlong programs can also be split into segments and then RUN one 
after the other.

Out of memory:
Your current program has used up all available memory. Using CLOSE
WORKBENCH can restore 40k, and saving memory is fully discussed in
Chapter 17.

			-=- 315 -=-


Syntax error:
The current line of your program is wrongly written. You must use 
the correct "grammar" or syntax as explained in this book.

Too many direct mode variables:
Normally, you can create up to 64 new variables in direct mode. If your
program is using too much memory, space in the variable table will be more
restricted.

Top of text:
The text cursor has come to the first line of your current program.

Variable name buffer too small:
You have christened your variables with too many long names.

What block?:
You must define a block before you can CUT or PASTE it.

PROGRAM ERRORS

Easy AMOS wants to help you to get rid of as many errors as possible 
while editing, otherwise you would have to wait until your program 
was executed before any errors became obvious. Here is a list of 
messages that can spot errors when you [TEST] your program from the 
MENU window. They may also appear when the program is [RUN].

Array already dimensioned:
You are trying to dimension an array that has already been dimensioned.

Array not dimensioned:
You must give an array a dimension before you can specify it.

Bad structure:
You have left part of a loop outside of its nest. Any nested loops must be
carried completely inside their parent loop.

Can't open narrator:
Easy AMOS cannot find the required library file from the program or 
hard disc in order to load up the narrator program.

			-=- 316 -=-


DATA must start at the beginning of a line:
You must put a DATA statement at the very beginning of a line. The only
exception to this rule is when you define a LABEL.

DO without LOOP:
You have forgotten to end your DO structure with its LOOP command.

ELSE without ENDIF:
You have forgotten to end an IF test with its ENDIF command.

ELSE without TF:
You can only use an ELSE statement inside an IF test.

ENDIF without IF:
You have used an ENDIF command but there is no IF statement for it to refer
to.

FOR without matching NEXT:
You are trying to use a FOR command, but there is no NEXT statement to
follow it.

IF without ENDIF:
When you are setting up a structured IF test, you must end it with a single
ENDIF statement. This sort of IF test is completely different from an 
IF/THEN command.

Illegal number of parameters:
You are trying to enter the wrong number of values into an instruction or a
procedure.

LOOP without DO:
You have written a LOOP command, but there is no DO statement at its start
to trigger it off.

Label defined twice:
Labels and procedures can only be defined once in each program.

			-=- 317 -=-

Music bank not defined:
The music number you are seeking is not in the current music bank.

Music bank not found:
There is no musical bank.

NEXT without FOR:
You have forgotten to precede a NEXT instruction with its FOR command.

No THEN in a structured test:
You cannot use IF/THEN inside a structured test, but you can use IF/ENDIF.

No jumps allowed in the middle of a loop!:
You can only jump out from a loop once you are inside of it. You 
cannot jump into a loop using a GOTO or GOSUB statement.

Not a packed bitmap:
You are trying to UNPACK a databank that is not in bitmap format.

Not a packed screen:
You are trying to UNPACK data that is not in packed screen format.

Not enough loops to exit:
You have specified a larger count of loops than the number of active loops
available in your EXIT or EXIT IF command.

Out of memory:
There is not enough memory available to create the variable name buffer.
Shorten the names or get some more memory.

Procedure's limits must be alone on a line:
All PROCEDURE and END PROC statements must begin on their own line.

Procedure not closed:
You have forgotten to end one of your procedures with an END PROC
statement.

Procedure not opened:
There is an END PROC statement in your program, but its PROCEDURE has
not been defined above.

			-=- 318 -=-

REPEAT without matching UNTIL:
There is a REPEAT instruction in your program, but there is no UNTIL
statement to go with it.

Sample not defined:
You are trying to play an audio sample that does not exist in the current
sample bank.

Syntax error:
The current line of your program is wrongly written. You must use the 
correct "grammar" or syntax as explained in this book.

This array is not defined in the main program:
You are trying to access an array inside a procedure, but you have 
forgotten to dimension it in the main program.

UNTIL without REPEAT:
You have programmed an UNTIL command that does not refer to a previous
REPEAT statement.

Undefined label:
Your program is trying to find a label that you have forgotten to 
specify.

Undefined procedure:
You are trying to call up a procedure that does not exist

Variable buffer can't be changed in the middle of a program!:
Apart from a REM statement, the SET BUFFER command must always be used
as the very first line of your program.

Variable buffer too small:
While Easy AMOS is testing your program, it is possible that the area 
reserved for variables can overflow. If there is enough memory available
, use SET BUFFER to expand this area.

WEND without WHILE:
There is no WHILE command to go with your WEND statement.

WHILE without matching WEND:
There is no matching WEND statement to go with your WHILE command

			-=- 319 -=-


RUN TIME ERRORS

If Easy AMOS trips over a mistake while your program is running, it 
will instantly grind to a halt and the offending instruction will come 
under the spotlight with its own error message. As soon as you go back 
to editing your program, the cursor automatically leaps to the line where 
the error is lurking.
These run time errors each have a special code number which is 
displayed in brackets immediately after the error message, and these 
code numbers can be very useful if you are using error trapping. For 
example, you may want to find the error message that goes with a 
particular code number, by using a line such as:

  Error Errn

Address error (25):
You are trying to read an odd address in a DEEK or LEEK command, which
must always be even. Similarly, DOKE and LOKE cannot load these addresses.

Array already dimensioned (28):
You have tried to dimension the same array more than once.

Bad IFF format (30):
LOAD IFF can only load IFF screens into memory, and not general purpose IFF
files.

Bank already reserved (35):
You have tried to create a memory bank that already exists.

Bank not reserved (36):
You are trying to select a bank, but you have forgotten to RESERVE it. 
This error message can also result from certain commands trying to use 
data from a specific memory bank automatically, such as SAMPLAY.

Block not found (65):
You cannot specify a block without first creating it, using GET BLOCK.

Bob not defined (68):
You cannot manipulate or PASTE a bob without first setting it up with a BOB
command.

			-=- 320 -=-


Can't fit picture in current screen (32):
You have tried to use LOAD IFF to load a picture into an existing 
screen of a different type. Easy AMOS will automatically create a screen 
of the correct type if you specify a screen number in the correct range 
of 0 to 7. You should tag the number of the destination screen to the 
LOAD IFF command like this:

  Load IFF filename,number

Can't resume to a label (4):
You cannot use RESUME label inside an error procedure.

Device not available (86):
You have specified a disc or a drive but your Amiga does not believe 
that it exists, possibly because you have changed a disc unexpectedly. 
You can set the directory to the correct drive with an instruction 
such as:

  Dir$= DfO:

Directory not empty (85):
You can only erase EMPTY directories by using KILL.

Directory not found (80):
Easy AMOS cannot find the required directory on the current disc. List 
it and check its contents.

Disc full (88):
There is not enough space on your current disc to hold your data.

Disc not validated (83):
This is the Amiga talking directly to you, and you have probably 
twisted its knickers by inserting a perfectly valid disc that it cannot 
come to terms with.
Don't panic. Try again. If all else fails, try using DISC DOCTOR from the
standard Workbench disc, although we really hate the idea of you leaving
Easy AMOS.

Disc is write protected (84):
The disc's write protection tab is " on" . If you want to save your 
data on the current disc, remove it, slide the write protection tab to 
"off' and try again, or use another disc.

			-=- 321 -=-

Division by zero (20):
You are trying to divide a number by zero, and that is impossible.

End of file (100):
The end of the current file has been reached unexpectedly while the 
disc is being accessed . You should use the EOF function to test for 
this condition from inside your program.

End of program (10):
Easy AMOS has executed the last instruction in your program.

Error not resumed (3):
You have come out of an error-handling routine, but forgotten to reset the
error using RESUME.

Error procedure must RESUME to end (8):
You cannot exit from an error-handling procedure using END PROC, use the
RESUME command instead.

Out of stack space(0):
There are too many procedure calls nested inside one another. Although Easy
AMOS procedures can call themselves up, this error may occur after 
about 50 loops. The same can happen with the GOSUB command.

File already exists (79)
You cannot RENAME a file with the same name belonging to another file or
directory on your current disc.

File already opened (97)
You cannot OPEN or APPEND a file that is already open.

File format not recognised (95)
The LOAD command can onlybe used to load Easy AMOS files from disc. Use
BLOAD for files stored in standard Amiga format. Use LOAD IFF for Iff
screens.

File is protected against deletion (89)
There is an Amiga security command to stop accidental wiping of important
system files, this is the PROTECT command to be found on the CLI. You have
probably just tried to DELETE one of these protected files.


			-=- 322 -=- 


File is protected against reading (91)
You have requested a file that has been protected from your prying eyes. 
The PROTECT command is on the CLl, and is explained in the Amiga User's 
Guide that you ignored when you unpacked your computer.

File is write protected (90)
You are trying to change a file that has been locked with the PROTECT 
security command.

Fi1e not found (81)
You have tried to call up a file or a directory that does not exist 
within the current directory.

File not opened ( 97 )
You must use an instruction like OPEN IN, OPEN OUT or APPEND to open
access to a file before you can use it to transfer data.

File type mismatch ( 98 )
You have used a command that is not allowed with the current file. For
example, GET and PUT will not work with sequential files.

Flash declaration error (52)
There is a mistake in the animation string that defines a FLASH colour
sequence.

Fonts not examined (37)
You must first create a list of the available fonts using GET FONTS 
before you can use the SET FONT command.

I/O error (94)
The input/output error implies that there is a corrupted file that cannot be
accessed properly. Try again, checking any disc drive connections that may
be faulty. If necessary, you may have to resort to the DISC DOCTOR program
supplied on your original Workbench disc.

IFF compression not recognised (31)
You are trying to load a screen that has been compressed with an unfamiliar
system. You should try and re-save your original screen source in standard
IFF format.

			-=- 323 -=-


I11ega1 block parameters (66)
The values you have entered in a GET BLOCK or PUT BLOCK command are
not allowed.

11lega1 file name (82)
You are trying to use a non-standard file name.

Illegal function call (23)
You have made a mistake with the values in an Easy AMOS command. return
to the editor, and identify the likely command in your line of program.

Illega1 number of colours (49)
You are trying to use the wrong number of colours on screen at once. Check
your syntax if you have used SCREEN OPEN, or see Chapter 8 for the list of
colour options.

I11ega1 screen parameter (48)
You have specified dimensions using SCREEN OPEN that are not acceptable.
Your minimum screen size can be as small as 32x8, and the maximum is l000
pixels wide.

Input too long (99)
Either your input string is too long for a previously dimensioned 
variable, or you have tried to INPUT# a line of more than 1000 
characters.

Label1 not defined (40)
You have included a label in an instruction, but forgotten to define it. 
Check for mistakes in GOTO, GOSUB or RESTORE statements.

No ON ERROR PROC before this instruction (5)
You can only use RESUME LABEL after an ON ERROR PROC command.

No data after this label (41)
You cannot RESTORE the data pointer to a line with no DATA statements on
that line or subsequent lines.

No disc in drive ( 93)
Your Amiga does not believe that there is a disc in the drive you are 
trying to access. Try again.

			-=- 324 -=-


No zone defined (73)
You cannot use SET ZONE without first allocating enough memory with
RESERVE ZONE.

Non dimensioned array (27)
You are trying to refer to an array, but it has not yet been defined.

Not an AmigaDOS disc (92)
Easy AMOS can only read discs created on an Amiga. If you want to use 
discs that are of compatible size but originate from another sort 
of computer, you will first have to use specialised software to translate 
your data.

Out of data (33)
You may have omitted some information from one of your DATA lines,
because a READ command has gone past the last item of DATA in the current
program. Alternatively, there may be a typing error in a RESTORE command.

Out of memory (24)
Your Amiga thinks that it has run out of available memory storage space. If
your information line assures you that there is plenty of spare memory, 
simply save your program, re-boot and load it back in again. CLOSE 
EDITOR will save a further 40k by deactivating the editor window when 
you are not using it.

Out of variable space (11)
Normally, Easy AMOS allocates 8k of storage space for your strings and
arrays. To increase variable space, use the SET BUFFER command at the
beginning of your program.

Overflow (29)
The result of a calculation has exceeded the maximum size of a variable.

Program interrupted (9)
You have pressed the [Cntrl] and [C] keys at the same time, to exit 
directly from your program. This is an information message, not an error.

RETURN without GOSUB (1)
RETURN can only be used to exit from a subroutine that was originally
entered with a GOSUB.

			-=- 325 -=-


Rainbow not defined (75)
You must define your rainbow effect using SET RAINBOW before you can call
it up.

Resume label not defined (6)
The label you have specified in a RESUME command does not exist.

Resume without error (7)
The RESUME command cannot be executed unless an error has cropped up in
your program.

Screen already in double buffering (69)
You are trying to call DOUBLE BUFFER more than once on the same screen.

Screen not opened (47)
You must open a screen with the SCREEN command before you can access it.

String too long (21)
Easy AMOS allows a maximum of 65000 characters in any string.

Too many colours in flash (51)
There is a maximum allowance of 16 colour changes in a single FLASH
command.

Type mismatch (34)
You have assigned an illegal value to a variable.

Valid screen numbers range from O to 7 (50)
There is a maximum of eight screens that can be opened at any one time.

256 characters for a wave
Audio waves can only be created by a list of 256 bytes.

			-=- 326 -=-


