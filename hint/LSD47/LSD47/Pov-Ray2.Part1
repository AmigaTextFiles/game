 		Persistence of Vision Ray Tracer (POV-Ray)

				Version 2.0

				User's Documentation
			Copyright 1993 POV-Ray Team	
				
				Table of Contents
				Part 1
	
1.0 INTRODUCTION

2.0 ABOUT POV-Ray

	2.1 PROGRAM DESCRIPTION -- WHAT IS RAY TRACING?

	2.2 WHICH VERSION OF POV-Ray SHOULD YOU USE?

	2.2.1	IBM-PC AND COMPATIBLES
	2.2.2	APPLE MACINTOSH
	2.2.3	COMMODORE AMIGA
	2.2.4	UNIX AND OTHER SYSTEMS
	2.2.5	ALL VERSIONS

	2.3 WHERE TO FIND POV-Ray FILES

	2.3.1	GRAPHICS DEVELOPER'S FORUM ON COMPUSERVE
	2.3.2	PC GRAPHICS AREA ON AMERICA ON-LINE
	2.3.3	YOU CAN CALL ME RAY BBS IN CHICAGO
	2.3.4	THE GRAPHICS ALTERNATIVE BBS IN EL CERRITO, CA
	2.3.5	PI SQUARED BBS MARYLAND
	2.3.6	INTERNET

3.0 QUICK START

	3.1 INSTALLING POV-Ray

	3.2 USING SAMPLE SCENES

	3.3 COMMAND LINE PARAMETERS

	3.3.1	ANTI-ALIASING
	3.3.2	BUFFERING
	3.3.3	CONTINUING INTERRUPTED TRACE
	3.3.4	DISPLAY PREVIEW IMAGE
	3.3.5	RENDER PARTIAL IMAGE
	3.3.6	FILE OUTPUT TYPE
	3.3.7	HEIGHT AND WIDTH OF IMAGE
	3.3.8	INPUT AND OUTPUT FILE NAMES
	3.3.10  ANIMATION CLOCK VARIABLE
	3.3.11  LIBRARY SEARCH PATH
	3.3.12  BOUNDING SLABS CONTROL
	3.3.13  SYMBOL TABLE SIZE
	3.3.14  VERSION COMPATIBILITY MODE
	3.3.15  PAUSE WHEN FINISHED
	3.3.16  QUALITY SETTINGS
	3.3.17  VERBOSE STATISTICS
	3.3.18  ALLOW ABORTED RENDERING

	3.4 DEFAULT PARAMETER FILE AND ENVIRONMENT VARIABLE

4.0 BEGINNING TUTORIAL

	4.1 YOUR FIRST IMAGE

	4.1.1	THE POV-Ray COORDINATE SYSTEM
	4.1.2	ADDING STANDARD INCLUDE FILES
	4.1.3	PLACING THE CAMERA
	4.1.4	DESCRIBING AN OBJECT
	4.1.5	ADDING TEXTURE TO AN OBJECT
	4.1.6	DEFINING A LIGHT SOURCE

	4.2 MORE TEXTURE OPTIONS

	4.2.1	SURFACE FINISHES
	4.2.2	ADDING BUMPINESS
	4.2.3	CREATING COLOR PATTERNS
	4.2.4	PRE-DEFINED TEXTURES

	4.3 MORE SHAPES

	4.3.1	PLANE OBJECT
	4.3.2	BOX OBJECT
	4.3.3	CONE OBJECT
	4.3.4	CYLINDER OBJECT

5.0 SCENE DESCRIPTION LANGUAGE REFERENCE

	5.1 LANGUAGE BASICS

	5.1.1	IDENTIFIERS AND KEYWORDS
	5.1.2	COMMENTS
	5.1.3	INCLUDE FILES
	5.1.4	FLOAT EXPRESSIONS
	5.1.5	VECTOR EXPRESSIONS
	5.1.6	TRANSFORMATIONS
		5.1.6.1 Translate
		5.1.6.2 Scale
		5.1.6.3 Rotate
		5.1.6.4 Transforming Textures and Objects
		5.1.6.5 Transformation Order
	5.1.7	DECLARE

	5.2 OBJECTS

	5.2.1	SOLID FINITE PRIMITIVES
		5.2.1.1 Spheres
		5.2.1.2 Boxes
		5.2.1.3 Cylinders
		5.2.1.4 Cones
		5.2.1.5 Torus
		5.2.1.6 Blob
		5.2.1.7 Height Fields
	5.2.2	FINITE PATCH PRIMITIVES
		5.2.2.1 Triangle and Smooth_triangle 
		5.2.2.2 Bicubic_patch
		5.2.2.3 Disc
	5.2.3	INFINITE SOLID PRIMITIVES
		5.2.3.1 Plane 
		5.2.3.2 Quadric 
		5.2.3.3 Poly, Cubic and Quartic.  
	5.2.4	CONSTRUCTIVE SOLID GEOMETRY (CSG)
		5.2.4.1 About CSG
		5.2.4.2 Inside and outside
		5.2.4.3 Union  
		5.2.4.4 Intersection
		5.2.4.5 Difference
		5.2.4.6 Merge
	5.2.5	LIGHT SOURCES
		5.2.5.1 Point Lights
		5.2.5.2 Spotlights
		5.2.3.3 Area Lights
		5.2.3.4 Looks_like

	5.3 OBJECT MODIFIERS

	5.3.1	CLIPPED_BY
	5.3.1	BOUNDED_BY
	5.3.2	NO_SHADOW

	5.4 TEXTURES

	5.4.1	PIGMENT
		5.4.1.1 Color
		5.4.1.2 Color List Patterns -- checker and hexagon
		5.4.1.3 Color Mapped Patterns
			5.4.1.3.1	Gradient 
			5.4.1.3.2	Color Maps
			5.4.1.3.3	Marble
			5.4.1.3.4	Wood
			5.4.1.3.5	Onion
			5.4.1.3.6	Leopard 
			5.4.1.3.7	Granite 
			5.4.1.3.8	Bozo 
			5.4.1.3.9	Spotted 
			5.4.1.3.10  Agate 
			5.4.1.3.11  Mandel
			5.4.1.3.12  Radial
		5.4.1.4 Image Maps
			5.4.1.4.1	Specifying an image map.
			5.4.1.4.2	The "once" option.
			5.4.1.4.3	The "map_type" option.
			5.4.1.4.4	The "filter" options.
			5.4.1.4.5	The "interpolate" option.
		5.4.1.5 Pigment Modifiers
			5.4.1.5.1	Turbulence
			5.4.1.5.2	Octaves
			5.4.1.5.3	Omega
			5.4.1.5.4	Lambda
			5.4.1.5.5	Quick_color
			5.4.1.5.6	Frequency and Phase
			5.4.1.5.7	Transforming pigments
	5.4.2	NORMAL
		5.4.2.1 Bumps
		5.4.2.2 Dents
		5.4.2.3 Ripples
		5.4.2.4 Waves
		5.4.2.5 Wrinkles
		5.4.2.6 Bump_map
			5.4.2.6.1	Specifying a bump map.
			5.4.2.6.2	Bump_size
			5.4.2.6.3	Use_index & use_color
			5.4.2.6.4	The "once" option.
			5.4.2.6.5	The "map_type" option.
			5.4.2.6.6	The "interpolate" option.
		5.4.2.7 Normal Modifiers
			5.4.2.7.1	Turbulence
			5.4.2.7.2	Frequency and Phase
			5.4.2.7.3	Transforming normals
	5.4.3	FINISH
		5.4.3.1 Diffuse Reflection Items
			5.4.3.1.1	Diffuse
			5.4.3.1.2	Brilliance
			5.4.3.1.3	Crand Graininess
			5.4.3.1.4	Ambient
		5.4.3.2 Specular Reflection Items
		5.4.3.3 Highlights
			5.4.3.3.1	Phong Highlights
			5.4.3.3.2	Specular Highlight
			5.4.3.3.3	Metallic Highlight Modifier
		5.4.3.4 Refraction
	5.4.4	SPECIAL TEXTURES
		5.4.4.1 Tiles
		5.4.4.2 Material_Map
			5.4.4.2.1	Specifying a material map.
			5.4.4.2.2	Material_map options.
	5.4.5	LAYERED TEXTURES
	5.4.6	DEFAULT TEXTURE

	5.5 CAMERA

	5.5.1	LOCATION AND LOOK_AT
	5.5.2	THE SKY VECTOR
	5.5.3	THE DIRECTION VECTOR
	5.5.4	UP AND RIGHT VECTORS
		5.5.4.1 Aspect Ratio
		5.5.4.2 Handedness
	5.5.5	TRANSFORMING THE CAMERA
	5.5.6	CAMERA IDENTIFIERS

	5.6 MISC FEATURES

	5.6.1	FOG
	5.6.2	MAX_TRACE_LEVEL
	5.6.3	MAX_INTERSECTIONS
	5.6.4	BACKGROUND
	5.6.5	THE #VERSION DIRECTIVE

APPENDIX A  COMMON QUESTIONS AND ANSWERS

APPENDIX B  TIPS AND HINTS

	B.1 SCENE DESIGN
	B.2 SCENE DEBUGGING TIPS
	B.3 ANIMATION
	B.4 TEXTURES
	B.5 HEIGHT FIELDS
	B.6 FIELD-OF-VIEW
	B.7 CONVERTING "HANDEDNESS"

APPENDIX C  SUGGESTED READING

APPENDIX D  LEGAL INFORMATION

APPENDIX E  CONTACTING THE AUTHORS



1.0	INTRODUCTION
==================

This document details the use of the Persistence of Vision Ray Tracer (POV-
Ray) and is broken down into several sections.

The first section describes the program POV-Ray, explains what ray tracing 
is and also describes where to find the latest version of the POV-Ray 
software.

The next section is a quick start that helps you quickly begin to use the 
software.

After the quick start is a more in-depth tutorial for beginning POV-Ray 
users.

Following the beginning tutorial is a scene description language reference 
that describes the language used with POV-Ray to create an image.

The last sections include some tips and hints, suggested reading, and legal 
information.

POV-Ray is based on DKBTrace 2.12 by David Buck & Aaron A. Collins


2.0	ABOUT POV-Ray
===================

This section describes POV-Ray and explains what a ray tracer does.  It 
also describes where to find the latest version of the POV-Ray software.


2.1	PROGRAM DESCRIPTION -- WHAT IS RAY TRACING?
------------------------------------------------

The Persistence of Vision Ray Tracer (POV-Ray) is a copyrighted freeware 
program that allows a user to easily create fantastic, three dimensional, 
photo-realistic images on just about any computer. POV-Ray reads standard 
ASCII text files that describe the shapes, colors, textures and lighting in 
a scene and mathematically simulates the rays of light moving through the 
scene to produce a photo-realistic image! 

No traditional artistic or programming skills are required to use POV-Ray. 
First, you describe a picture in POV-Ray's scene description language, then 
POV-Ray takes your description and automatically creates an image from it 
with near perfect shading, perspective, reflections and lighting. 

The standard POV-Ray package also includes a collection of sample scene 
files that illustrate the program's features.  Additionally the POV-Ray 
Team distributes several volumes of scenes that have been created by other 
artists using the program. These scenes can be rendered and enjoyed even 
before learning the scene description language. They can also be modified 
to create new scenes. 

Here are some highlights of POV-Ray's features:
  *	Easy to use scene description language
  *	Large library of stunning example scene files
  *	Standard include files that pre-define many shapes, colors and 
	textures
  *	Very high quality output image files (24-bit color.)
  *	15 and 24 bit color display on IBM-PC's using appropriate hardware
  *	Create landscapes using smoothed height fields
  *	Spotlights for sophisticated lighting
  *	Phong and specular highlighting for more realistic-looking surfaces.
  *	Several image file output formats including Targa, dump and raw
  *	Wide range of shapes:
  *	Basic Shape Primitives such as... Sphere, Box, Quadric, Cylinder,
	Cone, Triangle and Plane
  *	Advanced Shape Primitives such as... Torus (Donut), Hyperboloid,
	Paraboloid, Bezier Patch, Height Fields (Mountains), Blobs,
	Quartics, Smooth Triangles (Phong shaded)
  *	Shapes can easily be combined to create new complex shapes. This
	feature is called Constructive Solid Geometry (CSG). POV-Ray
	supports unions, merges, intersections and differences in CSG.
  *	Objects are assigned materials called textures.  (A texture describes
	the coloring and surface properties of a shape.)
  *	Built-in color patterns: Agate, Bozo, Checker, Granite, Gradient,
	Leopard, Mandel, Marble, Onion, Spotted, Radial, Wood and image file
	mapping.
  *	Built-in surface bump patterns: Bumps, Dents, Ripples, Waves,
	Wrinkles and mapping.
  *	Users can create their own textures or use pre-defined textures such
	as... Mirror, Metals like Chrome, Brass, Gold and Silver, Bright
	Blue Sky with Clouds, Sunset with Clouds, Sapphire Agate, Jade,
	Shiny, Brown Agate, Apocalypse, Blood Marble, Glass, Brown Onion,
	Pine Wood, Cherry Wood
  *	Combine textures using layering of semi-transparent textures or tile
	or material map files.
  *	Display preview of image while computing (not available on all
	computers)
  *	Halt rendering when part way through
  *	Continue rendering a halted partial scene later


2.2	WHICH VERSION OF POV-Ray SHOULD YOU USE?
----------------------------------------------

There are specific versions of POV-Ray available for three different 
computers, the IBM-PC, the Apple Macintosh, and the Commodore Amiga.


2.2.1 IBM-PC AND COMPATIBLES

The IBM-PC version is called POVRAY.EXE and is found in the self-extracting 
archive POVIBM.EXE. It can be run on any IBM-PC with a 386 or 486 CPU and 2 
megabytes of memory. A math co-processor is not required, but it is 
recommended. This version of POV-Ray may be run under DOS, OS\2, and 
Windows. It will not run under Desqview at this time. A version that runs 
on IBM-PC's using the 286 CPU is also available in the self-extracting 
archive POV286.EXE.


2.2.2 APPLE MACINTOSH

The Apple Macintosh version of POV-Ray can be found in the archive 
POVMAC.SEA or POVMNF.SEA.  POVMAC.SEA contains the preferred "high-
performance" executable for Macs with a floating point coprocessor (FPU).  
POVMNF.SEA contains the slower more universal executable, which will run on 
any 68020 or better Mac without an FPU.  

The Macintosh version of POV-Ray needs a 68020 or better CPU (Mac II 
series, SE/30, Quadras, some Powerbooks, etc.)  It will run under Sytem 
6.0.4 or newer (System 7 preferred.)  It also requires 32 bit Color 
Quickdraw, which is built into System 7, and is an optional init in System 
6.  The init can be found on the System 6 System disk "Printing", under the 
"Apple Color" folder.  It should also be available from any authorized 
Apple Service Center, or CompuServe or local Macintosh bulletin boards.  
QuickTime 1.5 or newer is preferred but not required.  If installed, it 
will allow compression of the final PICT images.  It will also allow adding 
custom System 7 Thumbnail icons to the PICT files in the Finder.  Of 
course, a color monitor is preferred, but not required.

2.2.3 COMMODORE AMIGA

The Commodore Amiga version of POV-Ray can be found in the file POVAMI.LZH. 
Two executables are supplied, one for computers with a math co-processor, 
and one for computers without a math co-processor. This version will run on 
Amiga 500, 1000, 2000, and 3000's and should work under AmigaDOS 1.3 or 
2.xx.  The Amiga version supports HAM mode as well as HAM-E and the 
Firecracker.


2.2.4 UNIX AND OTHER SYSTEMS

POV-Ray is written in highly portable C source code and it can be compiled 
and run on many different computers.  There is specific source code in the 
source archive for UNIX, X-Windows, VAX, and generic computers. If you have 
one of these, you can use the C compiler included with your operating 
system to compile a POV-Ray executable for your own use. This executable 
may not be distributed except under the terms specified in the file 
POVLEGAL.DOC.  Users on high powered computers like Suns, SGI, RS-6000's, 
Crays, and so on use this method to run POV-Ray.


2.2.5 ALL VERSIONS

All versions of the program share the same ray tracing features like 
shapes, lighting and textures. In other words, an IBM-PC can create the 
same pictures as a Cray supercomputer as long as it has enough memory.

The user will want to get the executable that best matches their computer 
hardware. See the section "Where to find POV-Ray files" for where to find 
these files. You can contact those sources to find out what the best 
version is for you and your computer.


2.3	WHERE TO FIND POV-Ray FILES
---------------------------------

POV-Ray is a complex piece of software made up of many files. The POV-Ray 
package is made up of several archives including executables, 
documentation, and example scene files. 

The average user will need an executable for their computer, the example 
scene files and the documentation. The example scenes are invaluable for 
learning about POV-Ray, and they include some exciting artwork.

Advanced users, developers, or the curious may want to download the C 
source code as well.

There are also many different utilities for POV-Ray that generate scenes, 
convert scene information from one format to another, create new materials, 
and so on. You can find these files from the same sources as the other POV-
Ray files. No comprehensive list of these utilities is available at the 
time of this writing.

The latest versions of the POV-Ray software are available from these 
sources:


2.3.1 GRAPHICS DEVELOPER'S FORUM ON COMPUSERVE

POV-Ray headquarters are on CompuServe Graphics Developer's Forum (GO 
GRAPHDEV) sections 8 POV Sources and 9 POV Images. We meet there to share 
info and graphics and discuss ray tracing. The forum is also home to 
development projects on fractals, animation and morphing.  It is the home 
of the Stone Soup Group, developers of Fractint, a popular IBM-PC fractal 
program. Everyone is welcome to join in on the action on CIS GraphDev. Hope 
to see you there! You can get information on joining CompuServe by calling 
(800)848-8990. CompuServe access is also available in Japan, Europe and 
many other countries.


2.3.2 PC GRAPHICS AREA ON AMERICA ON-LINE

There's an area now on America On-Line dedicated to POV-Ray support and 
information. You can find it in the PC Graphics section of AOL. Jump 
keyword "PCGRAPHICS". This area includes the Apple Macintosh executables 
also.


2.3.3 YOU CAN CALL ME RAY BBS IN CHICAGO

There is a ray trace specific BBS in the (708) Area Code (Chicago suburbia, 
United States) for all you Traceaholics out there. The phone number of this 
BBS is (708) 358-5611. Bill Minus is the sysop and Aaron Collins is co-
sysop of that board, and it's filled with interesting stuff.


2.3.4 THE GRAPHICS ALTERNATIVE BBS IN EL CERRITO, CA

For those on the West coast, you may want to find the POV-Ray files on The 
Graphics Alternative BBS. It's a great graphics BBS run by Adam Shiffman.  
TGA is high quality, active and progressive BBS system which offers both 
quality messaging and files to its 1300+ users.

	510-524-2780 (PM14400FXSA v.32bis 14.4k, Public)
	510-524-2165 (USR DS v.32bis/HST 14.4k, Subscribers)

2.3.5 PI SQUARED BBS MARYLAND

For those on the East coast you may want to try th Pi Squared BBS in 
Maryland.  The sysop Alfonso Hermida CIS: 72114,2060 is the creator of 
POVCAD.  He carries the latest POV files and utilities, plus supports his 
software.  Call (301)-725-9080 in Maryland USA running @ 14.4K bps 24 hrs.


2.3.6 INTERNET

The POV-Ray files are also available over Internet by anonymous FTP from 
alfred.ccs.carleton.ca (134.117.1.1).


3.0	QUICK START
=================

The next section describes how to quickly install POV-Ray and render a 
sample scene on your computer. 


3.1	INSTALLING POV-Ray
------------------------

Specific installation instructions are included with the executable program 
for your computer. In general, there are two ways to install POV-Ray. 

[ Note that the generic word "directory" is used throughout.  Your 
operating system may use another word (subdirectory, folder, etc.) ]

1-- The messy way: Create a directory called POVRAY and copy all POV-Ray 
files into it. Edit and run all files and programs from this directory. 
This method works, but is not recommended.

Or the preferred way:
2-- Create a directory called POVRAY and several subdirectories called  
INCLUDE, DEMO, SCENES, UTIL. The self-extracting archives used in some 
versions of the program will create subdirectories for you.  If you create 
your own, the file tree for this should look something like this:
	\--
	 |	
	 +POVRAY --
		|
		+INCLUDE
		|
		+DEMO
		|  
		+SCENES
		|  
		+UTIL	

Copy the executable file and docs into the directory POVRAY. Copy the 
standard include files into the subdirectory INCLUDE. Copy the sample scene 
files into the subdirectory SCENES. And copy any POV-Ray related utility 
programs and their related files into the subdirectory UTIL. Your own scene 
files will go into the SCENES subdirectory. Also, you'll need to add the 
directories \POVRAY and \POVRAY\UTIL to your "search path" so the 
executable programs can be run from any directory.

	 *Note that some operating systems don't 
	 *have an equivalent to the
	 *multi-path search command.

The second method is a bit more difficult to set-up, but is preferred. 
There are many files associated with POV-Ray and they are far easier to 
deal with when separated into several directories.


3.2	USING SAMPLE SCENES
-------------------------

This section describes how to render a sample scene file. You can use these 
steps to render any of the sample scene files included in the sample scenes 
archive. 

A scene file is a standard ASCII text file that contains a description of a 
three dimensional scene in the POV-Ray language.  The scene file text 
describes objects and lights in the scene, and a camera to view the scene. 
Scene files have the file extension .POV and can be created by any word 
processor or editor that can save in standard ASCII text format.

Quite a few example scenes are provided with this distribution in the 
example scenes archive. The scenes in the standard archives are designed to 
illustrate and teach you the features of the program.  Additionally the 
POV-Ray Team distributes several volumes of scenes in its ongoing series 
"The POV-Ray Scene Library"  These scene files range from very simple to 
very complex. They have been created by users of POV-Ray all over the 
world, and were picked to give examples of the variety of features in POV-
Ray. Many of them are stunning in their own right. 

The scenes were graciously donated by the artists because they wanted to 
share what they had created with other users. Feel free to use these scenes 
for any purpose. You can just marvel at them as-is, you can study the scene 
files to learn the artists techniques, or you can use them as a starting 
point to create new scenes of your own.

Here's how to make these sample scenes into images you can view on your 
computer. We'll use SIMPLE.POV as an example, just substitute another 
filename to render a different image.

	Note: The sequence of commands is not the same for
	 every version of POV-Ray. There should be a 
	 document with the executable describing the
	 specific commands to render a file.

The file SIMPLE.POV was included with the standard scene files and should 
now be in the DEMO directory.  Make that the active directory, and then at 
the command line, type:

  POVRAY +Isimple.pov +V +W80 +H60

POVRAY is the name of your executable, +Ifilename.pov tells POV-Ray what 
scene file it should use as input, and +V tells the program to output its 
status to the text screen as it's working. +W and +H set the width and 
height of the image in pixels. This image will be 80 pixels wide by 60 
pixels high.

POV-Ray will read in the text file SIMPLE.POV and begin working to render 
the image. It will write the image to a file called DATA.TGA. The file 
DATA.TGA contains a 24 bit image of the scene file SIMPLE.POV. Because many 
computers can't display a 24 bit image, you will probably have to convert 
DATA.TGA to an 8 bit format before you can view it on your computer. The 
docs included with your executable lists the specific steps required to 
convert a 24 bit file to an 8 bit file.


3.3	COMMAND LINE PARAMETERS
-----------------------------

The following section gives a detailed description of the command-line 
options.

The command-line parameters may be specified in any order. Repeated 
parameters overwrite the previous values except for the +L switch which 
defines include file library paths.  Up to 10 +L paths may be specified.  
Default parameters may also be specified in a file called "povray.def" or 
by the environment variable "POVRAYOPT". 

Switches may be specified in upper or lower case.  Switches must be 
preceded by a + (plus) or - (minus).  In switches which toggle a feature, 
the plus turns it on and minus turns it off.  For example +P turns on the 
"pause for keypress when finished" option while -P turns it off.  Other 
switches are used to specify values and do not toggle a feature.  Either 
plus or minus may be used in that instance.  For example +W320 sets the 
width to 320 pixels.  You could also use -W320 and get the same results.  
More examples follow this table.

Table 1 Command Line Parameters
Parameter......|.....Range........|...Description........................
-------------------------------------------------------------------------
+Annn	  	| 0.0 to 3.0	  | Render picture with anti-aliasing,or 
		|		  | "smoothing", on.  Lower values cause 
		|		  | more smoothing.
+A		|		  | Use default 0.3 anti-aliasing
-A		|		  | Turn anti-aliasing off (default)
+Bnnn or -Bnnn 	| Varies w/ sys	  | Output file buffer size.
+C		|		  | Continue an aborted partial image. 
-C		|		  | Start rendering from first line.
+Dxxx	  	| Varies w/sys	  | Display image graphically while 
		|		  | rendering (Not available on all vers).
+Enn or +ERnn  	| 1 to 32,767	  | End row for tracing
		|  or 0.0 to 1.0	| a portion of a scene.
+ECnn	  	| 1 to 32,767	  | End column for tracing
		|  or 0.0 to 1.0  | a portion of a scene.
+FT		|		  | Output Targa format file 
+FD		|		  | Output dump format file 
+FR		|		  | Output raw format file 
-F		|		  | Disable file output.
+Hnnn	  	| 1 to 32,767	  | Height of image in pixels.
+Ifilespec	| Varies w/ sys	  | Input scene file name, generally ends 
		|		  | in .pov.
+Jnnn.nnn	| 0.0 to 1.0	  | Set amount of jitter for anti-aliasing
+J		|		  | Use anti-aliasing jitter 1.0 (default)
-J		|		  | Turn off anti-aliasing jitter 
+Knnn.nnn	| any real value  | Set "clock" float value for animation
+Lpathspec	| Varies w/ sys	  | Library path: POV-Ray will search for 
		|		  | files in the directory listed here.
		|		  | Multiple lib paths may be specified.
-MB		|		  | Turn off bounding slabs
+MBnnn	 	| 0 to 32,767	  | Use bounding slabs if more than nnn
		|		  | objects in scene.
+MSnnn	 	| 300 or more	  | Set symbol table size (default 1000)
+MVn.m	 	| 1.0 or 2.0	  | Set version compatibility mode
+Ofilespec	| Varies w/ sys	  | Output image filename.
+P		|		  | Pause and wait for keypress after 
		|		  | tracing image.
-P		|		  | Don't pause
+Qn		|	0 to 9	  | Image quality: 9 highest(default) to
		|		  | 0 lowest.
+Rn or -Rn	|	1 to 9	  | Use n*n rays for anti-aliasing. Default 
		|		  | of 3 gives 9 rays; 4 gives 16 rays etc.
+Snn or +SRnn  	| 1-32,768	  | Start row for tracing
		|  or 0.0 to 1.0  | a portion of a scene.
+SCnn	  	| 1-32,768	  | Start column for tracing
		|  or 0.0 to 1.0  | a portion of a scene.
+Vnn		| Varies w/sys	  | Display verbose image stats while
		|		  | rendering. 
-V		|		  | No stats during rendering
+Wnnn	  	| 1-32,768	  | Width of image in pixels.
+X		|		  | Allow abort with keypress.(IBM-PC).
-X		|		  | Disable abort with keypress.(IBM-PC).
--------------------------------------------------------------


3.3.1 ANTI-ALIASING

	 +Annn	Anti-alias with tolerance level nnn.
	 +A	  Anti-alias with tolerance level 0.3
	 -A	  Don't anti-alias (default)
	 +Jn.nn	 Scale factor for jittering
	 +J	  Jitter AA with scale 1.0 (default)
	 -J	  Turn off jittering
	 +Rn or -Rn  Use n*n rays when anti-aliasing (default 3)

Anti-aliasing is a technique used to make the ray traced image look 
smoother. Often the color difference between two objects creates a "jaggy" 
appearance. When anti-aliasing is turned on, POV-Ray attempts to "smooth" 
the jaggies by shooting more rays into the scene and averaging the results. 
This technique can really improve the appearance of the final image. Be 
forewarned though, anti-aliasing drastically slows the time required to 
render a scene since it has do many more calculations to "smooth" the 
image. Lower numbers mean more anti-aliasing and also more time. Use anti-
aliasing for your final version of a picture, not the rough draft.

The +A option enables adaptive anti-aliasing. The number after the +A 
option determines the threshold for the anti-aliasing. 

If the color of a pixel differs from its neighbor (to the left or above) by 
more than the threshold, then the pixel is subdivided and super-sampled. If 
r1,g1,b1 and r2,g2,b2 are the rgb components of two pixels then the 
difference between pixels is computed by:

	diff=abs(r1-r2)+abs(g1-g2)+abs(b1-b2)

The rgb values are in the range 0.0 to 1.0 thus the most two pixels can 
differ is 3.0.  If the anti-aliasing threshold is 0.0, then every pixel is 
super-sampled. If the threshold is 3.0, then no anti-aliasing is done. 

The lower the contrast, the lower the threshold should be. Higher contrast 
pictures can get away with higher tolerance values.

Good values seem to be around 0.2 to 0.4.

The super-samples are jittered to introduce noise and to eliminate moire 
interference patterns. Note that the jittering "noise" is non-random and 
repeatable in nature, based on an object's 3-D orientation in space. Thus, 
it's okay to use anti-aliasing for animation sequences, as the anti-aliased 
pixels won't vary and flicker annoyingly from frame to frame.  The +Jnn.nn 
switch scales down the amount of jitter from its default value 1.0.  For 
example +J0.5 uses half the normal jitter.  Values over 1.0 jitter outside 
the pixel bounds and are not recommended.  Use -J to turn off jittering.

The +R switch controls the number of rows and columns of rays per pixel 
with anti-aliasing.  The default value 3 gives 3x3=9 rays per pixel.

The jittering and multiple rays are only used when +A is on.


3.3.2 BUFFERING

	 +Bnnn	Use an output file buffer of nnn kilobytes. 
	 -Bnnn	Same as +Bnnn

The +B option allows you to assign large buffers to the output file. This 
reduces the amount of time spent writing to the disk. If this parameter is 
not specified, then as each scanline is finished, the line is written to 
the file and the file is flushed. On most systems, this operation insures 
that the file is written to the disk so that in the event of a system crash 
or other catastrophic event, at least part of the picture has been stored 
properly and retrievable on disk. (see also the +C option below.)  A value 
of +B30 is a good value to use to speed up small renderings.  A value of 
+B0 defaults to a small system-dependent buffer size.  Note neither +B0 nor 
-B turns this feature off.  Once a buffer is set, subsequent +B commands 
can change its size but cannot turn it off.


3.3.3 CONTINUING INTERRUPTED TRACE

	 +C	  Continue partially complete rendering
	 -C	  Render from beginning (default)

If you abort a render while it's in progress or if you used the +E or +ER 
options to end the render prematurely, you can use the +C option to 
continue the render when you get back to it. This option reads in the 
previously generated output file, displays the image to date on the screen, 
then proceeds with the ray tracing. This option cannot be used if file 
output is disabled with -F.  It does not work with +S, +SR, +SC or +EC 
switches.


3.3.4 DISPLAY PREVIEW IMAGE

	 +D	  Use preview display
	 -D	  Turn preview display off (default)

If the +D option is used and your computer supports a graphic display, then 
the image will be displayed while the program performs the ray tracing. On 
most systems, the picture displayed is not as good as the one created by 
the post-processor because it does not try to make optimum choices for the 
color registers. 

The +D parameters are system-dependent and are listed in the executable 
documentation.


3.3.5 RENDER PARTIAL IMAGE

	 +Snnn or +SRnnn	Start tracing at row number nnn.
	 +SCnnn		Start tracing at column number nnn.
	 +Ennn or +ERnnn	End tracing at row number nnn.
	 +ECnnn		End tracing at column number nnn.

When doing test rendering it is often convenient to define a rectangular 
section of the whole screen so you can quickly check out one area of the 
image.  The +S and +E switches let you define starting and ending rows and 
columns for partial renderings.

The +S and +E options also allow you to begin and end the rendering of an 
image at a specific scan line so you can render groups of scanlines on 
different systems and concatenate them later.

WARNING: Image files created on with different executables on the same or 
different computers may not look exactly the same due to different random 
number generators used in some textures. If you are merging output files 
from different systems, make sure that the random number generators are the 
same. If not, the textures from one will not blend in with the textures 
from the other. 

Note if the number following +SR, +SC, +ER or +EC is a greater 1 then it is 
interpreted as a number of pixels.  If it is a decimal value between 0.0 
and 1.0 then it is interpreted as a percent of the total width or height of 
the image.  For example: +SR0.75 +SC0.75 starts on a row 75% down from the 
top at a column 75% from the left and thus renders only the lower-right 25% 
of the image.


3.3.6 FILE OUTPUT TYPE

	 +FT	 Uncompressed Targa-24 format (IBM-PC Default)
	 +FD	 Dump format (QRT-style)
	 +FR	 Raw format - one file each for Red, Green and Blue. 
	 +F	  Use default file type for your system
	 -F	  Turn off file output

Normally, you don't need to specify any form of +F option. The default 
setting will create the correct format image file for your computer. The 
docs included with the executable specify which format is used.

You can disable image file output by using the command line option -F. This 
is only useful if your computer has display options and should be used in 
conjunction with the +P option. If you disable file output using -F, there 
will be no record kept of the image file generated. This option is not 
normally used.

Unless file output is disabled (-F) POV-Ray will create an image file of 
the picture. This output file describes each pixel with 24 bits of color 
information. Currently, three output file formats are directly supported.  
They are +FT - Uncompressed Targa-24 format (IBM-PC Default), +FD - Dump 
format (QRT-style) and +FR - Raw format - one file each for Red, Green and 
Blue. 


3.3.7 HEIGHT AND WIDTH OF IMAGE

	 +Hnnn or -Hnnn	Set height of image in pixels
	 +Wnnn or -Wnnn	Set width of image in pixels

These switches set the height and width of the image in pixels.  This 
specifies the image size for file output.  The preview display with the +D 
option will generally attempt to pick a video mode to accommodate this size 
but the +D settings do not in any way affect the resulting file output.


3.3.8 INPUT AND OUTPUT FILE NAMES

	 +Ifilename  Set the input filename
	 +Ofilename  Set output filename

The default input filename is "object.pov". The default output filename is 
"data" and the suffix for your default file type.  The +O switch has no 
effect unless file output is turned on with +F

IBM-PC default file type is Targa, so the file is "data.tga".

Amiga uses dump format and the default outfile name is "data.dis".

Raw mode writes three files, "data.red", "data.grn" and "data.blu". On IBM-
PC's, the default extensions for raw mode are ".r8", ".g8", and ".b8" to 
conform to Piclab's "raw" format. Piclab is a widely used free-ware image 
processing program. Normally, Targa files are used with Piclab, not raw 
files.


3.3.10 ANIMATION CLOCK VARIABLE

	 +Knnn or -Knnn	Set the "clock" float value

The +K switch may be used to pass a single float value to the program for 
basic animation.  The value is stored in the float identifier "clock".  If 
an object had a "rotate <0,clock,0>" attached then you could rotate the 
object by different amounts over different frames by setting +K10, +K20... 
etc. on successive renderings.


3.3.11 LIBRARY SEARCH PATH

	 +Lpathspec  Specify on of 10 library search paths

The +L option may be used to specify a "library" pathname to look in for 
include, parameter and image files. Multiple uses of the +L switch do not 
override previous settings.  Up to ten +L options may be used to specify a 
search path. The home (current) directory will be searched first followed 
by the indicated library directories in order.


3.3.12 BOUNDING SLABS CONTROL

	 -MB	 Turn off bounding slabs
	 +MBnnn	 Use bounding slabs if more than nnn objects in scene.

New in POV-Ray 2.0 is a spatial sub-division system called bounding slabs.  
It compartmentalizes all of the objects in a scene into rectangular slabs 
and computes which slabs a particular ray hits before testing the objects 
within the slab.  This can greatly improve rendering speed.  However for 
scenes with only a few objects the overhead of using slabs is not worth the 
effort.  The +MB switch sets the minimum number of objects before slabs are 
used.  The default is +MB25.  The -MB switch turns off slabs completely.


3.3.13 SYMBOL TABLE SIZE

	 +MSnnn or -MSnnn	Sets symbol table size (default 1000)

POV-Ray allocates a fixed number of spaces in its symbol table for declared 
identifiers.  The default of 1000 may be increased if you get a "Too many 
symbols" error message.


3.3.14 VERSION COMPATIBILITY MODE

	 +MVn.n or -MVn.n	Set version compatibility mode

While many language changes have been made for POV-Ray 2.0, most version 
1.0 syntax still works.  One new feature in 2.0 that is incompatible with 
any 1.0 scene files is the parsing of float expressions.  Setting +MV1.0 
turns off expression parsing as well as many warning messages so that 
nearly all 1.0 files will still work.  The "#version" language directive 
also can be used to change modes within scene files.  The +MV switch 
affects only the initial setting.


3.3.15 PAUSE WHEN FINISHED

	 +P	  Pause when image is complete so preview image can
		  be seen.
	 -P	  Do not pause.  (default)

Normally when preview display is on you want to look at the image awhile 
before continuing.  The +P switch pauses and waits for you to press a key 
before going on.


3.3.16 QUALITY SETTINGS

	 +Qn or -Qn  Set rendering quality

The +Q option allows you to specify the image rendering quality, for 
quickly rendering images for testing. You may also use -Q with no 
difference.  The parameter can range from 0 to 9. The values correspond to 
the following quality levels:

0,1  Just show quick colors. Ambient lighting only.
	Quick colors are used only at 5 or below.
2,3  Show Diffuse and Ambient light
4,5  Render shadows, use extended lights at 5 but not 4
6,7  Create surface textures
8,9  Compute reflected, refracted, and transmitted rays.

The default is +Q9 (maximum quality) if not specified.


3.3.17 VERBOSE STATISTICS

	 +V	  Verbose statistics on
	 -V	  Verbose statistics off

When the +D option is not used, it is often desirable to monitor progress 
of the rendering.  The +V switch turns on verbose reporting while -V turns 
it off.  The format of the output is system dependent.


3.3.18 ALLOW ABORTED RENDERING

	 +X	  Allow abort with keypress
	 -X	  Disable abort with keypress

On the IBM-PC versions only, when you specify the +X switch then any 
keypress will abort rendering.  The -X switch disables this feature.


3.4	DEFAULT PARAMETER FILE AND ENVIRONMENT VARIABLE
-----------------------------------------------------

You may specify the default parameters by modifying the file "povray.def" 
which contains the parameters in the above format. This filename contains a 
complete command line as though you had typed it in, and is processed 
before any options supplied on the command line are recognized. You may put 
commands on more than one line in the "povray.def" file.

Examples:

  POVRAY +Ibox.pov +Obox.tga +V +X +W320 +H200 

	+Ibox.pov = Use the scene file box.pov for input
	+Obox.tga = Output the image as a Targa file to box.tga 
	+V = Show line numbers while rendering.
	+X = Allow key press to abort render.
	+W320 = Set image width to 320 pixels
	+H200 = Set image height to 200 pixels

Some of these parameters could have been put in the POVRAYOPT environment 
variable to save typing:

  SET POVRAYOPT = +V +X +W320 +H200

Then you could just type:

  POVRAY +Ibox.pov +Obox.tga 

Or, you could create a file called POVRAY.DEF in the same directory as the 
scene file.  If POVRAY.DEF contains "+V +X +W320 +H200" then you could also 
type:

  POVRAY +Ibox.pov +Obox.tga 

With the same results. You could also create an option file with a 
different name and specify it on the command line:

For example, if QUICK.DEF contains "+V +X +W80 +H60" then you could also 
type:

  POVRAY +Ibox.pov +Obox.tga QUICK.DEF

When POV-Ray sees QUICK.DEF, it will read it in just as if you typed it on 
the command line.

The order that the options are read in for the IBM-PC version are as 
follows:

  POVRAYOPT environment variable

  POVRAY.DEF in current directory or,
		if not found, in library path

  Command line and command line option files

For example, +V in POVRAY.DEF would override -V in POVRAYOPT. +X on the 
command line would override -X in POVRAY.DEF and so on.

Other computer's versions may read in the POVRAY.DEF file before the 
POVRAYOPT environment variable.  See the documentation on your version.


4.0	BEGINNING TUTORIAL
========================

This section describes how to create a scene using POV-Ray's scene 
description language and how to render this scene.


4.1	YOUR FIRST IMAGE
----------------------

Let's create the scene file for a simple picture. Since ray tracers thrive 
on spheres, that's what we'll render first.


4.1.1 THE POV-Ray COORDINATE SYSTEM

First, we have to tell POV-Ray where our camera is and where it's looking. 
To do this, we use 3D coordinates. The usual coordinate system for POV-Ray 
has the positive Y axis pointing up, the positive X axis pointing to the 
right, and the positive Z axis pointing into the screen as follows:

	^+Y
	|   /+Z
	|  /
	| /
	|/	+X
	|-------->


The negative values of the axes point the other direction, as follows:


	  ^+Y
	  |   /+Z
	  |  /
	  | /
  -X	  |/	+X
  <-------|-------->
	 /|
	/ |
       /  |
    -Z/	  |
	  v-Y


4.1.2 ADDING STANDARD INCLUDE FILES

Using your personal favorite text editor, create a file called 
"picture1.pov". Now, type in the following (note: The input is case 
sensitive, so be sure to get capital and lowercase letters correct):

	 #include "colors.inc"	// The include files contain
	 #include "shapes.inc"	// pre-defined scene elements
	 #include "textures.inc"

	 camera {
	location  <0, 2, -3>
	look_at	<0, 1,  2>
	 }

The first include statement reads in definitions for various useful colors. 
The second and third include statements read in some useful shapes and 
textures respectively. When you get a chance, have a look through them to 
see but a few of the many possible shapes and textures available.

You may have as many include files as needed in a scene file. Include files 
may themselves contain include files, but you are limited to declaring 
includes nested only 10 "deep".

Filenames specified in the include statements will be searched for in the 
home (current) directory first, and if not found, will then be searched for 
in directories specified by any "+L" (library path) options active. This 
would facilitate keeping all your "include" (.inc) files such as 
shapes.inc, colors.inc, and textures.inc in an "include" subdirectory, and 
giving an "+L" option on the command line to where your library of include 
files are.


4.1.3 PLACING THE CAMERA

The camera declaration describes where and how the camera sees the scene. 
It gives X, Y, Z coordinates to indicate the position of the camera and 
what part of the scene it is pointing at. You describe X, Y, Z coordinates 
using a 3-part "vector".  A vector is specified by putting 3 numeric values 
between a pair of angle brackets and separating the values with commas.

Briefly, "location <0, 2, -3>" places the camera up two units and back 
three units from the center of the ray tracing universe which is at <0, 0, 
0>. Remember that by default +Z is into the screen and -Z is back out of 
the screen.

Also "look_at <0, 1, 2>" rotates the camera to point at X, Y, Z coordinates 
<0, 1, 2>.  A point 5 units in front of and 1 unit lower than the camera. 
The look_at point should be the center of attention of your image.


4.1.4 DESCRIBING AN OBJECT

Now that the camera is set up to record the scene, let's place a red sphere 
into the scene.  Type the following into your scene file:

	 sphere {
	<0, 1, 2>, 2
	texture {
	  pigment {color Yellow}  // Yellow is pre-defined in COLORS.INC
	}
	 }

The first vector specifies center of the sphere.  In this example the X 
coordinate is zero so it is centered left and right.  It is also at Y=1 or 
1 unit up from the origin. The Z coordinate is 2 which is 5 units in front 
of the camera at Z=-3. After the center vector is a comma followed by the 
radius which in this case is 2 units. Since the radius is 1/2 the width of 
a sphere, the sphere is 4 units wide. 


4.1.5 ADDING TEXTURE TO AN OBJECT

Now that we've defined the location and size of the sphere, we need to 
describe the appearance of the surface.  The texture {...} block specifies 
these parameters.  Texture blocks describe the color, bumpiness and finish 
properties of an object.  In this example we will specify the color only.  
This is the minimum we must do.  All other texture options except color 
will use the default values.

The color you define is the way you want it to look if fully illuminated.  
If you were painting a picture of a sphere you would use dark shades of a 
color to indicate the shadowed side and bright shades on the illuminated 
side.  However ray tracing takes care of that for you.  You pick the basic 
color inherent in the object and POV-Ray brightens or darkens it depending 
on the lighting in the scene.  Because we are defining the basic color the 
object actually IS rather than how it LOOKS the parameter is called 
"pigment".

Many types of color patterns are available for use in a pigment {...} 
statement.  The keyword "color" specifies that the whole object is to be 
one solid color rather than some pattern of colors.  The word "Yellow" is a 
color identifier which was previously defined in the standard include file 
"colors.inc".

If no standard color is available for your needs, you may define your own 
color by using the color keyword followed by "red", "green" and "blue" 
keywords specifying the amount of red, green and blue to be mixed.  For 
example a nice shade of pink can be specified by:

	 color red 1.0 green 0.8 blue 0.8

The values after each keyword should be in the range 0.0 to 1.0.  Any of 
the three components not specified will default to 0.  A shortcut notation 
may also be used.  The following produces the same shade of pink:

	 color rgb <1.0, 0.8, 0.8>

Colors are explained in more detail later.


4.1.6 DEFINING A LIGHT SOURCE

One more detail is needed for our scene.  We need a light source. Until you 
create one, there is no light in this virtual world.  Add the following 
text to your scene file:

	 light_source { <2, 4, -3> color White}

The vector specifies the location of the light as 2 units to our right, 4 
units above the origin and 3 units back from the origin. The light_source 
is invisible, it only casts light, so no texture is needed.

That's it!  Close the file and render a small picture of it using this 
command:

	 POVRAY +W160 +H120 +P +X +D0 -V -Ipicture1.pov

If your computer does not use the command line, see the executable docs for 
the correct command to render a scene.

You may set any other command line options you like, also. The scene is 
output to the image file DATA.TGA (or some suffix other than TGA if your 
computer uses a different file format). You can convert DATA.TGA to a GIF 
image using the commands listed in the docs included with your executable. 


4.2	MORE TEXTURE OPTIONS
--------------------------

You've now rendered your first picture but it is somewhat boring.  Let's 
add some fancy features to the texture.


4.2.1 SURFACE FINISHES

One of the main features of a ray tracer is its ability to do interesting 
things with surface finishes such as highlights and reflection.  Let's add 
a nice little phong highlight (shiny spot) to the sphere. To do this you 
need a "finish" parameter. Change the definition of the sphere to this:

	 sphere {
	<0, 1, 2>, 2
	texture {
	  pigment {color Yellow}  // Yellow is pre-defined in COLORS.INC
	  finish {phong 1}
	}
	 }

Now render this the same way you did before. The phong keyword adds a 
highlight the same color of the light shining on the object. It adds a lot 
of credibility to the picture and makes the object look smooth and shiny. 
Lower values of phong will make the highlight less bright. Phong can be 
between 0 and 1.


4.2.2 ADDING BUMPINESS

The highlight you've added illustrates how much of our perception depends 
on the reflective properties of an object.  Ray tracing can exploit this by 
playing tricks on our perception to make us see complex details that aren't 
really there.

Suppose you wanted a very bumpy surface on the object.  It would be very 
difficult to mathematically model lots of bumps.  We can however simulate 
the way bumps look by altering the way light reflects off of the surface.  
Reflection calculations depend on a vector called a "surface normal" 
vector.  This is a vector which points away from the surface and is 
perpendicular to it.  By artificially modifying (or perturbing) this normal 
vector you can simulate bumps.  Change the scene to read as follows and 
render it:

	 sphere {
	<0, 1, 2>, 2
	texture {
	  pigment {color Yellow}  
	  normal {bumps 0.4	scale 0.2}
	  finish {phong 1}
	}
	 }

This tells POV-Ray to use a bump pattern to modify the surface normal.  The 
value 0.4 controls the apparent depth of the bumps.  Usually the bumps are 
about 1 unit wide which doesn't work very well with a sphere of radius 2.  
The scale makes the bumps 1/5th as wide but does not affect their depth. 


4.2.3 CREATING COLOR PATTERNS

You can do more than assign a solid color to an object.  You can create 
complex patterns in the pigment block.  Consider this example:

	 sphere {
	<0, 1, 2>, 2
	texture {
	  pigment {
		wood
		color_map {
		 [0.0 color DarkTan]
		 [0.9 color DarkBrown]
		 [1.0 color VeryDarkBrown]
		}
		turbulence 0.05
		scale <0.2, 0.3, 1>
	  }
	  finish {phong 1}
	}
	 }

The keyword "wood" specifies a pigment pattern of concentric rings like 
rings in wood.  The color_map specifies that the color of the wood should 
blend from DarkTan to DarkBrown over the first 90% of the vein and from 
DarkBrown to VeryDarkBrown over the remaining 10%.  The turbulence slightly 
stirs up the pattern so the veins aren't perfect circles and the scale 
factor adjusts the size of the pattern.

The most of the patterns are set up by default to give you one "feature" 
across a sphere of radius 1.0. A "feature" is very roughly defined as a 
color transition. For example, a wood texture would have one band on a 
sphere of radius 1.0. In this example we scale the pattern using the 
"scale" keyword followed by a vector.  In this case we scaled 0.2 in the x 
direction, 0.3 in the y direction an the z direction is scaled by 1, which 
leaves it unchanged. Scale values larger than 1 will stretch an element. 
Scale values smaller than one will squish an element. And scale value 1 
will leave an element unchanged.


4.2.4 PRE-DEFINED TEXTURES

POV-Ray has some very sophisticated textures pre-defined in the standard 
include files "textures.inc" and "stones.inc".  Some are entire textures 
with pigment, normal and/or finish parameters already defined.  Some are 
just pigments or just finishes.	Change the definition of our sphere to 
the following and then re-render it: 

	 sphere {
	<0, 1, 2>, 2
	texture {
	  pigment {
		DMFWood4	// Pre-defined from textures.inc 
		scale 4	// Scale by the same amount in all
			// directions
	  }
	  finish {Shiny}	 // This finish defined in textures.inc
	}
	 }

The pigment identifier DMFWood4 has already been scaled down quite small 
when it was defined.  For this example we want to scale the pattern larger.  
Because we want to scale it uniformly we can put a single value after the 
scale keyword rather than a vector of x,y,z scale factors.

Look through the file TEXTURES.INC to see what pigments and finishes are 
defined and try them out. Just insert the name of the new pigment where 
DMFWood1 is now or try a different finish in place of Shiny and re-render 
your file. 

Here is an example of using a complete texture identifier rather than just 
the pieces.

	 sphere {
	<0, 1, 2>, 2
	texture { PinkAlabaster }
	 }


4.3	MORE SHAPES
-----------------

So far, we've just used the sphere shape. There are many other types of 
shapes that can be rendered by POV-Ray.  First let's make some room in the 
image by changing the sphere from a radius of 2 to a radius of 1 like this:

	 sphere {
	<0, 1, 2>, 1 
	texture { ... and so on.


4.3.1 PLANE OBJECT

Let's try out a computer graphics standard - "The Checkered Floor."  Add 
the following object to your .pov file:

	 plane {
	<0, 1, 0>, 0 
	pigment {
	  checker
		color Red
		color Blue
	}
	 }

The object defined here is an infinite plane. The vector <0, 1, 0> is the 
surface normal of the plane (i.e., if you were standing on the surface, the 
normal points straight up.) The number afterward is the distance that the 
plane is displaced along the normal from the origin - in this case, the 
floor is placed at Y=0 so that the sphere at Y=1, radius= 1, is resting on 
it. 

Notice that there is no "texture{...}" statement.  There really is an 
implied texture there.  You might find that continually typing statements 
that are nested like "texture {pigment {...}}" can get to be a tiresome so 
POV-Ray lets you leave out the "texture{...}" under many circumstances.  In 
general you only need the texture block surrounding a texture identifier 
(like the PinkAlabaster example above), or when creating layered textures 
(which are covered later).  

This pigment uses the checker color pattern and specifies that the two 
colors red and blue should be used.

Because the vectors <1,0,0>, <0,1,0> and <0,0,1> are used frequently, POV-
Ray has 3 built-in vector identifiers "x", "y", and "z" respectively that 
can be used as shorthand.  Thus the plane could be defined as:

	 plane { 
	y,0 
	pigment {... etc.

Note that you do not use angle brackets around vector identifiers.

Looking at the floor, you'll notice that the ball casts a shadow on the 
floor. Shadows are calculated very accurately by the ray tracer and creates 
precise, sharp shadows.  In the real world, penumbral or "soft" shadows are 
often seen. Later you'll learn how to use extended light sources to soften 
the shadows.


4.3.2 BOX OBJECT

There are several other simple shapes available in POV-Ray.  The most 
common are the box, cylinder and cone.  Try these examples in place of the 
sphere:

	 box {
	<-1,0  ,-1>,	// Near lower left corner
	< 1,0.5, 3>	// Far upper right corner
	pigment {
	  DMFWood4	// Pre-defined from textures.inc 
	  scale 4	// Scale by the same amount in all
			// directions
	}
	rotate y*20	// Equivalent to "rotate <0,20,0>"
	 }

In this example you can see that a box is defined by specifying the 3D 
coordinates of opposite corners.  The first vector must be the minimum 
x,y,z coordinates and the 2nd vector must be the maximum x,y,z values.  Box 
objects can only be defined parallel to the axes.  You can later rotate 
them to any angle.  Note that you can perform simple math on values and 
vectors.  In the rotate parameter we multiplied the vector identifier "y" 
by 20.  This is the same as "<0,1,0>*20" or "<0,20,0>".  


4.3.3 CONE OBJECT

Here's another example:

	 cone {
	<0,1,0>,0.3	// Center and radius of one end
	<1,2,3>,1.0	// Center and radius of other end
	pigment {DMFWood4  scale 4 }
	finish {Shiny}  
	 }

The cone shape is defined by the center and radius of each end.  In this 
example one end is at location <0,1,0> and has radius of 0.3 while the 
other end is centered at <1,2,3> with radius 1.  If you want the cone to 
come to a sharp point then use a 0 radius.  The solid end caps are parallel 
to each other and perpendicular to the cone axis.  If you want a hollow 
cone with no end caps then add the keyword "open" after the 2nd radius like 
this:

	 cone {
	<0,1,0>,0.3	// Center and radius of one end
	<1,2,3>,1.0	// Center and radius of other end
	open		// Removes end caps
	pigment {DMFWood4  scale 4 }
	finish {Shiny}  
	 }


4.3.4 CYLINDER OBJECT

You may also define a cylinder like this:

	 cylinder {
	<0,1,0>,	// Center of one end
	<1,2,3>,	// Center of other end
	0.5		// Radius
	open		// Remove end caps
	pigment {DMFWood4  scale 4 }
	finish {Shiny}  
	 }

Finally the standard include file "shapes.inc" contains some pre-defined 
shapes that are about the size of a sphere with a radius of one unit.  You 
can invoke them like this:

	 object {
	UnitBox
	pigment {DMFWood4  scale 4 }
	finish {Shiny}  
	scale 0.75
	rotate <-20,25,0>
	translate y
	 }

That's the end of our brief tutorial.  We've only scratched the surface.  
The rest of this document provides a reference to all of POV-Ray's 
features.


5.0	SCENE DESCRIPTION LANGUAGE REFERENCE
==========================================

The Scene Description Language allows the user to describe the world in a 
readable and convenient way.  Files are created in plain ASCII text using 
an editor of your choice.  POV-Ray reads the file, processes it by creating 
an internal model of the scene and the renders the scene.


5.1	LANGUAGE BASICS
---------------------

The POV-Ray language consists of identifiers, reserved keywords, floating 
point literals, string literals, special symbols and comments.  The text of 
a POV-Ray scene file is free format.  You may put statements on separate 
lines or on the same line as you desire.  You may add blank lines, spaces 
or indentations as long as you do not split any keywords or identifiers.


5.1.1 IDENTIFIERS AND KEYWORDS

POV-Ray allows you to define identifiers for later use in the file.  An 
identifier may be 1 to 40 characters long.  It may consist of upper or 
lower case letters, the digits 0 through 9 or an underscore character.  The 
first character must be an alphabetic character.  The declaration of 
identifiers is covered later.

POV-Ray has a number of reserved words which are used in the language.  All 
reserved words are fully lower case.  Therefore it is recommended that your 
identifiers contain at least 1 upper case character so it is sure to avoid 
conflict with reserved words.

The following keywords are reserved in POV-Ray:

adaptive		height_field		rgbf		  
agate		  	hexagon			right		 
agate_turb		iff			ripples		
all			image_map		rotate		
alpha		  	include			roughness		
ambient			interpolate		scale		 
area_light		intersection		sky			
background		inverse			smooth		
bicubic_patch	  	ior			smooth_triangle	
blob			jitter		 	specular		 
blue			lambda		 	sphere		
bounded_by		leopard			spotlight		
box			light_source		spotted		
bozo			location		sturm		 
brilliance		looks_like		texture		
bumps		  	look_at			tga			
bump_map		mandel		 	threshold		
bump_size		map_type		tightness		
camera		 	marble		 	tile2		 
checker			material_map		tiles		 
clipped_by		max_intersections	torus		 
clock		  	max_trace_level		translate		
color		  	merge		  	triangle		 
color_map		metallic		turbulence		
colour		 	normal		 	type		  
colour_map		no_shadow		union		 
component		object		 	up			
composite		octaves			use_color		
cone			omega		  	use_colour		
crand		  	once			use_index		
cubic		  	onion		  	u_steps		
cylinder		open			version		
declare			phase		  	v_steps		
default			phong		  	water_level		
dents		  	phong_size		waves		 
difference		pigment			wood		  
diffuse			plane		  	wrinkles		 
direction		point_at		x			
disc			poly			y			
distance		pot			z			
dump			quadric		
falloff			quartic		
filter		 	quick_color		
finish		 	quick_colour	  
flatness		radial		
fog			radius		
frequency		raw			
gif			red			
gradient		reflection		
granite			refraction		
green		  	rgb			
			
			
5.1.2 COMMENTS

Comments are text in the scene file included to make the scene file easier 
to read or understand. They are ignored by the ray tracer and are there for 
humans to read.  There are two types of comments in POV-Ray.

Two slashes are used for single line comments.  Anything on a line after a 
double slash // is ignored by the ray tracer.  For example:

  // This line is ignored

You can have scene file information on the line in front of the comment, as 
in:

  object { FooBar }  // this is an object

The other type of comment is used for multiple lines.  This type of comment 
starts with /* and ends with */ everything in-between is ignored.  For 
example:

/* These lines
	Are ignored 
	By the
	Raytracer */

This can be useful if you want to temporarily remove elements from a scene 
file.	/*...*/ comments can "comment out" lines containing the other // 
comments, and thus can be used to temporarily or permanently comment out 
parts of a scene.  /*..*/ comments can be nested, the following is legal:

/* This is a comment
	// This too
	/* This also */
 */

Use comments liberally and generously. Well used, they really improve the 
readability of scene files.


5.1.3 INCLUDE FILES

The language allows include files to be specified by placing the line:

	#include "filename.inc"

at any point in the input file. The filename must be enclosed in double 
quotes and may be up to 40 characters long (or your computer's limit), 
including the two double-quote (") characters. 

The include file is read in as if it were inserted at that point in the 
file. Using include is the same as actually cutting and pasting the entire 
contents of this file into your scene. 

Include files may be nested. You may have at most 10 nested include files.  
There is no limit on un-nested include files.

Generally, include files have data for scenes, but are not scenes in 
themselves. By convention scene files end in .pov and include files end 
with .inc.


5.1.4 FLOAT EXPRESSIONS

Many parts of the POV-Ray language require you to specify one or more 
floating point numbers.  A floating point number is a number with a decimal 
point.  Float literals are represented by an optional sign (-), some 
digits, an optional decimal point, and more digits.  If the number is an 
integer you may omit the decimal point and trailing zero.  If it is all 
fractional you may omit the leading zero.  POV-Ray supports scientific 
notation for very large or very small numbers.  The following are all valid 
float literals:

	 1.0	-2.0  -4	34	3.4e6	2e-5	.3	0.6

Float identifiers may be declared and used anywhere a float can be used.  
See section 5.1.7 on declaring identifiers.  

Complex float expressions can be created using + - * / ( ) with float 
literals or identifiers.  Assuming the identifiers have been previously 
declared as floats, the following are valid float expressions:

	 1+2+3	2*5	 1/3	 Row*3	Col*5

	 (Offset-5)/2		This/That+Other*Thing

Expressions are evaluated left to right with innermost parenthesis 
evaluated first, then unary + or -, then multiply or divide, then add or 
subtract.

There are two built-in float identifiers.  The identifier "version" is the 
current setting of the version compatibility switch (See +MV under command-
line switches).  This allows you to save and restore the previous version 
switch.  For example suppose MYSTUFF.INC is in version 1.0 format.  At the 
top of the file you could put:

  #declare Temp_Vers = version	// Save previous value
  #version 1.0			// Change to 1.0 mode

  ...	// Version 1.0 stuff goes here...

  #version Temp_Vers		 // Restore previous version

The other float identifier is "clock".  Its value is set by the +K command-
line switch. (See +K under command-line switches).  This allows you to do 
limited animation control.  For example you could move an object using:

	translate <0.1*clock,0,0>

and render successive frames with +K1, +K2, +K3 etc.  In each frame the 
object would move 1/10th of a unit.


5.1.5 VECTOR EXPRESSIONS

POV-Ray operates in a 3D x,y,z coordinate system.  Often you will need to 
specify x, y and z values.  A "vector" is a set of three float values used 
for such specification.  Vectors consist of three float expressions that 
are bracketed by angle brackets < and >.  The three terms are separated by 
commas.  For example:

	< 1.0, 3.2, -5.4578 >

The commas are necessary to keep the program from thinking that the 2nd 
term is "3.2-5.4578" and that there is no 3rd term.  If you see an error 
message "Float expected but '>' found instead" it probably means two floats 
were combined because a comma was missing.

The three values correspond to the x, y and z directions respectively. For 
example, the vector <1,2,3> means the point that's 1 unit to the right, 2 
units up, and 3 units in front the center of the "universe" at <0,0,0>. 
Vectors are not always points, though. They can also refer to an amount to 
size, move, or rotate a scene element.

Vectors may also be combined in expressions the same as float values.  For 
example <1,2,3>+<4,5,6> evaluates as <5,7,9>.  Subtraction, multiplication 
and division are also performed on a term-by-term basis.  You may also 
combine floats with vectors.  For example 5*<1,2,3> evaluates as <5,10,15>.

Sometimes POV-Ray requires you to specify floats and vectors side-by-side.  
Thus commas are required separators whenever an ambiguity might arise.  For 
example <1,2,3>-4 evaluates as <-3,-2,-1> but <1,2,3>,-4 is a vector 
followed by a float.

Vector identifiers may be declared and used anywhere a vector can be used.  
See section 5.1.7 on declaring identifiers.

Because vectors almost always refer to the x, y and z coordinates, POV-Ray 
has three built-in vector identifiers "x "y" and "z".  Like all POV-Ray 
keywords they must be lower case.  The vector identifier x is equivalent to 
the vector <1,0,0>.  Similarly y is <0,1,0> and z is <0,0,1>.

Thus an expression like 5*x evaluates to 5*<1,0,0> or <5,0,0>.  The use of 
these identifiers can make the scene file easier to read.


5.1.6 TRANSFORMATIONS

Vectors are used not only as a notation for a point in space but are used 
in the transformations scale, rotate, and translate. Scale sizes a texture 
or object. Translate moves a texture or object. And rotate turns a texture 
or object.


5.1.6.1	Translate

An object or texture pattern may be moved by adding a "translate" 
parameter.  It consists of the keyword "translate" followed by a vector.  
The terms of the vector specify the number of units to move in each of the 
x, y, and z directions.  Translate moves the element relative to it's 
current position. For example,

  sphere { <10, 10, 10>, 1 
	pigment { Green }
	translate <-5, 2, 1>
  }

Will move the sphere from <10, 10, 10> to <5, 12, 11>.  It does not move it 
to absolute location <5, 2, 1>. Translating by zero will leave the element 
unchanged on that axis. For example,

  sphere { <10, 10, 10>, 1 
	pigment { Green }
	translate <0, 0, 0>
  }

Will not move the sphere at all.


5.1.6.2	Scale

You may change the size of an object or texture pattern by adding a "scale" 
parameter.  It consists of the keyword "scale" followed by a vector or a 
single float value.  If a vector is used, terms of the vector specify the 
amount of scaling in each of the x, y, and z directions.  If a float value 
is used, the item is uniformly scaled by the same amount in all directions.

Scale, is used to "stretch" or "squish" an element. Values larger than 1 
stretch the element on that axis. Values smaller than one are used to 
squish the element on that axis. Scale is relative to the current element 
size. If the element has been previously re-sized using scale, then scale 
will size relative to the new size. Multiple scale values may used.


5.1.6.3	Rotate

You may change the orientation of an object or texture pattern by adding a 
"rotate" parameter.  It consists of the keyword "rotate" followed by a 
vector.  The three terms of the vector specify the number of degrees to 
rotate about each of the x, y, and z axes.  

Note that the order of the rotations does matter.  Rotations occur about 
the x axis first, then the y axis, then the z axis.  If you are not sure if 
this is what you want then you should use multiple rotation statements to 
get a correct rotation. You should only rotate on one axis at a time. As 
in,

	rotate <0, 30, 0>  // 30 degrees around Y axis then,
	rotate <-20, 0, 0> // -20 degrees around X axis then,
	rotate <0, 0, 10>  // 10 degrees around Z axis.

Rotation is always performed relative to the axis.  Thus if an object is 
some distance from the axis of rotation, its will not only rotate but it 
will "orbit" about the axis as though it was swinging around on an 
invisible string.  

To work out the rotation directions, you must perform the famous "Computer 
Graphics Aerobics" exercise. Hold up your left hand. Point your thumb in 
the positive direction of the axis of rotation. Your fingers will curl in 
the positive direction of rotation. Similarly if you point your thumb in 
the negative direction of the axis your fingers will curl in the negative 
direction of rotation.  This is the famous "left-hand coordinate system". 

		^
	      +Y|   +Z/ _
		|    /_| |_  _
		|   _| | | |/ \
		|  | | | | |  |
		| /| | | | |  V
	-X	|/ | | | | |	+X
     <----------+--|-|-|-|-|------>
	       /|  |	   \____
	      / |  |	     ___|
	     /  |  \	    /
	    /	|  |  	   /
	 -Z/  -Y|
	  /	|

In this illustration, the left hand is curling around the X axis. The thumb 
points in the positive X direction and the fingers curl over in the 
positive rotation direction.

If you want to use a right hand system, as some CAD systems such as AutoCAD 
do, the "right" vector in the camera specification needs to be changed. See 
the detailed description of the camera.  In a right handed system you use 
your right hand for the "Aerobics". 


5.1.6.4	Transforming Textures and Objects

When an object is transformed, all textures attached to the object AT THAT 
TIME are transformed as well. This means that if you have a translate, 
rotate, or scale in an object BEFORE a texture, the texture will not be 
transformed. If the scale, translate, or rotate is AFTER the texture then 
the texture will be transformed with the object.  If the transformation is 
INSIDE the "texture { }" statement then ONLY THE TEXTURE is affected.  The 
shape remains the same.  For example:

	sphere { <0, 0, 0>, 1
	texture { White_Marble }  // texture identifier from TEXTURES.INC
	scale 3			// This scale affects both the 
				// shape and texture 
	}

	sphere { <0, 0, 0>, 1
	scale 3		// This scale affects the shape only
	texture { White_Marble }  
	}

	sphere { <0, 0, 0>, 1
	texture { 
	White_Marble	 
	scale 3		// This scale affects the texture only
	}  
	}

Transformations may also be independently applied to pigment patterns and 
surface normal (bump) patterns.  Note scaling a normal pattern affects only 
the width and spacing.  It does not affect the height or depth.  For 
example:

	box { <0, 0, 0>, <1, 1, 1>
	texture { 
	pigment {
	 checker color Red color White
	 scale 0.25  // This affects only the color pattern
	}
	normal {
	 bumps 0.3	// This specifies apparent height of bumps
	 scale 0.2	// Scales diameter and space between bumps but not 
			//  not the height. Has no effect on color pattern.
	}
	rotate y*45	// This affects the entire texture but not
	}		//  the object. 
	}


5.1.6.5	Transformation Order

Because rotations are always relative to the axis and scaling is relative 
to the origin, you will generally want to create an object at the origin 
and scale and rotate it first.  Then you may translate it into its proper 
position.  It is a common mistake to carefully position an object and then 
to decide to rotate it.  Because a rotation of an object causes it to orbit 
the axis, the position of the object may change so much that it orbits out 
of the field of view of the camera!

Similarly scaling after translation also moves an object unexpectedly. If 
you scale after you translate, the scale will multiply the translate 
amount. For example:

  translate <5, 6, 7>
  scale 4 

Will translate to 20, 24, 28 instead of 5, 6, 7. Be careful when 
transforming to get the order correct for your purposes.


5.1.7 DECLARE

The parameters used to describe the scene elements can be tedious to use at 
times. Some parameters are often repeated and it seems wasteful to have to 
type them over and over again. To make this task easier, the program allows 
users to create identifiers as synonyms for a pre-defined set of parameters 
and use them anywhere the parameters would normally be used. For example, 
the color white is defined in the POV-Ray language as:

	color red 1 green 1 blue 1

This can be pre-defined in the scene as:

	#declare White = color red 1 green 1 blue 1

and then substituted for the full description in the scene file, for 
example:

	sphere { 
	<0, 0, 0>, 1
	pigment { color red 1 green 1 blue 1 }
	}

becomes:

	#declare White = color red 1 green 1 blue 1

	sphere { 
	<0, 0, 0>, 1
	pigment { color White }
	}

This is much easier to type and to read. The pre-defined element may be 
used many times in a scene.

You use the keyword "declare" to pre-define a scene element and give it a 
one-word identifier. This pre-defined scene element is not used in the 
scene until you invoke its identifier. Textures, objects, colors, numbers 
and more can be predefined.

In most cases when you invoke an identifier you simply use the form 
"keyword{identifier}" where the keyword used is the type of statement that 
was declared. For example:

  #declare Shiny = finish {phong 0.8 phong_size 50 reflection 0.2}

  sphere {
	<0, 0, 0>, 1
	pigment { color White }
	finish { Shiny }
	}

The identifier "Shiny" was declared as a "finish" and is invoked by placing 
it inside a "finish { }" statement.

One exception is object identifiers.  If you declare any object of any kind 
such as sphere, box, union, intersection etc. you should invoke it by 
placing it in an "object { }" statement.  Thus you might have:

  #declare Thing = intersection {...}

  object {Thing}  // not "intersection{Thing}"

Pre-defined elements may be modified when they are used, for example:

  #declare Mickey = // Pre-define a union object called Mickey
	union {
	sphere { < 0, 0, 0>, 2 }
	sphere { <-2, 2, 0>, 1 }
	sphere { < 2, 2, 0>, 1 }
	}

  // Use Mickey
	object{	// Note use of "object", not "union" keyword
	Mickey
	scale 3
	rotate y*20
	translate <0, 8, 10>
	pigment {color red 1}
	finish {phong .7}
	}

This scene will only have one "Mickey", the Mickey that is described 
doesn't appear in the scene. Notice that Mickey is scaled, rotated, 
translated, and a texture is added to it. The Mickey identifier could be 
used many times in a scene file, and each could have a different size, 
position, orientation, and texture.

Declare is especially powerful when used to create a complex object. Each 
part of the object is defined separately using declare. These parts can be 
tested, rotated, sized, positioned, and textured separately then combined 
in one shape or object for the final sizing, positioning, etc. For example, 
you could define all the parts of a car like this:

  #declare Wheel = object {...}
  #declare Seat = object {...}
  #declare Body = object {...}
  #declare Engine = object {...}
  #declare Steering_Wheel = object {...}

  #declare Car = 
	union {
	object { Wheel translate < 1, 1, 2>}
	object { Wheel translate <-1, 1, 2>}
	object { Wheel translate < 1, 1,-2>}
	object { Wheel translate <-1, 1,-2>}
	object { Seat translate < .5, 1.4, 1>}
	object { Seat translate <-.5, 1.4, 1>}
	object { Steering_Wheel translate <-.5, 1.6, 1.3>}
	object { Body texture { Brushed_Steel } }
	object { Engine translate <0, 1.5, 1.5> 
	}

and then it like this:
 
  // Here is a car
  object {
	Car 
	translate <4, 0, 23>
  }

Notice that the Wheel and Seat are used more than once. A declared element 
can be used as many times as you need. Declared elements may be placed in 
"include" files so they can be used with more than one scene.

There are several files included with POV-Ray that use declare to pre-
define many shapes, colors, and textures. See the archive INCLUDE for more 
info.

NOTE: Declare is not the same as the C language's define. Declare creates 
an internal object of the type specified that POV-Ray can copy for later 
use.  The "define" used in C creates a text substitution macro.

Here's a list of what can be declared, how to declare the element, and how 
to use the declaration. See the reference section for element syntax.

Objects: (Any type may be declared, sphere, box, height_field, blob, etc.)
  #declare Tree = union {...}
  #declare Ball = sphere {...}
  #declare Crate= box {...}
 
  object {
	Tree
	(OBJECT_MODIFIERS...) 
  }

  object {
	Ball
	(OBJECT_MODIFIERS...) 
  }

  object {
	Crate
	(OBJECT_MODIFIERS...) 
  }

Textures:
  #declare Fred = texture {...} 

  sphere { <0, 0, 0>, 1 
	texture {
	 Fred 
	 (texture_modifiers) 
	}
  }

Layered textures:
  #declare Fred = 
	texture {...} 
	texture {...} 
	texture {...} (etc.)

  sphere { <0, 0, 0>, 1 
	texture {
	 Fred 
	 (texture_modifiers) 
	}
  }

Pigment:
  #declare Fred = pigment {checker color Red color White} 

  sphere { <0, 0, 0>, 1 
	pigment {
	 Fred 
	 (pigment_modifiers) 
	}
  }

Normal:
  #declare Fred = normal {bumps 0.5} 

  sphere { <0, 0, 0>, 1 
	pigment {White}
	normal {
	 Fred 
	 (normal_modifiers) 
	}
  }

Finish:
  #declare Fred = finish {phong 0.7 reflection 0.2} 

  sphere { <0, 0, 0>, 1 
	pigment {White}
	finish {
	 Fred 
	 (finish_items) 
	}
  }

Colors:
  #declare Fred = color red 1 green 1 blue 1 

  sphere { <0, 0, 0>, 1 
	pigment { color Fred }
  }

Color_map:
  #declare Rainbow = 
	color_map {
	 [0.0 color Cyan]
	 [1/3 color Yellow]
	 [2/3 color Magenta]
	 [1.0 color Cyan]
	}

  sphere { <0, 0, 0>, 1 
	pigment { radial color_map{Rainbow} rotate -90*x}
  }

Float Values:
  #declare Fred  = 3.45
  #declare Fred2 = .02
  #declare Fred3 = .5

 // Use the numeric value identifier 
 // anywhere a number would go
  sphere { <-Fred, 2, Fred>, Fred 
	pigment { color red 1 }
	finish { phong Fred3 }
  }

Camera:
  #declare Fred = camera {..}

  camera { Fred }

Vectors:
	#declare Fred = <9, 3, 2>
	#declare Fred2 = <4, 1, 4>

	sphere { Fred, 1  // Note do not put < > brackets
	scale Fred2	// around vector identifiers
	}


5.2	OBJECTS
-------------

Objects are the building blocks of your scene.  There are 20 different 
types of objects supported by POV-Ray.  Seven of them are finite solid 
primitives, 4 are finite patch primitives, 5 are infinite solid polynomial 
primitives, 3 are types of Constructive Solid Geometry types and one is a 
specialized object that is a light source.

The basic syntax of an object is a keyword describing its type, some 
floats, vectors or other parameters which further define its location 
and/or shape and some optional object modifiers such as texture, pigment, 
normal, finish, bounding, clipping or transformations.

The texture describes what the object looks like, ie. its material.  
Textures are combinations of pigments, normals and finishes.  Pigment is 
the color or pattern of colors inherent in the material.  Normal is a 
method of simulating various patterns of bumps, dents, ripples or waves by 
modifying the surface normal vector.  Finish describes the reflective and 
refractive properties of a material.

Bounding shapes are finite, invisible shapes which wrap around complex, 
slow rendering shapes in order to speed up rendering time.  Clipping shapes 
are used to cut away parts of shapes to expose a hollow interior.  
Transformations tell the ray tracer how to move, size or rotate the shape 
and/or the texture in the scene.


5.2.1 SOLID FINITE PRIMITIVES

There are 7 different solid finite primitive shapes: blob, box, cone, 
cylinder, height_field, sphere, and torus. These have a well-defined 
"inside" and can be used in Constructive Solid Geometry. Because these 
types are finite, POV-Ray can use automatic bounding on them to speed up 
rendering time.  


5.2.1.1	Spheres

Since spheres are so common in ray traced graphics, POV-Ray has a highly 
optimized sphere primitive which renders much more quickly than the 
corresponding polynomial quadric shape. The syntax is:

	sphere { <CENTER>, RADIUS }

Where <CENTER> is a vector specifying the x,y,z coordinates of the center 
of the sphere and RADIUS is a float value specifying the radius.  You can 
also add translations, rotations, and scaling to the sphere. For example, 
the following two objects are identical:

  sphere { <0, 25, 0>, 10
	pigment {Blue}
  }

  sphere { <0, 0, 0>, 1.0
	pigment {Blue}
	scale 10
	translate y*25
  }

Note that Spheres may be scaled unevenly giving an ellipsoid shape. 

Because spheres are highly optimized they make good bounding shapes. 
Because they are finite they respond to automatic bounding. As with all 
shapes, they can be translated, rotated and scaled.


5.2.1.2	Boxes

A simple box can be defined by listing two corners of the box like this:

  box { <CORNER1>, <CORNER2> }

Where <CORNER1> and <CORNER2> are vectors defining the x,y,z coordinates of 
opposite corners of the box.  For example:

  box { <0, 0, 0>, <1, 1, 1> }

Note that all boxes are defined with their faces parallel to the coordinate 
axes.  They may later be rotated to any orientation using a rotate 
parameter.

Each element of CORNER1 should always be less than the corresponding 
element in CORNER2. If any elements of CORNER1 are larger than CORNER2, the 
box will not appear in the scene.

Boxes are calculated efficiently and make good bounding shapes. Because 
they are finite they respond to automatic bounding. As with all 
shapes, they can be translated, rotated and scaled.


5.2.1.3	Cylinders

A finite length cylinder with parallel end caps may be defined by.

	cylinder { <END1>, <END2>, RADIUS }

Where <END1> and <END2> are vectors defining the x,y,z coordinates of the 
center of each end of the cylinder and RADIUS is a float value for the 
radius.  For example:

	cylinder { <0,0,0>, <3,0,0>, 2}

is a cylinder 3 units long lying along the x axis from the origin to x=3 
with a radius of 2.

Normally the ends of a cylinder are closed by flat planes which are 
parallel to each other and perpendicular to the length of the cylinder.  
Adding the optional keyword "open" after the radius will remove the end 
caps and results in a hollow tube.

Because they are finite they respond to automatic bounding. As with all 
shapes, they can be translated, rotated and scaled.


5.2.1.4	Cones

A finite length cone or a frustum (a cone with the point cut off) may be 
defined by.

	cone { <END1>, RADIUS1, <END2>, RADIUS2 }

Where <END1> and <END2> are vectors defining the x,y,z coordinates of the 
center of each end of the cone and RADIUS1 and RADIUS2 are float values for 
the radius of those ends.  For example:

	cone { <0,0,0>,2 <0,3,0>, 0}

is a cone 3 units tall pointing up the y axis from the origin to y=3.  The 
base has a radius of 2.  The other end has a radius of 0 which means it 
comes to a sharp point.  If neither radius is zero then the results look 
like a tapered cylinder or a cone with the point cut off.

Like a cylinder, normally the ends of a cone are closed by flat planes 
which are parallel to each other and perpendicular to the length of the 
cone.  Adding the optional keyword "open" after RADIUS2 will remove the end 
caps and results in a tapered hollow tube like a megaphone or funnel.

Because they are finite they respond to automatic bounding. As with all 
shapes, they can be translated, rotated and scaled.


5.2.1.5	Torus

A torus is a 4th order quartic polynomial shape that looks like a donut or 
inner tube.  Because this shape is so useful and quartics are difficult to 
define, POV-Ray lets you take a short-cut and define a torus by:

	torus { MAJOR, MINOR }

where MAJOR is a float value giving the major radius and MINOR is a float 
specifying the minor radius.  The major radius extends from the center of 
the hole to the mid-line of the rim while the minor radius is the radius of 
the cross-section of the rim.  The torus is centered at the origin and lies 
in the X-Z plane with the Y-axis sticking through the hole.

   ----------- - - - - - - - ----------		+Y	
  /	     \		    /	       \	|	
 /	      \		   /	        \	|	
|	       |	  |	  |<-B-->| -X---|---+X  
 \	      /		   \	        /	|	
  \__________/_ _ _ _ _ _ _ \__________/	|	
		    |<-----A----->|		-Y	

	 A = Major Radius
	 B = Minor Radius

Internally the torus is computed the same as any other quartic or 4th order 
polynomial however a torus defined this way will respond to automatic 
bounding while a quartic must be manually bound if at all.  As with all 
shapes, a torus can be translated, rotated and scaled.  Calculations for 
all higher order polynomials must be very accurate.  If this shape renders 
improperly you may add the keyword "sturm" after the MINOR value to use 
POV-Ray's slower-yet-more-accurate Sturmian root solver.


5.2.1.6	Blob

Blobs are an interesting shape type. Their components are "flexible" 
spheres that attract or repel each other creating a "blobby" organic 
looking shape. The spheres' surfaces actually stretch out smoothly and 
connect, as if coated in silly putty (honey? glop?) and pulled apart.

Picture each blob component as a point floating in space.  Each point has a 
field around it that starts very strong at the center point and drops off 
to zero at some radius. POV-Ray adds together the field strength of each 
component and looks for the places that the strength of the field is 
exactly the same as the "threshold" value that was specified.  Points with 
a total field strength greater than the threshold are considered inside the 
blob.  Those less than the threshold are outside.  Points equal to the 
threshold are on the surface of the blob.

A blob is defined as follows:

  blob {
	threshold THRESHOLD_VALUE
	component STRENGTH, RADIUS, <CENTER>
	component STRENGTH, RADIUS, <CENTER>  // Repeat for any number  
	component STRENGTH, RADIUS, <CENTER>  //  of components	 
  }

The keyword "threshold" is followed by a float THRESHOLD_VALUE.  Each 
component begins with the keyword "component".  STRENGTH is a float value 
specifying the field strength at its center.  The strength may be positive 
or negative. A positive value will make that component attract other 
components. Negative strength will make that component repel other 
components. Components in different, separate blob shapes do not affect 
each other.  The strength tapers off to zero at the value specified by the 
float RADIUS.  The vector <CENTER> specifies the x,y,z coordinates of the 
component. For example:

  blob {
	threshold 0.6
	component 1.0, 1.0, <.75, 0, 0>
	component 1.0, 1.0, <-.375, .64952, 0>
	component 1.0, 1.0, <-.375, -.64952, 0>
	scale 2 
  }

If you have a single blob component then the surface you see will look just 
like a sphere, with the radius of the surface being somewhere inside the 
"radius" value you specified for the component. The exact radius of this 
sphere-like surface can be determined from the blob equation listed below 
(you will probably never need to know this, blobs are more for visual 
appeal than for exact modeling).

If you have a number of blob components, then their fields add together at 
every point in space - this means that if the blob components are close 
together the resulting surface will smoothly flow around the components.

The various numbers that you specify in the blob declaration interact in 
several ways.  The meaning of each can be roughly stated as:

THRESHOLD:
	This is the total density value that POV-Ray is looking for. By 
following the ray out into space and looking at how each blob component 
affects the ray, POV-Ray will find the points in space where the density is 
equal to the "threshold" value.

	1) "threshold" must be greater than 0. POV-Ray only looks for positive 
densities.
	2) If "threshold" is greater than the strength of a component, then 
the component will disappear.
	3) As "threshold" gets larger the surface you see gets closer to the 
centers of the components.
	4) As "threshold" gets smaller, the surface you see gets closer to the 
spheres at a distance of "radius" from the centers of the components.

STRENGTH:
	Each component has a strength value - this defines the density of the 
component at the center of the component. Changing this value will usually 
have only a subtle effect.

	1) "strength" may be positive or negative. Zero is a bad value, as the 
net result is that no density was added - you might just as well have not 
used this component.
	2) If "strength" is positive, then POV-Ray will add its density to the 
space around the center of the component. If this adds enough density to be 
greater than "threshold you will see a surface.
	3) If "strength" is negative, then POV-Ray will subtract its density 
from the space around the center of the component. This will only do 
something if there happen to be positive components nearby. What happens is 
that the surface around any nearby positive components will be dented away 
from the center of the negative component.

RADIUS: 
	Each component has a radius of influence. The component can only 
affect space within "radius" of its center. This means that if all of the 
components are farther than "radius" from each other, you will only see a 
bunch of spheres.  If a component is within the radius of another 
component, then the two components start to affect each other. At first 
there is only a small bulge outwards on each of the two components, as they 
get closer they bulge more and more until they attach along a smooth neck.  
If the components are very close (i.e. their centers are on top of each 
other), then you will only see a sphere (this is just like having a 
component of more strength. bigger than the size of each of the component 
radii)
	1) "radius" must be bigger than 0.
	2) As "radius" increases the apparent size of the component will 
increase.

CENTER:
	This is simply a point in space.  It defines the center of a blob 
component.  By changing the x/y/z values of the center you move the 
component around.

THE FORMULA
	For the more mathematically minded, here's the formula used internally 
by POV-Ray to create blobs. You don't need to understand this to use blobs. 

The formula used for a single blob component is:

	 density = strength * (1 - radius^2)^2

This formula has the nice property that it is exactly equal to strength" at 
the center of the component and drops off to exactly 0 at a distance of 
"radius" from the center of the component. The density formula for more 
than one blob component is just the sum of the individual component 
densities:

	 density = density1 + density2 + ...

Blobs can be used in CSG shapes and they can be scaled, rotated and 
translated. Because they are finite they respond to automatic bounding.  
The calculations for blobs must be very accurate.  If this shape renders 
improperly you may add the keyword "sturm" after the last component to use 
POV-Ray's slower-yet-more-accurate Sturmian root solver.


5.2.1.7	Height Fields

Height fields are fast, efficient objects that are generally used to create 
mountains or other raised surfaces out of hundreds of triangles in a mesh.  

A height field is essentially a 1 unit wide by 1 unit long box with a 
mountainous surface on top.  The height of the mountain at each point is 
taken from the color number (palette index) of the pixels in a graphic 
image file. 


		    ________  <---- image index 255
		  /  	    /|
	     +1y  ---------- |
		 |	   | |
		 |	   | |+1z <- Image upper-right
		 |	   | /
	     0,0,0---------- +1x
		 ^
		 |____ Image lower-left


	NOTE: Image resolution is irrelevant to the scale of the heightfield.

The mesh of triangles corresponds directly to the pixels in the image file. 
In fact, there are two small triangles for every pixel in the image file. 
The Y (height) component of the triangles is determined by the palette 
index number stored at each location in the image file. The higher the 
number, the higher the triangle. The maximum height of an un-scaled height 
field is 1 unit.

The higher the resolution of the image file used to create the height 
field, the smoother the height field will look. A 640 X 480 GIF will create 
a smoother height field than a 320 x 200 GIF.  The size/resolution of the 
image does not affect the size of the height field. The un-scaled height 
field size will always be 1x1. Higher resolution image files will create 
smaller triangles, not larger height fields.

There are three types files which can define a height field as follows:

	height_field { gif "filename.gif" }
	height_field { tga "filename.tga" }
	height_field { pot "filename.pot" }

The image file used to create a height field can be a GIF, TGA or POT 
format file. The GIF format is the only one that can be created using a 
standard paint program.

In a GIF file, the color number is the palette index at a given point. Use 
a paint program to look at the palette of a GIF image. The first color is 
palette index zero, the second is index 1, the third is index 2, and so on. 
The last palette entry is index 255. Portions of the image that use low 
palette entries will be lower on the height field.  Portions of the image 
that use higher palette entries will be higher on the height field. For 
example, an image that was completely made up of entry 0 would be a flat 
1x1 square. An image that was completely made up of entry 255 would be a 
1x1x1 cube.

The maximum number of colors in a GIF are 256, so a GIF height field can 
have any number of triangles, but they will only 256 different height 
values. 

The color of the palette entry does not affect the height of the pixel. 
Color entry 0 could be red, blue, black, or orange, but the height of any 
pixel that uses color entry 0 will always be 0. Color entry 255 could be 
indigo, hot pink, white, or sky blue, but the height of any pixel that uses 
color entry 255 will always be 1.

You can create height field GIF images with a paint program or a fractal 
program like "Fractint".  If you have access to an IBM-PC, you can get 
Fractint from most of the same sources as POV-Ray.

A POT file is essentially a GIF file with a 16 bit palette. The maximum 
number of colors in a POT file is greater than 32,000. This means a POT 
height field can have over 32,000 possible height values. This makes it 
possible to have much smoother height fields. Note that the maximum height 
of the field is still 1 even though more intermediate values are possible.

At the time of this writing, the only program that created POT files was a 
freeware IBM-PC program called Fractint. POT files generated with this 
fractal program create fantastic landscapes. If you have access to an IBM-
PC, you can get Fractint from most of the same sources as POV-Ray.

The TGA file format may be used as a storage device for 16 bit numbers 
rather than an image file. The TGA format uses the red and green bytes of 
each pixel to store the high and low bytes of a height value. TGA files are 
as smooth as POT files, but they must be generated with special custom-made 
programs. Currently, this format is of most use to programmers, though you 
may see TGA height field generator programs arriving soon.  There is 
example C source code included with the POV-Ray source archive to create a 
TGA file for use with a height field.  

It is nearly impossible to take advantage of the 16 bits of resolution 
offered by the use of tga files in height fields when the tga file is 
created in a paint program.  A gif file is a better choice for paint 
created height fields in 8 bits.  Also see Appendix B.5 for a tip on 
creating tga files for height fields.

An optional "water_level" parameter may be added after the file name.  It 
consists of the keyword "water_level" followed by a float value tells the 
program not to look for the height field below that value. Default value is 
0, and legal values are between 0 and 1. For example, "water_level .5" 
tells POV-Ray to only render the top half of the height field. The other 
half is "below the water" and couldn't be seen anyway. This term comes from 
the popular use of height fields to render landscapes. A height field would 
be used to create islands and another shape would be used to simulate water 
around the islands. A large portion of the height field would be obscured 
by the "water" so the "water_level" parameter was introduced to allow the 
ray-tracer to ignore the unseen parts of the height field. Water_level is 
also used to "cut away" unwanted lower values in a height field. For 
example, if you have an image of a fractal on a solid colored background, 
where the background color is palette entry 0, you can remove the 
background in the height field by specifying, "water_level .001" 

Normally height fields have a rough, jagged look because they are made of 
lots of flat triangles.  Adding the keyword "smooth" causes POV-Ray to 
modify the surface normal vectors of the triangles in such a way that the 
lighting and shading of the triangles will give a smooth look.  This may 
allow you to use a lower resolution file for your height field than would 
otherwise be needed.

Height fields can be used in CSG shapes and they can be scaled, rotated and 
translated. Because they are finite they respond to automatic bounding.  

Here are a notes and helpful hints on height fields from their creator, 
Doug Muir:

The height field is mapped to the x-z plane, with its lower left corner 
sitting at the origin. It extends to 1 in the positive x direction and to 1 
in the positive z direction. It is maximum 1 unit high in the y direction. 
You can translate it, scale it, and rotate it to your heart's content. 

When deciding on what water_level to use, remember, this applies to the un-
transformed height field. If you are a Fractint user, the water_level 
should be used just like the water_level parameter for 3d projections in 
Fractint.

Here's a detailed explanation of how the ray-tracer creates the height 
field. You can skip this if you aren't interested in the technical side of 
ray-tracing. This information is not needed to create or use height fields.

To find an intersection with the height field, the ray tracer first checks 
to see if the ray intersects the box which surrounds the height field. 
Before any transformations, this box's two opposite vertexes are at (0, 
water_level, 0) and (1, 1, 1). If the box is intersected, the ray tracer 
figures out where, and then follows the line from where the ray enters the 
box to where it leaves the box, checking each pixel it crosses for an 
intersection. 

It checks the pixel by dividing it up into two triangles. The height vertex 
of the triangle is determined by the color index at the corresponding 
position in the GIF, POT, or TGA file.

If your file has a uses the color map randomly, your height field is going 
to look pretty chaotic, with tall, thin spikes shooting up all over the 
place. Not every GIF will make a good height field.

If you want to get an idea of what your height field will look like, I 
recommend using the IBM-PC program Fractint's 3d projection features to do 
a sort of preview. If it doesn't look good there, the ray tracer isn't 
going to fix it. For those of you who can't use Fractint, convert the image 
palette to a gray scale from black at entry 0 to white at entry 255 with 
smooth steps of gray in-between. The dark parts will lower than the 
brighter parts, so you can get a feel for how the image will look as a 
height field.


5.2.2 FINITE PATCH PRIMITIVES

There are 4 totally thin, finite objects which have NO well-defined inside.  
They may be combined in CSG union but cannot be use in other types of CSG.  
They are bicubic_patch, disc, smooth_triangle and triangle.  Because these 
types are finite, POV-Ray can use automatic bounding on them to speed up 
rendering time.  


5.2.2.1	Triangle and Smooth_triangle 

The triangle primitive is available in order to make more complex objects 
than the built-in shapes will permit.  Triangles are usually not created by 
hand, but are converted from other files or generated by utilities. 

A triangle is defined by:

	triangle { <CORNER1>, <CORNER2>, <CORNER3> }

where <CORNERn> is a vector defining the x,y,z coordinates of each corner 
of the triangle.

Because triangles are perfectly flat surfaces it would require extremely 
large numbers of very small triangles to approximate a smooth, curved 
surface.  However much of our perception of smooth surfaces is dependent 
upon the way light and shading is done.  By artificially modifying the 
surface normals we can simulate as smooth surface and hide the sharp-edged 
seams between individual triangles. 

The smooth_triangle primitive is used for just such purposes.  The 
smooth_triangles use a formula called Phong normal interpolation to 
calculate the surface normal for any point on the triangle based on normal 
vectors which you define for the three corners.  This makes the triangle 
appear to be a smooth curved surface. A smooth_triangle is defined by:

  smooth_triangle {
	<CORNER1>, <NORMAL1>,
	<CORNER2>, <NORMAL2>,
	<CORNER3>, <NORMAL3>
  }

where the corners are defined as in regular triangles and <NORMALn> is a 
vector describing the direction of the surface normal at each corner.

These normal vectors are prohibitively difficult to compute by hand.  
Therefore smooth_triangles are almost always generated by utility programs.  
To achieve smooth results, any triangles which share a common vertex should 
have the same normal vector at that vertex.  Generally the smoothed normal 
should be the average of all the actual normals of the triangles which 
share that point.


5.2.2.2	Bicubic_patch

A bicubic patch is a 3D curved surface created from a mesh of triangles. 
POV-Ray supports a type of bicubic patch called a Bezier patch.  A bicubic 
patch is defined as follows:

  bicubic_patch { 
	type PATCH_TYPE
	flatness FLATNESS_VALUE
	u_steps NUM_U_STEPS
	v_steps NUM_V_STEPS
	<CP1>,  <CP2>,	<CP3>,	<CP4>,
	<CP5>,  <CP6>,	<CP7>,	<CP8>,
	<CP9>,  <CP10>,  <CP11>,  <CP12>,
	<CP13>, <CP14>,  <CP15>,  <CP16>
  }

The keyword "type" is followed by a float PATCH_TYPE which currently must 
be either 0 or 1.  For type 0 only the control points are retained within 
POV-Ray. This means that a minimal amount of memory is needed, but POV-Ray 
will need to perform many extra calculations when trying to render the 
patch.  Type 1 preprocesses the patch into many subpatches.  This results 
in a significant speedup in rendering, at the cost of memory.

These 4 parameters: type, flatness, u_steps & v_steps, may appear in any 
order.  They are followed by 16 vectors that define the x,y,z coordinates 
of the 16 control points which define the patch.  The patch touches the 4 
corner points <CP1>, <CP4>, <CP13> and <CP16> while the other 12 points 
pull and stretch the patch into shape.

The keywords "u_steps" and "v_steps" are each followed by float values 
which tell how many rows and columns of triangles are the minimum to use to 
create the surface.  The maximum number of individual pieces of the patch 
that are tested by POV-Ray can be calculated from the following:

	sub-pieces = 2^u_steps * 2^v_steps

This means that you really should keep "u_steps" and "v_steps" under 4 or 
5.  Most patches look just fine with "u_steps 3" and "v_steps 3", which 
translates to 64 subpatches (128 smooth triangles).

As POV-Ray processes the Bezier patch, it makes a test of the current piece 
of the patch to see if it is flat enough to just pretend it is a rectangle.  
The statement that controls this test is: "flatness xxx".  Typical flatness 
values range from 0 to 1 (the lower the slower).

If the value for flatness is 0, then POV-Ray will always subdivide the 
patch to the extend specified by u_steps and v_steps.  If flatness is 
greater than 0, then every time the patch is split, POV-Ray will check to 
see if there is any need to split further.

There are both advantages and disadvantages to using a non-zero flatness.  
The advantages include:

	If the patch isn't very curved, then this will be detected and POV-Ray
	won't waste a lot of time looking at the wrong pieces.

	If the patch is only highly curved in a couple of places, POV-Ray will
	keep subdividing there and concentrate it's efforts on the hard part.

The biggest disadvantage is that if POV-Ray stops subdividing at a 
particular level on one part of the patch and at a different level on an 
adjacent part of the patch, there is the potential for "cracking".  This is 
typically visible as spots within the patch where you can see through.  How 
bad this appears depends very highly on the angle at which you are viewing 
the patch.

Like triangles, the bicubic patch is not meant to be generated by hand.  
These shapes should be created by a special utility. You may be able to 
acquire utilities to generate these shapes from the same source from which 
you obtained POV-Ray. 

Example:
  bicubic_patch { 
	type 1 
	flatness 0.01
	u_steps 4
	v_steps 4
	<0, 0, 2>, <1, 0, 0>, <2, 0, 0>, <3, 0,-2>,
	<0, 1  0>, <1, 1, 0>, <2, 1, 0>, <3, 1, 0>,
	<0, 2, 0>, <1, 2, 0>, <2, 2, 0>, <3, 2, 0>,
	<0, 3, 2>, <1, 3, 0>, <2, 3, 0>, <3, 3, -2>
  }

The triangles in a POV-Ray bicubic_patch are automatically smoothed using 
normal interpolation but it is up to the user (or the user's utility 
program) to create control points which smoothly stitch together groups of 
patches.  

As with the other shapes, bicubic_patch objects can be translated, rotated, 
and scaled.  Because they are finite they respond to automatic bounding.  
Since it's made from triangles, a bicubic_patch cannot be used in CSG 
intersection or difference types or inside a clipped_by modifier because 
triangles have no clear "inside". The CSG union type works acceptably.


5.2.2.3	Disc

One other flat, finite object type is available with POV-Ray.  Note that a 
disc is infinitely thin.  It has no thickness.  If you want a disc with 
true thickness you should use a very short cylinder.  A disc shape may be 
defined by:
 
  disc { <CENTER>, <NORMAL>, RADIUS }

or 

  disc { <CENTER>, <NORMAL>, RADIUS, HOLE_RADIUS }

The vector <CENTER> defines the x,y,z coordinates of the center of the 
disc.  The <NORMAL> vector describes its orientation by describing its 
surface normal vector.  This is followed by a float specifying the RADIUS.  
This may be optionally followed by another float specifying the radius of a 
hole to be cut from the center of the disc.

Example:
  disc {
	<-2,-0.5, 0>,	//center location
	<0,  1,	0>,	//normal vector
	2		//radius	 
	pigment { color Cyan }
  }

  disc {
	<0, 1, 0>,	//center location
	<-1, 3, -2>,	//normal vector  
	1.5,		//radius	 
	0.5		 //hole radius (optional)
	pigment { color Yellow }
  }

As with the other shapes, discs can be translated, rotated, and scaled.  
Because they are finite they respond to automatic bounding.  Disc cannot be 
used in CSG intersection or difference types or inside a clipped_by 
modifier because it has no clear "inside". The CSG union type works 
acceptably.


5.2.3 INFINITE SOLID PRIMITIVES

There are 5 polynomial primitive shapes that are possibly infinite and do 
not respond to automatic bounding.  They do have a well defined inside and 
may be used in CSG.  They are plane, cubic, poly, quadric, and quartic.  


5.2.3.1	Plane 

The plane primitive is a fast, efficient way to define an infinite flat 
surface.  The plane is specified as follows:

  plane { <NORMAL>, DISTANCE }

The <NORMAL> vector defines the surface normal of the plane.  A surface 
normal is a vector which points up from the surface at a 90 degree angle.  
This is followed by a float value that gives the distance along the normal 
that the plane is from the origin.  For example:

  plane { <0,1,0>,4 }

This is a plane where "straight up" is defined in the positive y direction.  
The plane is 4 units in that direction away from the origin.  Because most 
planes are defined with surface normals in the direction of an axis, you 
will often see planes defined using the "x", "y", or "z" built-in vector 
identifiers.  The example above could be specified as:

  plane { y,4 }

The plane extends infinitely in the x and z directions.  It effectively 
divides the world into two pieces.  By definition the normal vector points 
to the outside of the plane while any points away from the vector are 
defined as inside.  This inside/outside distinction is only important when 
using planes in CSG.

As with the other shapes, planes can be translated, rotated, and scaled.  
Because they are infinite they do not respond to automatic bounding.  Plane 
can be used freely in CSG because it has a clear defined "inside". 

A plane is called a "polynomial" shape because it is defined by a first 
order polynomial equation.  Given a plane:

  plane { <A, B, C>, D }

it can be represented by the formula:

	A*x + B*y + C*z = D

Therefore our example "plane {y,4}" is actually the polynomial equation 
"y=4".  You can think of this as a set of all x,y,z points where all have y 
values equal to 4, regardless of the x or z values.

This equation is a "first order" polynomial because each term contains only 
single powers of x, y or z.  A second order equation has terms like x^2, 
y^2, z^2, xy, xz and yz.  Another name for a 2nd order equation is a 
quadric equation.  Third order polys are called cubics.  A 4th order 
equation is a quartic.  Such shapes are described in the sections below.


5.2.3.2	Quadric 

Quadric surfaces can produce shapes like ellipsoids, spheres, cones, 
cylinders, paraboloids (dish shapes), and hyperboloids (saddle or hourglass 
shapes).  NOTE: Do not confuse "quaDRic" with "quaRTic".  A quadric is a 
2nd order polynomial while a quartic is 4th order.

A quadric is defined in POV-Ray by:

  quadric { <A,B,C>, <D,E,F>, <G,H,I>, J }

where A through J are float expressions.  

This defines a surface of x,y,z points which satisfy the equation:

	A x^2	+ B y^2	+ C z^2
	+ D xy	+ E xz	+ F yz
	+ G x	+ H y	+ I z	+ J = 0

Different values of A,B,C,...J will give different shapes. So, if you take 
any three dimensional point and use its x, y, and z coordinates in the 
above equation, the answer will be 0 if the point is on the surface of the 
object. The answer will be negative if the point is inside the object and 
positive if the point is outside the object. Here are some examples: 

	X^2 + Y^2 + Z^2 - 1 = 0  Sphere
	X^2 + Y^2 - 1 = 0	Infinitely long cylinder along the Z axis 
	X^2 + Y^2 - Z^2 = 0	 Infinitely long cone along the Z axis

The easiest way to use these shapes is to include the standard file 
"SHAPES.INC" into your program. It contains several pre-defined quadrics 
and you can transform these pre-defined shapes (using translate, rotate, 
and scale) into the ones you want.

You can invoke them by using the syntax,

  object { Quadric_Name }

The pre-defined quadrics are centered about the origin <0, 0, 0> and have a 
radius of 1. Don't confuse radius with width. The radius is half the 
diameter or width making the standard quadrics 2 units wide.

Some of the pre-defined quadrics are,

 Ellipsoid
 Cylinder_X, Cylinder_Y, Cylinder_Z
 QCone_X, QCone_Y, QCone_Z
 Paraboloid_X, Paraboloid_Y, Paraboloid_Z

For a complete list, see the file SHAPES.INC.


5.2.3.3	Poly, Cubic and Quartic.  

Higher order polynomial surfaces may be defined by the use of a poly shape.  
The syntax is:

  poly { ORDER, <T1, T2, T3, .... Tm> }

Where ORDER is a whole number from 2 to 7 inclusively that specifies the 
order of the equation.  T1, T2... Tm are float values for the coefficients 
of the equation.  There are "m" such terms where 

	m=((ORDER+1)*(ORDER+2)*(ORDER+3))/6

An alternate way to specify 3rd order polys is:

  cubic { <T1, T2,... T20> }

Also 4th order equations may be specified with:

  quartic { <T1, T2,... T35> }

Here's a more mathematical description of quartics for those who are 
interested.  Quartic surfaces are 4th order surfaces, and can be used to 
describe a large class of shapes including the torus, the lemniscate, etc. 
The general equation for a quartic equation in three variables is (hold 
onto your hat):

  a00 x^4 + a01 x^3 y + a02 x^3 z+ a03 x^3 + a04 x^2 y^2+ 
  a05 x^2 y z+ a06 x^2 y + a07 x^2 z^2+a08 x^2 z+a09 x^2+
  a10 x y^3+a11 x y^2 z+ a12 x y^2+a13 x y z^2+a14 x y z+ 
  a15 x y + a16 x z^3 + a17 x z^2 + a18 x z + a19 x+
  a20 y^4 + a21 y^3 z + a22 y^3+ a23 y^2 z^2 +a24 y^2 z+ 
  a25 y^2 + a26 y z^3 + a27 y z^2 + a28 y z + a29 y+ 
  a30 z^4 + a31 z^3 + a32 z^2 + a33 z + a34

To declare a quartic surface requires that each of the coefficients (a0 -> 
a34) be placed in order into a single long vector of 35 terms. 

As an example let's define a torus the hard way.  A Torus can be 
represented by the equation:

 x^4 + y^4 + z^4 + 2 x^2 y^2 + 2 x^2 z^2 + 2 y^2 z^2
 -2 (r0^2 + r1^2) x^2 + 2 (r0^2 - r1^2) y^2 
 -2 (r0^2 + r1^2) z^2 + (r0^2 - r1^2)^2 = 0

Where r0 is the "major" radius of the torus - the distance from the hole of 
the donut to the middle of the ring of the donut, and r1 is the "minor" 
radius of the torus - the distance from the middle of the ring of the donut 
to the outer surface. The following object declaration is for a torus 
having major radius 6.3 minor radius 3.5 (Making the maximum width just 
under 10). 

//Torus having major radius sqrt(40), minor radius sqrt(12)

	quartic {
	 < 1,	0,	0,	0,	2,	0,	0,	2,	0, 
	-104,	0,	0,	0,	0,	0,	0,	0,	0, 
	0,	0,	1,	0,	0,	2,	0,  	56,	0, 
	0,	0,	0,	1,	0,    -104,  	0, 	784 >
	 sturm
	 bounded_by { // bounded_by speeds up the render,
			// see bounded_by
			// explanation later 
			// in docs for more info.
		sphere { <0, 0, 0>, 10 }
	 }
	}

Poly, cubic and quartics are just like quadrics in that you don't have to 
understand what one is to use one. The file SHAPESQ.INC has plenty of pre-
defined quartics for you to play with. The most common one is the torus or 
donut. The syntax for using a pre-defined quartic is:
 
	object { Quartic_Name }

As with the other shapes, these shapes can be translated, rotated, and 
scaled.  Because they are infinite they do not respond to automatic 
bounding.  They can be used freely in CSG because they have a clear defined 
"inside". 

Polys use highly complex computations and will not always render perfectly. 
If the surface is not smooth, has dropouts, or extra random pixels, try 
using the optional keyword "sturm" in the definition. This will cause a 
slower, but more accurate calculation method to be used. Usually, but not 
always, this will solve the problem. If sturm doesn't work, try rotating, 
or translating the shape by some small amount. See the sub-directory MATH 
for examples of polys in scenes.

There are really so many different quartic shapes, we can't even begin to 
list or describe them all. If you are interested and mathematically 
inclined, an excellent reference book for curves and surfaces where you'll 
find more quartic shape formulas is:

	"The CRC Handbook of Mathematical Curves and Surfaces"
	David von Seggern
	CRC Press
	1990


5.2.4 CONSTRUCTIVE SOLID GEOMETRY (CSG)

POV-Ray supports Constructive Solid Geometry (also called Boolean 
operations) in order to make the shape definition abilities more powerful.


5.2.4.1	About CSG
	
The simple shapes used so far are nice, but not terribly useful on their 
own for making realistic scenes. It's hard to make interesting objects when 
you're limited to spheres, boxes, cylinders, planes, and so forth. 
	
Constructive Solid Geometry (CSG) is a technique for taking these simple 
building blocks and combining them together. You can use a cylinder to bore 
a hole through a sphere. You can start with solid blocks and carve away 
pieces.  Objects may be combined in groups and treated as though they were 
single objects.
	
Constructive Solid Geometry allows you to define shapes which are the 
union, intersection, or difference of other shapes.  Additionally you may 
clip sections of objects revealing their hollow interiors.
	
Unions superimpose two or more shapes. This has the same effect as defining 
two or more separate objects, but is simpler to create and/or manipulate. 
In POV-Ray 2.0 the union keyword may be used anyplace composite was used in 
previous versions of POV-Ray.  Also a new type of union called "merge" can 
eliminate internal surfaces on transparent or clipped objects.
	
Intersections define the space where the two or more surfaces overlap.
	
Differences allow you to cut one object out of another.
	
CSG intersections, unions, and differences can consist of two or more 
shapes. For example:
	
	  union {
		object{O1}
		object{O2}
		object{O3}  // any number of objects 
		texture{T1}
	  }
	
CSG shapes may be used in CSG shapes. In fact, CSG shapes may be used 
anyplace that a standard shape is used.
	
The order of the component shapes with the CSG doesn't matter except in a 
difference shape. For CSG differences, the first shape is visible and the 
remaining shapes are cut out of the first.
	
Constructive solid geometry shapes may be translated, rotated, or scaled in 
the same way as any shape. The shapes making up the CSG shape may be 
individually translated, rotated, and scaled as well.
	
When using CSG, it is often useful to invert a shape so that it's inside-
out. The appearance of the shape is not changed, just the way that POV-Ray 
perceives it. The inverse keyword can be used to do this for any shape. 
When inverse is used, the "inside" of the shape is flipped to become the 
"outside". For planes, "inside" is defined to be "in the opposite direction 
to the "normal" or "up" direction. 
	
Note that performing an intersection between a shape and some other inverse 
shapes is the same as performing a difference. In fact, the difference is 
actually implemented in this way in the code.
