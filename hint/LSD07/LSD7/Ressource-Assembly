                                RESOURCE

Typed in by ???. Edited by PARASITE.


TO GET STARTED QUICKLY:
      Don't forget to put arp.library in your LIBS: directory!

      Run ReSource from a CLI, and when you are presented with a file
      requester, select an executable file to disassemble (anything
      within your "C" directory will do nicely).  Alternatively, you
      may disassemble Kickstart by supplying a filename of "*".  Once
      loaded, you may scroll forwards/backwards through the file with
      the down/up arrow keys.  Using the shift key with the up/down
      arrow keys will move you faster through the file.  You may also
      use mouse-scrolling, by holding the left mouse button down, then
      SLOWLY moving the mouse forwards or backwards, depending on which
      way you want to move through the file.  While moving forwards
      with the mouse, holding the left Amiga key down will start the
      label creation process, in a controlled manner.  When labels are
      created, ReSource decides which type of data is being labelled,
      and it is generally correct in its judgement.  Once you have made
      some labels, select the 'Fill-in data types' menu item, under the
      "DISPLAY" menu.  Once you have created labels from all areas of
      code, select 'Fill-in data types' again, and you may then scroll
      through the file, checking for yourself that all is in order
      (there will occasionally be cases where ReSource made an
      incorrect judgement, and code made be shown as ASCII, or vice-
      versa).  Use one of the "Set data types" sub-menu selections, to
      set the correct data type.  Remember to use the "Fill-in data
      types" command again, so that code and data are shown correctly.

      If you are working on a large file, you may wish to save your
      work, so that you can continue it at a later time.  To do this,
      select "save all" under the "PROJECT" menu.  When you use the
      "save all" option, you are creating a "ReSource file", as it is
      only useable by ReSource.  By default, the filename will end in
      ".RS".  You may change this if you like.

ABOUT RESOURCE:
      ReSource is an interactive disassembler.  To give you an idea of
      which files can and cannot be disassembled, the following is a
      list of files from a Workbench 1.2 disk, that ReSource can
      disassemble:
      C directory: all
      L directory: all
      LIBS directory: all
      DEMOS directory: Boxes, Dots, Spots
      SYSTEM directory: CLI, DiskCopy, Format, GraphicDump, IconEd,
      Say, SetMap.
      DEVS directory: all keymaps, all printer drivers, everything
      ending in ".device".
      FONTS directory: everything within sub-directories
      (topaz/11,emerald/17, etc.)
      UTILITIES directory: Calculator, Notepad
      ROOT directory: Preferences, Clock

      I personally wanted a good disassembler to fix bugs in many of
      the public domain programs that I use.  I was also interested in
      getting to know how C programs worked, at the assembly language
      level.  ReSource is the result of 3 and a half months full-time
      effort; during this time I have been using each version
      extensively.  I am very impatient when it comes to waiting for
      programs to complete operations, this has resulted in a
      disassembler that is extremely fast, at the cost of memory usage.
      Even though ReSource was written purely in assembly language, it
      uses lots of memory, especially when disassembling large
      programs.  Generally, if you have 1.5 Megs of memory, you will be
      able to disassemble most programs.  To disassemble Kickstart, you
      will require at least 2 Megs if you have a hard drive, or 3.5
      Megs if you do not have a hard drive.  As a further condition,
      there must be at least 1.1 Megs of contiguous memory, for the
      attributes table.

GENERAL USAGE:
      Don't forget to put arp.library in your LIBS: directory!

      Disassembling a program consists of examining a load file
      (sometimes called "executable" or "object" files), and from the
      information contained therein, create a text file (assembler
      source code) which, when assembled, can be used identically to
      the original load file.  It takes many, often hundreds, of hours
      of painstaking work to become proficient at disassembling even a
      small program manually.  Even experts can spend many hours
      disassembling very small programs, while large Amiga programs may
      take weeks.  From now on, this will not be the case with Amiga
      programs.  Large programs (100K or larger) can be disassembled in
      an evening, while small programs (such as CD, PROMPT, AVAIL,
      ECHO, FILENOTE, etc., take around 3-5 seconds to produce re-
      assemblable source code.

      As an example, let's disassemble LoadWB, which you'll find in the
      C directory of just about any booting disk, including a standard
      Workbench disk (make sure that it comes from a V1.2 Workbench,
      not 1.1 or 1.3!  At the CLI prompt, type:

      RUN RS C:LOADWB

      You don't really have to use the "run" command, but I find it
      convenient, so maybe you will too.  When ReSource starts running,
      it will load the file "loadwb" from the C directory, and
      disassemble the first page for you.  We can now start the label-
      creation process.  This involves getting ReSource to examine
      lines of code, and on each line, if there is any reference to
      another part of the program, ReSource will decide which type of
      data is being referenced.  For example, the first line of code in
      our program is:

              MOVE.L  SP,START+$01E0

      Okay, go to the menus, under "LABELS" menu, you'll find "Create
      single".  A sub-menu box will pop out, and from this, select
      "Address symbol dest".  Now, the first line of code in our
      program should be:

              MOVE.L  SP,lbL0001E0

      Now, scroll forward through the program (using shift-down arrow),
      until you find a line starting with "lbL0001E0":

      lbL0001E0       dc.l    0

      The label "lbL0001E0" is something that ReSource has just now
      created.  In this case, ReSource decided that the data being
      referenced was a Longword, hence the "L" in "lbL0001E0".  If it
      was code that was being referenced, the label would have been
      "lbC0001E0" instead.  There are five type of data recognized by
      ReSource:

      ASCII - CODE - BYTES - WORDS - LONGWORDS

      The processes involved in deciding which type of data is being
      referenced is quite complex, and such things as the surrounding
      code/data, the relative position of reloc32 areas, hunk types,
      relative position from the start of a hunk, the actual
      information being referenced, whether the data is word/longword
      aligned, the actual instruction from which the reference was
      derived, the proximity of other labels, and what data types they
      refer to, all take part in the decision-making process.  If the
      first line of code in out program had been:

              MOVE.W  SP,START+$01E0

      , then the label created would have been "lbW0001E0" instead, and
      the data type at this label would have been set to words.  If you
      like, you can manually set the data type of any byte in the
      program, by selecting a sub-menu item from the "Set data type"
      menu item, under "DISPLAY" in the menus.  This will not create a
      label, but it will re-define the current byte within the file (on
      the top line of the display) as being ASCII, CODE, or whichever
      data type you selected.  Generally, this is not required, except
      sometimes in large programs, but after letting ReSource do its
      thing first.  If you like doing things with the mouse, you can
      even set the data type this way.  Once you have mastered mouse
      scrolling, try holding down the left-shift key while still
      holding down the left mouse button.  This will display everything
      as if it were set to the data type BYTES.  Holding down the left
      alt key will display everything as if it were set to ASCII.
      Similarly, the left shift and left alt keys held down together to
      show everything in WORDs; hold down the ctl key and everything
      will be displayed as CODE.  Hold down all three, and everything
      will be shown as LONGWORDS.  If you decide make this data type
      permanent, press the menu button, and the current position within
      the program will be set to the data type currently being
      displayed.  By holding down the right alt key, you can remove
      labels while scrolling.

      Now scroll back to the start of the program (select "Start of
      file" submenuitem, under the "Absolute" menuitem under the
      "CURSOR" menu).  Alternatively, just use the up arrow key, to
      scroll back slowly.  Look in the screen title bar to find out how
      far you are from the start of the file.  This offset is being
      shown in hexdecimal.  Now, use the down arrow key to scroll
      forward to the second line of code in our program:

              MOVE.L  D0,START+$01E8

      Again, select the "Address symbol dest" submenuitem, to create
      the label "lbL0001E8".  Do this to as many lines of code as you
      like, so that you become familiar with the label creating
      process.  What you have just done can be done far quicker, by
      using the "Create multiple" label functions.  Firstly, select the
      "Open" menuitem, under "PROJECT" in the menus.  Again, we will
      use "LoadWB" from within your C directory.  Once it is loaded,
      look in the menu under "LABELS", go to the menuitem "Create
      multiple", and select "All" from the sub-menuitem box.  Around
      three quarters of a second later, you should be at position
      "0001C8" relative from the start of the file.  The top line of
      the display should read:

      lbL0001C8       dc.l    0

      If this is correct, you should now find some more code to make
      labels from.  To do this, you could use the down arrow key to
      scroll forward, the shift-arrow key to page forward, or let
      ReSource do the searching for you, by selecting "Next unparsed
      code" from the "CURSOR" menu.  If there is no more code that has
      not been parsed, you will be returned to the start of the file.
      However in this case, there is more code to parse, so go to it!
      When eventually "Next unparsed code" returns you to the start of
      the file, slowly scroll through the file, and examine as you go.
      You should find some ASCII, but it isn't being shown like it
      really should.  This is the time to select "Fill-in data types"
      from the "DISPLAY" menu.

      Okay, now the program is completely disassembled right?  Well,
      nearly.  If you followed the above instructions to the letter,
      there will be once more section of code that labels have NOT been
      created from.  This will be at offset "000584".  This is because
      this area of the program was only recognized as code, after it
      had been skipped over.  In fact, the only reference to this part
      of the program is made at offset "0005E6", and the code is:

              JSR     lbC000584

      Again, create multiple labels within this area, and search for
      the next unparsed code.  If you select "Next unparsed code" while
      at the start of the file, and ReSource cannot find any, then
      again select "Fill-in data types", and this should complete the
      disassembly of LoadWB.

      Actually, at this point, I generally will change some of the
      labels, so that they are meaningful.  For instance, the first
      line of code places the contents of the SP register at
      "lbL0001E0", right?  Scroll forward to the line starting with
      this label, and select "Address symbol" submenuitem, from the
      "Create single" menuitem, under "LABELS" menu.  You will be
      requested to input a new label name.  I would call this label
      "SaveSP"; you call it anything you like.  Now, scroll backwards
      to the offset "0000D2":

              MOVE.L  SaveSP,SP

      We didn't change this line, so what is going on?  You have just
      witnessed one of the major benefits of an interactive
      disassembler; any label changes you make are reflected throughout
      the entire program, instantly.  Anywhere else in the program that
      you can place a meaningful label, will help greatly in
      recognizing how a program executes, without actually executing
      it.  Also, if you wish to make changes to the source, meaningful
      labels help greatly.  While still within ReSource, you may add
      comments, both full-line, and end-of-line, to aid in the
      understanding of the program.

EXPLANATION OF FUNCTIONS:
      The following section gives details of the uses of each function,
      as they are shown in the menus.  Not all functions are enabled in
      all versions, this is especially so in V0.x (demo version).

      PROJECT/Abort:
              Use this to abort out of most functions.

      PROJECT/Open:
              Requests you to select a file to open.  Use this function
      to load executable files, as well as ReSource files.

      PROJECT/Restore:
              Same as PROJECT/Open, but assumes that you wish to open
      the same file as you last opened.

      PROJECT/Save .RS:
              Saves the file that you are currently working on, in a
      form useable only by ReSource.  Also saves the current location
      with the file.  To continue work on the file later, use the
      PROJECT/Open function.

      PROJECT/About:
              Gives you some specific details about the version of
      ReSource that you are currently using.

      PROJECT/Quit:
              Asks you for confirmation, then quits without saving.

      OUTPUT/Save .asm:
              Saves current file in assembler source code format.

      OUTPUT/O/P directory:
              Requests you to supply the name of a directory that .asm
      files will be sent to (you can still change this when you supply
      the name of the output file, it just makes it easier if you are
      disassembling many files).

      OUTPUT/Tabs:
              Use to select between real tabs (ASCII value 9) and
      spaces being used in the output source code.

      DISPLAY/Hiliting:
              Selective use of inverse video can be useful to give
      extra information about parts of a file.  For instance, you may
      want to get a quick idea of which parts of a file came from a BSS
      hunk, rather than CODE or DATA hunks.  To do this, select
      DISPLAY/Hiliting/BSS hunks.

      DISPLAY/Hiliting/Reloc32:
              I find it particularly useful to hilite the Reloc32
      areas, especially when determining data types (reloc32 is
      documented in the Amiga technical reference manual.  It
      ultimately means that a number of longwords in the file point to
      somewhere in memory, relative to the start of one of the hunks of
      the file.  This almost always end up being somewhere within the
      file.  This information helps ReSource greatly when defining data
      types).

      DISPLAY/Hiliting/Chip load hunks:
              Certain hunks of a load file may only be loaded into chip
      memory.  Usually, graphics, especially sprites, will be included
      in one of these special hunks, and this information is sometimes
      useful, especially when you intend to re-assemble the file.
      "Chip load hunks" will hilite these hunks for you, also fast load
      hunks may be hilited.

      DISPLAY/Hiliting/Symbol scan:
              For all lines that you have created labels from, these
      lines will be hilited.

      DISPLAY/Hiliting/Data type uncertain:
              For most labels that ReSource creates automatically, it
      is certain of the data type that it assigns.  Sometimes though,
      it cannot be 100% sure, and this function will hilite all lines
      that fall into this category.

      DISPLAY/Hiliting/Data type known:
              Similar to above function, only the lines where the
      ReSource was certain of the data type, will be hilited.

      DISPLAY/Hiliting/Internally produced refs:
              All lines which have a label that was created by
      ReSource, will be hilited.

      DISPLAY/Set data type:
              When you are certain of which type of data that you are
      looking at, select from one of the submenu items:
      Code - Ascii - Bytes - Words - Longwords

      DISPLAY/Set numeric base:
              By default, all numbers are shown in hexdecimal (base
      16).  You can change this to ASCII, DECIMAL or BINARY on any line
      by selecting from the appropriate sub-menu item.  To change back
      to HEXDECIMAL, simply select the same function again.  It is
      possible to change the default to decimal for numbers less than
      16, or less than 10, using the decimal conversion function (see
      below).

      DISPLAY/Decimal conversion:
              By default, all numbers are show in hexdecimal.  You can
      have numbers less than 16, or numbers less than 10, shown in
      decimal throughout the file, by selecting one of the appropriate
      sub-menu items.

      DISPLAY/Block-fill:
              This function will probably not get much use.  It can be
      used to set the data type of blocks of data.  For example, in a
      particular file, there may a large section of code, maybe 100K or
      so, and rather than rely on ReSource to make the correct
      judgement of data type every time, you can set the data type of
      every byte in the file to code, by doing the following:  Scroll
      to the start of the block.  Set the data type here to CODE.
      Select the "CURSOR/Remember" function.  Now, scroll to the end of
      the block (don't use any function that stacks the cursor
      position, such as "CURSOR/Absolute/End of file", as this will
      change the remembered offset.  When you get to the end of the
      block, select the "DISPLAY/Block-fill" function.  The type of
      data at the start of the block will be echoed throughout the
      entire block.

      DISPLAY/Fill-in data types:
              This function has several uses, and will be one of the
      most-used functions.  To understand what this function does, you
      will need to know how ReSource keeps track of data types (see
      section "Inside ReSource").  Suffice it to say, when you set the
      data type anywhere within a file, that data type is immediately
      echoed forward, to a maximum of several hundred bytes, but will
      not change any other places where the data type has already been
      set, or where there is an address symbol (label) on a line.
      Where there is large areas of a file where the data type has not
      been set, this function attempts to set the data type where
      appropriate.  All of the above is done in the first pass.  On the
      second pass, the length of each line is set, this is particularly
      useful where there is large areas of ASCII.  This function should
      always be used just before saving a file as source code (OUTPUT/
      Save .asm).

      DISPLAY/Set counter:
              The current offset in a file is always shown in the title
      bar, in hexdecimal.  This is normal zero at the start of the
      file.  You can change this, so that it is zero at somewhere other
      than the start of the file, by using this function.  You may use
      this function to measure the size of a hunk, for example.  To
      "reset" the counter, use the function "DISPLAY/Reset counter".

      DISPLAY/Reset counter:
              Resets the offset counter, in the title bar, so that it
      is zero at the start of the file.  See "DISPLAY/Set counter".

      SYMBOLS:
              When you create an assembly-language program, if you wish
      to allocate some memory, you will probably have somewhere in you
      file:

              JSR     _LVOAllocMem(A6)

      If you were to disassemble this program, this line of code would
      be show as:

              JSR     -$0228(A6)

      , which is not particularly meaningful.  When disassembling a
      program, if you can figure out which library base the A6 register
      is pointing to (in this case, it would be the EXEC library), you
      can get ReSource to make the appropriate substitution.  In this
      example, you would select "SYMBOLS/E-G/Exec library".  Following
      is another example:

              MOVE.L  #$00038007,D7
              MOVE.L  4,A6
              JSR     -$006C(A6)

      The second line loads Execbase into the A6 register, so you
      should move the third line to the top of the display, and select
      "SYMBOLS/E-G/Exec library".  Scroll back a couple of lines, and
      you would see:

              MOVE.L  #$00038007,D7
              MOVE.L  4,A6
              JSR     _LVOAlert(A6)

      If you looked at the documentation for the Exec "Alert" call, you
      would find that one of the input parameters is required to be in
      the D7 register.  If you then looked in the include file "exec/
      alerts.i", you would find that the number "$00038007" consists of
      three values, OR'd together:

      AT_Recovery  -  AG_OpenLib  -  AO_DOSLib

      There is no need to go to all this trouble, simple line up the
      first line with the top of the display, and select "SYMBOLS/A-B/
      Alert codes", and ReSource will make the appropriate
      substituition for you:

              MOVE.L  #AT_Recovery!AG_OpenLib!AO_DOSLib,D7
              MOVE.L  4,A6
              JSR     _LVOAlert(A6)

      Now isn't that much better than the original?  There are over 200
      different classes of symbols that ReSource can substitute (only
      two are enabled in the demo version).

              Consider the following lines of code:

              MOVE.L  4,A4
              MOVE.L  #$100000,$003A(A4)

      Let's assume that you wish to substitute a symbol for the "$003A"
      in the second line of code.  By default, ReSource will attempt to
      substitute a symbol for the first number that it finds in a line
      of code.  To change this, select "SYMBOLS/Set source/dest/
      Destination", and then the appropriate symbol base (Exec library,
      in this example).

      CURSOR/Remember:
              Where it is possible to lose your place within a file by
      using certain functions (such as "CURSOR/Absolute/Start of
      file"), ReSource will store the current cursor location, just
      prior to the function being executed.  To return to the previous
      cursor location, select "CURSOR/Absolute/Previous location".
      When you plan to return to a specific place within the file,
      using this function will make it easier to do so.  It simply
      stores the cursor location on a stack, for later access.

      CURSOR/Clear Loc stack:
              The cursor location stack can contain up to 256
      locations.  If more locations are "pushed" onto this stack, the
      location at the bottom (the oldest) are forgotten.  This function
      will empty the cursor location stack.

      CURSOR/Relative/Next byte:
              The cursor position is incremented.

      CURSOR/Relative/Previous byte:
              The cursor position is decremented.

      CURSOR/Relative/Next line:
              Scroll forward by one line.

      CURSOR/Relative/Previous line:
              Scroll backwards by one line.  The length of a line will
      depend on what the data type is.  Until you first use "DISPLAY/
      Fill-in data types", backwards scrolling may not be quite what
      you expect.

      CURSOR/Relative/Next page:
              Scroll forward by one page.  This will be approximately
        20 lines.

      CURSOR/Relative/Previous page:
              Scroll backwards by one page.  This will be approximately
        20 lines.

      CURSOR/Relative/Skip forward:
              Scroll forward by approx 4096 bytes ($1000).

      CURSOR/Relative/Skip Backward:
              Scroll backward by approx 4096 bytes ($1000).

      CURSOR/Relative/Next unparsed code:
              Scroll forward to the next line of code, that has been
      labelled, and that has not been parsed for labels yet.

      CURSOR/Relative/Next data type change:
              Scroll forward to the next byte whose data type is
      different to the data type of the current byte.

      CURSOR/Relative/Previous data type change:
              Scroll backward to the first byte found whose data type
      is different to the data type of the current byte.

      CURSOR/Relative/Next uncertain data type:
              Scroll forward to the next position within the file that
      ReSource has labelled, but at the time was not quite sure of
      which data type to set.

      CURSOR/Relative/Next backward reference:
              Using the "CURSOR/Absolute/Backward reference" function,
      it is possible to find the first reference to the current
      position within the file.  Use this function to find further
      references to the same position.  The search function could be
      used instead, but may also find references within comments,
      mnemonics, or even within other labels.

      CURSOR/Absolute/End of file:
              Move cursor to the last line of the file.

      CURSOR/Absolute/Start of file:
              Move cursor to the first line of the file.

      CURSOR/Absolute/Forward reference:
              I'll use an example to explain this one:

                          JSR    lbC0132DE

              If you wanted to "check out" the subroutine at label
      "lbC0132DE", but later return to the current cursor position,
      simply scroll until this line is on the top line of the display,
      and select "CURSOR/Absolute/Forward reference".  The current
      cursor location is stored (on a stack), so that you can return to
      this cursor position, using the "CURSOR/Absolute/Previous
      location" function.

      CURSOR/Absolute/Forward reference:
              This is similar to the "CURSOR/Absolute/Forward
      reference" function, except that on a line such as:

                          MOVE.L  lbL00DEAF,lbL00BEEF

              the second label is used (lbL00BEEF), rather than the first
      (lbL00DEAF).

      CURSOR/Absolute/Backward reference:
              Use to find the first reference made to the current
      cursor position.  See "CURSOR/Absolute/Next backward reference".

      CURSOR/Absolute/Previous location:
              With many functions that change the cursor location
      substantially, the current cursor position is stored on a stack.
      To "pop" the last saved location, use this function.

      CURSOR/Scrolling speed:
              You can select from five scrolling speeds.  This relates
      to the speed/smoothness of scrolling when using the "CURSOR/
      Relative/Next line" and "CURSOR/Relative/Previous line" functions.

      CURSOR/Search/Set search pattern:
              You will be requested to input a string.  Unless you
      select "CANCEL", the string you input will be searched for
      immediately, starting at the current cursor position.  Normal ARP
      wildcards are accepted:

                  (a|b|c)   Will match one of a, b or c.
                            These can be patterns.

                  ? Matches any single character
                  #<pat>   Pattern repeated 0 or more times,
                           in particular, #? matches anything.

                  [char]   A set of characters, for example,
                           [abc] or [a..c] specify the same set.

                  [^char]   Match everything but this set of characters.

                  *         0 or more occurances of any character.

      CURSOR/Search/Find next occurence:
              Using the current search string, search forward from the
      current cursor position.  See "CURSOR/Search/Set search pattern".

      LABELS/Create single/End-of-line comment:
              You will requested for a string, which will be shown at
      the end of the current line, starting with " ; ".

      LABELS/Create single/Full-line comment:
              You will requested for a string, which will be shown on a
      seperate line, previous to the current line, starting with "; ".
      Generally, this will be used to add a comment too long to put at
      the end of the current line.

      LABELS/Create single/Address symbol:
              You will be requested for a string, which will become the
      label for the current line.  Any references to the current line
      will use the new label name, throughout the entire file,
      immediately.

      LABELS/Create single/Address symbol dest:
              The current line of code will be searched for references
      to positions within the current file.  If any are found, ReSource
      will make a decision on which type of data is at the position
      referenced, it will then set the data type, and create a label at
      that offset.  This new label will be immediately used for all
      references to that location, which of course includes the
      reference within the current line.  If the current line is not
      being shown as code, or if there is no references, or there is a
      reference, but it is outside of the range of the current file,
      then this function will do nothing.  Normally, this function will
      only be used within macros, as it is easier and quicker to hold
      down the left Amiga key, while holding down the left mouse
      button, possibly while scrolling also.

      LABELS/Create single/Value symbol:
              Following is several examples of address symbols
      (labels), and value symbols.

      lbC000124        MOVE.B   bm_Depth(A0),D0

      In the above line, "lbC000124" is an address symbol, and
      "bm_Depth" is a value symbol.

                       MOVE.B   bm_Depth(A0),DepthByte

      In this line, "DepthByte" is and a reference to an address symbol
      (label), NOT a value symbol.

                       MOVE.L   #MEMF_CLEAR,D1

      In this line, "MEMF_CLEAR" is a value symbol.  If a value symbol
      had not been created for this line, the line would be:

                       MOVE.L   #$10000,D1

      Address symbols (labels) always equate to a position within the
      file, while value symbols may equate to any value at all.
      Unfortunately, there is several cases where a value symbol may
      equate to a position within the file:

                       MOVEA.L   #lbC000134,A0
                       JSR       (A0)

      In this case, you may assign a value symbol, in which case the
      value symbol will be shown, not the label name of the position
      within the file that the instruction refers to.  If however, you
      later remove the value symbol, the then label name of the line
      being referenced (at present, this is "lbC000134"), will be
      shown.  When you create an address symbol or value symbol, the
      name is NOT checked for validity, it is up to you to decide
      whether or not the assembler that you will be using will accept
      the resulting code.  For example:

                       MOVE.L    #FFFFFFFA,D0

      may be changed to:

                       MOVE.L    #-6,D0

      by creating a value symbol "-6".  Virtually any value can be
      given a value symbol, including bit numbers:

                       BTST      #AFB_68020,$0124(A6)

      LABELS/Create single/Value symbol - dest:
              Similar to "LABELS/Create single/Value symbol" function,
      except that the second reference within the current line will
      used, rather than the first:

                       BTST      #4,SysFlags(A6)

      LABELS/Edit single:
              All of these functions are identical to their
      counterparts in "LABELS/Create single", except that if their is
      an existing label/symbol/comment, you will be requested to edit
      it, rather than create a new one.  Given the editing capabilities
      of a string gadget, the create functions are a luxury really,
      although I find that when I change a label/symbol/comment, I
      generally make it nothing like the original, hence I nearly
      always use the create functions, to save me the trouble of
      pressing "rAmiga-X".

      LABELS/Remove single/Address symbol:
              Remove any address symbol (label) for the current line.

      LABELS/Remove single/Value symbol:
              Remove ALL value symbols in the current line.

      LABELS/Remove single/End-of-line comment:
              Remove any end-of-line comment for the current line.

      LABELS/Remove single/All:
              Remove all symbols and comments for the current line.

      LABELS/Create multiple/Reloc32 all:
              For each reloc32 pointer within the current file,
      determine the data type being referenced, set the data type, and
      create a label at that address.  This function should be used
      with caution, as when it makes a decision on the data type, it
      does not have the same information available as when creating
      labels normally.  This function should be most useful after
      creating labels from all code in a program, where there is one or
      more large tables of pointers.

      LABELS/Create multiple/All:
              Starting at the current address, the "LABELS/Create
      single/Address symbol dest" function is executed, and if ReSource
      thinks that there was valid code in the current line, the
      "CURSOR/Relative/Next line" function is executed, and the entire
      function loops, otherwise the "PROJECT/-=Abort=-" function is
      executed.  This function can make the disassembly process very
      fast, the disadvantage being that there is a very slight chance
      that what ReSource thinks is valid code, is really ascii, and
      invalid labels will be created.

      SPECIAL FUNCTIONS/Repeat last command:
              Execute the last function that was executed.  This does
      not include most cursor movements.  By rebinding this function to
      an easily-accessed key, such as the space bar, (and saving the
      keytable) there should be much less need to rebind keys often.

      SPECIAL FUNCTIONS/Convert xx(A4) EA's
              These functions were specifically designed to be used
      when disassembling 'C' programs, in which the A4 register is used
      as a base register for accessing data, throughout all or most of
      the program.  Let's use an example program here:

                          SECTION  test000000,CODE
                          LEA      START+$11E,A4
                          LEA      0(A4),A1
                          MOVE.L   $000C(A4),D0
      .... rest of code
                          SECTION  test00011E,DATA
                          dc.b     'dos.library',0
                          dc.l     $00010001
                          END

      In the above program, the A4 register will point to the start of
      the data segment.  There are three ways to tell ReSource where
      the A4 register will point to; in the above example, the "This
      operand" function could be used with the cursor at start of file,
      or the "This address" function could be used with the cursor at
      offset $00011E, or the "Specify" function could be used, suppying
      a parameter of "11E".  Basically, with this function, you are
      telling ReSource where, relative to the start of the program, the
      A4 register can be assumed to be pointing.  After you do this,
      any effective address that involves a word offset to the A4
      register, will be shown as an absolute address.  Thus, the
      example program above will appear as:

                          SECTION  test000000,CODE
                          LEA      START+$011E,A4
                          LEA      START+$011E,A1
                          MOVE.L   START+$012A,D0
      .... rest of code
                          SECTION  test00011E,DATA
                          dc.b     'dos.library',0
                          dc.l     $00010001
                          END

      The advantage here is that labels can automatically be created
      where they could not before.  If this conversion process is not
      used, it is likely that the program will not successfully re-
      assemble, as different assemblers assemble the same source code
      into different opcodes.  For example, the assembler that I
      normally use does virtually no optimizing, and so the resulting
      program is often larger than the original, even if I did not
      modify the source code.  For example:

                          MOVE.L   4,A6

      If absolute long addressing is used, the instruction above will
      be 6 bytes long, whereas if absolute short addressing is used, it
      will be only 4 bytes long.  Where you wish to do EA conversions
      in only a portion of a program, you can set the lower and upper
      limits.

      Changing to absolute EA's will increase the size of the resulting
      program, unless you convert back to relative addressing, within
      the source code.  I believe that one of the features of BLINK
      (from the Software Distillery) can help to make this conversion.

      SPECIAL FUNCTIONS/Convert specific EA's:
              Please read and understand the "SPECIAL FUNCTIONS/Convert
      xx(A4) EA's" functions first!  Where you want to do specific EA
      conversions, use "Set base #1" (or #2, or #3), when the cursor is
      the same as where the base register (whatever that is, it does
      not have to be A4 this time) can be assumed to point to.
      Assuming that you set base #1, and it is the A5 register that is
      being used as a base register, you will then use the "Convert W/
      Base #1" function to convert lines like:

                          MOVE.L   $0032(A5),A6

      .. into:

                          MOVE.L   lbL0014AC(A5),A6

      Note here that there has not actually been an EA conversion, but
      a label has been created, the data type at label "lbL0014AC" has
      been determined and set, and a value symbol ("lbL0014AC") has
      been created for this line.  It is up to you then to make the
      necessary changes to the resulting source code, if re-assembling
      is required.  Whereas the "Convert xx(A4) EA's" function converts
      immediately and automatically, you must use the "Convert W/Base
      #1" function on each line that you want converted.  If you wish
      to convert a destination address, first use the "SYMBOLS/Set
      source/dest/Destination" function first.

MACROS:
              There are currently twelve user-definable macros
      available in ReSource.  To start macro #1, select "MACROS/Start/
      #1", select the functions to be included in the macro (you can
      use the menus, or press keys, it's all the same thing to the
      macro).  When you are done, select "MACROS/Start/#1" again, to
      end the macro.  To run the macro, select "MACROS/Execute/#1".
      The display is always refreshed during the defining of a macro,
      however it is not during the execution.  At the end of a macro,
      the display is always refreshed.  You may nest macros, but you
      should not use recursion.  If ReSource finds that the nesting
      level has exceeded 40, the macro will be abandoned.

              Macro files can be saved and re-loaded.  When ReSource
      first starts up, it looks for "S:RS.macros".  If it finds it, it
      will load it, and execute macro #12 immediately (that is why
      macro #12 is hilited in the menus).  This is used to configure
      ReSource.  Just start macro #12, set what option you want, end
      macro #12, save the macro file as "S:RS.macros", and ReSource
      will be configured every time that you run it.

KEY BINDINGS:
              Every function in ReSource can be found in the menus.
      You do not need to use any keys at all, but you probably will
      want to.  You can bind any function to any key.  All Amiga keys
      are supported, you may use shift, alt, ctl, lAmiga, rAmiga,
      shift-alt, shift-ctl, alt-ctl, or shift-alt-ctl in combination
      with any key, as a distinct key to bind a function to.  Thus, you
      have complete control over which keys do what.  After re-binding
      some keys, you will probably want to save the keytable.  If you
      save the keytable as "S:RS.keytable", it will be loaded every
      time you run ReSource.  You may want to create several keytables,
      suitable for doing differing program types (C, assembler, etc.).

      OPTIONS/Show offsets:
              If this option is set to ON, all lines will start with
      either a label, or the offset from the start of the file.

      OPTIONS/Display Beep:
              If this option is set to ON, the "BeepDisplay" function
      is used to give feedback to the user, that either a function has
      failed, or that a lengthy function has completed, and that the
      user should now wake up.

      OPTIONS/User Feedback:
              If this option is set to ON, messages will appear in the
      title bar, to let the user know what ReSource is doing,
      especially while doing functions that take a lot of time,
      extraordinary functions that only ReSource has direct control
      over (such as dynamically allocating more memory for strings,
      etc.), and also information about what hunks, etc., that it finds
      in a load file.

      OPTIONS/Feedback Delays:
              If this option is set to ON, whenever a feedback message
      is displayed, ReSource will wait for you to read the message,
      before continuing.  You will probably not want to keep this on
      all the time, as it can slow down the disassembly process
      somewhat, but while you are learning to use ReSource, it will
      probably be very useful.

      OPTIONS/Labels:
              If this option is set to ON, labels will be displayed.  This is
      the default.


      OPTIONS/Value symbols:
             If this option is set to ON, value symbols will be displayed.
      This is the default.

      OPTIONS/End-of-line comments:
             If this option is set to ON, end-of-line comments will be
      displayed.  This is the default.

      OPTIONS/Full-line comments:
             If this option is set to ON, full-line comments will be
      displayed.  This is the default.

      Don't forget to put arp.library in your LIBS: directory!
