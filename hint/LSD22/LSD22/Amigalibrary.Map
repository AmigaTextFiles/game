
------------------------- 
Final Notes 
There are a few macros included in the following function list. Accessing a 
macro is much like accessing a library function. In Modula-2, all supported 
macros are defined as standard procedures and placed into modules. With C 
and machine language, they are actual compiler/assembler macros that must be 
included in your source code. The include file, header file, and Modula-2 mod-
ule that contains the macro definitions are included in the macro's table entry.
A few last minute points should be made regarding the terminology used 
in the following list of functions: By convention, a NULL value is equivalent to 
0. The Modula-2 equivalent of NULL is NIL, which is defined as ADDRESS(0). 
In C, TRUE represents a nonzero value (usually equal to 1) and FALSE equals 
0. In Modula-2, TRUE and FALSE are elements of the type BOOLEAN. If you 
see an _fptr in a C usage description, it specifies a pointer to a function.
The following table is mainly for reference purposes-it's a place you can 
look up information about any Amiga library function, quickly and easily. For 
more details about using a specific function, we suggest you refer to the auto-
docs section of the Commodore-Amiga ROM Kernel Reference Manual.

-------------------------Functions Start Here-------------------------
AbortIO
Description:     	attempts to abort an I/O request already in progress
Library:        	exec.library
Offset:         	-$01E0 (-480)
Modula-2 Module: 	IO
Syntax:        		error = AbortIO(ioRequest)
C:            		long AbortIO(struct IORequest *)
Machine Language: 	d0 = AbortIO(a1)
Modula-2:		AbortIO(ioRequest: ADDRESS): LONGINT
Arguments:		ioRequest = IORequest block containing I/O request to abort
Result:			error = 0 if successful; nonzero error value if unsuccessful
-------------------------
ActivateGadget
Description:		activates a string gadget so the user does not have to click in the
			gadget box to bring up a cursor
Library:		intuition.library
Offset:			-$01CE (-462)
Modula-2 Module: 	Intuition
Syntax:			success = ActivateGadget(gadget, window, requester)
C:            long ActivateGadget(struct Gadget *, struct Window *, struct 
Requester *)
Machine Language: 	d0 = ActivateGadget(a0, a1, a2)
Modula-2:		ActivateGadget(gadget: GadgetPtr; window: WindowPtr; request-
			er: RequesterPtr): BOOLEAN
Arguments:		gadget = string gadget to activate
			window = window containing gadget
			requester = requester to receive gadgets; NULL if gadgets are not
			to be part of a requester
Result:			success = TRUE if successful; FALSE if arguments are bogus
-------------------------
ActivateWindow
Description:		activates a window
Library:		intuition.library
Offset:			-$01C2 (-450)
Modula-2 Module: 	Intuition
Syntax:        		ActivateWindow(window)
C:            		long ActivateWindow(struct Window *)
Machine Language: 	ActivateWindow(a0)
Modula-2:		ActivateWindow(window: WindowPtr)
Arguments:		window = window to activate
Result:			none
-------------------------
AddAnimOb
Description:		adds an AnimOb to the linked list of AnimObs
Library:		graphics.library
Modula-2 Module: 	Gels
Offset:         	-$009C (-156)
Syntax:        		AddAnimOb(anOb, anKey, rastPort)
C:            		void AddAnimOb(struct AnimOb *, long, struct RastPort *)
Machine Language: 	AddAnimOb(a0, a1, a2)
Modula-2:		AddAnimOb(anOb: AnimObPtr; anKey: ADDRESS; rastPort:
			RastPortPtr)
Arguments:		anOb = AnimOb structure to be added to list
			anKey = address of pointer to the first AnimOb in the list
			(anKey=NULL if none in list so far)
			rastPort = RastPort structure
Result:			none
-------------------------
AddBob
Description:     	adds a Bob to GEL list
Library:        	graphics.library
Offset:         	-$0060 (-96)
Modula-2 Module: 	Gels
Syntax:        		AddBob(bob, rastPort)
C:           		void AddBob(struct Bob *, struct RastPort *)
Machine Language: 	AddBob(a0, a1)
Modula-2:		AddBob(bob: BobPtr; VAR rastPort: RastPortPtr)
Arguments:		bob = Bob structure to be added to GEL list
			rastPort = RastPort structure
Result:			none
-------------------------
AddConfigDev
Description:		adds a new ConfigDev structure to the system's list of configura-
			tion devices
Library:		expansion.library
Offset:			-$001E (-30)
Modula-2 Module: 	ConfigVars
Syntax:        		AddConfigDev(configDev)
C:            		void AddConfigDev(long)
Machine Language: 	AddConfigDev(a0)
Modula-2:		AddConfigDev(configDev: ConfigDevPtr)
Arguments:		configDef = a valid ConfigDev structure
Result:			none
-------------------------
AddDevice
Description:		adds a device to the system
Library:		exec.library
Offset:			-$01B0 (-432)
Modula-2 Module: 	Devices
Syntax:        		AddDevice(device)
C:            		void AddDevice(struct Device *)
Machine Language: 	AddDevice(a1)
Modula-2:      		AddDevice(device: DevicePtr)
Arguments:     		device = initialized device node
Result:			none
-------------------------
AddDosNode
Description:     	mounts a disk
Library:        	expansion.library
Offset:         	-$0096 (-150)
Modula-2 Module: 	Expansion
Syntax:        		AddDosNode(bootPri, flags, deviceNode)
C:            		void AddDosNode(long, long, struct dosNode *)
Machine Language: 	AddDosNode(d0, d1, a0)
Modula-2:		AddDosNode(bootPri: INTEGER; flags: BITSET; deviceNode:
			DeviceNodePtr): BOOLEAN
Arguments:		bootPri = boot priority of disk-+5 for floppy disk, 0 for hard
			disk,-5 for a network disk,-128 non-bootable device
			flags = ADN_STARTPROC (1) to start handler process
			immediately
			dosNode = initialized device node, as returned by
			MakeDosNode( )
Result:			none
-------------------------
AddFont
Description:		adds a font to the system
Library:		graphics.library
Offset:			-$01E0 (-480)
Modula-2 Module: 	Text
Syntax:        		AddFont(textFont)
C:            		void AddFont(struct TextFont *)
Machine Language: 	AddFont(a1)
Modula-2:		AddFont(textFont: TextFontPtr)
Arguments:		textFont = TextFont structure (in public RAM) to add
Result:			none
-------------------------
AddFreeList
Description:		adds memory to the free list
Library:		icon.library
Offset:			-$0048 (72)
Modula-2 Module: 	Icon
Syntax:        		status = AddFreeList(free, mem, len)
C:            		long AddFreeList(struct FreeList *, char *, long)
Machine Language: 	d0 = AddFreeList(a0, a1, a2)
Modula-2:       	AddFreeList(free: FreeListPtr; mem: ADDRESS; len:
			LONGCARD): BOOLEAN
Arguments:		free = FreeList structure
			mem = memory to record
			len = length of the memory to record
Result:			status = nonzero value if the call succeeded
-------------------------
AddGadget
Description:		adds gadget to window
Library:		intuition.library
Offset:			-$002A (-42)
Modula-2 Module: 	Intuition
Syntax:        		position = AddGadget(window, gadget, position)
C:            		long AddGadget(struct Window *, struct Gadget *, long)
Machine Language: 	d0 = AddGadget(a0, a1, d0)
Modula-2:		AddGadget(window: WindowPtr; gadget: GadgetPtr; position:
			INTEGER): INTEGER
Arguments:		window = window to contain gadget
			gadget = gadget to add
			position = position in gadget list for new gadget; -1 for end of
			list
Result:			position = position where gadget is actually added
-------------------------
AddGList
Description:		adds or inserts a gadget list to an existing gadget list
Library:		intuition.library
Offset:			-$01B6 (-438)
Modula-2 Module: 	Intuition
Syntax: 	    	position = AddGList(window, gadget, position, numGadgets, 
			requester)
C:		        long AddGList(struct Window *, Gadget *, long, long, struct
			Requester *)
Machine Language: 	d0 = AddGList(a0, a1, d0, d1, a2)
Modula-2:		AddGList(window: WindowPtr; gadget: GadgetPtr; position:
			INTEGER; numGadgets: INTEGER; requester: RequesterPtr):
			CARDINAL

Arguments:		window = window to receive gadgets
			gadget = first gadget in new gadget list
			position = position in existing gadget list where new gadget list
			should be added
			numGadgets = number of gadgets to add
			requester = requester to receive gadgets; NULL if gadgets are not
			to be part of a requester
Result:			position = position where gadget list is actually added
-------------------------  
AddHead
Description:   		inserts a node at the head of a list
Library:        	exec.library
Offset:         	-$00F0 (-240)
Modula-2 Module: 	Lists
Syntax:        		AddHead(list, node)
C:            		void AddHead(struct List *, struct Node *)
Machine Language:	AddHead(a0, a1)
Modula-2:		AddHead(list: ListPtr; VAR node: NodePtr)
Arguments:		list = list header
			node = node to insert
Result:			none
-------------------------
AddIntServer
Description:		adds an interrupt server to the system
Library:		exec.library
Offset:			-$00A8 (-168)
Modula-2 Module: 	Interrupts
Syntax:        		AddlntServer(intNum, interrupt)
C:            		void AddIntServer(long, struct Interrupt *)
Machine Language: 	AddIntServer(d0, a1)
Modula-2:		AddIntServer(intNum: CARDINAL; interrupt: InterruptPtr)
Arguments:		intNum = portia interrupt bit (0-4)
			interrupt = interrupt server node
Result:			none
------------------------
AddLibrary
Description:		adds a library to the system
Library:		exec.library
Offset:			-$018C (-396)
Modula-2 Module: 	Libraries
Syntax:       		AddLibrary(library)
C:            		void AddLibrary(struct Library *)
Machine Language: 	AddLibrary(a1)
Modula-2:       	AddLibrary(library:LibraryPtr)
Arguments:      	library = initialized Library structure
Result:			none
-------------------------
AddMemList
Description:		adds memory to the system's pool of free memory
Library:        	exec.library
Offset:         	-$026A (-618)
Modula-2 Module: 	Memory
Syntax:        		AddMemList(size, attributes, pri, base, name)
C:            		void AddMemList(long, long, long, char *, char *)
Machine Language: 	AddMemList(d0, d1, d2, a0, a1)
Modula-2:		AddMemList(size: LONGCARD; attributes: MemReqSet; pri:
			INTEGER; base: ADDRESS; name: STRPTR)
Arguments:		size = size of memory block in bytes
			attributes = type of memory-MEMF_PUBLIC, MEMF_CHIP,
			MEMF_FAST, MEMB_CLEAR
			pri = priority of memory-CHIP memory has a priority of -10;
			16-bit expansion memory has a priority of 0
			base = address of the first location in the memory block
			name = name to be used in memory header; NULL for no name
Result:			none
-------------------------
AddPort
Description:		adds a message port to the system
Library:		exec.library
Offset:			-$0162 (-354)
Modula-2 Module: 	Ports
Syntax:        		AddPort(port)
C:            		void AddPort(struct MsgPort *)
Machine Language: 	AddPort(a1)
Modula-2:		AddPort(port: MsgPortPtr)
Arguments:		port = message port to add
Result:			none
-------------------------
AddResouree
Description:		adds a resource to the system
Library:		exec.library
Offset:			-$01E6 (-486)
Modula-2 Module: 	Resources
Syntax:        		AddResource(resource)
C:            		void AddResource(struct Resource *)
Machine Language: 	AddResource(a1)
Modula-2:		AddResource(resource: ResourcePtr)
Arguments:		resource = resource node
Result:			none
-------------------------
AddSemaphore
Description:		attaches a signal semaphore to the system
Library:		exec.library
Offset:			-$0258 (-600)
Modula-2 Module: 	Semaphores
Syntax:        		AddSemaphore(signalSemaphore)
C:            		void AddSemaphore(struct SignalSemaphore *)
Machine Language: 	AddSemaphore(a1)
Modula-2:		AddSemaphore(signalSemaphore: SignalSemaphorePtr)
Arguments:		signalSemaphore = initialized SignalSemaphore structure
Result:			none
-------------------------
AddTail
Description:		appends a node to the tail of a list
Library:		exec.library
Offset:			-$00F6 (-246)
Modula-2 Module: 	Lists
Syntax:        		AddTail(list, node)
C:            		void AddTail(struct List *, struct Node *)
Machine Language: 	AddTail(a0, a1)
Modula-2:		AddTail(list: ListPtr; node: NodePtr)
Arguments:		list = list header
			node = node to insert
Result:			none
-------------------------
AddTask
Description:		adds a task to the system
Library:		exec.library
Offset:			-$011A (-282)
Modula-2 Module: 	Tasks
Syntax:        		AddTask(task, initialPC, finalPC)
C:            		void AddTask(struct Task *, char *, char *)
Machine Language: 	AddTask(a1, a2, a3)
Modula-2:		AddTask(task: TaskPtr; initialPC, finalPC:ADDRESS)
Arguments:		task = task control block
			initialPC = initial entry point
			finalPC = address of entry point of finalization code
Result:			none
-------------------------
AddTOF
Description:		adds a task to the TopOfFrame (vertical-blanking interval) inter-
			rupt server chain
Library:		amiga.lib (linked library)
Modula-2 Module: 	none
Syntax:       		AddTOF(i, p, a)
C:            		void AddTOF(struct Isrvstr *, APTR, APTR)
Machine Language: 	pea a
			pea p
			pea i
			jsr _AddTOF
			add.l #12,sp
Modula-2:		not available
Arguments:		i = Isrvstr structure
			p = entry point of routine to call at every vertical blank
			a = array of long words that will receive routine's arguments
Result:			none
-------------------------
AddVSprite
Description:		adds VSprite to GEL list
Library:		graphics.library
Offset:			-$0066 (-102)
Modula-2 Module: 	Gels
Syntax:       		AddVSprite(vSprite, rastPort)
C:            		void AddVSprite(struct VSprite *, struct RastPort *)
Machine Language: 	AddVSprite(a0, a1)
Modula-2:      		AddVSprite(vSprite: VSpritePtr; rastPort: RastPortPtr)
Arguments:     		vSprite = initialized VSprite structure
			rastPort = RastPort structure
Result:			none
-------------------------   
afp
Description:     	converts an ASCII string into a fast floating point number
Library:        	amiga.lib (linked library)
Modula-2 Module: 	none
Syntax:        		fnum = afp(string)
C:           		float afp(char *)
Machine Language: 	pea string
			jsr _afp ;fnum returned in d0/d1
			addq.l #4,sp
Modula-2:		not available; use ConvStrToReal in RealConversions module
Arguments:		string = string to convert
Result:			fnum = floating point equivalent of string arguments
-------------------------
Alert
Description:		alerts the user of a serious error
Library:		exec.library
Offset:			-$006C (-108)
Modula-2 Module: 	Alerts
Syntax:        		Alert(alertNum, flags)
C:            		void Alert(long, char *)
Machine Language: 	Alert(d7, a5)
Modula-2:		Alert(alertNum: LONGCARD; flags: LONGCARD)
Arguments:		alertNum = alert number
			flags = second part of Guru Meditation number (usually the ad-
			dress of the offending task)
Result:			none
-------------------------
AllocAbs
Description:		allocates a block of memory from a specified location
Library:		exec.library
Offset:			-$00CC (-204)
Modula-2 Module:	 Memory
Syntax:        		memoryBlock = AllocAbs(byteSize, location)
C:            		void *AllocAbs(long, void *)
Machine Language: 	d0 = AllocAbs(d0, a1)
Modula-2:     		AllocAbs(byteSize: LONGCARD; location: ADDRESS): ADDRESS
Arguments:     		byteSize = size of desired block in bytes
			location = address where the memory must be
Result:			memoryBlock = pointer to allocated block; NULL if unsuccessful
------------------------- 
Allocate
Description:		allocates a block of memory
Library:        	exec.library
Offset:         	-$00BA (-186)
Modula-2 Module: 	Memory
Syntax:        		memoryBlock = Allocate(freeList, byteSize)
C:            		void *Allocate(struct MemHeader *, long)
Machine Language: 	d0 = Allocate(a0, d0)
Modula-2:		Allocate(freeList: MemHeaderPtr; byteSize: LONGCARD):
			ADDRESS
Arguments:		freeList = memory list header
			byteSize = size of desired block in bytes
Result:			memoryBlock = pointer to allocated block; NULL if unsuccessful.
-------------------------
AllocBoardMem
Description:		allocates expansion board memory
Library:		expansion.library
Offset:			-$002A (-42)
Modula-2 Module: 	Expansion
Syntax:        		startSlot = AllocBoardMem(slotSpec)
C:           		long AllocBoardMem(long)
Machine Language: 	d0 = AllocBoardMem(d0)
Modula-2:		AllocBoardMem(slotSpec: INTEGER): INTEGER
Arguments:		slotSpec = number of slots to allocate
Result:			startSlot = slot allocated; -1 if unsuccessful
------------------------
AllocCList
Description:		allocates and initializes a clist
Library:		clist.library
Offset:			$0024 (-36)
Modula-2 Module: 	none
Syntax:        		cList = AllocCList(cLPool)
C:            		long AllocCList(long)
Machine Language: 	d0 = AllocCList(a1)
Modula-2:      		not available
Arguments:     		cLPool = initialized CListPool
Result:			cList = longword cList descriptor; negative if unsuccessful.
------------------------- 
AllocConfigDev
Description:  		allocates a ConfigDev structure
Library:        	expansion.library
Offset:         	-$0030 (-48)
Modula-2 Module: 	ConfigVars
Syntax:        		configDev = AllocConfigDev( )
C:            		struct ConfigDev *AllocConfigDev(void)
Machine Language: 	d0 = AllocConfigDev( )
Modula-2:		AllocConfigDev( ): ConfigDevPtr
Arguments:		none
Result:			configDef = a valid ConfigDev structure; NULL if unsuccessful
-------------------------
AllocEntry
Description:		allocates many regions of memory
Library:		exec.library
Offset:			-$00DE (-222)
Modula-2 Module: 	Memory
Syntax:        		memlist = AllocEntry(memlist)
C:            		struct MemList *AllocEntry(stuct MemList *)
Machine Language: 	d0 = AllocEntry(a0)
Modula-2:       	AllocEntry(memList: MemListPtr): MemListPtr
Arguments:      	memList = initialized cList pool
Result:         	memList = different memList filled with allocated memory
------------------------
AllocExpansionMem
Description:     	allocates expansion memory
Library:        	expansion.library
Offset:         	-$0036 (-54)
Modula-2 Module: 	Expansion
Syntax:        		startSlot = AllocExpansionMem(numSlots, slotOffset)
C:            		CPTR AllocExpansionMem(long, long)
Machine Language: 	d0 = AllocExpansionMem(d0, d1)
Modula-2:      		AllocExpansionMem(numSlots, slot Offset: INTEGER): INTEGER
Arguments:     		numSlots = number slots to allocate
			slotOffset = boundary offset
Result:			startSlot = slot allocated; -1 if unsuccessful
------------------------- 
AllocMem
Description:		allocates many regions of memory
Library:        	exec.library
Offset:         	-$00C6 (-198)
Modula-2 Module: 	Memory
Syntax:        		memoryBlock = AllocMem(byteSize, requirements)
C:            		void *AllocMem(long, long)
Machine Language: 	d0 = AllocMem(d0, d1)
Modula-2:		AllocMem(byteSize: LONGCARD; requirements: MemReqSet):
			ADDRESS
Arguments:		byteSize = size of desired block in bytes
			requirements = type of memory-MEMF_PUBLIC,
			MEMF_CHIP, MEMF_FAST, MEMB_CLEAR
Result:			memoryBlock = pointer to allocated block
-------------------------
AllocRaster
Description:		allocates space for a bit plane
Library:		graphics.library
Offset:			-$01EC (-492)
Modula-2 Module: 	Rasters
Syntax:        		raster = AllocRaster(width, height)
C:            		PLANEPTR AllocRaster(long, long)
Machine Language: 	d0 = AllocRaster(d0, d1)
Modula-2:		AllocRaster(width, height: CARDINAL): PlanePtr
Arguments:		width = width of bitplane in pixels
			height = height of bitplane in pixels
Result:			raster = pointer to allocated memory; NULL if unsuccessful
-------------------------
AllocRemember
Description:		calls AllocMem and creates a link node
Library:		intuition.library
Offset:			-$018C (-396)
Modula-2 Module: 	Intuition
Syntax:        		memoryBlock = AllocRemember(rememberKey, size, flags)
C:            		char *AllocRemember(struct Remember *, long, long)
Machine Language: 	d0 = AllocRemember(a0, d0, d1)
Modula-2:      		AllocRemember(VAR rememberKey: RememberPrt; size:
			LONGCARD; flags: MemReqSet): ADDRESS
Arguments:		rememberKey = address of pointer to Remember structure
			size = size of desired block in bytes
 			flags = type of memory-MEMF_PUBLIC, MEMF_CHIP, 
			MEMF_FAST, MEMB_CLEAR
Result:			memoryBlock = pointer to allocated block
-------------------------
AllocSignal
Description:		allocates a signal bit
Library:		exec.library
Offset:			-$014A (-330)
Modula-2 Module: 	Tasks
Syntax:        		signalNum = AllocSignal(signalNum)
C:            		long AllocSignal(long)
Machine Language: 	d0 = AllocSignal(d0)
Modula-2:		AllocSignal(signalNum: SIGNAL): SIGNAL
Arguments:		signalNum = desired signal number (0-31); -1 for no preference
Result:			signalNum = signal number allocated; -1 if no signal is
			available
-------------------------
AllocTrap
Description:		allocates a processor trap vector
Library:		exec.library
Offset:			-$0156 (-342)
Modula-2 Module: 	Tasks
Syntax:        		trapNum = AllocTrap(trapNum)
C:            		long AllocTrap(long)
Machine Language: 	d0 = AllocTrap(d0)
Modula-2:		AllocTrap(trapNum: TRAP): TRAP
Arguments:		trapNum = desired trap number (0-15); -1 for no preference
Result:			trapNum = trap number allocated; -1 if no trap is available
-------------------------
AllocWBObject
Description:		allocates a Workbench object
Library:		icon.library
Offset:			-$0042 (-66)
Modula-2 Module: 	none
Syntax:        		object = AllocWBObject( )
C:            		struct WBObject AllocWBObject(void)
Machine Language: 	d0 = AllocWBObject( )
Modula-2:       	not available
Arguments:      	none
Result:			object = the WBObject; NULL if unsuccessful
-------------------------
AndRectRegion
Description:		performs a two-dimensional AND operation of a rectangle with a
			region, leaving the result in the region
Library:		graphics.library
Offset:			-$01F8 (-504)
Modula-2 Module: 	Regions
Syntax:        		AndRectRegion(region, rectangle)
C:            		void AndRectRegion(struct Region *, struct Rectangle *)
Machine Language: 	AndRectRegion(a0, a1)
Modula-2:		AndRectRegion(region: RegionPtr; rectangle: RectanglePtr)
Arguments:		region = Region structure
			rectangle = Rectangle structure
Result:			none
-------------------------
AndRegionRegion
Description:		performs a two-dimensional AND operation of one region with a
			second region, leaving the result in second region
Library:		graphics.library
Offset:			-$0270 (-624)
Modula-2 Module: 	Regions
Syntax:        		success = AndRegionRegion(region1, region2)
C:            		long AndRegionRegion(struct Region *, struct Region *)
Machine Language: 	d0 = AndRegionRegion(a0, a1)
Modula-2:		AndRegionRegion(region1, region2: RegionPtr): BOOLEAN
Arguments:		region1 = Region structure
			region2 = Region structure
Result:	success = 	TRUE if successful; FALSE if unsuccessful
-------------------------
Animate
Description:		processes every AnimOb in the current animation list
Library:		graphics.library
Offset:			-$00A2 (-162)
Modula-2 Module: 	Gels
Syntax:        		Animate(anKey, rastPort)
C:            		void Animate(long, struct RastPort *)
Machine Language: 	Animate(a0, a1)
Modula-2:       	Animate(ankey: ADDRESS; rastPort: RastPortPtr)
Arguments:     		anKey = address of variable that points to the head AnimOb
			rastPort = RastPort structure
Result:			none
-------------------------
AreaCircle (macro)
Description:     	adds a circle to the list of points used to fill an area
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module: 	Areas
Syntax:        		error = AreaCircle(rastPort, cx, cy, radius)
C:            		long AreaCircle(struct RastPort *, long, long, long)
Machine Language: 	not available, use AreaEllipse
Modula-2:		AreaCircle(rp: RastPortPtr; cx, cy, radius: INTEGER): INTEGER
Arguments:		rastPort = RastPort structure
			cx = horizontal coordinate of circle's center
			cy = vertical coordinate of circle's center
			radius = circle's radius
Result:			error = 0 if successful; -1 if no room left in list of points
-------------------------
AreaDraw
Description:		adds a point to the list of points used to fill an area
Library:		graphics.library
Offset:			-$0102 (-258)
Modula-2 Module: 	Areas
Syntax:        		error = AreaDraw(rastPort, x, y)
C:            		long AreaDraw(struct RastPort *, long, long)
Machine Language: 	d0 = AreaDraw(a1, d0, d1)
Modula-2:		AreaDraw(rastPort: RastPortPtr; x, y: INTEGER): INTEGER
Arguments:		rastPort = RastPort structure
			x = horizontal coordinate of point
			y = vertical coordinate of point
Result:			error = 0 if successful; -1 if no room left in list of points
-------------------------
AreaEllipse
Description:		adds an ellipse to the list of points used to fill an area
Library:		graphics.library
Offset:			-$00BA (-186)
Modula-2 Module: 	Areas
Syntax:        		error = AreaEllipse(rastPort, cx, cy, a, b)
C:            		long AreaEllipse(struct RastPort *, long, long, long, long)
Machine Language: 	d0 = AreaEllipse(a1, d0, d1, d2, d3)
Modula-2:       	AreaEllipse(rastPort: RastPortPtr; cx, cy, a, b: INTEGER):
			INTEGER
-------------------------
AttemptLockLayerRom
Description:		attempts to lock a Layer structure
Library:        	graphics.library
Offset:         	-$028E (-582)
Modula-2 Module: 	Clip
Syntax:        		success = AttemptLockLayerRom(layer)
C:            		long AttemptLockLayerRom(struct Layer *)
Machine Language: 	d0 = AttemptLockLayerRom(a5)
Modula-2:		AttemptLockLayerRom(layer: LayerPtr): BOOLEAN
Arguments:		layer = Layer structure to lock
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
AttemptSemaphore
Description:		attempts to obtain access to a SignalSemaphore structure
Library:		exec.library
Offset:			-$0240 (-576)
Modula-2 Module: 	Semaphores
Syntax:        		success = AttemptSemaphore(signalSemaphore)
C:            		long AttemptSemaphore(struct SignalSemaphore *)
Machine Language: 	d0 = AttemptSemaphore(a0)
Modula-2:		AttemptSemaphore(signalSemaphore: SignalSemaphorePtr):
			BOOLEAN
Arguments:		signalSemaphore = initialized SignalSemaphore structure
Result:			success = TRUE if successful; FALSE if another task is using
			specified SignalSemaphore structure
-------------------------
AutoRequest
Description:		automatically creates and gets a response from a requester
Library:		intuition.library
Offset:			-$015C (-348)
Modula-2 Module: 	Intuition
Syntax:        		response = AutoRequest(window, bodyText, positiveText,
			negativeText, positiveFlags, negativeFlags, width, height)
C:            		long AutoRequest(struct Window *, struct IntuiText *, struct
			IntuiText *, struct IntuiText *, long, long, long)
Machine Language: 	d0 = AutoRequest(a0, a1, a2, a3, d0, d1, d2, d3)
Modula-2:      		AutoRequest(window: WindowPtr; bodyText, positiveText,
			negativeText: IntuiTextPtr; positiveFlags, negativeFlags:
			IDCMPFlagsSet; width, height: INTEGER): BOOLEAN
Arguments:		window = Window structure
			bodyText = IntuiText structure
			positiveText = IntuiText structure
			negativeText = IntuiText structure
			positiveFlags = flags for the IDCMP
			negativeFlags = flags for the IDCMP
			width = width of requester
			height = height of requester
Result:			response = TRUE for a positive response; FALSE for a negative
			response
-------------------------
AvailFonts
Description:		builds an array of all available fonts on disk and/or in memory
Library:		diskfont.library
Offset:			-$0024 (-36)
Modula-2 Module: 	DiskFont
Syntax:        		error = AvailFonts(buffer, bufBytes, types)
C:            		long AvailFonts(char *, long, long)
Machine Language: 	d0 = AvailFonts(a0, d0, d1)
Modula-2:		AvailFonts(buffer: ADDRESS; bufBytes: LONGCARD; types:
			AFTypeSet): LONGCARD
Arguments:		buffer = memory buffer used to hold the array
			bufBytes = size of buffer in bytes
			types = type of fonts to search for-AFF_MEMORY and/or
			AFF_DISK
Result:			error = 0 if successful, otherwise, error contains the number of
			additional bytes that must be added to the buffer size (bufBytes)
			to contain all of the font information
-------------------------
AvailMem
Description:		returns memory available given certain requirements
Library:		exec.library
Offset:			-$00D8 (-216)
Modula-2 Module: 	Memory
Syntax:        		size = AvailMem(requirements)
C:            		long AvailMem(long)
Machine Language: 	d0 = AvailMem(d1)
Modula-2:      		AvailMem(requirements: MemReqSet): LONGCARD
Arguments:     		requirements = type of memory required-MEMF_PUBLIC,
			MEMF_CHIP, MEMF_FAST, MEMB_CLEAR
Result:			size = total free space remaining
------------------------- MISSING IN ORIGINAL TEXT!!!! -------------------------
Arguments:		rastPort = RastPort structure
			cx = horizontal coordinate of ellipse's center
			cy = vertical coordinate of ellipse's center
			a = horizontal radius of ellipse (must be greater than O)
			b = vertical radius of ellipse (must be greater than O)
Result:			error = 0 if successful; -1 if no room left in list of points
-------------------------
AreaEnd
Description:		fills an area using a list of vertices
Library:		graphics.library
Offset:			-$0108 (-264)
Modula-2 Module: 	Areas
Syntax:        		error = AreaEnd(rastPort)
C:            		long AreaEnd(struct RastPort *)
Machine Language: 	d0 = AreaEnd(a1)
Modula-2:		AreaEnd(rastPort: RastPortPtr): INTEGER
Arguments:		rastPort = RastPort structure
Result:			error = 0 if successful; -1 if unsuccessful
-------------------------
AreaMove
Description:		closes the current polygon described by a table of vertices and de-
			fines the starting point for a new polygon
Library:		graphics.library
Offset:			-$00FC (-252)
Modula-2 Module: 	Areas
Syntax:        		error = AreaMove(rastPort, x, y)
C:            		long AreaMove(struct RastPort *, long, long)
Machine Language: 	d0 = AreaMove(a1, d0, d1)
Modula-2:		AreaMove(rastPort: RastPortPtr; x, y: INTEGER): INTEGER
Arguments:		rastPort = RastPort structure
			x = horizontal coordinate of point
			y = vertical coordinate of point
Result:			error = 0 if successful; -1 if no room left in list of points
-------------------------
arnd
Description:		rounds a floating point number contained in an ASCII string
Library:		amiga.lib (linked library)
Modula-2 Module: 	none
Syntax:        		arnd(place, exp, string)
C:			void arnd(long, long, char *)
Machine Language: 	pea string 
			move.l #exp,-(sp) 
			move.l #place,-(sp) 
			jsr _arnd 		;string contents are modified 
			add.l #12,sp
Modula-2:		not available
Arguments:		place = number of desired decimal places
			exp = exponent value of number in string argument
			string = string containing number to round
Result:			string argument is modified to contain rounded number
-------------------------
AskFont
Description:		puts text attributes of the current font in the specified TextAttr
			structure
Library:		graphics.library
Offset:			-$01DA (-474)
Modula-2 Module: 	Text
Syntax:        		AskFont(rastPort, textAttr)
C:            		void AskFont(struct RastPort *, struct TextAttr *)
Machine Language: 	AskFont(a1, a0)
Modula-2:		AskFont(rastPort: RastPortPtr; textAttr: TextAttrPtr)
Arguments:		rastPort = RastPort structure
			textAttr = TextAttr structure to be filled
Result:			returns results in textAttr argument
-------------------------
AskSoftStyle
Description:		returns the soft style bits of the current font
Library:		graphics.library
Offset:			-$0054 (-84)
Modula-2 Module: 	Text
Syntax:        		enable = AskSoftStyle(rastPort)
C:            		long AskSoftStyle(struct RastPort *)
Machine Language: 	d0 = AskSoftStyle(a1)
Modula-2:      		AskSoftStyle(rastPort: RastPortPtr): FontStyleSet
Arguments:     		rastPort = RastPort structure
Result:			enable = valid style bits
-------------------------
BeginIO 
Description: 		initiates an IO request like SendIO( ), but does not clear io_Flags 
			field 
Library:	        amiga.lib (linked library) 
Modula-2 Module: 	IO 
Syntax:        		BeginIO(ioRequest) 
C:            		void BeginIO(struct IORequest *) 
Machine Language: 	pea ioRequest
			jsr _BeginIO
			addq.l #4,sp
Modula-2:		BeginIO(ioRequest: ADDRESS)
Arguments:		IORequest = initialized IORequest structure
Result:			none
-------------------------
BeginRefresh
Description:		sets up a window for optimized refreshing
Library:		intuition.library
Offset:			-$0162 (-354)
Modula-2 Module: 	Intuition
Syntax:        		BeginRefresh(window)
C:            		void BeginRefresh(struct Window *)
Machine Language: 	BeginRefresh(a0)
Modula-2:		BeginRefresh(window: WindowPtr)
Arguments:		window = window that needs updating
Result:			none
-------------------------
BeginUpdate
Description:		prepares to repair a damaged layer
Library:		layers.library
Offset:			-$004E (-78)
Modula-2 Module: 	Layers
Syntax:        		success = BeginUpdate(layer)
C:            		long BeginUpdate(struct Layer *)
Machine Language: 	d0 = BeginUpdate(a0)
Modula-2:      		BeginUpdate(layer: LayerPtr): BOOLEAN
Arguments:     		layer = Layer to be repaired
Result:			TRUE if successful; FALSE if unsuccessful
------------------------- 
BehindLayer
Description:     	moves a layer behind other layers
Library:        	layers.library
Offset:         	-$0036 (-54)
Modula-2 Module: 	Layers
Syntax:       		success = BehindLayer(dummy, layer)
C:            		long BehindLayer(struct Layer_Info, struct Layer *)
Machine Language: 	d0 = BehindLayer(a0, a1)
Modula-2:		BehindLayer(layer: LayerPtr): BOOLEAN
Arguments:		dummy = unused
			layer = Layer to move behind other layers
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
BltBitMap
Description:		uses the blitter chip to move (blit) a rectangular region of bits from
			a BitMap to a BitMap
Library:		graphics.library
Offset:			-$001E (-30)
Modula-2 Module: 	Blitter
Syntax:   		planes = BltBitMap(scrBitMap, srcX, srcY, destBitMap, destX, 
			destY, sizeX, sizeY, miniterm, mask, tempA)

C:		        long BltBitMap(struct BitMap *, long, long, struct BitMap *, long, 
			long, long, long, long, long, char *)
Machine Language: 	d0 = BltBitMap(a0, d0, d1, a1, d2, d3, d4, d5, d6, d7, a2)
Modula-2:		BltBitMap(scrBitMap: BitMapPtr; srcX, srcY: INTEGER;
			destBitMap: BitMapPtr; destX, destY: INTEGER; sizeX, sizeY:
			INTEGER; miniterm: BYTE; mask: BITSET; tempA: ADDRESS):
			LONGCARD
Arguments:		scrBitMap = source BitMap structure
			srcX = horizontal coordinate of upper left corner of source
			rectangle
			srcY = vertical coordinate of upper left corner of source rectangle
			destBitMap = destination BitMap structure
			destX = horizontal coordinate of upper left corner of destination
			rectangle
			destY = vertical coordinate of upper left corner of destination
			rectangle
			sizeX = width of rectangle
			sizeY = height of rectangle
			miniterm = logic function to apply to rectangle
			mask = bit planes to be affected
			tempA = pointer to chip memory for one source line or NULL
Result:			planes = actual number of planes involved in blit
-------------------------
BltBltMapRastPort
Description:		moves a rectangular region from a BitMap to a RastPort
Library: 		graphics.library
Offset: 	        -$025E (-606)
Modula-2 Module:	Blitter
Syntax:        		BltBitMapRastPort(srcBitMap, srcX, srcY, destRastPort, destX, 
			destY, sizeX, sizeY, miniterm)
C:		        void BltBitMapRastPort(struct BitMap *, long, long, struct RastPort
			*, long, long, long, long, long)
Machine Language: 	BltBitMapRastPort(a0, d0, d1, a1, d2, d3, d4, d5, d6)
Modula-2:		BltBitMapRastPort(srcBitMap: BitMapPtr; srcX, srcY: INTEGER;
			destRastPort: RastPortPtr; destX, destY: INTEGER; sizeX, sizeY:
			INTEGER; miniterm: BYTE)
Arguments:		srcBitMap = source BitMap structure
			srcX = horizontal coordinate of upper left corner of source
			rectangle
			srcY = vertical coordinate of upper left corner of source rectangle
			destRastPort = destination RastPort structure
			destX = horizontal coordinate of upper left corner of destination
			rectangle
			destY = vertical coordinate of upper left corner of destination
			rectangle
			sizeX = width of rectangle
			sizeY = height of rectangle
			miniterm = logic function to apply to rectangle
Result:			none
-------------------------
BltClear
Description:		fills a section of chip memory with zeros
Library:		graphics.library
Offset:			-$012C (-300)
Modula-2 Module: 	Blitter
Syntax:        		BltClear(memBlock, byteCount, flags)
C:            		void BltClear(char *, long, long)
Machine Language: 	BltClear(a1, d0, d1)
Modula-2:      		BltClear(memBlock: ADDRESS; byteCount: LONGCARD; flags:
			BltClearFlagSet)

Arguments:		memBlock = memory to clear (must start on a word boundary)
			byteCount = number of bytes to clear
			flags = set bit 0 to force function to wait until memory is cleared;
			set bit 1 if byteCount is to be interpreted as the number of rows
			and bytes per row to clear; clear bit 1 if byteCount is to be inter-
			preted as an even number of bytes
Result:			none
-------------------------
BltMaskBitMapRastPort
Description: 		moves a rectangular region from a BitMap to a RastPort through a 
			mask
Library:	        graphics.library
Offset:         	-$027C (-636)
Modula-2 Module: 	Blitter
Syntax:        		BltMaskBitMapRastPort(srcBitMap, srcX, srcY, destRastPort, destX, 
			destY, sizeX, sizeY, miniterm, mask)
C:		        void BltMaskBitMapRastPort(struct BitMap *, long, long, struct 
			RastPort *, long, long, long, long, long, APTR)
Machine Language: 	BltMaskBitMapRastPort(a0, d0, d1, a1, d2, d3, d4, d5, d6, a2)
Modula-2:		BltMaskBitMapRastPort(srcBitMap: BitMapPtr; srcX, srcY: INTE-
			GER; destRastPort: RastPortPtr; destX, destY: INTEGER; sizeX,
			sizeY: INTEGER; miniterm: BYTE; mask: PlanePtr)
Arguments:		srcBitMap = source BitMap structure
			srcX = horizontal coordinate of upper left corner of source
			rectangle
			srcY = vertical coordinate of upper left corner of source rectangle
			destRastPort = destination RastPort structure
			destX = horizontal coordinate of upper left corner of destination
			rectangle
			destY = vertical coordinate of upper left corner of destination
			sizeX = width of rectangle
			sizeY = height of rectangle
			miniterm = logic function to apply to rectangle
			mask = pointer to bit-plane mask
Result:			none
-------------------------
BltPattern
Description:		draws through a mask using standard drawing rules
Library:		graphics.library
Offset:			-$0138 (-312)
Modula-2 Module: 	Blitter
Syntax:			BltPattern(destRastPort, pattern, x1, y1, x2, y2, width)
C:		        void BltPattern(struct RastPort *, struct RastPort *, long, long, 
			long, long, long)
Machine Language: 	BltPattern(a1, a0, d0, d1, d2, d3, d4)
Modula-2:		BltPattern(destRastPort: RastPortPtr; pattern: ADDRESS; x1, y1:
			INTEGER; x2, y2: INTEGER; width: INTEGER)
Arguments:		destRastPort = destination RastPort
			pattern = two-dimensional mask pattern
			x1 = horizontal coordinate of upper left corner in destination
			RastPort
			y1 = vertical coordinate of upper left corner in destination
			RastPort
			x2 = horizontal coordinate of lower right corner in destination
			RastPort
			y2 = vertical coordinate of lower right corner in destination
			RastPort
			width = width of mask in bytes
Result:			none
-------------------------
BltTemplate
Description:		"cookie cuts" a shape in a rectangle to a RastPort
Library:		graphics.library
Offset:			-$0024 (-36)
Modula-2 Module: 	Blitter
Syntax:		        BltTemplate(source, srcX, srcMod, destRastPort, destX, destY, 
			sizeX, sizeY)
C:		        void BltTemplate(char *, long, long, struct RastPort *, long, long, 
			long, long)
Machine Language: 	BltTemplate(a0, d0, d1, a1, d2, d3, d4, d5)
Modula-2:		BltTemplate(source: PlanePTR; srcX, srcMod: INTEGER;
			destRastPort: RastPortPtr; destX, destY: INTEGER; sizeX, sizeY:
			INTEGER) (changes)
Arguments:		source = template mask
			srcX = horizontal offset into template mask (0-15)
			srcMod = number of bytes per row in template mask
			destRastPort = destination RastPort
			destX = horizontal coordinate of upper left corner in destination
			RastPort
			destY = vertical coordinate of upper left corner in destination
			RastPort
			sizeX = width of rectangular template
			sizeY = height of rectangular template
Result:			none
-------------------------
BNDRYOFF (macro)
Description:    	turns boundary mode off
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module: 	Pens
Syntax:        		BNDRYOFF(rastPort)
C:            		void BNDRYOFF(struct RastPort *)
Machine Language: 	not available
Modula-2:		BNDRYOFF(rastPort: RastPortPtr)
Arguments:		rastPort = RastPort structure
Result:			none
-------------------------
BuildSysRequest
Description:		builds and displays a system requester
Library:		intuition.library
Offset:			-$0168 (-360)
Modula-2 Module: 	Intuition
Syntax:		        window = BuildSysRequest(window, bodyText, positiveText, 
			negativeText, flags, width, height)
C:		        struct Window *BuildSysRequest(struct Window *, struct IntuiText 
			*, struct IntuiText *, struct IntuiText *, long, long, long)
Machine Language: 	d0 = BuildSysRequest(a0, a1, a2, a3, d0, d1, d2)
Modula-2:		BuildSysRequest(window: WindowPtr; bodyText, positiveText,
			negativeText: IntuiTextPtr; flags: IDCMPFlagsSet; width, height:
			INTEGER): ADDRESS
Arguments:		window = Window to contain requester
			bodyText = IntuiText structure containing requester's main text
			positiveText = IntuiText structure containing text for positive
			gadget
			negativeText = IntuiText structure containing text for negative
			gadget
			flags = IDCMP flags for initialization of window containing
			requester
			width = requester width
			height = requester height
Result:			window = pointer to window containing requester; if requester
			could not be opened, DisplayAlert( ) is called and this function re-
			turns TRUE if the left mouse button is pressed and FALSE if the
			right mouse button is pressed
------------------------- 
BumpRevision
Description:  		creates a new name for the copy of a file, directory, or disk
Library:       		icon.library
Offset:         	-$006C (-108)
Modula-2 Module: 	Icon
Syntax:        		newname = BumpRevision(newbuf, oldname)
C:            		long BumpRevision(char *, char *)
Machine Language: 	d0 = BumpRevision(a0, a1)
Modula-2:		BumpRevision(newbuf, oldname: STRPTR)
Arguments:		newbuf = buffer to contain the new name (must be at least 31
			characters long)
			oldname = old name
Result:			newname = pointer to the new name contained in newbuf
-------------------------
Cause
Description:		causes a software interrupt
Library:		exec.library
Offset:			-$00B4 (-180)
Modula-2 Module: 	Interrupts
Syntax:        		Cause(interrupt)
C:            		void Cause(struct Interrupt *)
Machine Language: 	Cause(a1)
Modula-2:		Cause(interrupt: InterruptPtr)
Arguments:		interrupt = initialized interrupt node
Result:			none
-------------------------
CBump
Description:		moves to the next position in user copper list
Library:		exec.library
Offset:			-$016E (-366)
Modula-2 Module: 	Copper
Syntax:        		CBump(copList)
C:            		void CBump(struct UCopList *)
Machine Language: 	CBump(a1)
Modula-2:      		CBump(copList: UCopListPtr)
Arguments:     		copList = UCopList structure
Result:			none
-------------------------
CEND (macro)
Description:    	adds the final instruction to a user copper list
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module: 	Copper
Syntax:        		CEND(copList)
C:            		void CEND(struct UCopList *)
Machine Language: 	not available
Modula-2:		CEND(VAR copList: UCopList)
Arguments:		copList = UCopList structure
Result:			none
------------------------
ChangeSprite
Description:		changes the shape of a sprite
Library:		graphics.library
Offset:			-$01A4 (-420)
Modula-2 Module: 	Sprites
Syntax:        		ChangeSprite(viewPort, simpleSprite, newdata)
C:            		void ChangeSprite(struct ViewPort *, struct SimpleSprite *, short *)
Machine Language: 	ChangeSprite(a0, a1, a2)
Modula-2:		ChangeSprite(viewPort: ViewPortPtr; simpleSprite:
			SimpleSpritePtr; newdata: ADDRESS)
Arguments:		viewPort = ViewPort structure
			simpleSprite = initialized SimpleSprite structure
			newdata = table of sprite shape data
Result:			none
-------------------------
CheckIO
Description:		gets the status of an IO request
Library:		exec.library
Offset:			-$01D4 (-468)
Modula-2 Module: 	IO
Syntax:        		status = CheckIO(ioRequest)
C:            		long CheckIO(struct IORequest *)
Machine Language: 	d0 = CheckIO(a1)
Modula-2:       	CheckIO(ioRequest: ADDRESS): ADDRESS
Arguments:     		ioRequest = IORequest block
Result:         	status = NULL if I/O is still in progress; pointer to IORequest
			block if I/O has completed
-------------------------
CINIT (macro)
Description:     	initializes a user copper list
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module: 	Copper
Syntax:        		copList = CINIT(copList, num)
C:            		struct UCopList *CINIT(struct UCopList *, short)
Machine Language: 	not available
Modula-2:		CINIT(copList: UCopListPtr; num: CARDINAL): UCopListPtr
Arguments:		copList = UCopList structure
			num = number of instructions buffer must hold
Result:			copList = pointer to an initialized UCopList structure, ready to
			accept copper instructions
-------------------------
ClearDMRequest
Description:		clears the DMRequest of a window
Library:		intuition.library
Offset:			-$0030 (-48)
Modula-2 Module: 	Intuition
Syntax:        		success = ClearDMRequest(window)
C:            		long ClearDMRequest(struct Window *)
Machine Language: 	d0 = ClearDMRequest(a0)
Modula-2:		ClearDMRequest(window: WindowPtr): BOOLEAN
Arguments:		window = window from which DMRequest is to be cleared
Result:			success = TRUE if successful; FALSE if unsuccessful (DMRequest
			is still in use)
-------------------------
ClearEOL
Description:		clears from the current position to the end of the line
Library:		graphics.library
Offset:			-$002A (-42)
Modula-2 Module: 	Text
Syntax:        		ClearEOL(rastPort)
C:            		void ClearEOL(struct RastPort *)
Machine Language: 	ClearEOL(a1)
Modula-2:       	ClearEOL(rastPort: RastPortPtr)
Arguments:     		rastPort = RastPort structure to clear
Result:			none
------------------------- 
ClearMenuStrip
Description:  		clears (detaches) a window's menu strip
Library:        	intuition.library
Offset:         	-$0036 (-54)
Modula-2 Module: 	Intuition
Syntax:        		ClearMenuStrip(window)
C:            		void ClearMenuStrip(struct Window *)
Machine Language: 	ClearMenuStrip(a0)
Modula-2:		ClearMenuStrip(window: WindowPtr)
Arguments:		window = Window structure
Result:			none
-------------------------
ClearPointer
Description:		returns the mouse pointer to its default shape
Library:		intuition.library
Offset:			-$003C (-60)
Modula-2 Module: 	Intuition
Syntax:        		ClearPointer(region)
C:            		void ClearPointer(struct Region *)
Machine Language: 	ClearPointer(a0)
Modula-2:		ClearPointer(window: WindowPtr)
Arguments:		window = Window structure
Result:			none
-------------------------
ClearRectRegion
Description:		performs a two-dimensional clearing operation of a clipping rec
			tangle with a region, leaving the result in the region
Library:		graphics.library
Offset:			-$020A (-522)
Modula-2 Module: 	Regions
Syntax:        		success = ClearRectRegion(region, rectangle)
C:            		long ClearRectRegion(struct Region *, struct Rectangle *)
Machine Language: 	d0 = ClearRectRegion(a0, a1)
Modula-2:		ClearRectRegion(region: RegionPtr; rectangle: RectanglePtr):
			BOOLEAN
Arguments:		region = Region to clear
			rectangle = Rectangle to be used as the clipping rectangle
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
ClearRegion
Description:    	removes all rectangles from a region
Library:        	graphics.library
Offset:         	-$0210 (-528)
Modula-2 Module: 	Regions
Syntax:        		ClearRegion(region)
C:            		void ClearRegion(struct Region *)
Machine Language: 	ClearRegion(a0)
Modula-2:		ClearRegion(region: RegionPtr)
Arguments:		region = Region to clear
Result:			none
-------------------------
ClearScreen
Description:		clears from the current position to the end of the RastPort
Library:		graphics.library
Offset:			-$0030 (-48)
Modula-2 Module: 	Text
Syntax:        		ClearScreen(rastPort)
C:            		void ClearScreen(struct RastPort *)
Machine Language: 	ClearScreen(a1)
Modula-2:		ClearScreen(rastPort: RastPortPtr)
Arguments:		rastPort = RastPort to clear
Result:			none
-------------------------
ClipBlit
Description:		copies bit-map data (and optionally manipulates) from one
			RastPort to another
Library:		graphics.library
Offset:			-$0228 (-552)
Modula-2 Module: 	Blitter
Syntax:        		ClipBlit(scrRastPort, srcX, srcY, destRastPort, destX, destY, sizeX,
			sizeY, miniterm)
C:            		void ClipBlit(struct RastPort * long, long, struct RastPort *, long,
			long, long, long, long)
Machine Language: 	ClipBlit(a0, d0, d1, a1, d2, d3, d4, d5, d6)
Modula-2:       	ClipBlit(scrRPort: RastPortPtr; srcX, srcY: INTEGER; destRPort:
			RastPortPtr; destX, destY: INTEGER; sizeX, sizeY: INTEGER;
			miniterm: BYTE)
Arguments:		scrRastPort = source RastPort structure
			srcX = horizontal coordinate of upper left corner of source
			rectangle
			srcY = vertical coordinate of upper left corner of source rectangle
			destRastPort = destination RastPort structure
			destX = horizontal coordinate of upper left corner of destination
			rectangle
			destY = vertical coordinate of upper left corner of destination
			rectangle
			sizeX = width of rectangle
			sizeY = height of rectangle
			miniterm = logic function to apply to rectangle
Result:			none
-------------------------
Close
Description:		closes an open file
Library:		dos.library
Offset:			-$0024 (-36)
Modula-2 Module: 	DOS
Syntax:        		Close(file)
C:            		void Close(BPTR)
Machine Language: 	Close(d1)
Modula-2:		Close(file: FileHandle)
Arguments:		file = BCPL pointer to file handle of file to close
Result:			none
-------------------------
CloseDevice
Description:		terminates access to a device
Library:		exec.library
Offset:			-$01C2 (-450)
Modula-2 Module: 	Devices
Syntax:        		CloseDevice(ioRequest)
C:            		void CloseDevice(struct IORequest *)
Machine Language: 	CloseDevice(a1)
Modula-2:       	CloseDevice(ioRequest: ADDRESS)
Arguments:     		ioRequest = IORequest structure
Result:			none
-------------------------
CloseFont
Description:     	tells the system that an opened font is no longer in use
Library:        	graphics.library
Offset:         	-$004E (-78)
Modula-2 Module: 	Text
Syntax:        		CloseFont(font)
C:            		void CloseFont(struct TextFont *)
Machine Language: 	CloseFont(a1)
Modula-2:		CloseFont(textfont: TextFontPtr)
Arguments:		font = font descriptor as returned by OpenFont( ) or
			OpenDiskFont( )
Result:			none
-------------------------
CloseLibrary
Description:		tells the system that an opened library is no longer in use
Library:		exec.library
Offset:			-$019E (-414)
Modula-2 Module: 	Libraries
Syntax:        		CloseLibrary(library)
C:           		void CloseLibrary(struct Library *)
Machine Language: 	CloseLibrary(a1)
Modula-2:		CloseLibrary(library: LibraryPtr)
Arguments:		library = base address of a library, as returned by OpenLibrary( )
Result:			none
-------------------------
CloseScreen
Description:		closes an Intuition screen
Library:		intuition.library
Offset:			-$0042 (-66)
Modula-2 Module: 	Intuition
Syntax:        		CloseScreen(screen)
C:            		void CloseScreen(struct Screen *)
Machine Language: 	CloseScreen(a0)
Modula-2:       	CloseScreen(screen: ScreenPtr)
Arguments:     		screen = screen to close
Result:			none
-------------------------
CloseWindow
Description:     	closes an Intuition window
Library:        	intuition.library
Offset:         	-$0048 (-72)
Modula-2 Module: 	Intuition
Syntax:        		CloseWindow(window)
C:            		void CloseWindow(struct Window *)
Machine Language: 	CloseWindow(a0)
Modula-2:		CloseWindow(window: WindowPtr)
Arguments:		window = window to close
Result:			none
-------------------------
CloseWorkBench
Description:		attempts to close the Workbench screen
Library:		intuition.library
Offset:			-$004E (-78)
Modula-2 Module: 	Intuition
Syntax:        		success = CloseWorkBench( )
C:            		long CloseWorkBench(void)
Machine Language: 	d0 = CloseWorkBench( )
Modula-2:		CloseWorkBench( ): BOOLEAN
Arguments:		none
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
CMove
Description:		appends a copper move instruction to a user copper list without
			bumping the copper instruction pointer to the next instruction
Library:		graphics.library
Offset:			-$0174 (-372)
Modula-2 Module: 	Copper
Syntax:        		CMove(copList, r, v)
C:            		void CMove(struct UCopList *, long, long)
Machine Language: 	CMove(a1, d0, d1)
Modula-2:		CMove(copList: UCopListPtr; r: ADDRESS; v: WORD)
Arguments:		copList = UCopList structure
			a = address of hardware register to receive value
			v = value to store in hardware register
Result:			none
-------------------------
CMOVE (macro)
Description:		appends a copper move instruction to a user copper list and
			bumps the copper instruction pointer to the next instruction
C Include File:		include/graphics/gfxmacros.h
ML Include File:	none
Modula-2 Module: 	Copper
Syntax:        		CMOVE(copList, r, v)
C:            		void CMOVE(struct UCopList *, APTR, short)
Machine Language: 	not available
Modula-2:		CMOVE(copList: UCopListPtr; r: ADDRESS; v: WORD)
Arguments:		copList = UCopList structure
			a = address of hardware register to receive value
			v = value to store in hardware register
Result:			none
-------------------------
ConcatCList
Description:		concatenates two character lists
Library:		clist.library
Offset:			-$009C (-156)
Modula-2 Module: 	none
Syntax:        		error = ConcatCList(srcCList, destCList)
C:            		long ConcatCList(long, long)
Machine Language: 	d0 = ConcatCList(a0, a1)
Modula-2:		not available
Arguments:		srcCList = source character list
			destCList = destination character list
Result:			error = Zero if successful; Nonzero if unsuccessful (out of
			memory)
-------------------------
ConfigBoard
Description:		configures an expansion board
Library:		expansion.library
Offset:			-$003C (-60)
Modula-2 Module: 	Expansion
Syntax:        		error = ConfigBoard(board, configDev)
C:            		long ConfigBoard(long, long)
Machine Language: 	d0 = ConfigBoard(a0, a1)
Modula-2:       	ConfigBoard(board: ADDRESS; configDev: ADDRESS):
			BOOLEAN
Arguments:		board = base address of expansion board (most likely
			E_EXPANSIONBASE)
			configDev = initialized ConfigDev structure
Result:			error = nonzero if unsuccessful
-------------------------
ConfigChain
Description:		configures the entire system
Library:		expansion.library
Offset:			-$0042 (-66)
Modula-2 Module: 	Expansion
Syntax:        		error = ConfigChain(baseAddr)
C:            		long ConfigChain(long)
Machine Language: 	d0 = ConfigChain(a0)
Modula-2:		ConfigChain(baseAddr: ADDRESS): BOOLEAN
Arguments:		baseAddr = base address (most likely E_EXPANSIONBASE)
Result:			error = nonzero if unsuccessful
-------------------------
CopyCList
Description:		copies a character list to a new character list
Library:		clist.library
Offset:			-$0090 (-144)
Modula-2 Module: 	none
Syntax:       		cList = CopyCList(cList)
C:            		long CopyCList(long)
Machine Language: 	d0 = CopyCList(a0)
Modula-2:		not available
Arguments:		cList = original character list
Result:			cList = new character list; Negative is unsuccessful (not enough
			memory)
-------------------------
CopyMem
Description:		copies the contents of RAM from one location to another
Library:		exec.library
Offset:			-$0270 (-624)
Modula-2 Module: 	Memory
Syntax:        		CopyMem(srcPointer, destPointer, size)
C:            		void CopyMem(char *, char *, long)
Machine Language: 	CopyMem(a0, a1, d0)
Modula-2:		CopyMem(srcPointer, destPointer: ADDRESS; size: LONGCARD)
Arguments:		srcPointer = pointer to memory block to be copied
			destPointer = pointer to destination memory block
			size = size of memory block in bytes
Result:			none
-------------------------
CopyMemQuick
Description:		performs an optimized copy of RAM with some restrictions
Library:		exec.library
Offset:			-$0276 (-630)
Modula-2 Module: 	Memory
Syntax:        		CopyMemQuick(srcPointer, destPointer, size)
C:            		void CopyMemQuick(char *, char *, long)
Machine Language: 	CopyMemQuick(a0, a1, d0)
Modula-2:		CopyMemQuick(srcPointer, destPointer: ADDRESS; size:
			LONGCARD)
Arguments:		srcPointer = pointer to the long-word aligned memory block to
			be copied
			destPointer = pointer to the long-word aligned destination mem-
			ory block
			size = size of memory block in bytes
Result:			none
-------------------------
CopySBitMap
Description:		copies all bits from a SuperBitMap into the Layer bitmap
Library:		graphics.library
Offset:			-$01C2 (-450)
Modula-2 Module: 	Clip
Syntax:        		CopySBitMap(layer)
C:            		void CopySBitMap(struct Layer *)
Machine Language: 	CopySBitMap(a0)
Modula-2:		CopySBitMap(layer: LayerPtr)
Arguments:		layer = pointer to a locked Layer that has a SuperBitMap
Result:			none
-------------------------
CreateBehindlayer
Description:		creates a new layer behind all existing layers
Library:		layers.library
Offset:			-$002A (-42)
Modula-2 Module: 	Layers
Syntax:        		layer = CreateBehindLayer(layerInfo, bitMap, x0, y0, x1, y1, 
			flags, superBitMap)
C:            		struct Layer *CreateBehindLayer(struct LayerInfo *, struct Bit-
			Map *, long, long, long, long, long, struct BitMap *)
Machine Language: 	d0 = CreateBehindLayer(a0, a1, d0, d1, d2, d3, d4, a2)
Modula-2:		CreateBehindLayer(layerInfo: LayerInfoPtr; bitMap: BitMapPtr; x0,
			y0, x1, y1: LONGINT; flags: LayerFlagSet; superBitMap:
			BitMapPtr): LayerPtr
Arguments:		layerInfo = info structure of Layer to create
			bitMap = common BitMap used by all Layers
			x0 = horizontal coordinate of upper left corner of Layer
			y0 = vertical coordinate of upper left corner of Layer
			x1 = horizontal coordinate of lower right corner of Layer
			y1 = vertical coordinate of lower right corner of Layer
			flags = type of Layer
			superBitMap = NULL or a SuperBitMap
Result:			layer = pointer to Layer structure if successful; NULL if
			unsuccessful
-------------------------
CreateDir
Description:		creates a new directory
Library:		dos.library
Offset:			-$0078 (-120)
Modula-2 Module: 	DOS
Syntax:        		lock = CreateDir(name)
C:            		BPTR CreateDir(char *)
Machine Language: 	d0 = CreateDir(d1)
Modula-2:		CreateDir(name: STRPTR): FileLock
Arguments:		name = NULL terminate string that specifies the new directory
			name
Result:			lock = BCPL pointer to a lock
-------------------------
CreateExtIO
Description:		allocates memory for and initializes an IO request block
Library:		amiga.lib (linked library)
Modula-2 Module: 	IOUtils
Syntax:        		block = CreateExtIO(ioReplyPort, size)
C:            		struct IORequest *CreateExtIO(struct MsgPort *, long)
Machine Language: 	move.l #size,-(sp)
			pea ioReplyPort
			jsr _CreateExtIO ;block returned in d0
			addq.l #8,sp
Modula-2:		CreateExtIO(ioReplyPort: MsgPortPtr; size: CARDINAL):
			ADDRESS
Arguments:		ioReplyPort = initialized MsgPort
			size = IORequest block size
Result:			block = pointer to newly created IORequest block; NULL if un-
			successful (not enough memory)
-------------------------
CreatePort
Description:		allocates memory for and initializes a message port
Library:		amiga.lib (linked library)
Modula-2 Module: 	PortUtils
Syntax:        		port = CreatePort(name, pri)
C:            		struct MsgPort *CreatePort(char *, long)
Machine Language: 	move.l #pri,-(sp)
			pea name
			jsr _CreatePort ;port returned in d0
			addq.l #8,sp
Modula-2:		CreatePort(name: STRPTR; pri: INTEGER): MsgPortPtr
Arguments:		name = name of public port to create; NULL for private port
			pri = priority to assign to port
Result:			port = pointer to newly created message port; NULL if unsuc-
			cessful (not enough memory)
-------------------------
CreateProc
Description:		creates a new process
Library:		dos.library
Offset:			-$008A (-138)
Modula-2 Module: 	DOSProcess
Syntax:        		process = CreateProc(name, pri, segment, stackSize)
C:            		struct MsgPort *CreateProc(char *, long, BPTR, long)
Machine Language: 	d0 = CreateProc(d1, d2, d3, d4)
Modula-2:		CreateProc(name: STRPTR; pri: LONGINT; segment: BPTR;
			stackSize: LONGINT): ProcessID
Arguments:		name = NULL terminated string that specifies the new process
			name
			priority = priority to be given to process
			segment = segment list, as returned by LoadSeg( )
			stackSize = size of root stack in bytes
Result:			process = pointer to newly created IORequest block; NULL if un-
			successful (not enough memory)
-------------------------
CreateTask
Description:		creates a task
Library:        	amiga.lib (linked library)
Modula-2 Module: 	TaskUtils
Syntax:       		task = CreateTask(name, pri, initPC, stackSize)
C:            		struct Task *CreateTask(char *, long, _fptr, long)
Machine Language: 	move.l #stackSize,-(sp)
			pea initPC
			move.l #pri,-(sp)
			pea name
			jsr _CreateTask ;task returned in d0
			add.l #16,sp
Modula-2:		CreateTask(name: STRPTR; pri: INTEGER; initP
C:			PROC; stackSize: LONGCARD): TaskPtr
Arguments:		name = name of task
			pri = exec task priority (-128 through 127, usually 0)
			stackSize = size of stack in bytes
Result:			task = pointer to newly created task; NULL if unsuccessful (not
			enough memory)
-------------------------
CreateUpfrontLayer
Description:		creates a new layer on top of all existing layers
Library:		layers.library
Offset:		        -$0024 (-36)
Modula-2 Module: 	Layers
Syntax:		        layer = CreateUpfrontLayer(layerInfo, bitMap, x0, y0, x1, y1, 
			flags, superBitMap)
C:		        struct Layer *CreateUpfrontLayer(struct Layer_Info *, struct Bit-
			Map *, long, long, long, long, long, struct BitMap *)
Machine Language: 	d0 = CreateUpfrontLayer(a0, a1, d0, d1, d2, d3, d4, a2)
Modula-2:		CreateUpfrontLayer(layerInfo: LayerInfoPtr; bitMap: BitMapPtr;
			x0, y0, x1, y1: LONGINT; flags: LayerFlagSet; superBitMap:
			BitMapPtr): LayerPtr
Arguments:		layerInfo = info structure of Layer to create
			bitMap = common BitMap used by all Layers
			x0 = horizontal coordinate of upper left corner of Layer
			y0 = vertical coordinate of upper left corner of Layer
			x1 = horizontal coordinate of lower right corner of Layer
			y1 = vertical coordinate of lower right corner of Layer
			flags = type of Layer
			superBitMap = NULL or pointer to SuperBitMap
Result:			layer = pointer to Layer structure if successful; NULL if
			unsuccessful
-------------------------   
CurrentDir
Description:		changes the current directory and returns the old current directory
Library:        	dos.library
Offset:         	-$007E (-126)
Modula-2 Module: 	DOS
Syntax:        		oldlock = CurrentDir(lock)
C:            		BPTR CurrentDir(BPTR)
Machine Language: 	d0 = CurrentDir(d1)
Modula-2:		CurrentDir(lock: FileLock): FileLock
Arguments:		lock = BCPL pointer to lock associated with new current
			directory
Result:			oldlock = BCPL pointer to lock associated with old directory
-------------------------
CurrentTime
Description:		returns the current system time
Library:		intuition.library
Offset:       		-$0054 (-84)
Modula-2 Module: 	Intuition
Syntax:        		CurrentTime(seconds, micros)
C:            		void CurrentTime(long *, long *)
Machine Language: 	CurrentTime(d0, d1)
Modula-2:		CurrentTime(VAR seconds, micros: LONGCARD)
Arguments:		seconds = pointer to four-byte (LONG) variable to receive sec-
			onds value
			micros = pointer to four-byte (LONG) variable to receive micro-
			seconds value
Result:			returned in seconds and micros arguments
-------------------------
CWait
Description:		appends copper wait instruction to a user copper list without
			bumping the copper instruction pointer to the next instruction
Library:		graphics.library
Offset:       		-$017A (-378)
Modula-2 Module: 	CopperUtil
Syntax:        		CWait(copList, vert, horiz)
C:            		void CWait(struct UCopList *, short, short)
Machine Language: 	not available
Modula-2:		CWait(copList: UCopListPtr; vert, horiz: INTEGER)
Arguments:		copList = UCopList structure
			vert = vertical beam position relative to top of ViewPort
			horiz = horizontal beam position (must be less than 223)
Result:			none
-------------------------
CWAIT (macro)
Description:		appends copper wait instruction to a user copper list and bumps
			the copper instruction pointer to the next instruction
C Include File:		include/graphics/gfxmacros.h
ML Include File:	none
Modula-2 Module:	CopperUtil
Syntax:        		CWAIT(copList, vert, horiz)
C:            		void CWAIT(struct UCopList *, short, short)
Machine Language: 	not available
Modula-2:		CWAIT(copList: UCopListPtr; vert, horiz: INTEGER)
Arguments:		copList = UCopList structure
			vert = vertical beam position relative to top of ViewPort
			horiz = horizontal beam position (must be less than 223)
Result:			none
-------------------------
DateStamp
Description:		returns the current date and time in internal format
Library:		dos.library
Offset:           	-$00C0 (-192)
Modula-2 Module: 	DOS
Syntax:        		DateStamp(v)
C:            		long *DateStamp(long *)
Machine Language: 	DateStamp(d1)
Modula-2:		DateStamp(v: DateStampRecPtr)
Arguments:		v = pointer to the first element of an array of three long words
Result:			v argument points to result in RAM
-------------------------
dbf
Description:		converts a fast floating point dual-binary number to plain fast
			floating point format
Library:		amiga.lib (linked library)
Modula-2 Module: 	none
Syntax:        		fnum = dbf(exp, mant)
C:			float dbf(long, long)
Machine Language: 	move.l #mant,-(sp)
			move.l #exp,-(sp) 
			jsr _dfb ;fnum returned in d0/d1 
			addq.l #8,sp
Modula-2:		not available
Arguments:		exp = 16 bit integer representing the sign (bit 16 equals 0 for
			positive or 1 for negative) and base ten exponent (bits 0-15)
			mant = integer representing the mantissa
Result:			fnum = floating point equivalent of value specified by exp and
			mant arguments
-------------------------
Deallocate
Description:		deallocates a block of previously allocated memory
Library:		exec.library
Offset:       		-$00C0 (-192)
Modula-2 Module: 	Memory
Syntax:        		Deallocate(freeList, memoryBlock, byteSize)
C:            		void Deallocate(struct MemHeader *, void *, long)
Machine Language: 	Deallocate(a0, a1, d0)
Modula-2:		Deallocate(freeList: MemHeaderPtr; memoryBlock: ADDRESS;
			byteSize: LONGCARD)
Arguments:		freeList = memory list header
			memoryBlock = memory block to deallocate
			byteSize = size of memory block in bytes
Result:			none
-------------------------
Debug
Description:		runs the system debugger or the debugger installed by
			SetFunction
Library:		exec.library
Offset:       		-$0072 (-114)
Modula-2 Module: 	Exec
Syntax:        		Debug(num)
C:            		void Debug(long)
Machine Language: 	Debug(d0)
Modula-2:      		Debug(num: LONGCARD)
Arguments:     		num = should be set to 0
Result:			none
-------------------------  
Delay
Description:     	delays a process for a specified amount of time
Library:        	dos.library
Offset:         	-$00C6 (-198)
Modula-2 Module: 	DOSProcess
Syntax:        		Delay(ticks)
C:            		void Delay(long)
Machine Language: 	Delay(d1)
Modula-2:		Delay(ticks: LONGINT)
Arguments:		ticks = number of ticks to wait (50 ticks per second)
Result:	none
-------------------------
DeleteExtIO
Description:		returns memory allocated by CreateExtIO
Library:		amiga.lib (linked library)
Modula-2 Module: 	IOUtils
Syntax:        		DeleteExtIO(ioRequest, size)
C:            		void DeleteExtIO(struct IORequest *, long)
Machine Language: 	move.l #size,-(sp)
			pea ioRequest
			jsr _DeleteExtIO
			addq.l #4,sp
Modula-2:		DeleteExtIO(ioReq: ADDRESS; size: CARDINAL)
Arguments:		ioRequest = IORequest block to delete
			size = size of IORequest block in bytes
Result:			none
-------------------------
DeleteFile
Description:		deletes a file or directory
Library:		dos.library
Offset:       		-$0048 (-72)
Modula-2 Module: 	DOS
Syntax:        		success = DeleteFile(name)
C:            		long DeleteFile(char *)
Machine Language: 	d0 = DeleteFile(d1)
Modula-2:       	DeleteFile(name: STRPTR): BOOLEAN
Arguments:      	name = NULL terminated string that specifies the file to delete
Result:			TRUE if successful; FALSE if unsuccessful
-------------------------
DeleteLayer
Description:		deletes a layer from a layer list
Library:        	layers.library
Offset:         	-$005A (-90)
Modula-2 Module: 	Layers
Syntax:        		success = DeleteLayer(dummy, layer)
C:            		long DeleteLayer(struct Layer_Info, struct Layer *)
Machine Language: 	d0 = DeleteLayer(a0, a1)
Modula-2:		DeleteLayer(layer: LayerPtr): BOOLEAN
Arguments:		dummy = unused
			layer = layer to delete
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
DeletePort
Description:		frees a message port created by CreatePort( )
Library:		amiga.lib (linked library)
Modula-2 Module: 	PortUtils
Syntax:        		DeletePort(msgPort)
C:            		void DeletePort(struct MsgPort *)
Machine Language: 	pea msgPort
			jsr _DeletePort
			addq.l #4,sp
Modula-2:		DeletePort(msgPort: MsgPortPtr)
Arguments:		msgPort = message port to delete
Result:			none
-------------------------
DeleteTask
Description:		deletes a task created with CreateTask( )
Library:		amiga.lib (linked library)
Modula-2 Module: 	TaskUtils
Syntax:        		DeleteTask(task)
C:            		void DeleteTask(struct Task *)
Machine Language: 	pea task
			jsr _DeleteTask
			addq.l #4,sp
Modula-2:		DeleteTask(task: TaskPtr)
Arguments:		task = Task to delete
Result:			none
-------------------------
DeviceProc
Description:		returns the process identifier of specified process
Library:        	dos.library
Offset:         	-$00AE (-174)
Modula-2 Module: 	DOSProcess
Syntax:        		process = DeviceProc(name)
C:            		struct MsgPort *DeviceProc(char *)
Machine Language: 	d0 = DeviceProc(d1)
Modula-2:		DeviceProc(name: STRPTR): ProcessID
Arguments:		name = NULL terminated string that specifies the device name
Result:			process = BCPL pointer to a process; NULL if unsuccessful
-------------------------
Disable
Description:		disables interrupt processing
Library:		exec.library
Offset:        		-$0078 (-120)
Modula-2 Module: 	Interrupts
Syntax:        		Disable( )
C:            		void Disable(void)
Machine Language: 	Disable( )
Modula-2:		Disable( )
Arguments:		none
Result:			none
-------------------------
DisownBlitter
Description:		frees blitter for use by other programs
Library:		graphics.library
Offset:        		-$01CE (-462)
Modula-2 Module: 	Blitter
Syntax:        		DisownBlitter( )
C:            		void DisownBlitter(void)
Machine Language: 	DisownBlitter( )
Modula-2:       	DisownBlitter( )
Arguments:      	none
Result:			none
-------------------------
DisplayAlert
Description: 		creates an Alert
Library:        	intuition.library
Offset:         	-$005A (-90)
Modula-2 Module: 	Intuition
Syntax:        		response = DisplayAlert(alertNumber, message, height)
C:            		long DisplayAlert(long, char *, long)
Machine Language: 	d0 = DisplayAlert(d0, a0, d1)
Modula-2:		DisplayAlert(alertNumber: LONGCARD; message: ADDRESS;
			height: CARDINAL): BOOLEAN
Arguments:		alertNumber = AlertMessage number
			message = NULL terminated Alert message string
			height = minimum display lines required for your message
Result:			response = TRUE or FALSE, depending on alert type and user
			response
-------------------------
DisplayBeep
Description:		flashes the video display and emits a beep
Library:		intuition.library
Offset:       		-$0060 (-96)
Modula-2 Module: 	Intuition
Syntax:        		DisplayBeep(screen)
C:            		void DisplayBeep(struct Screen *)
Machine Language: 	DisplayBeep(a0)
Modula-2:       	DisplayBeep(screen: ScreenPtr)
Arguments:     		screen = screen to beep
Result:        		none
-------------------------
DisposeFontContents (available in library version 34)
Description:     	frees the array of FontContents returned by NewFontContents( )
Library:        	diskfont.library
Offset:         	-$0030 (-48)
Modula-2 Module: 	none
Syntax:        		DisposeFontContents(fontContentsHeader)
C:            		void DisposeFontContents(struct FontContentsHeader *)
Machine Language: 	DisposeFontContents(a1)
Modula-2:       	not available
Arguments:     		fontContentsHeader = FontContentsHeader as returned by
			NewFontContents( )
Result:			none
-------------------------  
DisposeLayerInfo
Description:		returns memory used by a LayerInfo structure
Library:        	layers.library
Offset:         	-$0096 (-150)
Modula-2 Module: 	Layers
Syntax:        		DisposeLayerInfo(layerInfo)
C:            		void DisposeLayerInfo(struct Layer_Info *)
Machine Language: 	DisposeLayerInfo(a0)
Modula-2:		DisposeLayerInfo(layerInfo: layerInfoPtr)
Arguments:		layerInfo = LayerInfo structure to remove
Result:			none
-------------------------
DisposeRegion
Description:		returns memory used by a Region structure and its
			RegionRectangles
Library:		graphics.library
Offset:        		-$0216 (-534)
Modula-2 Module: 	Regions
Syntax:        		DisposeRegion(region)
C:            		void DisposeRegion(struct Region *)
Machine Language: 	DisposeRegion(a0)
Modula-2:		DisposeRegion(region: RegionPtr)
Arguments:		region = Region structure to remove
Result:			none
-------------------------
DoCollision
Description:		tests all GELs in GEL list for GEL-to-GEL collisions
Library:		graphics.library
Offset:        		-$006C (-108)
Modula-2 Module: 	Gels
Syntax:        		DoCollision(rastPort)
C:            		void DoCollision(struct RastPort *)
Machine Language: 	DoCollision(a1)
Modula-2:       	DoCollision(rastPort: RastPortPtr)
Arguments:     		rastPort = RastPort with GEL list
Result:			none
-------------------------  
DoIO
Description:		performs IO command and waits for completion
Library:       		exec.library
Offset:        		-$01C8 (-465)
Modula-2 Module: 	IO
Syntax:        		error = DoIO(ioRequest)
C:            		long DoIO(struct IORequest *)
Machine Language: 	d0 = DoIO(a1)
Modula-2:		DoIO(ioRequest: ADDRESS): INTEGER
Arguments:		ioRequest = initialized IORequest structure
Result:			error = zero if successful; nonzero if unsuccessful
-------------------------
DoubleClick
Description:		test two time values for double-click timing
Library:		intuition.library
Offset:       		-$0066 (-102)
Modula-2 Module: 	Intuition
Syntax:        		double = DoubleClick(startSecs, startMicros, currentSecs,
			currentMicros)
C:            		long DoubleClick(long, long, long, long)
Machine Language: 	d0 = DoubleClick(d0, d1, d2, d3)
Modula-2:		DoubleClick(startSecs, startMicros, currentSecs, currentMicros:
			LONGCARD): BOOLEAN
Arguments:		startSecs = seconds value at time of first click
			startMicros = micros value at time of first click
			currentSecs = seconds value at time of second click
			currentMicros = micros value at time of second click
Result:			double = TRUE if valid double click; FALSE if not
-------------------------
Draw
Description:		draws a line from current pen position to specified point
Library:		graphics.library
Offset:       		-$00F6 (-246)
Modula-2 Module: 	Pens
Syntax:        		Draw(rastPort, x, y)
C:            		long Draw(struct RastPort *, long, long)
Machine Language:	Draw(a1, d0, d1)
Modula-2:		Draw(rastPort: RastPortPtr; x, y: INTEGER)
Arguments:		rastPort = RastPort to draw line in
			x = horizontal coordinate of line's destination
			y = vertical coordinate of line's destination
Result:			none
-------------------------
DrawBorder
Description:		draws a border
Library:		intuition.library
Offset:       		-$006C (-108)
Modula-2 Module: 	Intuition
Syntax:        		DrawBorder(rastPort, border, leftOffset, topOffset)
C:            		long DrawBorder(struct RastPort *, struct Border *, long, long)
Machine Language: 	DrawBorder(a0, a1, d0, d1)
Modula-2:		DrawBorder(rastPort: RastPortPtr; border: BorderPtr; leftOffset,
			topOffset: INTEGER)
Arguments:		rastPort = RastPort to draw border in
			border = Border to be drawn
			leftOffset = horizontal placement offset for border
			topOffset = vertical placement offset for border
Result:			none
-------------------------
DrawCircle (macro)
Description:     	draws a circle in the specified RastPort
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module: 	Pens
Syntax:        		DrawCircle(rastPort, cx, cy, radius)
C:            		void DrawCircle(struct RastPort *, long, long, long)
Machine Language: 	not available, use DrawEllipse instead
Modula-2:		DrawCircle(rastPort: RastPortPtr; cx, cy, radius: INTEGER)
Arguments:		rastPort = RastPort structure
			cx = horizontal coordinate of circle's center
			cy = vertical coordinate of circle's center
			radius = circle's radius
Result:			none
-------------------------
DrawEllipse
Description:     	draws an elliptical outline within a rectangular outline
Library:       		graphics.library
Offset:         	-$00B4 (-180)
Modula-2 Module: 	Pens
Syntax:        		DrawEllipse(rastPort, cx, cy, a, b)
C:            		void DrawEllipse(struct RastPort *, long, long, long, long)
Machine Language: 	DrawEllipse(a1, d0, d1, d2, d3)
Modula-2:		DrawEllipse(rastPort: RastPortPtr; cx, cy, a, b: INTEGER)
Arguments:		rastPort = RastPort into which ellipse will be drawn
			cx = horizontal coordinate of ellipse's center, relative to the
			RastPort
			cy = vertical coordinate of ellipse's center, relative to the RastPort
			a = ellipse's horizontal radius (must be greater than O)
			b = ellipse's vertical radius (must be greater than O)
Result:			none
-------------------------
DrawGList
Description:		processes a GEL list, drawing bobs and constructing a copper list
			for VSprites
Library:		graphics.library
Offset:       		-$0072 (-114)
Modula-2 Module: 	Gels
Syntax:        		DrawGList(rastPort, viewPort)
C:            		void DrawGList(struct RastPort *, struct ViewPort *)
Machine Language: 	DrawGList(a1, a0)
Modula-2:		DrawGList(rastPort: RastPortPtr; viewPort: ViewPortPtr)
Arguments:		rastPort = RastPort where bobs will be drawn
			viewPort = ViewPort in which VSprites will be created
Result:			none
-------------------------
DrawImage
Description:		draw the specified image
Library:		intuition.library
Offset:       		-$0072 (-114)
Modula-2 Module:	Intuition
Syntax:       		DrawImage(rastPort, image, leftOffset, topOffset)
C:            		long DrawImage(struct RastPort *, struct Image *, long, long)
Machine Language: 	DrawImage(a0, a1, d0, d1)
Modula-2:		DrawImage(rastPort: RastPortPtr; image: ImagePtr; leftOffset,
			topOffset: INTEGER)
Arguments:		rastPort = RastPort where image will be drawn
			image = Image to be drawn
			leftOffset = horizontal placement offset for image
			topOffset = vertical placement offset for image
Result:			none
-------------------------
Duplock
Description:		duplicates a lock
Library:		dos.library
Offset:       		-$0060 (-96)
Modula-2 Module: 	DOS
Syntax:        		newlock = DupLock(lock)
C:            		BPTR DupLock(BPTR)
Machine Language: 	d0 = DupLock(d1)
Modula-2:		DupLock(lock: FileLock): FileLock
Arguments:		lock = lock to duplicate
Result:			newlock = duplicate lock
-------------------------
Enable
Description:		enables interrupt processing
Library:		exec.library
Offset:       		-$007E (-126)
Modula-2 Module: 	Interrupts
Syntax:        		Enable( )
C:            		void Enable(void)
Machine Language: 	Enable( )
Modula-2:		Enable( )
Arguments:		none
Result:			none
-------------------------
EndRefresh
Description:		ends optimized refresh of a window
Library:		intuition.library
Offset:       		-$016E (-366)
Modula-2 Module: 	Intuition
Syntax:        		EndRefresh(window, complete)
C:            		void EndRefresh(struct Window *, long)
Machine Language: 	EndRefresh(a0, d0)
Modula-2:		EndRefresh(window: WindowPtr; complete: BOOLEAN)
Arguments:		window = window in optimized-refresh mode
			complete = TRUE if window is completely refreshed; FALSE if
			not
Result:			none
-------------------------
EndRequest
Description:		removes requester from window
Library:		intuition.library
Offset:       		-$0078 (-120)
Modula-2 Module: 	Intuition
Syntax:        		EndRequest(requester, window)
C:            		void EndRequest(struct Requester *, struct Window *)
Machine Language: 	EndRequest(a0, a1)
Modula-2:		EndRequest(requester: RequesterPtr; window: WindowPtr)
Arguments:		requester = requester to remove
			window = window which is associated with requester
Result:			none
-------------------------
EndUpdate
Description:		removes damage list and restores layer to normal state
Library:		layers.library
Offset:       		-$0054 (-84)
Modula-2 Module:	Layers
Syntax:        		EndUpdate(layer, flag)
C:            		void EndUpdate(struct Layer *, long)
Machine Language: 	EndUpdate(a0, d0)
Modula-2:		EndUpdate(layer: LayerPtr; flag: BOOLEAN)
Arguments:		layer = layer to return to normal state
			flag = TRUE if update was complete-damage list will be
			cleared; FALSE if update was not complete-damage list will be
			retained
Result:	none
-------------------------
Enqueue
Description:		inserts or appends node to a system queue
Library:		exec.library
Offset:       		-$010E (-270)
Modula-2 Module: 	Lists
Syntax:			Enqueue(list, node)
C:     			void Enqueue(struct List *, struct Node *)
Machine Language: 	Enqueue(a0, a0)
Modula-2:		Enqueue(list: ListPtr; node: NodePtr)
Arguments:		list = system queue header
			node = node to insert or append
Result:			none
-------------------------
Examine
Description:		examines a directory or file
Library:		dos.library
Offset:       		-$0066 (-102)
Modula-2 Module: 	DOS
Syntax:        		success = Examine(lock, infoBlock)
C:            		long Examine(BPTR, struct FileInfoBlock *)
Machine Language: 	d0 = Examine(d1, d2)
Modula-2:		Examine(lock: FileLock; infoBlock: FileInfoBlockPtr): BOOLEAN
Arguments:		lock = lock of directory or file to examine
			infoBlock = info block to receive directory or file information
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
Execute
Description:		executes a CLI command
Library:		dos.library
Offset:       		-$00DE (-222)
Modula-2 Module: 	DOSLoader
Syntax:        		success = Execute(command, input, output)
C:            		long Execute(char *, BPTR, BPTR)
Machine Language: 	d0 = Execute(d1, d2, d3)
Modula-2:		Execute(command: STRPTR; input, output: FileHandle):
			BOOLEAN
Arguments:		command = NULL terminated string containing CLI command
			input = file handle for input redirection; NULL if none
			output = file handle for output redirection; NULL if none
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
Exit
Description:		ends a program
Library:		dos.library
Offset:       		-$0090 (-144)
Modula-2 Module: 	DOSProcess
Syntax:		        Exit(returnCode)
C:            		void Exit(long)
Machine Language: 	Exit(d1)
Modula-2:		Exit(returnCode: LONGINT)
Arguments:		returnCode = return code passed to parent (usually the CLI)-by
			convention, a value of zero implies no error
Result:			none
-------------------------
ExNext
Description:		examines the next entry in a directory
Library:		dos.library
Offset:         	-$006C (-108)
Modula-2 Module: 	DOS
Syntax:        		success = ExNext(lock, infoBlock)
C:            		long ExNext(BPTR, struct FilelnfoBlock *)
Machine Language: 	d0 = ExNext(d1, d2)
Modula-2:		ExNext(lock: FileLock; infoBlock: FileInfoBlockPtr): BOOLEAN
Arguments:		lock = lock of directory to examine
			infoBlock = info block to receive entry information
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
FastRand
Description:		generates a somewhat random integer
Library:		amiga.lib (linked library)
Modula-2 Module: 	none
Syntax:        		rnd = FastRand(seed)
C:            		long FastRand(long)
Machine Language: 	move.l #long,-(sp)
			jsr _FastRand ;rnd returned in d0
			addq.l #4,sp
Modula-2:		not available, use Random in RandomNumbers module
Arguments:		seed = value used to seed random number
Result:			rnd = random number calculate using the following C equation:
			rnd=(seed << 1) ^ 0x1872B41
-------------------------
FattenLayerInfo
Description:		converts 1.0 LayerInfo structure to 1.1-1.3-compatible LayerInfo
			structure
Library:		layers.library
Offset:         	-$009C (-156)
Modula-2 Module: 	none
Syntax:        		FattenLayerInfo(layerInfo)
C:            		void FattenLayerInfo(struct Layer_Info *)
Machine Language: 	FattenLayerInfo(a0)
Modula-2:		not available
Arguments:		layerInfo = LayerInfo structure to update
Result:			none
-------------------------
FindConfigBoard
Description:		finds a matching ConfigDev entry
Library:		expansion.library
Offset:          	-$0048 (-72)
Modula-2 Module: 	none
Syntax:        		configDev = FindConfigBoard(oldConfigDev, manufacturer,
			product)
C:            		struct ConfigDev *FindConfigBoard(long, long, long)
Machine Language: 	d0 = FindConfigBoard(a0, d0, d1)
Modula-2:		not available
Arguments:		oldConfigDev = ConfigDev structure just before the location in
			ConfigDev list where search should begin; NULL to start search at
			the beginning of the list
			manufacturer = manufacturer code to search for; -1 to ignore
			manufacturer code
			product = product code to search for; -1 to ignore product coed
Result:			configDev = first ConfigDev structure that matches the manufac-
			turer and product codes specified; NULL if no more matches
-------------------------
FindName
Description:		finds a system list node
Library:		exec.library
Offset:         	-$0114 (-276)
Modula-2 Module: 	Lists
Syntax:        		node = FindName(start, name)
C:            		struct Node *FindName(struct List *, char *)
Machine Language: 	d0 = FindName(a0, a1)
Modula-2:		FindName(start: ADDRESS; name: STRPTR): NodePtr
Arguments:		start = list header or list node to start search (if node this one is
			skipped)
			name = NULL terminated string that specifies name of node
Result:			node = pointer to specified node; NULL if unsuccessful
-------------------------  
FindPort
Description:     	finds a public message port
Library:        	exec.library
Offset:         	-$0186 (-390)
Modula-2 Module: 	Ports
Syntax:        		port = FindPort(name)
C:            		struct MsgPort *FindPort(char *)
Machine Language: 	d0 = FindPort(a1)
Modula-2:		FindPort(name: STRPTR): MsgPortPtr
Arguments:		name = NULL terminated string that specifies name of port
Result:			port = pointer to specified port; NULL if unsuccessful
-------------------------
FindResident
Description:		finds a Resident structure
Library:		exec.library
Offset:        		-$0060 (-96)
Modula-2 Module: 	Resident
Syntax:        		resident = FindResident(name)
C:            		struct Resident *FindResident(char *)
Machine Language: 	d0 = FindResident(a1)
Modula-2:		FindResident(name: STRPTR): ResidentPtr
Arguments:		name = NULL terminated string that specifies name of Resident
			structure
Result:			resident = pointer to specified Resident structure; NULL if
			unsuccessful
-------------------------
FindSemaphore
Description:		finds a SignalSemaphore structure
Library:		exec.library
Offset:        		-$0252 (-612)
Modula-2 Module: 	Semaphores
Syntax:        		semaphore = FindSemaphore(name)
C:            		struct SignalSemaphore *FindSemaphore(char *)
Machine Language: 	d0 = FindSemaphore(a1)
Modula-2:		FindSemaphore(name: STRPTR): SignalSemaphorePtr
Arguments:		name = NULL terminated string that specifies name of
			semaphore
Result:			semaphore = pointer to specified SignalSemaphore structure;
			NULL if unsuccessful
-------------------------  
FindTask
Description:     	finds a task
Library:        	exec.library
Offset:         	-$0126 (-294)
Modula-2 Module: 	Tasks
Syntax:        		task = FindTask(name)
C:            		struct Task *FindTask(char *)
Machine Language:	d0 = FindTask(a1)
Modula-2:		FindTask(name: STRPTR): TaskPtr
Arguments:		name = NULL terminated string that specifies name of task
Result:			task = pointer to specified task; NULL if unsuccessful
-------------------------
FindToolType
Description:		finds value of a ToolType variable
Library:		icon.library
Offset:       		-$0060 (-96)
Modula-2 Module: 	Icon
Syntax:        		value = FindToolType(toolTypeArray, typeName)
C:            		struct char *FindToolType(char *, char *)
Machine Language: 	d0 = FindToolType(a0, a1)
Modula-2:		FindToolType(toolTypeArray: StrArrayPtr; typeName: STRPTR):
			ADDRESS
Arguments:		toolTypeArray = pointer to an array of strings containing tool
			types
			typeName = NULL terminated string that specifies tool type to
			find
Result:			value = pointer to string containing specified tool type; NULL if
			typeName not found in toolTypeArray
-------------------------
Flood
Description:	floods (fills) an area of a RastPort
Library:	graphics.library
Offset:       -$014A (-330)
Modula-2 Module: Pens
Syntax:        Flood(rastPort, mode, x, y)
C:            void Flood(struct RastPort *, long, long, long)
Machine Language: Flood(a1, d2, d0, d1)
Modula-2:		Flood(rastPort: RastPortPtr; mode: LONGCARD; x, y: INTEGER)  
Arguments:	rastPort = RastPort to fill
	mode = type of fill- 0 (fill pixels that are the same color as
	AOLPen) or 1 (fill pixels that are the same color as pixel at x,y)
	x = horizontal coordinate where fill will begin
	y = vertical coordinate where fill will begin

Result:			none
-------------------------
FlushCList
Description:		clears a character list
Library:		clist.library
Offset:			-$0030 (-48)
Modula-2 Module:	none
Syntax:			FlushCList(cList)
C:			void FlushCList(long)
Machine Language:	FlushCList(a0)
Modula-2:		not available
Arguments:		cList = CList header-as returned by AllocCList( )
			or StrToCL( )-used to manage character list to clear
Result:			none
-------------------------
Forbid
Description:		prevents task rescheduling
Library:		exec.library
Offset:			-$0084 (-132)
Modula-2 Module:	Interrupts
Syntax:			Forbid( )
C:			void Forbid(void)
Machine Language:	Forbid( )
Modula-2:		Forbid( )
Arguments:		none
Result:			none
-------------------------
fpa
Description:		converts a fast floating point number into an ASCII string
Library:		amiga.lib (linked library)
Modula-2 Module:	none
Syntax:			exp = fpa(fnum, string)
C:			long fpa(float, char *)
Machine Language:	pea string 
			move.l fnum,-(sp)
			jsr _fpa ;exp returned in d0 and string equals fnum 
			addq.l #8,sp
Modula-2:		not available
Arguments:		fnum = floating point number to convert
			string = address of string to receive ASCII equivalent of fnum
			argument
Result:			exp = integer exponent of fnum
-------------------------
fpbcd
Description:		converts a fast floating point number into BCD format
Library:		amiga.lib (linked library)
Modula-2 Module:	none
Syntax:			fpbcd(fnum, string)
C:			void fpbcd(float, char *)
Machine Language:	pea string
			move.l fnum,-(sp)
			jsr _fpbcd ;BCD equivalent of fnum returned in string
			addq.l #8,sp
Modula-2:		not available
Arguments:		fnum = floating point number to convert
			string = address of five-byte string to receive BCD equivalent of
			fnum argument
Result:			string argument receives the BCD equivalent of fnum argument
-------------------------
FreeBoardMem
Description:		frees expansion board memory (opposite of AllocBoardMem( )
Library:		expansion.library
Offset:			-$004E (-78)
Modula-2 Module:	Expansion
Syntax:			FreeBoardMem(startSlot, slotSpec)
C:			void FreeBoardMem(long, long)
Machine Language:	d0 = FreeBoardMem(d0, d1)
Modula-2:		FreeBoardMem(startslot, slotSpeC: INTEGER)
Arguments:		startSlot = slot number as returned by AllocBoardMem( )
			slotSpec = number of slots to free
Result:			none
-------------------------
Modula-2:		FreeMem(memoryBlock: ADDRESS: byteSize: LONGCARD)
Arguments:		memoryBlock = pointer to memory block to free
			byteSize = size of block in bytes
Result:			none
-------------------------  
FreeCList
Description:		releases character list descriptor and any resources it uses
Library:        	clist.library
Offset:			-$002A (-42)
Modula-2 Module:	none
Syntax:			FreeCList(cList)
C:			void FreeCList(long)
Machine Language:	FreeCList(a0)
Modula-2:		not available
Arguments:		cList = descriptor of character list to free
Result:			none
-------------------------
FreeColorMap
Description:		returns memory used by a ColorMap structure
Library:		graphics.library
Offset:			-$0240 (-576)
Modula-2 Module:	Views
Syntax:			FreeColorMap(colorMap)
C:			void FreeColorMap(struct ColorMap *)
Machine Language:	FreeColorMap(a0)
Modula-2:		FreeColorMap(colorMap: ColorMapPtr)
Arguments:		colorMap = ColorMap structure to free
Result:			none
-------------------------
FreeConfigDev
Description:		frees a ConfigDev structure
Library:		expansion.library
Offset:			-$0054 (-84)
Modula-2 Module:	ConfigVars
Syntax:			FreeConfigDev(configDev)
C:			void FreeConfigDev(struct ConfigDev *)
Machine Language:	FreeConfigDev(a0)
Modula-2:       	FreeConfigDev(configDev: ConfigDevPtr)
Arguments:     		configDev = ConfigDev structure as returned by AllocConfigDev( )
Result:			none
-------------------------  
FreeCopList
Description:		returns memory allocated for an intermediate copper list
Library:        	graphics.library
Offset:			-$0222 (-546)
Modula-2 Module:	Copper
Syntax:			FreeCopList(copList)
C:			void FreeCopList(struct CopList *)
Machine Language:	FreeCopList(a0)
Modula-2:		FreeCopList(copList: CopListPtr)
Arguments:		copList = CopList structure to free
Result:			none
-------------------------
FreeCprList
Description:		returns memory allocated for a hardware copper list
Library:		graphics.library
Offset:			-$0234 (-564)
Modula-2 Module:	Copper
Syntax:			FreeCprList(cprlist)
C:			void FreeCprList(struct cprlist *)
Machine Language:	FreeCprList(a0)
Modula-2:		FreeCprList(cprlist: cprlistPtr)
Arguments:		cprlist = cprlist structure to free
Result:			none
-------------------------
FreeDiskObject
Description:		frees memory allocated for a Workbench disk object
Library:		icon.library
Offset:			-$005A (-90)
Modula-2 Module:	Icon
Syntax:			FreeDiskObject(diskObj)
C:			void FreeDiskObject(struct DiskObject *)
Machine Language:	FreeDiskObject(a0)
Modula-2:		FreeDiskObject(diskObj: DiskObjectPtr)
Arguments:		diskObj = DiskObject structure to free
Result:			none
-------------------------  
FreeEntry
Description:		frees many regions of memory
Library:		exec.library
Offset:			-$00E4 (-228)
Modula-2 Module:	Memory
Syntax:			FreeEntry(memList)
C:			void FreeEntry(struct MemList *)
Machine Language:	FreeEntry(a0)
Modula-2:		FreeEntry(memList: MemListPtr)
Arguments:		memList = MemList structure
Result:			none
-------------------------
FreeExpansionMem
Description:		frees expansion memory
Library:		expansion.library
Offset:			-$005A (-90)
Modula-2 Module:	Expansion
Syntax:			FreeExpansionMem(startSlot, numSlots)
C:			void FreeExpansionMem(long, long)
Machine Language:	FreeExpansionMem(d0, d1)
Modula-2:		FreeExpansionMem(startSlot, numSlots: INTEGER)
Arguments:		startSlot = slot number as returned by AllocExpansionMem( )
			slotSpec = number of slots to free
Result:			none
-------------------------
FreeFreeList
Description:		frees all memory in a free list
Library:		icon.library
Offset:			-$0036 (-54)
Modula-2 Module:	Icon
Syntax:			FreeFreeList(freeList)
C:			void FreeFreeList(struct FreeList *)
Machine Language:	FreeFreeList(a0)
Modula-2:		FreeFreeList(freeList: FreeListPtr)
Arguments:		memList = FreeList structure
Result:			none
-------------------------
FreeGBuffers
Description:		frees memory allocated by GetGBuffers( )
Library:		graphics.library
Offset:			-$0258 (-600)
Modula-2 Module:	Gels
Syntax:			FreeGBuffers(animOb, rastPort, dBuffer)
C:			void FreeGBuffers(struct AnimOb *, struct RastPort *, long)
Machine Language:	FreeGBuffers(a0, a1, d0)
Modula-2:		FreeGBuffers(animOb: AnimObPtr; rastPort: RastPortPtr; dBuffer:
			BOOLEAN)
Arguments:		animOb = AnimOb structure
			rastPort = Rastport structure
			dBuffer = double-buffer flag-TRUE for double-buffering
Result:			none
-------------------------
FreeMem
Description:		frees memory allocated by GetGBuffers( )
Library:		exec.library
Offset:			-$00D2 (-210)
Modula-2 Module:	Memory
Syntax:			FreeMem(memoryBlock, byteSize)
C:			void FreeMem(void *, long)
Machine Language:	FreeMem(a1, d0)
Modula-2:		FreeMem(memoryBlock: ADDRESS: byteSize: LONGCARD)
Arguments:		memoryBlock = pointer to memory block to free
			byteSize = size of block in bytes
Result:			none
-------------------------
FreeRaster
Description:		frees memory allocated by AllocRaster( )
Library:		graphics.library
Offset:			-$01F2 (-498)
Modula-2 Module:	Rasters
Syntax:			FreeRaster(p, width, height)
C:			void FreeRaster(PLANEPTR, long, long)
Machine Language:	FreeRaster(a0, d0, d1)
Modula-2:		FreeRaster(p: PlanePtr; width, height: CARDINAL)
Arguments:		p = memory block returned by AllocRaster( )
		width = width of bitplanes in pixels
		height = height of bitplanes in pixels
Result:			none
-------------------------  
FreeRemember
Description:		frees memory allocated by AllocRemember( )
Library:		intuition.library
Offset:			-$0198 (-408)
Modula-2 Module:	Intuition
Syntax:			FreeRemember(rememberKey, reallyForget)
C:			void FreeRemember(struct Remember *, long)
Machine Language:	FreeRemember(a0, d0)
Modula-2:		FreeRemember(rememberKey: RememberPrt; reallyForget:
			BOOLEAN)
Arguments:		rememberKey = address of pointer to Remember structure
			reallyForget = TRUE to free memory and link nodes; FALSE to
			free only link nodes
Result:			none
-------------------------
FreeSignal
Description:		frees a signal bit
Library:		exec.library
Offset:			-$0150 (-336)
Modula-2 Module:	Tasks
Syntax:			FreeSignal(signalNum)
C:			void FreeSignal(long)
Machine Language:	FreeSignal(d0)
Modula-2:		FreeSignal(signalNum: SIGNAL)
Arguments:		signalNum = signal number to free (0-31)
Result:			none
-------------------------
FreeSprite
Description:		makes sprite available for others to use
Library:		graphics.library
Offset:			-$019E (-414)
Modula-2 Module:	Sprites
Syntax:			FreeSprite(pick)
C:			void FreeSprite(long)
Machine Language:	FreeSprite(d0)
Modula-2:		FreeSprite(pick: INTEGER)
Arguments:		pick = number of sprite to free (0-7)
Result:			none
-------------------------
FreeSysRequest
Description:		frees memory allocated by BuildSysRequest( )
Library:		intuition.library
Offset:			-$0174 (-372)
Modula-2 Module:	Intuition
Syntax:			FreeSysRequest(window)
C:			void FreeSysRequest(struct Window *)
Machine Language:	FreeSysRequest(a0)
Modula-2:		FreeSysRequest(window: WindowPtr)
Arguments:		window = Window structure as returned by BuildSysRequest( )
Result:			none
-------------------------
FreeTrap
Description:		frees a processor trap
Library:		exec.library
Offset:			-$015C (-348)
Modula-2 Module:	Tasks
Syntax:			FreeTrap(trapNum)
C:			void FreeTrap(long)
Machine Language:	FreeTrap(d0)
Modula-2:		FreeTrap(trapNum: TRAP)
Arguments:		trapNum = trap number to free (0-15)
Result:			none
-------------------------
FreeVPortCoplists
Description:		frees all intermediate copper lists and their headers from a
			ViewPort
Library:		graphics.library
Offset:			-$021C (-540)
Modula-2 Module:	Views
Syntax:			FreeVPortCopLists(viewPort)
C:			void FreeVPortCopLists(struct ViewPort *)
Machine Language:	FreeVPortCopLists(a0)
Modula-2:		FreeVPortCopLists(viewPort: ViewPortPtr)
Arguments:		viewPort = ViewPort structure containing copper lists
Result:			none
-------------------------  
FreeWBObject
Description:		frees memory allocated for a Workbench object
Library:		icon.library
Offset:			-$003C (-60)
Modula-2 Module:	none
Syntax:			FreeWBObject(object)
C:			void FreeWBObject(struct WBObject *)
Machine Language:	FreeWBObject(a0)
Modula-2:		not available
Arguments:		object = WBObject structure to free
Result:			none
--------------------------
GetCC
Description:		gets 68000/68010 condition codes
Library:		exec.library
Offset:			-$0210 (-528)
Modula-2 Module:	Exec
Syntax:			condition = GetCC( )
C:			long GetCC(void)
Machine Language:	d0 = GetCC( )
Modula-2:		GetCC( ): BITSET
Arguments:		none
Result:			condition = 68000/68010 condition code
-------------------------
GetCLBuf
Description:		converts character list into contiguous data
Library:		clist.library
Offset:			-$0072 (-114)
Modula-2 Module:	none
Syntax:			length = GetCLBuf(cList, buffer, maxLength)
C:			long GetCLBuf(long, char *, long)
Machine Language:	d0 = GetCLBuf(a0, a1, d1)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
			buffer = buffer to hold data
			maxLength = maximum size of buffer in bytes
Result:			length = number of bytes copied into buffer
-------------------------  
GetCLChar
Description:		gets a byte from the beginning of a character list
Library:		clist.library
Offset:			-$0042 (-66)
Modula-2 Module:	none
Syntax:			byte = GetCLChar(cList)
C:			long GetCLChar(long)
Machine Language:	d0 = GetCLChar(a0)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
Result:			byte = byte from beginning of character list; -1 if no data
-------------------------
GetCLWord
Description:		gets a word from the beginning of a character list
Library:		clist.library
Offset:			-$005A (-90)
Modula-2 Module:	none
Syntax:			word = GetCLWord(cList)
C:			long GetCLWord(long)
Machine Language:	d0 = GetCLWord(a0)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
Result:			word = word from beginning of character list; -1 if no data
-------------------------
GetColorMap
Description:		allocates and initializes a ColorMap structure
Library:		graphics.library
Offset:			-$023A (-570)
Modula-2 Module:	Views
Syntax:			colorMap = GetColorMap(entries)
C:			struct ColorMap *GetColorMap(long)
Machine Language:	d0 = GetColorMap(d0)
Modula-2:		GetColorMap(colorMap: LONGINT): ColorMapPtr
Arguments:		entries = number of entries for this color map
Result:			colorMap = pointer to ColorMap structure; O if unsuccessful
-------------------------  
GetCurrentBinding
Description:		sets static board configuration area
Library:		expansion.library
Offset:			-$008A (-138)
Modula-2 Module:	none
Syntax:			actual = GetCurrentBinding(currentBinding, size)
C:			long GetCurrentBinding(long, long)
Machine Language:	d0 = GetCurrentBinding(a0, d0)
Modula-2:		not available
Arguments:		currentBinding = CurrentBinding structure
			size = size of user's BindDriver structure
Result:			actual = actual size of the CurrentBinding structure
-------------------------
GetDefPrefs
Description:		gets a copy of the default Preferences
Library:		intuition.library
Offset:			-$007E (-126)
Modula-2 Module:	Preferences
Syntax:			prefBuffer = GetDefPrefs(prefBuffer, size)
C:			struct Preferences *GetDefPrefs(struct Preferences *, long)
Machine Language:	d0 = GetDefPrefs(a0, d0)
Modula-2:		GetDefPrefs(prefBuffer: ADDRESS; size: INTEGER): ADDRESS
Arguments:		prefBuffer = buffer to receive copy of default Preferences
			size = size of buffer in bytes
Result:			prefBuffer = pointer to your buffer
-------------------------
GetDiskObject
Description:		reads a Workbench DiskObject (.info file) from disk
Library:		icon.library
Offset:			-$004E (-78)
Modula-2 Module:	Icon
Syntax:			diskObj = GetDiskObject(name)
C:			struct DiskObject *GetDiskObject(char *)
Machine Language:	d0 = GetDiskObject(a0)
Modula-2:		GetDiskObject(name: STRPTR): DiskObjectPtr
Arguments:		name = name of Workbench object (.info file)
Result:			diskObj = pointer to DiskObject structure; 0 if unsuccessful
-------------------------  
GetGBuffers
Description:		attempts to allocate all buffers of an enter AnimOb
Library:		graphics.library
Offset:			-$00A8 (-168)
Modula-2 Module:	Gels
Syntax:			success = GetGBuffers(animOb, rastPort, dBuffer)
C:			long GetGBuffers(struct AnimOb *, struct RastPort *, long)
Machine Language:	d0 = GetGBuffers(a0, a1, d0)
Modula-2:		GetGBuffers(animOb: AnimObPtr; rastPort: RastPortPtr; dBuffer:
			BOOLEAN): BOOLEAN
Arguments:		animOb = AnimOb structure
			rastPort = Rastport structure
			dBuffer = double-buffer flag-TRUE for double-buffering
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
GetIcon
Description:		reads a DiskObject structure from disk
Library:		icon.library
Offset:			-$002A (-42)
Modula-2 Module:	none
Syntax:			status = GetIcon(name, icon, free)
C:			long GetIcon(char *, struct DiskObject *, struct FreeList *)
Machine Language:	d0 = GetIcon(a0, a1, a2)
Modula-2:		not available
Arguments:		name = name of icon (.info file)
			icon = DiskObject structure
			free = FreeList structure
Result:			status = nonzero if successful
-------------------------
GetMsg
Description:		gets next message from a message port
Library:		exec.library
Offset:			-$0174 (-372)
Modula-2 Module:	Ports
Syntax:			message = GetMsg(port)
C:			struct Message *GetMsg(struct MsgPort *)
Machine Language:	d0 = GetMsg(a0)
Modula-2:		GetMsg(port: MsgPortPtr): ADDRESS
Arguments:		port = receiving message port
Result:			message = pointer to first message; NULL if no message
-------------------------
GetPrefs
Description:		gets Preferences' current settings
Library:		intuition.library
Offset:			-$0084 (-132)
Modula-2 Module:	Preferences
Syntax:			prefBuffer = GetDefPrefs(prefBuffer, size)
C:			struct Preferences *GetDefPrefs(struct Preferences *, long)
Machine Language:	d0 = GetDefPrefs(a0, d0)
Modula-2:		GetDefPrefs(prefBuffer: ADDRESS; size: INTEGER): ADDRESS
Arguments:		prefBuffer = buffer to receive copy of Preferences
			size = size of buffer in bytes
Result:			prefBuffer = pointer to your buffer
-------------------------
GetRGB4
Description:		gets the value of an entry in a ColorMap structure
Library:		graphics.library
Offset:			-$0246 (-582)
Modula-2 Module:	Views
Syntax:			value = GetRGB4(colorMap, entry)
C:			long GetRGB4(struct ColorMap *, long)
Machine Language:	d0 = GetRGB4(a0, d0)
Modula-2:		GetRGB4(colorMap: ColorMapPtr; entry: LONGINT): INTEGER
Arguments:		colorMap = ColorMap structure
			entry = index into color table, specifying desired entry
Result:			value = two-byte, right-justified RGB value with four bits per
			color-red, green, blue; -1 if no valid entry
-------------------------
GetSereenData
Description:		copies all or part of a Screen structure into buffer; opens specifled
			screen if not already open
Library:		intuition.library
Offset:			-$01AA (-426)
Modula-2 Module:	Intuition
Syntax:			success = GetScreenData(buffer, size, type, screen)
C:			long GetScreenData(char *, long, long, struct Screen *)
Machine Language:	d0 = GetScreenData(a0, d0, d1, a1)
Modula-2:		GetScreenData(buffer: ADDRESS; size: CARDINAL; type:
			ScreenFlagSet; screen: ScreenPtr): BOOLEAN
Arguments:		buffer = buffer in which data will be placed
			size = size of buffer in bytes
			type = screen type-CUSTOMSCREEN, WORKBENCHSCREEN
			screen = custom Screen structure; ignored if type argument
			equals WORKBENCHSCREEN

Result:			success = TRUE if successful; FALSE if screen not available and
			could not be opened
-------------------------
GetSprite
Description:		allocates hardware sprite for simple sprite manager
Library:		graphics.library
Offset:			-$0198 (-408)
Modula-2 Module:	Sprites
Syntax:			spriteNumber = GetSprite(sprite, pick)
C:			long GetSprite(struct SimpleSprite *, long)
Machine Language:	d0 = GetSprite(a0, d0)
Modula-2:		GetSprite(sprite: SimpleSpritePtr; pick: INTEGER): INTEGER
Arguments:		sprite = SimpleSprite structure
			pick = number of desired sprite (0-7); -1 for next available
			sprite
Result:			spriteNumber = number of sprite allocated; -1 if sprite
			unavailable
-------------------------
GetWBObject
Description:		reads in a Workbench object from disk
Library:		icon.library
Offset:			-$001E (-30)
Modula-2 Module:	none
Syntax:			object = GetWBObject(name)
C:			struct WBObject *GetWBObject(char *)
Machine Language:	d0 = GetWBObject(a0)
Modula-2:		not available
Arguments:		name = NULL terminated string that specifies name of Work-
			bench object
Result:			object = pointer to Workbench object; 0 if unsuccessful
------------------------- 
IEEEDPAbs
Description:		obtains the absolute value of an IEEE double-precision floating-
			point number
Library:		mathieeedoubbas.library
Offset:			-$0036 (-54)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPAbs(fnum2)
C:			double IEEEDPAbs(double)
Machine Language:	d0/d1 = IEEEDPAbs(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
Result:			fnum1 = absolute value of fnum2 in IEEE double-precision
			floating-point format
-------------------------
IEEEDPAcos
Description:		obtains the arccosine of an IEEE double-precision floating-point
			number
Library:		mathieeedoubtrans.library
Offset:			-$0078 (-120)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPAcos(fnum2)
C:			double IEEEDPAcos(double)
Machine Language:	d0/d1 = IEEEDPAcos(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing the cosine of an angle
Result:			fnum1 = IEEE double-precision floating-point value of fnum2 an-
			gle in radians
-------------------------
IEEEDPAdd
Description:		adds two IEEE double-precision floating-point numbers
Library:		mathieeedoubbas.library
Offset:			-$0042 (-66)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPAdd(fnum2, fnum3)
C:			double IEEEDPAdd(double, d0uble)
Machine Language:	d0/d1 = IEEEDPAdd(d0/d1, d2/d3)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
			fnum3 = IEEE double-precision floating-point number
Result:			fnum1 = fnum2 plus fnum3 in IEEE double-precision floating-
			point format
-------------------------
IEEEDPAsin
Description:		obtains the arcsine of an IEEE double-precision floating-point
			number
Library:		mathieeedoubtrans.library
Offset:			-$0072 (-114)
Modula-2 Module:	none
Syntax:			fnum2 = IEEEDPAsin(fnum2)
C:			double IEEEDPAsin(double)
Machine Language:	d0/d1 = IEEEDPAsin(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing the sine of an angle
Result:			fnum1 = IEEE double-precision floating-point value of fnum2 an-
			gle in radians
-------------------------
IEEEDPAtan
Description:		obtains the arctangent of an IEEE double-precision floating-point
			number
Library:		mathieeedoubtrans.library
Offset:			-$0030 (-48)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPAtan(fnum2)
C:			double IEEEDPAtan(double)
Machine Language:	d0/d1 = IEEEDPAtan(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing the tangent of an angle
Result:			fnum1 = IEEE double-precision floating-point value of fnum2 an-
			gle in radians
-------------------------
IEEEDPCeil
Description:		obtains the Ceil function of an IEEE double-precision floating-
			point number (rounds it up)
Library:		mathieeedoubbas.library
Offset:			-$0060 (-96)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPCeil(fnum2)
C:			double IEEEDPCeil(double)
Machine Language:	d0/d1 = IEEEDPCeil(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
Result:			fnum1 = IEEE double-precision floating-point integer value that's
			closest to, but not less than the value of fnum2
-------------------------
IEEEDPCmp
Description:		compares two IEEE double-precision floating-point numbers
Library:		mathieeedoubbas.library
Offset:			-$002A (-42)
Modula-2 Module:	none
Syntax:			flag = IEEEDPCmp(fnum1, fnum2)
C:			long IEEEDPCmp(double, d0uble)
Machine Language:	d0 = IEEEDPCmp(d0/d1, d2/d3)
Modula-2:		not available
Arguments:		fnum1 = IEEE double-precision floating-point number
			fnum2 = IEEE double-precision floating-point number
Result:			flag = -1 if fnum1<fnum2; +1 if fnum1>fnum2; 0 if
			fnum1 = fnum2
-------------------------
IEEEDPCos
Description:		obtains the cosine of an IEEE double-precision floating-point
			number
Library:		mathieeedoubtrans.library
Offset:			-$002A (-42)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPCos(fnum2)
C:			double IEEEDPCos(double)
Machine Language:	d0/d1 = IEEEDPCos(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing an angle in radians
Result:			fnum1 = IEEE double-precision floating-point cosine of fnum2
-------------------------
IEEEDPCosh
Description:		obtains the hyperbolic cosine of an IEEE double-precision float-
			ing-point number
Library:		mathieeedoubtrans.library
Offset:			-$0042 (-66)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPCosh(fnum2)
C:			double IEEEDPCosh(double)
Machine Language:	d0/d1 = IEEEDPCosh(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing an angle in radians
Result:			fnum1 = IEEE double-precision floating-point hyperbolic cosine
			of fnum2
-------------------------
IEEEDPDiv
Description:		divides one IEEE double-precision floating-point number by
			another
Library:		mathieeedoubbas.library
Offset:			-$0054 (-84)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPDiv(fnum2, fnum3)
C:			double IEEEDPDiv(double, d0uble)
Machine Language:	d0/d1 = IEEEDPDiv(d0/d1, d2/d3)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point dividend
			fnum3 = IEEE double-precision floating-point divisor
Result:			fnum1 = IEEE double-precision floating-point format results of
			fnum2 divided by fnum3
-------------------------
IEEEDPExp
Description:		obtains the exponent of an IEEE double-precision floating-point
			number
Library:		mathieeedoubtrans.library
Offset:			-$004E (-78)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPExp(fnum2)
C:			double IEEEDPExp(double)
Machine Language:	d0/d1 = IEEEDPExp(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
Result:			fnum1 = IEEE double-precision floating-point value representing
			e raised to the power of fnum2
-------------------------
IEEEDPFieee
Description:		converts a IEEE single-precision floating-point number to an IEEE
			double-precision floating-point number
Library:		mathieeedoubtrans.library
Offset:			-$006C (-108)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPFieee(fnum2)
C:			double IEEEDPFieee(float)
Machine Language:	d0/d1 = IEEEDPFieee(d0)
Modula-2:		not available
Arguments:		fnum2 = IEEE single-precision floating-point number
Result:			fnum1 = IEEE double-precision floating-point equivalent to
			fnum2
-------------------------
IEEEDPFix
Description:		converts an IEEE double-precision floating-point number to an
			integer
Library:		mathieeedoubbas.library
Offset:			-$001E (-30)
Modula-2 Module:	none
Syntax:			inum = IEEEDPFix(fnum)
C:			long IEEEDPFix(double)
Machine Language:	d0 = IEEEDPFix(d0/d1)
Modula-2:		not available
Arguments:		fnum = IEEE double-precision floating-point number
Result:			inum = integer equivalent to fnum
-------------------------
IEEEDPFloor
Description:		obtains the Floor function of an IEEE double-precision floating-
			point number (rounds it down)
Library:		mathieeedoubbas.library
Offset:			-$005A (-90)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPFloor(fnum2)
C:			double IEEEDPFloor(double)
Machine Language:	d0/d1 = IEEEDPFloor(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
Result:			fnum1 = IEEE double-precision floating-point integer value that's
			closest to, but not greater than the value of fnum2
-------------------------
IEEEDPFlt
Description:		converts an integer to an IEEE double-precision floating-point
			number
Library:		mathieeedoubbas.library
Offset:			-$0024 (-36)
Modula-2 Module:	none
Syntax:			fnum = IEEEDPFlt(inum)
C:			double IEEEDPFlt(long)
Machine Language:	d0/d1 = IEEEDPFlt(d0)
Modula-2:		not available
Arguments:		inum = signed integer to be converted
Result:			fnum = IEEE double-precision floating-point equivalent to inum
-------------------------
IEEEDPLog
Description:		obtains the natural logarithm of an IEEE double-precision floating-
			point number
Library:		mathieeedoubtrans.library
Offset:			-$0054 (-84)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPLog(fnum2)
C:			double IEEEDPLog(double)
Machine Language:	d0/d1 = IEEEDPLog(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
Result:		        fnum1 = IEEE double-precision floating-point natural logarithm
			(base e) of fnum2
-------------------------
IEEEDPlog10
Description:		obtains the naparian logarithm (base 10) of an IEEE double-
			precision floating-point number
Library:		mathieeedoubtrans.library
Offset:			-$007E (-126)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPLog10(fnum2)
C:			double IEEEDPLog10(double)
Machine Language:	d0/d1 = IEEEDPLog10(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
Result:			fnum1 = IEEE double-precision floating-point naparian logarithm
			(base 10) of fnum2
-------------------------
IEEEDPMul
Description:		multiplies one IEEE double-precision floating-point number by
			another
Library:		mathieeedoubbas.library
Offset:			-$004E (-78)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPMul(fnum2, fnum3)
C:			double IEEEDPMul(double, d0uble)
Machine Language:	d0/d1 = IEEEDPMul(d0/d1, d2/d3)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
			fnum3 = IEEE double-precision floating-point number
Result:			fnum1 = product of fnum2 and fnum3 in IEEE double-precision
			floating-point format
-------------------------
IEEEDPNeg
Description:		negates the value of an IEEE double-precision floating-point number
Library:		mathieeedoubbas.library
Offset:			-$003C (-60)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPNeg(fnum2)
C:			double IEEEDPNeg(double)
Machine Language:	d0/d1 = IEEEDPNeg(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number to negate
Result:			fnum1 = negative fnum2 in IEEE double-precision floating-point
			format
-------------------------
IEEEDPPow
Description:		obtains the exponentiation of two IEEE double-precision floating-
			point numbers
Library:		mathieeedoubtrans.library
Offset:			-$005A (-90)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPPow(fnum2, fnum3)
C:			double IEEEDPPow(double, d0uble)
Machine Language:	d0/d1 = IEEEDPPow(d2/d3, d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
			fnum3 = IEEE double-precision floating-point number
Result:			fnum1 = IEEE double-precision floating-point value of fnum2
			raised to the power of fnum3
-------------------------
IEEEDPSin
Description:		obtains the sine of an IEEE double-precision floating-point
			number
Library:		mathieeedoubtrans.library
Offset:			-$0024 (-36)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPSin(fnum2)
C:			double IEEEDPSin(double, d0uble)
Machine Language:	d0/d1 = IEEEDPSin(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing an angle in radians
Result:			fnum1 = IEEE double-precision floating-point sine of fnum2
-------------------------
IEEEDPSincos
Description:		obtains the sine and cosine of an IEEE double-precision floating-
			point number
Library:		mathieeedoubtrans.library
Offset:			-$0036 (-54)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPSincos(fnum2, fnum3)
C:			double IEEEDPSincos(double, d0uble *)
Machine Language:	d0/d1 = IEEEDPSincos(d0/d1, a0)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
			fnum3 = pointer to an IEEE double-precision floating point num-
			ber to receive the cosine of fnum2
Result:			fnum1 = IEEE double-precision floating-point sine of fnum2 (co-
			sine is returned in fnum3)
-------------------------
IEEEDPSinh
Description:		obtains the hyperbolic sine of an IEEE double-precision floating-
			point number
Library:		mathieeedoubtrans.library
Offset:			-$003C (-60)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPSinh(fnum2)
C:			double IEEEDPSinh(double, d0uble)
Machine Language:	d0/d1 = IEEEDPSinh(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing an angle in radians
Result:			fnum1 = IEEE double-precision floating-point hyperbolic sine of
			fnum2
-------------------------
IEEEDPSqrt
Description:		obtains the square root of an IEEE double-precision floating-point
			number
Library:		mathieeedoubtrans.library
Offset:			-$0060 (-96)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPSqrt(fnum2)
C:			double IEEEDPSqrt(double)
Machine Language:	d0/d1 = IEEEDPSqrt(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
Result:			fnum1 = IEEE double-precision floating-point square root of
			fnum2
-------------------------
IEEEDPSub
Description:		subtracts one IEEE double-precision floating-point number from
			another
Library:		mathieeedoubbas.library
Offset:			-$0048 (-72)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPSub(fnum2, fnum3)
C:			double IEEEDPSub(double, d0uble)
Machine Language:	d0/d1 = IEEEDPSub(d0/d1, d2/d3)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
			fnum3 = IEEE double-precision floating-point number
Result:			fnum1 = fnum2 minus fnum3 in IEEE double-precision floating-
			point format
-------------------------
IEEEDPTan
Description:		obtains the tangent of an IEEE double-precision floating-point
			number
Library:		mathieeedoubtrans.library
Offset:			-$0030 (-48)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPTan(fnum2)
C:			double IEEEDPTan(double, d0uble)
Machine Language:	d0/d1 = IEEEDPTan(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing an angle in radians
Result:			fnum1 = IEEE double-precision floating-point tangent of fnum2
-------------------------
IEEEDPTanh
Description:		obtains the hyperbolic tangent of an IEEE double-precision
			floating-point number
Library:		mathieeedoubtrans.library
Offset:			-$0048 (-72)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPTanh(fnum2)
C:			double IEEEDPTanh(double, d0uble)
Machine Language:	d0/d1 = IEEEDPTanh(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing an angle in radians
Result:			fnum1 = IEEE double-precision floating-point hyperbolic tangent
			of fnum2
------------------------- 
IEEEDPTIeee
Description:		converts an IEEE double-precision floating-point number to an
			IEEE single-precision floating-point number
Library:		mathieeedoubtrans.library
Offset:			-$0066 (-102)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPTieee(fnum2)
C:			float IEEEDPTieee(double)
Machine Language:	d0 = IEEEDPTieee(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
Result:			fnum1 = IEEE single-precision floating-point equivalent to fnum2
-------------------------
IEEEDPTst
Description:		compares an IEEE double-precision floating-point number with
			zero
Library:		mathieeedoubbas.library
Offset:			-$0030 (-48)
Modula-2 Module:	none
Syntax:			flag = IEEEDPTst(fnum)
C:			long IEEEDPTst(double)
Machine Language:	d0 = IEEEDPTst(d0/d1)
Modula-2:		not available
Arguments:		fnum = IEEE double-precision floating-point number
Result:			flag = -1 if fnum <0; +1 if fnum >0; 0 if fnum=0
-------------------------
IncrCLMark
Description:		increments character list mark to the next position
Library:		clist.library
Offset:			-$007E (-126)
Modula-2 Module:	none
Syntax:			error = IncrCLMark(cList)
C:			long IncrCLMark(long)
Machine Language:	d0 = IncrCLMark(a0)
Modula-2:      		not available
Arguments:		cList = character list descriptor
Result:			error = 0 if successful; nonzero if next offset is not in the charac-
			ter list
-------------------------
Info
Description:		returns information about a disk or disk file
Library:		dos.library
Offset:			-$0072 (-114)
Modula-2 Module:	DOS
Syntax:			success = Info(lock, infoData)
C:		        long Info(BPTR, struct InfoData *)
Machine Language:	d0 = Info(d1, d2)
Modula-2:		Info(lock: FileLock; infoData: InfoDataPtr): BOOLEAN
Arguments:		lock = BCPL pointer to a lock
			infoData = InfoData structure to be filled
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
InitArea
Description:		initializes vector collection matrix
Library:		graphics.library
Offset:			-$011A (-282)
Modula-2 Module:	Areas
Syntax:			InitArea(areaInfo, buffer, maxVectors)
C:		        long InitArea(struct AreaInfo *, short *, long)
Machine Language:	InitArea(a0, a1, d0)
Modula-2:		InitArea(areaInfo: AreaInfoPtr; buffer: ADDRESS; maxVectors:
			INTEGER)
Arguments:		areaInfo = AreaInfo structure
			buffer = pointer to memory block where vectors will be stored-
			must start on word boundary and should be 5*maxVectors bytes
			long
			maxVectors = maximum number of vectors
Result:			none
-------------------------
InitBitMap
Description:		initializes a BitMap structure
Library:		graphics.library
Offset:			-$0186 (-390)
Modula-2 Module:	Graphics
Syntax:			InitBitMap(bitMap, depth, width, height)
C:			void InitBitMap(struct Bitmap *, long, long, long)
Machine Language:	InitBitMap(a0, d0, d1, d2)
Modula-2:		InitBitMap(bitMap: BitMapPtr; depth, width, height: INTEGER)
Arguments:		bitMap = BitMap structure
			depth = number of bit planes to be used
			width = width of each bit plane in bits
			height = height of each bit plane in lines
Result:			none
-------------------------
InitCLPool
Description:		initializes a character list pool
Library:		clist.library
Offset:			-$001E (-30)
Modula-2 Module:	none
Syntax:			error = InitCLPool(cLPool, size)
C:			long InitCLPool(long, long)
Machine Language:	d0 = InitCLPool(a0, d0)
Modula-2:		not available
Arguments:		cLPool = data area to be used as character list pool
			size = size of pool in bytes
Result:			error = 0 if successful; nonzero if pool size is too small
-------------------------
InitCode
Description:		initializes resident modules with a startup class value and version
			number
Library:		exec.library
Offset:			-$0048 (-72)
Modula-2 Module: 	Resident
Syntax:			InitCode(startClass, version)
C:			void InitCode(long, long)
Machine Language:	InitCode(d0, d1)
Modula-2:		InitCode(startClass, version: LONGCARD)
Arguments:		startClass = startup class of resident module-COLDSTART,
			COOLSTART, or WARMSTART
			version = version number of resident module
Result:			none
-------------------------
InitGels
Description:		initializes a GEL list
Library:		graphics.library
Offset:			-$0078 (-120)
Modula-2 Module:	Gels
Syntax:			InitGels(head, tail, gelsInfo)
C:			void InitGels(struct VSprite *, struct VSprite *, struct GelsInfo *)
Machine Language:	InitGels(a0, a1, a2)
Modula-2:		InitGels(head, tail: VSpritePtr; gelsInfo: GelsInfoPtr)
Arguments:		head = VSprite structure to be used as head of GEL list
			tail = VSprite structure to be used as tail of GEL list
			gelsInfo = GelsInfo structure to be initialized
Result:			none
-------------------------
InitGMasks
Description:		initializes all masks of an AnimOb structure
Library:		graphics.library
Offset:			-$00AE (-174)
Modula-2 Module:	Gels
Syntax:			InitGMasks(animOb)
C:			void InitGMasks(struct AnimOb *)
Machine Language:	InitGMasks(a0)
Modula-2:		InitGMasks(animOb: AnimObPtr)
Arguments:		animOb = AnimOb structure containing masks to initialize
Result:			none
-------------------------
InitLayers
Description:		initializes a Layer_Info structure
Library:		layers.library
Offset:			-$001E (-30)
Modula-2 Module:	none
Syntax:			InitLayers(layerInfo)
C:			void InitLayers(struct Layer_Info *)
Machine Language:	InitLayers(a0)
Modula-2:		not available
Arguments:		layerInfo = Layer_Info structure to initialize
Result:			none
-------------------------
InitMasks
Description:		initializes the BorderLine and CollMask values used by a VSprite
			structure
Library:		graphics.library
Offset:			-$007E (-126)
Modula-2 Module:	Gels
Syntax:			InitMasks(vSprite)
C:			void InitMasks(struct VSprite *)
Machine Language:	InitMasks(a0)
Modula-2:		InitMasks(vSprite: VSpritePtr)
Arguments:		vSprite = VSprite structure containing BorderLine and CollMask
			values to initialize
Result:			none
-------------------------
InitRastPort
Description:		initializes a RastPort structure
Library:		graphics.library
Offset:			-$00C6 (-198)
Modula-2 Module:	Rasters
Syntax:			InitRastPort(rastPort)
C:			void InitRastPort(struct RastPort *)
Machine Language:	InitRastPort(a1)
Modula-2:		InitRastPort(rastPort: RastPortPtr)
Arguments:		rastPort = RastPort structure to initialize
Result:			none
-------------------------
InitRequester
Description:		initializes a Requester structure
Library:		intuition.library
Offset:			-$008A (-138)
Modula-2 Module:	Intuition
Syntax:			InitRequester(requester)
C:			void InitRequester(struct Requester *)
Machine Language:	InitRequester(a0)
Modula-2:		InitRequester(requester: RequesterPtr)
Arguments:		requester = Requester structure to initialize
Result:			none
-------------------------
InitResident
Description:		initializes a resident module
Library:		exec.library
Offset:			-$0066 (-102)
Modula-2 Module:	Resident
Syntax:			InitResident(resident, segList)
C:			void InitResident(struct Resident *, char *)

Machine Language:	InitResident(a1, d1)
Modula-2:		InitResident(resident: ResidentPtr; segList: ADDRESS)
Arguments:		resident = Resident structure representing resident module to
			initialize
			segList = a segment list
Result:			none
-------------------------
InitSemaphore
Description:		initializes a SignalSemaphore structure
Library:		exec.library
Offset:			-$022E (-558)
Modula-2 Module:	Semaphores
Syntax:			InitSemaphore(signalSemaphore)
C:			void InitSemaphore(struct SignalSemaphore *)
Machine Language:	InitSemaphore(a0)
Modula-2:		InitSemaphore(signalSemaphore: SignalSemaphorePtr)
Arguments:		signalSemaphore = SignalSemaphore structure to initialize
Result:			none
-------------------------
InitStruct
Description:		clears an area of memory following rules defined by a table
Library:		exec.library
Offset:			-$004E (-78)
Modula-2 Module:	Memory
Syntax:			InitStruct(initTable, memBlock, size)
C:			void InitStruct(char *, char *, long)
Machine Language:	InitStruct(a1, a2, d0)
Modula-2:		InitStruct(initTable, memBlock: ADDRESS; size: CARDINAL)
Arguments:		initTable = pointer to the commands and data used to initialize
			memory
			memBlock = pointer to memory to be initialized
			size = size of memory to clear before it is initialized with
			initTable; 0 for no initial clearing of memory
Result:			none
-------------------------
InitTmpRas
Description:		initializes chip RAM for use by area-fill, flood-fill, and text
			functions
Library:		graphics.library
Offset:			-$01D4 (-468)
Modula-2 Module:	Rasters
Syntax:			InitTmpRas(tmpRas, buffer, size)
C:			void InitTmpRas(struct TmpRas *, char *, long)
Machine Language:	InitTmpRas(a0, a1, d0)
Modula-2:		InitTmpRas(tmpRas: TmpRasPtr; buffer: PlanePtr; size:
			LONGCARD)
Arguments:		tmpRas = TmpRas structure to be linked into a RastPort
			buffer = pointer to chip RAM memory
			size = size of buffer in bytes
Result:			none
-------------------------
InitView
Description:		initializes a View structure
Library:		graphics.library
Offset:			-$0168 (-360)
Modula-2 Module:	Views
Syntax:			InitView(view)
C:			void InitView(struct View *)
Machine Language:	InitView(a1)
Modula-2:		InitView(view: ViewPtr)
Arguments:		view = View structure to initialize
Result:			none
-------------------------
InitVPort
Description:		initializes a ViewPort structure
Library:		graphics.library
Offset:			-$00CC (-204)
Modula-2 Module:	Views
Syntax:			InitVPort(viewPort)
C:			void InitVPort(struct ViewPort *)
Machine Language:	InitVPort(a0)
Modula-2:      		InitVPort(viewPort: ViewPortPtr)
Arguments:		viewPort = ViewPort structure to initialize
Result:			none
-------------------------  
Input
Description:		gets the initial input file handle assigned to a program
Library:		dos.library
Offset:			-$0036 (-54)
Modula-2 Module:	DOS
Syntax:			file = Input( )
C:			BPTR Input(void)
Machine Language:	d0 = Input( )
Modula-2:		Input( ): FileHandle
Arguments:		none
Result:			file = BCPL pointer to a file handle
-------------------------
Insert
Description:		inserts a Node structure into a doubly-linked list
Library:		exec.library
Offset:			-$00EA (-234)
Modula-2 Module:	Lists
Syntax:			Insert(list, node, listNode)
C:			void Insert(struct List *, struct Node *, struct Node *)
Machine Language:	Insert(a0, a1, a2)
Modula-2:		Insert(list: ListPtr; node, listNode: NodePtr)
Arguments:		list = target List header
			node = Node structure to insert
			listNode = node after which to insert; NULL to insert at head
Result:			none
-------------------------
InstallClipRegion
Description:		installs a clip region into a layer
Library:		layers.library
Offset:			-$00AE (-174)
Modula-2 Module:	Layers
Syntax:			oldClipRegion = InstallClipRegion(layer, region)
C:			struct Region *InstallClipRegion(struct Layer *, struct Region *)
Machine Language:	d0 = InstallClipRegion(a0, a1)
Modula-2:		InstallClipRegion(layer: LayerPtr; region: RegionPtr): RegionPtr
Arguments:		layer = Layer structure to which region will be added
			region = Region structure to be added to layer
Result:			oldClipRegion = previous clip region that was installed; NULL if
			no previous clip region
------------------------- 
IntuiTextLength
Description:		returns the pixel width of an IntuiText string
Library:		intuition.library
Offset:			-$014A (-330)
Modula-2 Module:	Intuition
Syntax:			length = IntuiTextLength(intuiText)
C:			long IntuiTextLength(struct IntuiText *)
Machine Language:	d0 = IntuiTextLength(a0)
Modula-2:		IntuiTextLength(intuiText: IntuiTextPtr): CARDINAL
Arguments:		intuiText = IntuiText structure
Result:			length = pixel width of text
-------------------------
Intuition
Description:		sets Intuition's main entry point, where input events arrive and
			are dispatched
Library:		intuition.library
Offset:			-$0024 (-36)
Modula-2 Module:	Intuition
Syntax:			Intuition(inputEvent)
C:			void Intuition(struct InputEvent *)
Machine Language:	Intuition(a0)
Modula-2:		Intuition(inputEvent: InputEventPtr)
Arguments:		inputEvent = first input event in a linked list of InputEvent
			structures
Result:			none
-------------------------
IoErr
Description:		gets extra information from the system
Library:		dos.library
Offset:			-$0084 (-132)
Modula-2 Module:	DOS
Syntax:			error = IoErr( )
C:			long IoErr(void)
Machine Language:	d0 = IoErr( )
Modula-2:		IoErr( ): LONGINT
Arguments:		none
Result:			error = error code or other error information
------------------------- 
IsInteractive
Description:		finds out whether a file is connected to a virtual terminal
Library:		dos.library
Offset:			-$00D8 (-216)
Modula-2 Module:	DOS
Syntax:			status = IsInteractive(file)
C:			long IsInteractive(BPTR)
Machine Language:	d0 = IsInteractive(d1)
Modula-2:		IsInteractive(file: FileHandle): BOOLEAN
Arguments:		file = BCPL pointer to a file handle
Result:			status = TRUE if file is connected to a virtual terminal; FALSE if
			not
-------------------------
ItemAddress
Description:		returns address of specified MenuItem
Library:		intuition.library
Offset:			-$0090 (-144)
Modula-2 Module:	Intuition
Syntax:			address = ItemAddress(menuStrip, menuNumber)
C:			struct MenuItem *ItemAddress(struct Menu *, long)
Machine Language:	d0 = ItemAddress(a0, d0)
Modula-2:		ItemAddress(menuStrip: MenuPtr; menuNumber: CARDINAL):
			MenuItemPtr
Arguments:		menuStrip = first menu in your menu strip
			menuNumber = value with packed data that specifies the menu
			and item (and optionally subitem)
Result:			address = pointer to specified MenuItem; NULL if menuNumber
			equals NULL
-------------------------
ITEMNUM (macro)
Description:		extracts the menu item number from a value
C Include File:		include/intuition/intuition.h
ML Include File:	none
Modula-2 Module:	Intuition
Syntax:			itemNumber = ITEMNUM(menuValue)
C:			long ITEMNUM(long)
Machine Language:	not available
Modula-2:		ITEMNUM(menuValue: CARDINAL): CARDINAL
Arguments:		menuValue = 16-bit packed number representing the menu num-
			ber, item number, and subitem number
Result:			itemNumber = item number (0-63); equals NOITEM if no menu
			was selected
-------------------------
LoadRGB4
Description:		loads color register values from a data table
Library:		graphics.library
Offset:			-$00C0 (-192)
Modula-2 Module:	Views
Syntax:			LoadRGB4(viewPort, colormap, pens)
C:			void LoadRGB4(struct ViewPort *, short *, long)
Machine Language:	LoadRGB4(a0, a1, d0)
Modula-2:		LoadRGB4(viewPort: ViewPortPtr; colormap: ADDRESS; pens:
			INTEGER)
Arguments:		viewPort = ViewPort whose colors you want to change
			colormap = pointer to array of 16-bit color values, where the firs
			four bits are zero, the second contains red, the third green, and
			the fourth blue
			pens = number of consecutive color registers to load
Result:			none
-------------------------
LoadSeg
Description:		loads an AmigaDOS load module into memory
Library:		dos.library
Offset:			-$0096 (-150)
Modula-2 Module:	DOSLoader
Syntax:			segment = LoadSeg(name)
C:			BPTR LoadSeg(char *)
Machine Language:	d0 = LoadSeg(d1)
Modula-2:		LoadSeg(name: STRPTR): BPTR
Arguments:		name = NULL terminated string that specifies the filename of
			load module
Result:			segment = BCPL pointer to a segment; 0 if unsuccessful
-------------------------
LoadView
Description:		creates a display using a new copper list
Library:		graphics.library
Offset:			-$00DE (-222)
Modula-2 Module:	Views
Syntax:			LoadView(view)
C:			void LoadView(struct View *)
Machine Language:	LoadView(a1)
Modula-2:		LoadView(view: ViewPtr)
Arguments:		view = View structure with pointer to copper list
Result:			none
-------------------------
Lock
Description:		locks a directory or file
Library:		dos.library
Offset:			-$0054 (-84)
Modula-2 Module:	DOS
Syntax:			lock = Lock(name, accessMode)
C:			BPTR Lock(char *, long)
Machine Language:	d0 = Lock(d1, d2)
Modula-2:		Lock(name: STRPTR; accessMode: LONGINT): FileLock
Arguments:		name = NULL terminated string that specifies name of file or
			directory
			accessMode = type of lock-ACCESS_READ (shared) or
			ACCESS_WRITE (exclusive)
Result:			lock = BCPL pointer to a lock
-------------------------
LockIBase
Description:		locks IntuitionBase to keep other tasks (or the system) from
			changing it
Library:		intuition.library
Offset:			-$019E (-414)
Modula-2 Module:	IntuitionBase
Syntax:			lockValue = LockIBase(lockNumber)
C:			long LockIBase(long)
Machine Language:	d0 = LockIBase(d0)
Modula-2:		LockIBase(lockNumber: LONGCARD): LONGCARD
Arguments:		lockNumber = Intuition lock desired (should be zero)
Result:			lockValue = value to use to unlock IntuitionBase via
			UnlockIBase( )
-------------------------
LockLayer
Description:		locks a layer to protect it from graphics output
Library:		layers.library
Offset:			-$0060 (-96)
Modula-2 Module:	Layers
Syntax:			LockLayer(dummy, layer)
C:			void LockLayer(struct Layer_Info *, struct Layer *)
Machine Language:	LockLayer(a0, a1)
Modula-2:		LockLayer(layer: LayerPtr)
Arguments:		dummy = unused
			layer = Layer structure
Result:			none
-------------------------
LockLayerInfo
Description:		locks a Layer_Info structure to keep other tasks from changing it
Library:		layers.library
Offset:			-$0078 (-120)
Modula-2 Module:	Layers
Syntax:			LockLayerInfo(layerInfo)
C:			void LockLayerInfo(struct Layer_Info *)
Machine Language:	LockLayerInfo(a0, a1)
Modula-2:		LockLayerInfo(layerInfo: LayerInfoPtr)
Arguments:		layerInfo = Layerlnfo structure to lock
Result:			none
-------------------------
LockLayerRom
Description:		locks a Layer structure to keep other tasks from changing it
Library:		layers.library
Offset:			-$01B0 (-432)
Modula-2 Module:	Clip
Syntax:			LockLayerRom(layer)
C:			void LockLayerRom(struct Layer *)
Machine Language:	LockLayerRom(a5)
Modula-2:      		LockLayerRom(layer: LayerPtr)
Arguments:		layer = Layer structure to lock
Result:			none
-------------------------
LockLayers
Description:		stops graphic output to all layers in a Layer_Info structure
Library:		layers.library
Offset:			-$006C (-108)
Modula-2 Module:	Layers
Syntax:			LockLayers(layerInfo)
C:		        void LockLayers(struct Layer_Info *)
Machine Language:	LockLayers(a0)
Modula-2:		LockLayers(layerInfo: LayerInfoPtr)
Arguments:		layerlnfo = Layerlnfo structure with list of layers to lock
Result:			none
-------------------------
MakeDosNode
Description:		initializes the DeviceNode structure required to enter a DOS disk
			device into the system
Library:		expansion.library
Offset:			-$0090 (-144)
Modula-2 Module:	Expansion
Syntax:			deviceNode = MakeDosNode(parameterPacket)
C:           		struct DeviceNode *MakeDosNode(long *)
Machine Language:	d0 = MakeDosNode(a0)
Modula-2:		MakeDosNode(parameterPacket: ADDRESS): DeviceNodePtr
Arguments:		parameterPacket = array of long words containing the DOS han-
			dler name, exec device name, unit number (for OpenDevice( )),
			flags (for OpenDevice( )), number of long words used to describe
			the handler environment, and the file handler environment, in
			that order.
Result:			deviceNode = pointer to initialized DeviceNode structure; NULL
			if not enough memory
-------------------------
MakeFunctions
Description:		constructs a jump table of the type used by resources, libraries,
			and devices
Library:		exec.library
Offset:			-$005A (-90)
Modula-2 Module:	Libraries
Syntax:			size = MakeFunctions(destination, funcArray, funcDispBase)
C:			void MakeFunctions(char *, long *, long)
Machine Language:	d0 = MakeFunctions(a0, a1, a2)
Modula-2:		MakeFunctions(destination, funcArray, funcDispBase: ADDRESS):
			LONGCARD
Arguments:		destination = target address for function jump table
			funcArray = pointer to array of function pointers or
			displacements
			funcDispBase = pointer to base about which all function displace-
			ments are relative; 0 if functionArray contains absolute pointers
Result:			size = size of new table in bytes (Modula-2 only)
-------------------------
MakeLibrary
Description:		constructs a library vector and data area
Library:		exec.library
Offset:			-$0054 (-84)
Modula-2 Module:	Libraries
Syntax:			library = MakeLibrary(vectors, structure, init, dataSize, segList)
C:			struct Library *MakeLibrary(long *, char *, _fptr, long, char *)
Machine Language:	d0 = MakeLibrary(a0, a1, a2, d0, d1)
Modula-2:		MakeLibrary(vectors, structure: ADDRESS; init: MAKELIBPROC;
			dataSize: LONGCARD; segList: ADDRESS): LibraryPtr
Arguments:		vectors = pointer to an array of function displacements-if first
			word is -1 array contains relative word displacements; otherwise
			array contains absolute function pointers
			structure = pointer to an InitStruct data region; can be NULL
			init = entry point that will be called before adding the library;
			can be NULL
			dataSize = size of library data area, including the standard library
			node data
			segList = pointer to a memory segment list (used by DOS)
Result:			library = reference address of library
-------------------------
MakeScreen
Description:		executes an Intuition-integrated MakeVPort( ) of a custom screen
Library:		intuition.library
Offset:			-$017A (-378)
Modula-2 Module:	Intuition
Syntax:			MakeScreen(screen)
C:			void MakeScreen(struct Screen *)
Machine Language:	MakeScreen(a0)
Modula-2:		MakeScreen(screen: ScreenPtr)
Arguments:		screen = custom screen
Result:			none
-------------------------
MakeVPort
Description:		constructs intermediate copper list for a ViewPort
Library:		graphics.library
Offset:			-$00D8 (-216)
Modula-2 Module:	Views
Syntax:			MakeVPort(view, viewPort)
C:			void MakeVPort(struct View *, struct ViewPort *)
Machine Language:	MakeVPort(a0, a1)
Modula-2:		MakeVPort(view: ViewPtr; viewPort: ViewPortPtr)
Arguments:		view = View structure
			viewPort = ViewPort structure
Result:			none
-------------------------
MarkCList
Description:		marks a position in a character list
Library:		clist.library
Offset:			-$0078 (-120)
Modula-2 Module:	none
Syntax:			error = MarkCList(cList, offset)
C:			long MarkCList(long, long)
Machine Language:	d0 = MarkCList(a0, a1)
Modula-2:		not available
Arguments:		cList = CList descriptor
			offset = byte offset into character list of position to mark
Result:			error = 0 if successful; nonzero if offset not in character list
-------------------------
MatchToolValue
Description:		checks a tool type variable for a particular value
Library:		icon.library
Offset:			-$0066 (-102)
Modula-2 Module:	Icon
Syntax:			result = MatchToolValue(typeString, value)
C:			long MatchToolValue(char *, char *)
Machine Language:	d0 = MatchToolValue(a0, a1)
Modula-2:		MatchToolValue(typeString, value: STRPTR): BOOLEAN
Arguments:		typeString = a ToolType value, as returned by FindToolType(
			value = value you are looking for
Result:			result = 0 if successful; nonzero if unsuccessful
------------------------- 
MENUNUM (macro)
Description:		extracts the menu number from a value
C Include File: 	include/intuition/intuition.h
ML Include File: 	none
Modula-2 Module:	Intuition
Syntax:			menuNumber = MENUNUM(menuValue)
C:			long MENUNUM(long)
Machine Language:	not available
Modula-2:		MENUNUM(menuValue: CARDINAL): CARDINAL
Arguments:		menuValue = 16-bit packed number representing the menu num-
			ber, item number, and subitem number
Result:			menuNumber = menu number (0-31); equals NOMENU if no
			menu was selected
-------------------------
ModifyIDCMP
Description:		modifies the state of a window's IDCMP
Library:		intuition.library
Offset:			-$0096 (-150)
Modula-2 Module:	Intuition
Syntax:			ModifyIDCMP(window, flags)
C:			void ModifyIDCMP(struct Window *, long)
Machine Language:	ModifyIDCMP(a0, d0)
Modula-2:		ModifyIDCMP(window: WindowPtr; flags: IDCMPFlagsSet)
Arguments:		window = window containing IDCMP
			flags = IDCMP flags
Result:			none
-------------------------
ModifyProp
Description:		modifies current state of proportional gadgets (see
			NewModifyProp)
Library:		intuition.library
Offset:			-$009C (-156)
Modula-2 Module:	Intuition
Syntax:			ModifyProp(propGadget, window, requester, flags, horizPot,
			vertPot, horizBody, vertBody)
C:			void ModifyProp(struct Gadget *, struct Window *, struct Request-
			er *, long, long, long, long, long)
Machine Language:	ModifyProp(a0, a1, a2, d0, d1, d2, d3, d4)
Modula-2:		ModifyProp(propGadget: GadgetPtr; window: WindowPtr; re-
			quester: RequesterPtr; flags: PropFlagSet; horizPot, vertPot,
			horizBody, vertBody: CARDINAL)
Arguments:		propGadget = proportional gadget to modify
			window = window containing proportional gadget
			requester = Requester structure; NULL if gadget is not part of a
			requester
			flags = new flags value
			horizPot = new horizontal pot value (position)
			vertPot = new vertical pot value (position)
			horizBody = new horizontal body value (size of slider)
			vertBody = new vertical body value (size of slider)
Result:			none
-------------------------
Move
Description:		moves the drawing pen to the specified position without drawing
			anything
Library:		layers.library
Offset:			-$00F0 (-240)
Modula-2 Module:	Drawing
Syntax:			Move(rastPort, x, y)
C:			void Move(struct RastPort *, long, long)
Machine Language:	Move(a0, d0, d1)
Modula-2:		Move(rastPort: RastPortPtr; x, y: INTEGER)
Arguments:		rastPort = RastPort structure
			x = new horizontal coordinate
			y = new vertical coordinate
Result:			none
-------------------------
MoveLayer
Description:		moves a nonbackdrop layer to a new position in the bitmap
Library:		layers.library
Offset:			-$003C (-60)
Modula-2 Module:	Layers
Syntax:			success = MoveLayer(dummy, layer, dx, dy)
C:			long MoveLayer(struct Layerlnfo *, struct Layer *, long, long)
Machine Language:	d0 = MoveLayer(a0, a1, d0, d1)
Modula-2:		MoveLayer(layer: LayerPtr; dx, dy: LONGINT): BOOLEAN
Arguments:		dummy = unused
			layer = nonbackdrop Layer structure
			dx = offset by which to move layer horizontally
			dy = offset by which to move layer vertically
Result:			success = TRUE is successful; FALSE if unsuccessful
-------------------------
MoveLayerInFrontOf
Description:		moves a layer in front of another layer
Library:		layers.library
Offset:			-$00A8 (-168)
Modula-2 Module:	Layers
Syntax:			success = MoveLayerInFrontOf(layer, target)
C:			long MoveLayerInFrontOf(struct Layer *, struct Layer *)
Machine Language:	d0 = MoveLayerInFrontOf(d0, a1)
Modula-2:		MoveLayerInFrontOf(layer, target: LayerPtr): BOOLEAN
Arguments:		layer = layer to move
			target = layer to have another layer placed on top of
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
MoveScreen
Description:		moves a screen vertically
Library:		intuition.library
Offset:			-$00A2 (-162)
Modula-2 Module:	Intuition
Syntax:			MoveScreen(screen, dx, dy)
C:			void MoveScreen(struct Screen *, long, long)
Machine Language:	MoveScreen(a0, d0, a1)
Modula-2:		MoveScreen(screen: ScreenPtr; dx, dy: INTEGER)
Arguments:		screen = screen to move
			dx = offset by which to move screen horizontally
			dy = offset by which to move screen vertically (not implemented
			as of system version 1.3)
Result:			none
-------------------------
MoveSprite
Description:		moves a sprite to specified location
Library:		graphics.library
Offset:			-$01AA (-426)
Modula-2 Module:	Sprites
Syntax:			MoveSprite(viewPort, sprite, x, y)
C:			long MoveSprite(struct ViewPort *, struct SimpleSprite *, long,
			long)
Machine Language:	MoveSprite(a0, a1, d0, d1)
Modula-2:		MoveSprite(viewPort: ViewPortPtr; sprite: SimpleSpritePtr; x, y:
			INTEGER)
Arguments:		viewPort = ViewPort structure
			sprite = SimpleSprite structure
			x = new horizontal position of sprite
			y = new vertical position of sprite
Result:			none
-------------------------
MoveWindow
Description:		moves a window
Library:		intuition.library
Offset:			-$00A8 (-168)
Modula-2 Module:	Intuition
Syntax:			MoveWindow(window, dx, dy)
C:			void MoveWindow(struct Window *, long, long)
Machine Language:	MoveWindow(a0, d0, a1)
Modula-2:		MoveWindow(window: WindowPtr; dx, dy: INTEGER)
Arguments:		window = window to move
			dx = offset by which to move window horizontally
			dy = offset by which to move window vertically
Result:			none
-------------------------
MrgCop
Description:		merges coprocessor instructions to form one instruction list
Library:		graphics.library
Offset:			-$00D2 (-210)
Modula-2 Module:	Views
Syntax:			MrgCop(view)
C:			void MrgCop(struct View *)
Machine Language:	MrgCop(a1)
Modula-2:		MrgCop(view: ViewPtr)
Arguments:		view = View structure
Result:			none
-------------------------
NewFontContents
Description:		creates an array of FontContents entries describing all fonts asso-
			ciated with specified font name
Library:		diskfont.library
Offset:			-$002A (-42)
Modula-2 Module:	none
Syntax:			fontContentsHeader = NewFontContents(fontsLock, fontName)
C:			struct FontContentsHeader *NewFontContents(BPTR, char *)
Machine Language:	d0 = NewFontContents(a0, a1)
Modula-2:		not available
Arguments:		fontsLock = BCPL pointer to a lock on the directory containing
			the fonts contents file (usually FONTS: directory)
			fontName = filename of font contents file (for example,
			"Diamond.font")
Result:			fontContentsHeader = pointer to a FontContentsHeader
-------------------------
NewLayerInfo
Description:		creates a Layer_Info structure
Library:		layers.library
Offset:			-$0090 (-144)
Modula-2 Module:	Layers
Syntax:			layerInfo = NewLayerInfo( )
C:			struct Layer_Info *NewLayerInfo(void)
Machine Language:	d0 = NewLayerInfo( )
Modula-2:		NewLayerInfo( ): LayerInfoPtr
Arguments:		none
Result:			layerInfo = pointer to initialized Layer_Info structure; NULL if
			unsuccessful
-------------------------
NewList
Description:		initializes a list header
Library:		amiga.lib (linked library)
ML Include File:	none
Modula-2 Module:	Lists
Syntax:			NewList(list)
C:			void NewList(struct List *)
Machine Language:	not available
Modula-2:		NewList(VAR list: List)
Arguments:		list = List structure
Result:			none
-------------------------
NewModifyProp
Description:		modifies current state of proportional gadgets, with selective gad-
			get refresh
Library:		intuition.library
Offset:			-$01D4 (-468)
Modula-2 Module:	Intuition
Syntax:			NewModifyProp(propGadget, window, requester, flags, horizPot, 
			vertPot, horizBody, vertBody, gadgetNumber)
C:		        void NewModifyProp(struct Gadget *, struct Window *, struct Re-
			quester *, long, long, long, long, long, long)
Machine Language:	NewModifyProp(a0, a1, a2, d0, d1, d2, d3, d4, d5)
Modula-2:		NewModifyProp(propGadget: GadgetPtr; window: WindowPtr; re-
			quester: RequesterPtr; flags: PropFlagSet; horizPot, vertPot,
			horizBody, vertBody: CARDINAL; gadgetNumber: INTEGER)
Arguments:		propGadget = proportional gadget to modify
			window = window containing proportional gadget
			requester = Requester structure; NULL if gadget is not part of a
			requester
			flags = new flags value
			horizPot = new horizontal pot value (position)
			vertPot = new vertical pot value (position)
			horizBody = new horizontal body value (size of slider)
			vertBody = new vertical body value (size of slider)
			gadgetNumber = number of gadgets to refresh after gadget modi-
			fication; -1 to refresh all gadgets to the end of gadget list
Result:			none
-------------------------
NewRegion
Description:		creates an empty Region structure
Library:		graphics.library
Offset:			-$0204 (-516)
Modula-2 Module:	Regions
Syntax:			region = NewRegion( )
C:		        struct Region *NewRegion(void)
Modula-2:		NewRegion(VAR list: List)
			NewRegion( ): RegionPrt
Arguments:		none
Result:			region = pointer to initialized Region structure; NULL if not
			enough memory
-------------------------
ObtainConfigBinding 
Description:		attempts to get permission to bind drivers 
Library:		expansion.library 
Offset:			-$0078 (-120) 
Modula-2 Module:	none
Syntax:			ObtainConfigBinding( )
C:			void ObtainConfigBinding(void)
Machine Language:	ObtainConfigBinding( )
Modula-2:		not available
Arguments:		none
Result:			none
------------------------
ObtainSemaphore
Description:		obtains exclusive use of a signal semaphore
Library:		exec.library
Offset:			-$0234 (-564)
Modula-2 Module:	Semaphores
Syntax:			ObtainSemaphore(signalSemaphore)
C:			void ObtainSemaphore(struct SignalSemaphore *)
Machine Language:	ObtainSemaphore(a0)
Modula-2:      		ObtainSemaphore(signalSemaphore: SignalSemaphorePtr)
Arguments:		signalSemaphore = initialized SignalSemaphore structure
Result:			none
-------------------------
ObtainSemaphoreList
Description:		obtains exclusive use of a list of signal semaphores
Library:		exec.library
Offset:			-$0246 (-582)
Modula-2 Module:	Semaphores
Syntax:			ObtainSemaphoreList(list)
C:			void ObtainSemaphoreList(struct List *)
Machine Language:	ObtainSemaphoreList(a0)
Modula-2:		ObtainSemaphoreList(list: SignalSemaphorePtr)
Arguments:		list = List structure representing a list of signal semaphores
Result:			none
-------------------------
OFFDISPLAY (macro)
Description:		clears the display DMA bit in the DMA control register
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module:	CustomHardware
Syntax:			OFF_DISPLAY( )
C:			void OFF_DISPLAY(void)
Machine Language:	not available
Modula-2:		OFFDISPLAY( )
Arguments:		none
Result:			none
-------------------------
OffGadget
Description:		disables a gadget
Library:		intuition.library
Offset:			-$00AE (-174)
Modula-2 Module:	Intuition
Syntax:			OffGadget(gadget, window, requester)
C:			void OffGadget(struct Gadget , struct Window *, struct Requester *)
Machine Language:	OffGadget(a0, a1, a2)
Modula-2:		OffGadget(gadget: GadgetPtr; window: WindowPtr; requester:
			RequesterPtr)
Arguments:		gadget = gadget to disable
			window = window containing gadget
			requester = Requester structure; NULL if gadget is not part of a
			requester
Result:			none
-------------------------
OffMenu
Description:		disables a menu or menu item
Library:		intuition.library
Offset:			-$00B4 (-180)
Modula-2 Module:	Intuition
Syntax:			OffMenu(window, menuNumber)
C:			void OffMenu(struct Window *, long)
Machine Language:	OffMenu(a0, d0)
Modula-2:		OffMenu(window: WindowPtr; menuNumber: CARDINAL)
Arguments:		window = window containing menu or menu item
			menuNumber = number specifying menu or menu item to dis-
			able-bits 0-4 specify menu number, bits 5-10 specify menu
			item, and bits 11-15 specify menu subitems
Result:			none
-------------------------
OFF_SPRITE (macro)
Description:		clears the sprite DMA bit in the DMA control register
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module:	CustomHardware
Syntax:			OFF_SPRITE( )
C:			void OFF_SPRITE(void)
Machine Language:	not available
Modula-2:		OFFSPRITE( )
Arguments:		none
Result:			none
-------------------------
OFF_VBLANK (macro) 
Description:		clears the vertical blanking interrupt (bit 5) in the interrupt control 
			register 
C Include File: 	include/graphics/gfxmacros.h 
ML Include File: 	none 
Modula-2 Module:	none 
Syntax:			OFF_VBLANK( ) 
C:			void OFF_VBLANK(void) 
Machine Language:	not available
Modula-2:		not available
Arguments:		none
Result:			none
-------------------------
OldOpenLibrary
Description:		obsolete version of the OpenLibrary( ) function which gains access
			to a library without requiring a version number; do not use this
			function-use OpenLibrary( ) instead
Library:		exec.library
Offset:			-$0198 (-408)
Modula-2 Module:	none
Syntax:			library = Old0penLibrary(name)
C:			struct Library *Old0penLibrary(char *)
Machine Language:	d0 = Old0penLibrary(a1)
Modula-2:		not available
Arguments:		name = name of desired library
Result:			library = base pointer to desired library; NULL if library cannot
			be found
-------------------------
ON_DISPLAY (macro)
Description:		sets the display DMA bit in the DMA control register
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module:	CustomHardware
Syntax:			ON_DISPLAY( )
C:			void ON_DISPLAY(void)
Machine Language:	not available
Modula-2:		ONDISPLAY( )
Arguments:		none
Result:			none
-------------------------
OnGadget
Description:		enables a gadget
Library:		intuition.library
Offset:			-$00BA (-186)
Modula-2 Module:	Intuition
Syntax:			OnGadget(gadget, window, requester)
C:			void OnGadget(struct Gadget *, struct Window *, struct Requester *)
Machine Language:	OnGadget(a0, a1, a2)
Modula-2:		OnGadget(gadget: GadgetPtr; window: WindowPtr; requester:
			RequesterPtr)
Arguments:		gadget = gadget to enable
			window = window containing gadget
requester = Requester structure; NULL if gadget is not part of a
			requester
Result:			none
-------------------------
OnMenu
Description:		enables a menu or menu item
Library:		intuition.library
Offset:			-$00C0 (-192)
Modula-2 Module:	Intuition
Syntax:			OnMenu(window, menuNumber)
C:			void OnMenu(struct Window *, long)
Machine Language:	OnMenu(a0, d0)
Modula-2:		OnMenu(window: WindowPtr; menuNumber: CARDINAL)
Arguments:		window = window containing menu or menu item
			menuNumber = number specifying menu or menu item to en-
			able-bits 0-4 specify menu number, bits 5-10 specify menu
			item, and bits 11-15 specify menu subitems
Result:			none	
-------------------------  
ON_SPRITE (macro)
Description:		sets the sprite DMA bit in the DMA control register
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module:	CustomHardware
Syntax:			ON_SPRITE( )
C:			void ON_SPRITE(void)
Machine Language:	ON_SPRITE( )
Modula-2:		ONSPRITE( )
Arguments:		none
Result:			none
-------------------------
ON_VBLANK (macro) 
Description:		sets the vertical blanking interrupt (bit 5) in the interrupt control 
			register 
C Include File: 	include/graphics/gfxmacros.h 
ML Include File: 	none 
Modula-2 Module:	none 
Syntax:			ON_VBLANK( ) 
C:			void ON_VBLANK(void) 
Machine Language:	ON_VBLANK( )
Modula-2:		not available
Arguments:		none
Result:			none
-------------------------
Open
Description:		opens a file for input or output
Library:		dos.library
Offset:			-$001E (-30)
Modula-2 Module:	DOS
Syntax:			file = Open(name, accessMode)
C:			BPTR Open(char *, long)
Machine Language:	d0 = Open(d1, d2)
Modula-2:		Open(name: STRPTR; accessMode: LONGINT): FileHandle
Arguments:		name = NULL terminated string specifying filename
			accessMode = type of file access desired-MODE_OLDFILE for
			reading, MODE_NEWFILE for writing
Result:			file = BCPL pointer to file handle; NULL if unsuccessful
-------------------------
OpenDevice
Description:		provides access to a device and initializes an IO request block for
			access to the device
Library:		exec.library
Offset:			-$01BC (-444)
Modula-2 Module:	Devices
Syntax:			error = OpenDevice(name, unitNumber, ioRequest, flags)
C:			long OpenDevice(char *, long, struct IORequest *, long)
Machine Language:	d0 = OpenDevice(a0, d0, a1, d2)
Modula-2:		OpenDevice(name: STRPTR; unitNumber: LONGCARD;
			ioRequest: ADDRESS; flags: LONGBITSET): INTEGER
Arguments:		name = NULL terminated string specifying device name
			unitNumber = desired unit number for device (device specific)
			ioRequest = IORequest block to initialize
			flags = additional device information (device specific)
Result:			error = 0 if successful; nonzero if unsuccessful
-------------------------
OpenDiskFont
Description:		gains access to a disk-resident font
Library:		diskfont.library
Offset:			-$001E (-30)
Modula-2 Module:	DiskFont
Syntax:			font = OpenDiskFont(textAttr)
C:			struct TextFont *OpenDiskFont(struct TextAttr *)
Machine Language:	d0 = OpenDiskFont(a0)
Modula-2:		OpenDiskFont(textAttr: TextAttrPtr): TextFontPtr
Arguments:		textAttr = TextAttr structure that describes the desired font
Result:			font = pointer to desired TextFont structure; 0 if unsuccessful
-------------------------
OpenFont
Description:		gains access to a memory-resident font
Library:		graphics.library
Offset:			-$0048 (-72)
Modula-2 Module:	Text
Syntax:			font = OpenFont(textAttr)
C:			struct TextFont *OpenFont(struct TextAttr *)
Machine Language:	d0 = OpenFont(a0)
Modula-2:		OpenFont(textAttr: TextAttrPtr): TextFontPtr
Arguments:		textAttr = TextAttr structure that describes the desired font
Result:			font = pointer to desired TextFont structure; 0 if unsuccessful
------------------------- 
OpenLibrary
Description:		gains access to a library
Library:		exec.library
Offset:			-$0228 (-552)
Modula-2 Module:	Libraries
Syntax:			library = OpenLibrary(name, version)
C:			struct Library *OpenLibrary(char *, long)
Machine Language:	d0 = OpenLibrary(a1, d0)
Modula-2:		OpenLibrary(name: STRPTR; version: LONGCARD): LibraryPtr
Arguments:		name = name of desired library
			version = lowest acceptable library version number; 0 if you
			don't care
Result:			library = base pointer to desired library; NULL if library cannot
			be found
-------------------------
OpenResource
Description:		gains access to a resource
Library:		exec.library
Offset:			-$01F2 (-498)
Modula-2 Module:	Resources
Syntax:			resource = OpenResource(name)
C:			struct Resource *OpenResource(char *)
Machine Language:	d0 = OpenResource(a1)
Modula-2:		OpenResource(name: STRPTR): ResourcePtr
Arguments:		name = name of desired resource
Result:			resource = pointer to resource; NULL if unsuccessful
-------------------------
OpenScreen
Description:		opens an Intuition screen
Library:		intuition.library
Offset:			-$00C6 (-198)
Modula-2 Module:	Intuition
Syntax:			screen = OpenScreen(newScreen)
C:			struct Screen *OpenScreen(struct NewScreen *)
Machine Language:	d0 = OpenScreen(a0)
Modula-2:		OpenScreen(newScreen: NewScreenPtr): ScreenPtr
Arguments:		newScreen = NewScreen structure that describes screen to open
Result:			screen = pointer to Screen structure; NULL if unsuccessful
------------------------- 
OpenWindow
Description:		opens an Intuition window
Library:		intuition.library
Offset:			-$00CC (-204)
Modula-2 Module:	Intuition
Syntax:			window = OpenWindow(newWindow)
C:			struct Window *OpenWindow(struct NewWindow *)
Machine Language:	d0 = OpenWindow(a0)
Modula-2:		OpenWindow(newWindow: NewWindowPtr): WindowPtr
Arguments:		newWindow = NewWindow structure that describes window to
			open
Result:			window = pointer to Window structure; NULL if unsuccessful
-------------------------
OpenWorkBench
Description:		opens the Workbench screen
Library:		intuition.library
Offset:			-$00D2 (-210)
Modula-2 Module:	Intuition
Syntax:			success = OpenWorkBench( )
C:			long OpenWorkBench(void)
Machine Language:	d0 = OpenWorkBench( )
Modula-2:		OpenWorkBench( ): BOOLEAN
Arguments:		none
Result:			success = TRUE if successful (value represents pointer to Work-
			Bench screen-this may change in system versions greater than
			1.3); FALSE (NULL) if unsuccessful
-------------------------
OrRectRegion
Description:		performs a two-dimensional OR operation of a rectangle with a
			region, leaving the result in the region
Library:		graphics.library
Offset:			-$01FE (-510)
Modula-2 Module:	Regions
Syntax:			success = OrRectRegion(region, rectangle)
C:			long OrRectRegion(struct Region *, struct Rectangle *)
Machine Language:	d0 = OrRectRegion(a0, a1)
Modula-2:		OrRectRegion(region: RegionPtr; rectangle: RectanglePtr):
			BOOLEAN
Arguments:		region = Region structure
			rectangle = Rectangle structure
Result:			success = TRUE if successful; FALSE if unsuccessful
------------------------- 
OrRegionRegion
Description:		performs a two-dimensional OR operation of one region with a
			second region, leaving the result in second region
Library:		graphics.library
Offset:			-$0264 (-612)
Modula-2 Module:	Regions
Syntax:			success = OrRegionRegion(region1, region2)
C:			long OrRegionRegion(struct Region *, struct Region *)
Machine Language:	d0 = OrRegionRegion(a0, a1)
Modula-2:		OrRegionRegion(region1, region2: RegionPtr): BOOLEAN
Arguments:		region1 = Region structure
			region2 = Region structure
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
Output
Description:		gets the initial output file handle assigned to a program
Library:		dos.library
Offset:			-$003C (-60)
Modula-2 Module:	DOS
Syntax:			file = Output( )
C:			BPTR Output(void)
Machine Language:	d0 = Output( )
Modula-2:		Output( ): FileHandle
Arguments:		none
Result:			file = BCPL pointer to a file handle
-------------------------
OwnBlitter
Description:		reserves the blitter for private use
Library:		graphics.library
Offset:			-$01C8 (-456)
Modula-2 Module:	Blitter
Syntax:			OwnBlitter( )
C:			void OwnBlitter(void)
Machine Language:	OwnBlitter( )
Modula-2:		OwnBlitter( )
Arguments:		none
Result:			none
------------------------- 
ParentDir
Description:		obtains the parent directory of a file or directory
Library:		dos.library
Offset:			-$00D2 (-210)
Modula-2 Module:	DOS
Syntax:			lock = ParentDir(lock)
C:			BPTR ParentDir(BPTR)
Machine Language:	d0 = ParentDir(d1)
Modula-2:		ParentDir(lock: FileLock): FileLock
Arguments:		lock = BCPL pointer to lock associated with child file or directory
Result:			lock = BCPL pointer to lock associated with parent directory
-------------------------
PeekCLMark
Description:		gets byte located in mark position of a character list
Library:		clist.library
Offset:			-$0084 (-132)
Modula-2 Module:	none
Syntax:			byte = PeekCLMark(cList)
C:			long PeekCLMark(long)
Machine Language:	d0 = PeekCLMark(a0)
Modula-2:		not available
Arguments:		cList = character list descriptor
Result:			byte = byte located in mark position of character list
-------------------------
Permit
Description:		permits task rescheduling halted by Forbid( )
Library:		exec.library
Offset:			-$008A (-138)
Modula-2 Module:	Interrupts
Syntax:			Permit( )
C:			void Permit(void)
Machine Language:	Permit( )
Modula-2:		Permit( )
Arguments:		none
Result:			none
-------------------------
PolyDraw
Description:		draws a series of connected lines from current pen position to
			points specified by a table of (x,y) coordinates
Library:		graphics.library
Offset:			-$0150 (-336)
Modula-2 Module:	Pens
Syntax:			PolyDraw(rastPort, count, array)
C:			long PolyDraw(struct RastPort *, long, short *)
Machine Language:	PolyDraw(al, d0, a0)
Modula-2:		PolyDraw(rastPort: RastPortPtr; count: INTEGER; array:
			ADDRESS)
Arguments:		rastPort = RastPort to draw lines in
			count = number of coordinates in array
			array = pointer to array of coordinates
Result:			none
-------------------------
printf
Description:		prints a formatted string to the standard output (Lattice and Manx
			users: if you link with lc.lib or c.lib, this is not the function you're
			calling)
Library:		amiga.lib (linked library)
Modula-2 Module:	none
Syntax:			printf(string, values...)
C:			void printf(char *, long...)
Machine Language:	move.l #value,-(sp) ;may have several values 
			pea string 
			jsr _printf 
			add.l #8,sp ;(2 arguments * 4 bytes = 8)
Modula-2:		not available
Arguments:		string = string containing optional C formatting commands (%); if
			you're passing longword values on the stack (as shown above) be
			sure to follow the percent symbol with a lowercase L
			values = values or addresses of strings to print; this routine
			knows how many values are on the stack by checking the number
			of formatting commands in the string argument
Result:			none
-------------------------
PrintIText
Description:		prints text according to its IntuiText specifications
Library:		intuition.library
Offset:			-$00D8 (-216)
Modula-2 Module:	Intuition
Syntax:			PrintIText(rastPort, intuiText, leftEdge, topEdge)
C:		        void PrintIText(struct RastPort *, struct IntuiText *, long, long)
Machine Language:	PrintIText(a0, a1, d0, d1)
Modula-2:		PrintIText(rastPort: RastPortPtr; intuiText: IntuiTextPtr; leftEdge,
			topEdge: INTEGER)
Arguments:		rastPort = RastPort structure to receive text
			intuiText = IntuiText structure containing text
			leftEdge = horizontal position of text within RastPort
			topEdge = vertical position of text within RastPort
Result:			none
-------------------------
Procure
Description:		obtains a message-based semaphore
Library:		exec.library
Offset:			-$021C (-540)
Modula-2 Module:	Semaphores
Syntax:			success = Procure(semaphore, message)
C:		        long Procure(struct Semaphore *, struct Message *)
Machine Language:	d0 = Procure(a0, a1)
Modula-2:		Procure(semaphore: SemaphorePtr; message: MessagePtr):
 			BOOLEAN
Arguments:		semaphore = Semaphore structure
			message = Message structure to be used if desired semaphore is
			unavailable
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
PutCLBuf
Description:		converts contiguous data into a character list
Library:		clist.library
Offset:			-$006C (-108)
Modula-2 Module:	none
Syntax:			error = PutCLBuf(cList, buffer, length)
C:		        long PutCLBuf(long, char *, long)
Machine Language:	d0 = PutCLBuf(a0, a1, d1)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
			buffer = buffer containing data to be converted
			length = size of buffer in bytes
Result:			error = 0 if successful; nonzero if unsuccessful
-------------------------
PutCLChar
Description:		adds a byte to the end of a character list
Library:		clist.library
Offset:			-$003C (-60)
Modula-2 Module:	none
Syntax:			error = PutCLChar(cList, byte)
C:			long PutCLChar(long, long)
Machine Language:	d0 = PutCLChar(a0, d0)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
			byte = byte to be added to end of character list
Result:			error = 0 if successful; nonzero if unsuccessful
-------------------------
PutCLWord
Description:		adds a word to the end of a character list
Library:		clist.library
Offset:			-$0054 (-84)
Modula-2 Module:	none
Syntax:			error = PutCLWord(cList, word)
C:			long PutCLWord(long)
Machine Language:	d0 = PutCLWord(a0, d0)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
			word = word to be added to end of character list
Result:			error = 0 if successful; nonzero if unsuccessful
-------------------------
PutDiskObject
Description:		writes a Workbench DiskObject to disk as an .info file
Library:		icon.library
Offset:			-$0054 (-84)
Modula-2 Module:	Icon
Syntax:			success = PutDiskObject(name, diskObj)
C:			long PutDiskObject(char *, struct DiskObject *)
Machine Language:	d0 = PutDiskObject(a0, a1)
Modula-2:		PutDiskObject(name: STRPTR; diskObj: DiskObjectPtr): BOOLEAN
Arguments:		name = name of object
			diskObj = DiskObject structure (.info file)
Result:			success = nonzero if successful
-------------------------
PutIcon
Description:		writes a DiskObject to disk as an .info file
Library:		icon.library
Offset:			-$0030 (-48)
Modula-2 Module:	none
Syntax:			success = PutIcon(name, icon)
C:           long PutIcon(char *, struct DiskObject *)
Machine Language:	d0 = PutIcon(a0, a1)
Modula-2:		not available
Arguments:		name = name of icon (.info file)
			icon = DiskObject structure
Result:			success = nonzero if successful
-------------------------
PutMsg
Description:		gets next message from a message port
Library:		exec.library
Offset:			-$016E (-366)
Modula-2 Module:	Ports
Syntax:			PutMsg(port, message)
C:		        void PutMsg(struct MsgPort *, struct Message *)
Machine Language:	PutMsg(a0, a1)
Modula-2:		PutMsg(port: MsgPortPtr; message: ADDRESS)
Arguments:		port = message port to receive message
			message = Message structure containing message to send
Result:			none
-------------------------
PutWBObject
Description:		writes a WBObject to disk as an .info file
Library:		icon.library
Offset:			-$0024 (-36)
Modula-2 Module:	none
Syntax:			success = PutWBObject(name, object)
C:			long PutWBObject(char *, struct WBObject *)
Machine Language:	d0 = PutWBObject(a0, a1)
Modula-2:		not available
Arguments:		name = name of WBObject (.info file)
			object = WBObject structure
Result:			success = nonzero if successful
------------------------- 
QBlit
Description:		queues up a blitter request
Library:		graphics.library
Offset:			-$0114 (-276)
Modula-2 Module:	Blitter
Syntax:			QBlit(blitNode)
C:			void QBlit(struct BlitNode *)
Machine Language:	QBlit(a1)
Modula-2:		QBlit(blitNode: bltnodePtr)
Arguments:		blitNode = BlitNode structure containing link information and
			address of your blitter routine
Result:			none
-------------------------
QBSlit
Description:		queues and synchronizes a blitter request with the video beam
Library:		graphics.library
Offset:			-$0126 (-294)
Modula-2 Module:	Blitter
Syntax:			QBSlit(blitNode)
C:			void QBSlit(struct BlitNode *)
Machine Language:	QBSlit(a1)
Modula-2:		QBSlit(blitNode: bltnodePtr)
Arguments:		blitNode = BlitNode structure containing link information and
			address of your blitter routine
Result:			none
-------------------------
RangeRand
Description:		generates a random integer within a specified range
Library:		amiga.lib (linked library)
Modula-2 Module:	none
Syntax:			rnd = RangeRand(range)
C:			long RangeRand(long)
Machine Language:	move.l range,-(sp)
			jsr _RangRand ;rnd returned in d0
			addq.l #4,sp
Modula-2:		not available
Arguments:		range = highest integer acceptable
Result:			rnd = random number between 0 and value of range argument
-------------------------
RASSIZE (macro)
Description:		calculates the memory requirements for a raster bitmap of the
			specified with and height
C Include File:		include/graphics/gfx.h
ML Include File:	none
Modula-2 Module:	Graphics
Syntax:			bytes = RASSIZE(width, height)
C:			long RASSIZE(long, long)
Machine Language:	not available
Modula-2:		RASSIZE(width, height: LONGCARD)
Arguments:		width = width of hypothetical bitmap in pixels
			height = height of hypothetical bitmap in pixels
Result:			bytes = number of bytes required to contain raster bitmap
-------------------------
RawDoFmt
Description:		formats data into a character stream using C formatting
			commands (%)
Library:		exec.library
Offset:			-$020A (-522)
Modula-2 Module:	Exec
Syntax:			RawDoFmt(formatString, dataStream, putChProc, putChData)
C:			void RawDoFmt(char *, APTR, void (*)(), APTR)
Machine Language:	RawDoFmt(a0, a1, a2, a3)
Modula-2:		RawDoFmt(formatString, dataStream: ADDRESS; putChProc:
			PROC; putChData: ADDRESS)
Arguments:		formatString = string with optional C formatting commands (%)
			dataStream = stream of data that is interpreted according to the
			formatString
			putChProc = address of procedure to call with each character to
			be output, where procedure is called as PutChProc(char,
			putChData)
			putChData = value to pass to PutChProc
Result:			none
-------------------------
Read
Description:		reads data from a file
Library:		dos.library
Offset:			-$002A (-42)
Modula-2 Module:	DOS
Syntax:			actualLength = Read(file, buffer, length)
C:			long Read(BPTR, char *, long)
Machine Language:	d0 = Read(d1, d2, d3)
Modula-2:		Read(file: FileHandle; buffer: ADDRESS; length: LONGINT):
			LONGINT
Arguments:		file = BCPL pointer to a file handle
			buffer = address of memory block to receive data
			length = number of bytes to read (must not exceed buffer size)
Result:			actualLength = actual number of bytes received
-------------------------
ReadExpansionByte
Description:		reads a byte nybble-by-nybble from a new-style expansion board
Library:		expansion.library
Offset:			-$0060 (-96)
Modula-2 Module:	Expansion
Syntax:			byte = ReadExpansionByte(board, offset)
C:			long ReadExpansionByte(long, long)
Machine Language:	d0 = ReadExpansionByte(a0, d0)
Modula-2:		ReadExpansionByte(board: ADDRESS; offset: LONGCARD):
			INTEGER	
Arguments:		board = base address of expansion board
			offset = logical offset from board base
Result:			byte = data received; -1 if an error occurred
-------------------------
ReadExpansionRom
Description:		reads a new-style expansion board's configuration ROM space
Library:		expansion.library
Offset:			-$0066 (-102)
Modula-2 Module:	Expansion
Syntax:			error = ReadExpansionRom(board, configDev)
C:			long ReadExpansionRom(long, long)
Machine Language:	d0 = ReadExpansionRom(a0, a1)
Modula-2:		ReadExpansionRom(board: ADDRESS; configDev: ADDRESS):
			BOOLEAN
Arguments:		board = base address of expansion board
			configDev = ConfigDev structure to receive ROM data
Result:			error = 0 if successful; nonzero if an error occurred
-------------------------
ReadPixel
Description:		finds the color register (pen) used to color a specific pixel
Library:		graphics.library
Offset:			-$013E (-318)
Modula-2 Module:	Pens
Syntax:			pen = ReadPixel(rastPort, x, y)
C:			long ReadPixel(struct RastPort *, long, long)
Machine Language:	d0 = ReadPixel(a0, d0, d1)
Modula-2:		ReadPixel(rastPort: RastPortPtr; x, y: INTEGER): INTEGER
Arguments:		rastPort = RastPort structure
			x = horizontal coordinate of pixel
			y = vertical coordinate of pixel
Result:			pen = pen number; -1 if pixel lies outside boundaries of rastport
-------------------------
RectFill
Description:		fills a rectangular area using the current pen color, outline color,
			secondary color, and pattern
Library:		graphics.library
Offset:			-$0132 (-306)
Modula-2 Module:	Pens
Syntax:			RectFill(rastPort, xmin, ymin, xmax, ymax)
C:			void RectFill(struct RastPort *, long, long, long, long)
Machine Language:	RectFill(a0, d0, d1, d2, d3)
Modula-2:		RectFill(rastPortPtr: RastPort; xmin, ymin, xmax, ymax: INTEGER)
Arguments:		rastPort = RastPort structure
			xmin = horizontal coordinate rectangle's upper left corner
			ymin = vertical coordinate rectangle's upper left corner
			xmax = horizontal coordinate rectangle's lower right corner
			ymax = vertical coordinate rectangle's lower right corner
Result:			none
-------------------------
RefreshGadgets
Description:		redraws a gadget and all following gadgets in gadget list
Library:		intuition.library
Offset:			-$00DE (-222)
Modula-2 Module:	Intuition
Syntax:			RefreshGadgets(gadgets, window, requester)
C:			void RefreshGadgets(struct Gadget *, struct Window *, struct Re-
			quester *)

Machine Language:	RefreshGadgets(a0, a1, a2)
Modula-2:		RefreshGadgets(gadgets: GadgetPtr; window: WindowPtr; request-
			er: RequesterPtr)
Arguments:		gadgets = first gadget in list of gadgets to refresh
			window = window containing gadgets
			requester = requester containing gadget; NULL if gadget is not
			part of a requester
Result:			none
-------------------------
RefreshGList
Description:		redraws a gadget and specified number of following gadgets in
			gadget list
Library:		intuition.library
Offset:			-$01BO (-432)
Modula-2 Module:	Intuition
Syntax:			RefreshGList(gadgets, window, requester, numGadgets)
C:			void RefreshGList(struct Gadget *, struct Window *, struct Re-
			quester *, long)
Machine Language:	RefreshGList(a0, a1, a2, d0)
Modula-2:		RefreshGList(gadgets: GadgetPtr; window: WindowPtr; requester:
			RequesterPtr; numGadgets: INTEGER)
Arguments:		gadgets = first gadget in list of gadgets to refresh
			window = window containing gadgets
			requester = requester containing gadget; NULL if gadget is not
			part of a requester
			numGadgets = number of gadgets to refresh; -1 to refresh to
			end of gadget list
Result:			none
-------------------------
RefreshWindowFrame
Description:		redraws a window's border, title bar, and gadgets
Library:		intuition.library
Offset:			-$01C8 (-456)
Modula-2 Module:	Intuition
Syntax:			RefreshWindowFrame(window)
C:			void RefreshWindowFrame(struct Window *)
Machine Language:	RefreshWindowFrame(a0)
Modula-2:		RefreshWindowFrame(window: WindowPtr)
Arguments:		window = window to refresh
Result:			none
------------------------- 
ReleaseConfigBinding
Description:		allows others to bind drivers
Library:		expansion.library
Offset:			-$007E (-126)
Modula-2 Module:	none
Syntax:			ReleaseConfigBinding( )
C:			void ReleaseConfigBinding(void)
Machine Language:	ReleaseConfigBinding( )
Modula-2:		not available
Arguments:		none
Result:			none
-------------------------
ReleaseSemaphore
Description:		releases a signal semaphore for use by other tasks
Library:		exec.library
Offset:			-$023A (-5 70)
Modula-2 Module:	Semaphores
Syntax:			ReleaseSemaphore(signalSemaphore)
C:			void ReleaseSemaphore(struct SignalSemaphore *)
Machine Language:	ReleaseSemaphore(a0)
Modula-2:		ReleaseSemaphore(signalSemaphore: SignalSemaphorePtr)
Arguments:		signalSemaphore = initialized SignalSemaphore structure
Result:			none
-------------------------
ReleaseSemaphoreList
Description:		releases a list of signal semaphores for other tasks
Library:		exec.library
Offset:			-$024C (-588)
Modula-2 Module:	Semaphores
Syntax:			ReleaseSemaphoreList(list)
C:			void ReleaseSemaphoreList(struct List *)
Machine Language:	ReleaseSemaphoreList(a0)
Modula-2:		ReleaseSemaphoreList(list: SignalSemaphorePtr)
Arguments:		list = List structure representing a list of signal semaphores
Result:			none
-------------------------
RemakeDisplay
Description:		redraws every intuition screen
Library:		intuition.library
Offset:			-$0180 (-384)
Modula-2 Module:	Intuition
Syntax:			RemakeDisplay( )
C:			void RemakeDisplay(void)
Machine Language:	RemakeDisplay( )
Modula-2:		RemakeDisplay( )
Arguments:		none
Result:			none
-------------------------
RemBob (macro)
Description:		removes a Bob from current GEL list
C Include File:		include/graphics/gels.h
ML Include File:	graphics/gels.i
Modula-2 Module:	none
Syntax:			RemBob(bob, rastPort)
C:			void RemBob(struct Bob *, struct RastPort *)
Machine Language:	RemBob(a0)
Modula-2:		not available
Arguments:		bob = Bob structure to remove
			rastPort = controlling RastPort structure (not needed in
			Modula-2)
Result:			none
-------------------------
RemConfigDev
Description:		removes a ConfigDev structure from the system
Library:		expansion.library
Offset:			-$006C (-108)
Modula-2 Module:	ConfigVars
Syntax:			RemConfigDev(configDev)
C:			void RemConfigDev(long)
Machine Language:	RemConfigDev(a0)
Modula-2:		RemConfigDev(configDev: ConfigDevPtr)
Arguments:		configDev = ConfigDev structure
Result:			none
------------------------- 
RemDevice
Description:		removes a device from the system
Library:		exec.library
Offset:			-$01B6 (-438)
Modula-2 Module:	Devices
Syntax:			error= RemDevice(device)
C:			long RemDevice(struct Device *)
Machine Language:	d0 = RemDevice(a1)
Modula-2:		RemDevice(device: DevicePtr)
Arguments:		device = device node
Result:			error = 0 if successful; nonzero if unsuccessful
-------------------------
RemFont
Description:		removes a font from the system
Library:		graphics.library
Offset:			-$01E6 (-486)
Modula-2 Module:	Text
Syntax:			error = RemFont(textFont)
C:			long RemFont(struct TextFont *)
Machine Language:	d0 = RemFont(a1)
Modula-2:		RemFont(textFont: TextFontPtr)
Arguments:		textFont = TextFont structure to remove
Result:			error = 0 if successful; nonzero if unsuccessful (no value returned
			by Modula-2)
-------------------------
RemHead
Description:		removes a node from the head of a list
Library:		exec.library
Offset:			-$0102 (-258)
Modula-2 Module:	Lists
Syntax:			node = RemHead(list)
C:			struct Node *RemHead(struct List *)
Machine Language:	d0 = RemHead(a0)
Modula-2:		RemHead(list: ListPtr): NodePtr
Arguments:		list = list header
Result:			node = node removed; NULL if list is was already empty
------------------------- 
RemIBob
Description:		immediately removes a Bob from the GEL list and erases it from
			the RastPort display
Library:		graphics.library
Offset:			-$0084 (-132)
Modula-2 Module:	Gels
Syntax:			RemIBob(bob, rastPort, viewPort)
C:			void RemIBob(struct Bob *, struct RastPort *, struct ViewPort *)
Machine Language:	RemIBob(a0, a1, a2)
Modula-2:		RemIBob(bob: BobPtr; rastPort: RastPortPtr; viewPort:
			ViewPortPtr)
Arguments:		bob = Bob structure to remove from GEL list
			rastPort = RastPort structure
			viewPort = ViewPort structure
Result:			none
-------------------------
RemIntServer
Description:		removes an interrupt server from the system
Library:		exec.library
Offset:			-$00AE (-174)
Modula-2 Module:	Interrupts/
Syntax:			RemIntServer(intNum, interrupt)
C:			void RemIntServer(long, struct Interrupt *)
Machine Language:	RemIntServer(d0, a1)
Modula-2:		RemIntServer(intNum: CARDINAL; interrupt: InterruptPtr)
Arguments:		intNum = portia interrupt bit (0-4)
			interrupt = interrupt server node
Result:			none
-------------------------
RemLibrary
Description:		removes a library from the system
Library:		exec.library
Offset:			-$0192 (-402)
Modula-2 Module:	Libraries
Syntax:			error= RemLibrary(library)
C:			long RemLibrary(struct Library *)
Machine Language:	d0 = RemLibrary(a1)
Modula-2:		RemLibrary(Library: LibraryPtr)
Arguments:		library = Library structure to remove
Result:			error = 0 if successful; nonzero if unsuccessful
-------------------------
Remove
Description:		removes a node from a list
Library:		exec.library
Offset:			-$00FC (-252)
Modula-2 Module:	Lists
Syntax:			Remove(node)
C:			void Remove(struct Node *)
Machine Language:	Remove(a1)
Modula-2:		Remove(node: NodePtr)
Arguments:		node = node to remove
Result:			none
-------------------------
RemoveGadget	  
Description:		removes gadget from a window
Library:		intuition.library
Offset:			-$00E4 (-228)
Modula-2 Module:	Intuition
Syntax:			position = RemoveGadget(window, gadget)
C:			long RemoveGadget(struct Window *, struct Gadget *)
Machine Language:	d0 = RemoveGadget(a0, a1)
Modula-2:		RemoveGadget(window: WindowPtr; gadget: GadgetPtr):
			INTEGER
Arguments:		window = window that contains gadget
			gadget = gadget to remove
Result:			position = position in gadget list where gadget was located; -1 if
			gadget was not found
-------------------------
RemoveGList
Description:		removes a series of gadgets from a gadget list
Library:		intuition.library
Offset:			-$01BC (-444)
Modula-2 Module:	Intuition
Syntax:			position = RemoveGList(window, gadget, numGadgets)
C:			long RemoveGList(struct Window *, Gadget *, long)
Machine Language:	d0 = RemoveGList(a0, a1, d0)

Modula-2:		RemoveGList(window: WindowPtr; gadget: GadgetPtr;
			numGadgets: INTEGER): INTEGER
Arguments:		window = window containing gadgets
			gadget = first gadget in gadget list to remove
			numGadgets = number of gadgets to remove
Result:			position = position of removed gadget list; -1 if gadget was not
			found
-------------------------
RemPort
Description:		removes a message port from the system
Library:		exec.library
Offset:			-$0168 (-360)
Modula-2 Module:	Ports
Syntax:			RemPort(port)
C:			void RemPort(struct MsgPort *)
Machine Language:	RemPort(a1)
Modula-2:		RemPort(port: MsgPortPtr)
Arguments:		port = message port to remove
Result:			none
-------------------------
RemResource
Description:		removes a resource from the system
Library:		exec.library
Offset:			-$01EC (-492)
Modula-2 Module:	Resources
Syntax:			RemResource(resource)
C:			void RemResource(struct Resource *)
Machine Language:	RemResource(a1)
Modula-2:		RemResource(resource: ResourcePtr)
Arguments:		resource = resource to remove
Result:			none
-------------------------
RemSemaphore
Description:		removes signal semaphore from the system
Library:		exec.library
Offset:			-$025E (-606)
Modula-2 Module:	Semaphores
Syntax:			RemSemaphore(signalSemaphore)
C:			void RemSemaphore(struct SignalSemaphore *)
Machine Language:	RemSemaphore(a1)
Modula-2:		RemSemaphore(signalSemaphore: SignalSemaphorePtr)
Arguments:		signalSemaphore = signal semaphore to remove
Result:			none
-------------------------
RemTail
Description:		removes node from the tail of a list
Library:		exec.library
Offset:			-$0108 (-264)
Modula-2 Module:	Lists
Syntax:			node = RemTail(list)
C:			struct Node *RemTail(struct List *)
Machine Language:	d0 = RemTail(a0)
Modula-2:		RemTail(list: ListPtr): NodePtr
Arguments:		list = list header
Result:			node = pointer to removed node; NULL if list is already empty
-------------------------
RemTask
Description:		removes a task from the system
Library:		exec.library
Offset:			-$0120 (-288)
Modula-2 Module:	Tasks
Syntax:			RemTask(task)
C:			void RemTask(struct Task *)
Machine Language:	RemTask(a1)
Modula-2:		RemTask(task: TaskPtr)
Arguments:		task = task to remove
Result:			none
-------------------------
RemTOF
Description:		removes a task from the TopOfFrame (vertical-blanking interval)
			interrupt server chain
Library:		amiga.lib (linked library)
Modula-2 Module:	none
Syntax:			RemTOF(i)
C:			void RemTOF(struct Isrvstr *)
Machine Language:	pea i
			jsr _RemTOF
			addq.l #4,sp
Modula-2:		not available
Arguments:		i = Isrvstr structure
Result:			none
-------------------------
RemVSprite
Description:		removes a VSprite from the GEL list
Library:		graphics.library
Offset:			-$008A (-138)
Modula-2 Module:	Gels
Syntax:			RemVSprite(vSprite)
C:			void RemVSprite(struct VSprite *)
Machine Language:	RemVSprite(a0)
Modula-2:		RemVSprite(vSprite: VSpritePtr)
Arguments:		vSprite = VSprite to remove
Result:			none
-------------------------
Rename
Description:		renames a directory or file
Library:		dos.library
Offset:			-$004E (-78)
Modula-2 Module:	DOS
Syntax:			success = Rename(oldName, newName)
C:			long Rename(char *, char *)
Machine Language:	d0 = Rename(d1, d2)
Modula-2:		Rename(oldName, newName: STRPTR): BOOLEAN
Arguments:		oldName = current name of file/directory (can include
			drive/directory path)
			newName = new name for file (can include drive/directory path)
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
ReplyMsg
Description:		replies to a message
Library:		exec.library
Offset:			-$017A (-378)
Modula-2 Module:	Ports
Syntax:			ReplyMsg(message)
C:			void ReplyMsg(struct MsgPort *)
Machine Language:	ReplyMsg(a1)
Modula-2:		ReplyMsg(message: ADDRESS)
Arguments:		message = message to reply to
Result:			none
-------------------------
ReportMouse
Description:		tells intuition whether or not to report the mouse movements as-
			sociated with a window
Library:		intuition.library
Offset:			-$00EA (-234)
Modula-2 Module:	Intuition
Syntax:			ReportMouse(window, flag)
C:			void ReportMouse(struct Window *, long)
Machine Language:	ReportMouse(a0, d0)
Modula-2:		ReportMouse(window: WindowPtr; flag: BOOLEAN)
Arguments:		window = window to be affected
			flag = TRUE to activate mouse movement reports; FALSE to stop
			mouse movement reports
Result:			none
-------------------------
Request
Description:		activates a requester
Library:		intuition.library
Offset:			-$00F0 (-240)
Modula-2 Module:	Intuition
Syntax:			success = Request(requester, window)
C:			long Request(struct Requester, struct Window *)
Machine Language:	d0 = Request(a0, a1)
Modula-2:		Request(requester: RequesterPtr; window: WindowPtr): BOOLEAN
Arguments:		requester = requester to display
			window = window in which requester will appear in
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
RethinkDisplay
Description:		performs a complete overhaul on the Intuition display-screens,
			ViewPorts, everything
Library:		intuition.library
Offset:			-$0186 (-390)
Modula-2 Module:	Intuition
Syntax:			RethinkDisplay( )
C:			void RethinkDisplay(void)
Machine Language:	RethinkDisplay( )
Modula-2:		RethinkDisplay( )
Arguments:		none
Result:			none
-------------------------
ScreenToBack
Description:		moves specified screen to back of the display
Library:		intuition.library
Offset:			-$00F6 (-246)
Modula-2 Module:	Intuition
Syntax:			ScreenToBack(screen)
C:			void ScreenToBack(struct Screen *)
Machine Language:	ScreenToBack(a0)
Modula-2:		ScreenToBack(screen: ScreenPtr)
Arguments:		screen = screen to move
Result:			none
-------------------------
ScreenToFront
Description:		moves specified screen to front of the display
Library:		intuition.library
Offset:			-$00FC (-252)
Modula-2 Module:	Intuition
Syntax:			ScreenToFront(screen)
C:			void ScreenToFront(struct Screen *)
Machine Language:	ScreenToFront(a0)
Modula-2:		ScreenToFront(screen: ScreenPtr)
Arguments:		screen = screen to move
Result:			none
-------------------------
ScrollLayer
Description:		copies data from a SuperBitMap to a layer so as to reposition the
			display over the bitmap
Library:		layers.library
Offset:			-$0048 (-72)
Modula-2 Module:	Layers
Syntax:			ScrollLayer(dummy, layer, dx, dy)
C:			void ScrollLayer(struct Layer_Info *, struct Layer *, long, long)
Machine Language:	ScrollLayer(a0, a1, d0, d1)
Modula-2:		ScrollLayer(layer: LayerPtr; dx, dy: LONGINT)
Arguments:		dummy = unused
			layer = Layer structure
			dx = offset by which to move layer horizontally
			dy = offset by which to move layer vertically
Result:			none
-------------------------
ScrollRaster
Description:		scrolls the contents of a rectangular area of a RastPort
Library:		graphics.library
Offset:			-$018C (-396)
Modula-2 Module:	Rasters
Syntax:			ScrollRaster(rastPort, dx, dy, x1, y1, x2, y2)
C:			void ScrollRaster(struct RastPort *, long, long, long, long, long, 
			long)
Machine Language:	ScrollRaster(a0, d0, d1, d2, d3, d4, d5)
Modula-2:		ScrollRaster(rastPort: RastPortPtr; dx, dy: INTEGER; x1, y1, x2,
			y2: INTEGER)
Arguments:		rastPort = RastPort structure
			dx = offset by which to scroll the rectangle
			dy = offset by which to scroll the rectangle
			x1 = horizontal position of the left edge of the rectangle
			y1 = vertical position of the top edge of the rectangle
			x2 = horizontal position of the right edge of the rectangle
			y2 = vertical position of the bottom edge of the rectangle
Result:			none
-------------------------
ScrollVPort
Description:		scrolls the contents of a rectangular area of a ViewPort by reinter-
			preting the RasInfo information in a ViewPort
Library:		graphics.library
Offset:			-$024C (-588)
Modula-2 Module:	Views
Syntax:			ScrollVPort(viewPort)
C:			void ScrollVPort(struct ViewPort *)
Machine Language:	ScrollVPort(a0)
Modula-2:		ScrollVPort(viewPort: ViewPortPtr)
Arguments:		viewPort = ViewPort structure to update
Result:			none
-------------------------
Seek
Description:		moves the file pointer to a specified position in a file
Library:		dos.library
Offset:			-$0042 (-66)
Modula-2 Module:	DOS
Syntax:			oldPosition = Seek(file, position, mode)
C:			long Seek(BPTR, long, long)
Machine Language:	d0 = Seek(d1, d2, d3)
Modula-2:		Seek(file: FileHandle; position: LONGINT; mode: LONGINT):
			LONGINT
Arguments:		file = BCPL pointer to a file handle
			position = offset by which to move file pointer
			mode = flag specifying how to interpret position offset-
			OFFSET_BEGINNING (-1), OFFSET_CURRENT (0), or
			OFFSET_END (1)
Result:			oldPosition = old file position; -1 if unsuccessful
-------------------------
SendIO
Description:		sends an IO request
Library:		exec.library
Offset:			-$01CE (-462)
Modula-2 Module:	IO
Syntax:			SendIO(ioRequest)
C:			void SendIO(struct IORequest *)
Machine Language:	SendIO(a1)
Modula-2:		SendIO(ioRequest: ADDRESS)
Arguments:		IORequest = an initialized IORequest structure
Result:			none
-------------------------
SetAfPt (macro)
Description:		sets area fill pattern
C Include File:		include/graphics/gfxmacros.h
ML Include File:	none
Modula-2 Module:	Pens
Syntax:			SetAfPt(rastPort, pattern, size)
C:			void SetAfPt(struct RastPort *, char *, long)
Machine Language:	not available
Modula-2:      		SetAfPat(rastPort: RastPortPtr; pattern: ADDRESS; size:
			CARDINAL)
Arguments:		rastPort = RastPort structure
			pattern = pointer to the first word in an area-fill pattern
			size = size of area pattern (size to the power of two equals the
			number of words in pattern)
Result:			none
-------------------------
SetAPen
Description:		sets the primary pen color
Library:		graphics.library
Offset:			-0156 (-342)
Modula-2 Module:	Pens
Syntax:			SetAPen(rastPort, pen)
C:			void SetAPen(struct RastPort *, long)
Machine Language:	SetAPen(a1, d0)
Modula-2:		SetAPen(rastPort: RastPortPtr; pen: CARDINAL)
Arguments:		rastPort = RastPort structure
			pen = pen number (0-255)
Result:			none
-------------------------
SetBPen
Description:		sets the secondary pen color
Library:		graphics.library
Offset:			-015C (-348)
Modula-2 Module:	Drawing
Syntax:			SetBPen(rastPort, pen)
C:			void SetBPen(struct RastPort *, long)
Machine Language:	SetBPen(al, d0)
Modula-2:		SetBPen(rastPort: RastPortPtr; pen: CARDINAL)
Arguments:		rastPort = RastPort structure
			pen = pen number (0-255)
Result:			none
-------------------------
SetCollision
Description:		sets a collision vector to point to a user-written routine
Library:		graphics.library
Offset:			-0090 (-144)
Modula-2 Module:	Gels
Syntax:			SetCollision(number, routine, gelsInfo)
C:			void SetCollision(long, _fgptr, struct GelsInfo *)
Machine Language:	SetCollision(d0, a0, a1)
Modula-2:		SetCollision(number: LONGCARD; routine: PROC; gelsInfo:
			GelsInfoPtr)
Arguments:		number = collision vector number
			routine = pointer to user's collision routine
			gelsInfo = GelsInfo structure
Result:			none
-------------------------
SetComment
Description:		adds a comment to a file
Library:		dos.library
Offset:			-00B4 (-180)
Modula-2 Module:	DOS
Syntax:			success = SetComment(name, comment)
C:			long SetComment(char *, char *)
Machine Language:	d0 = SetComment(d1, d2)
Modula-2:		SetComment(name, comment: STRPTR): BOOLEAN
Arguments:		name = filename of file to comment
			comment = comment to add to file
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
SetCurrentBinding
Description:		sets static board configuration area
Library:		expansion.library
Offset:			-$0084 (-132)
Modula-2 Module:	none
Syntax:			SetCurrentBinding(currentBinding, size)
C:			void SetCurrentBinding(long, long)
Machine Language:	SetCurrentBinding(a0, d0)
Modula-2:      		not available
Arguments:		currentBinding = CurrentBinding structure
			size = size of user's BindDriver structure
Result:			none
-------------------------
SetDMRequest
Description:		attaches a DMRequester (a requester activated when the mouse's
			menu button is double clicked) to a window
Library:		intuition.library
Offset:			-0102 (-258)
Modula-2 Module:	Intuition
Syntax:			success = SetDMRequest(window, dmRequester)
C:			long SetDMRequest(struct Window *, struct Requester *)
Machine Language:	d0 = SetDMRequest(a0, a1)
Modula-2:		SetDMRequest(window: WindowPtr; dmRequester: RequesterPtr)
Arguments:		window = window to which the requester will be added
			dmRequester = requester to attach
Result:			success = TRUE if successful; FALSE if unsuccessful (nothing re-
			turned by Modula-2)
-------------------------
SetDrMd
Description:		sets a drawing mode for drawing routines
Library:		graphics.library
Offset:			-0162 (-354)
Modula-2 Module:	Pens
Syntax:			SetDrMd(rastPort, mode)
C:			void SetDrMd(struct RastPort *, long)
Machine Language:	SetDrMd(a1, d0)
Modula-2:		SetDrMd(rastPort: RastPortPtr; mode: DrawingModeSet)
Arguments:		rastPort = RastPort structure
			mode = drawing mode JAM1, JAM2, COMPLEMENT,
			INVERSVID)
Result:			none
-------------------------
SetDrPt (macro)
Description:		sets a pattern to use for line drawing
C Include File:		include/graphics/gfxmacros.h
ML Include File:	none
Modula-2 Module:	Pens
Syntax:			SetDrPt(rastPort, pattern)
C:			void SetDrPt(struct RastPort *, long)
Machine Language:	not available
Modula-2:		SetDrPt(rastPort: RastPortPtr; pattern: BITSET)
Arguments:		rastPort = RastPort structure
			pattern = 16-bit drawing pattern
Result:			none
-------------------------
SetExcept
Description:		defines which signals cause an exception
Library:		exec.library
Offset:			-0138 (-312)
Modula-2 Module:	Tasks
Syntax:			oldSignals = SetExcept(newSignals, signalMask)
C:			long SetExcept(long, long)
Machine Language:	d0 = SetExcept(d0, d1)
Modula-2:		SetExcept(newSignals, signalMask: SignalSet): SignalSet
Arguments:		newSignals = new values for signals specified in signalMask
			signalMask = set of signals to be affected
Result:			oldSignals = prior exception signals
-------------------------
SetFont
Description:		sets the font to be used for drawing text in a rastport
Library:		graphics.library
Offset:			-0042 (-66)
Modula-2 Module:	Text
Syntax:			SetFont(rastPort, font)
C:			void SetFont(struct RastPort *, struct TextFont *)
Machine Language:	SetFont(a1/ a0)
Modula-2:		SetFont(rastPort: RastPortPtr; font: TextFontPtr)
Arguments:		rastPort = RastPort structure
			font = font descriptor obtained from OpenFont( ) function
Result:			none
-------------------------
SetFunction
Description:		changes a function vector in a library
Library:		exec.library
Offset:			-01A4 (-420)
Modula-2 Module:	Libraries
Syntax:			oldFunc = SetFunction(library, offset, newFunc)
C:			_fptr SetFunction(struct Library *, long,_fptr)
Machine Language:	d0 = SetFunction(a1, a0, d0)
Modula-2:		SetFunction(library: LibraryPtr; offset: INTEGER; newFunc:
			PROC): PROC
Arguments:		library = library to change
			offset = offset of function vector to change
			newFunc = address of new function
Result:			oldFunc = address of old function
-------------------------
SetIntVector
Description:		changes a system interrupt vector
Library:		exec.library
Offset:			-00A2 (-162)
Modula-2 Module:	Interrupts
Syntax:			oldInt = SetIntVector(intNum, newInt)
C:			struct Interrupt *SetIntVector(long, struct Interrupt *)
Machine Language:	d0 = SetIntVector(d0, a1)
Modula-2:		SetIntVector(intNum: CARDINAL; newInt: InterruptPtr):
			InterruptPtr
Arguments:		intNum = Portia interrupt bit number (0-14)
			newInt = initialized Interrupt structure
Result:			oldInt = old Interrupt structure
-------------------------
SetMenuStrip
Description:		attaches a menu strip to a window
Library:		intuition.library
Offset:			-0108 (-264)
Modula-2 Module:	Intuition
Syntax:			SetMenuStrip(window, menu)
C:			void SetMenuStrip(struct Window *, struct Menu *)
Machine Language:	SetMenuStrip(a0, a1)
Modula-2:		SetMenuStrip(window: WindowPtr; menu: MenuPtr)
Arguments:		window = window to receive menu strip
			menu = first menu in menu strip
Result:			none
-------------------------
SetOPen (macro)
Description:		sets the color of the pen used for outlining figures and tums on
			outlining
C Include File:		include/graphics/gfxmacros.h
ML Include File:	none
Modula-2 Module:	Pens
Syntax:			SetOPen(rastPort, pen)
C:			void SetOPen(struct RastPort *, long)
Machine Language:	not available
Modula-2:		SetOPen(rastPort: RastPortPtr; pen: CARDINAL)
Arguments:		rastPort = RastPort structure
			pen = pen number (0-255)
Result:			none
-------------------------
SetPointer
Description:		sets the shape of a window's sprite mouse pointer
Library:		intuition.library
Offset:			-010E (-270)
Modula-2 Module:	Intuition
Syntax:			SetPointer(window, pointer, height, width, xOffset, yOffset)
C:			void SetPointer(struct Window *, short *, long, long, long, long)
Machine Language:	SetPointer(a0, a1, d0, d1, d2, d3)
Modula-2:		SetPointer(window: WindowPtr; pointer: ADDRESS; height,
			width: CARDINAL; xOffset, y: INTEGER)
Arguments:		window = window to receive new pointer
			pointer = sprite data defining new shape
			height = height of sprite in lines
			width = width of sprite in pixels (less than or equal to 16)
			xOffset = horizontal offset of pointer hot spot
			yOffset = vertical offset of pointer hot spot
Result:			none
-------------------------
SetPrefs
Description:		changes Preferences' current settings
Library:		intuition.library
Offset:			-$0144 (-324)
Modula-2 Module:	Preferences
Syntax:			prefBuffer = SetPrefs(prefBuffer, size, inform)
C:			struct Preferences *SetPrefs(struct Preferences *, long, long)
Machine Language:	d0 = SetPrefs(a0, d0, d1)
Modula-2:		SetPrefs(prefBuffer: ADDRESS; size: INTEGER; inform:
			BOOLEAN)
Arguments:		prefBuffer = buffer which contains your desired Preferences
			settings
			size = size of buffer in bytes
			inform = TRUE if you want to send a NEWPREFS message to all
			interested windows
Result:			prefBuffer = pointer to your prefBuffer
------------------------- 
SetProtection
Description:		sets a file or directories protection bits
Library:		dos.library
Offset:			-00BA (-186)
Modula-2 Module:	DOS
Syntax:			success = SetProtection(name, mask)
C:			long SetProtection(char *, long)
Machine Language:	d0 = SetProtection(d1, d2)
Modula-2:		SetProtection(name: STRPTR; mask: ProtectionSet): BOOLEAN
Arguments:		name = file or directory name
			mask = protection bits to set
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
SetRast
Description:		sets the entire rastport to a specified color
Library:		graphics.library
Offset:			-00EA (-234)
Modula-2 Module:	Rasters
Syntax:			SetRast(rastPort, pen)
C:			void SetRast(struct RastPort *, long)
Machine Language:	SetRast(a1, d0)
Modula-2:		SetRast(rastPort: RastPortPtr; pen: CARDINAL)
Arguments:		rastPort = RastPort structure
			pen = color register used to color the rastport (0-31)
Result:			none
-------------------------
SetRGB4
Description:		sets the red, green, and blue values for a viewport's color register
Library:		graphics.library
Offset:			-0120 (-288)
Modula-2 Module:	Views
Syntax:			SetRGB4(viewPort, pen, red, green, blue)
C:			void SetRGB4(struct ViewPort *, long, long, long, long)
Machine Language:	SetRGB4(a0, d0, d1, d2, d3)
Modula-2:		SetRGB4(viewPort: ViewPortPtr; pen: INTEGER; red, green, blue:
			CARDINAL)
Arguments:		viewPort = ViewPort structure
			pen = color register to set (0-31)
			red = red color level (0-15)
			green = green color level (0-15)
			blue = blue color level (0-15)
Result:			none
-------------------------
SetRGB4CM
Description:		sets the red, green, and blue values for a colormap's color register
Library:		graphics.library
Offset:			-0276 (-630)
Modula-2 Module:	Views
Syntax:			SetRGB4CM(colorMap, pen, red, green, blue)
C:			void SetRGB4CM(struct ColorMap *, long, long, long, long)
Machine Language:	SetRGB4CM(a0, d0, d1, d2, d3)
Modula-2:		SetRGB4CM(colorMap: ColorMapPtr; pen: INTEGER; red, green,
			blue: CARDINAL)
Arguments:		colorMap = ColorMap structure
			pen = color register to set (0-31)
			red = red color level (0-15)
			green = green color level (0-15)
			blue = blue color level (0-15)
Result:			none
-------------------------
SetSignal
Description:		defines the state of a task's signals
Library:		exec.library
Offset:			-0132 (-306)
Modula-2 Module:	Tasks
Syntax:			oldSignals = SetSignal(newSignals, signalMask)
C:			long SetSignal(long, long)
Machine Language:	d0 = SetSignal(d0, d1)
Modula-2:		SetSignal(newSignals, signalMask: SignalSet): SignalSet
Arguments:		newSignals = new values for signals specified in signalMask
			signalMask = set of signals to be affected
Result:			oldSignals = prior values for signals
------------------------- 
SetSoftStyle
Description:		sets the style for the current font
Library:		graphics.library
Offset:			-005A (-90)
Modula-2 Module:	Text
Syntax:			newStyle = SetSoftStyle(rastPort, style, enable)
C:			long SetSoftStyle(struct RastPort *, long, long)
Machine Language:	d0 = SetSoftStyle(a1, d0, d1, a6)
Modula-2:		SetSoftStyle(rastPort: RastPortPtr; style, enable: FontStyleSet):
			FontStyleSet
Arguments:		rastPort = RastPort structure
			style = new font style
			enable = mask that determines which style bit can be changed;
			can be derived from AskSoftStyle( ) function
Result:			newStyle = resulting font style
-------------------------
SetSR
Description:		gets and/or sets the processor's status register
Library:		exec.library
Offset:			-0090 (-144)
Modula-2 Module:	Exec
Syntax:			oldSR = SetSR(newSR, mask)
C:			long SetSR(long, long)
Machine Language:	d0 = SetSR(d0, d1)
Modula-2:		SetSR(newSR: BITSET; mask: BITSET): BITSET
Arguments:		newSR = new value for bits specified in mask
			mask = bits to be affected
Result:			oldSR = prior value of status register
-------------------------
SetTaskPri
Description:		gets and sets the priority of a task
Library:		exec.library
Offset:			-012C (-300)
Modula-2 Module:	Tasks
Syntax:			oldPriority = SetTaskPri(task, newPriority)
C:			long SetTaskPri(struct Task *, long)
Machine Language:	d0 = SetTaskPri(a1, d0)
Modula-2:		SetTaskPri(task: TaskPtr; newPriority: INTEGER): INTEGER
Arguments:		task = task to be affected
			newPriority = new priority value (0-8)
Result:			oldPriority = old task priority (0-8)
-------------------------
SetWindowTitles
Description:		sets the titles for both a window and its screen
Library:		intuition.library
Offset:			-0114 (-276)
Modula-2 Module:	Intuition
Syntax:			SetWindowTitles(window, windowTitle, screenTitle)
C:			void SetWindowTitles(struct Window *, char *, char *)
Machine Language:	SetWindowTitles(a0, a1, a2)
Modula-2:		SetWindowTitles(window: WindowPtr; windowTitle, screenTitle:
			STRPTR)
Arguments:		window = window to be affected
			windowTitle = new window title (-1 to keep as-is)
			screenTitle = new screen title (-1 to keep as-is)
Result:			none
-------------------------
SetWrMsk (macro)
Description:		sets the write mask for a rastport (locks and unlocks bitplanes)
C Include File:	include/graphics/gfxmacros.h
ML Include File:	none
Modula-2 Module:	Pens
Syntax:			SetWrMsk(rastPort, mask)
C:			void SetWrMsk(struct RastPort *, long)
Arguments:		cList = character list containing substring
			index = starting position of substring
			length = number of bytes to copy
Result:			cList = new character list that contains the substring; -1 if there
			is not enough memory
-------------------------
SHIFTITEM (macro)
Description:		shifts a menu value to define a new value for the menu item
			number
C Include File:		include/intuition/intuition.h
ML Include File:	none
Modula-2 Module:	none
Syntax:			newValue = SHIFTITEM(menuValue)
C:			long SHIFTITEM(long)
Machine Language:	not available
Modula-2:		not available
Arguments:		menuValue = 16-bit packed number representing the menu num-
			ber, item number, and subitem number
Result:			newValue = the menuValue ANDed with $3F and shifted to the
			left five times-((menuValue & 0x3F) << 5)
-------------------------
SHIFTMENU (macro)
Description:		extracts the menu number from a value (identical to MENUNUM 
			macro)
C Include File: 	include/intuition/intuition.h
ML Include File: 	none
Modula-2 Module:	none
Syntax:			menuNumber= SHIFTMENU(menuValue)
C:			long SHIFTMENU(long)
Machine Language:	not available
Modula-2:		not available
Arguments:		menuValue = 16-bit packed number representing the menu num-
			ber, item number, and subitem number
Result:			menuNumber = menu number (0-31); equals NOMENU if no
			menu was selected
-------------------------
SHIFTSUB (macro)
Description:		shifts a menu value to define a new value for the menu subitem
			number
C Include File:		include/intuition/intuition.h
ML Include File:	none
Modula-2 Module:	none
Syntax:			newValue = SHIFTSUB(menuValue)
C:			long SHIFTSUB(long)
Machine Language:	not available
Modula-2:		not available
Arguments:		menuValue = 16-bit packed number representing the menu num-
			ber, item number, and subitem number
Result:			newValue = the menuValue ANDed with $1F and shifted to the
			left 11 times-((menuValue & 0x1F) << 11)
-------------------------
ShowTitle
Description:		determines whether the screen title bar will be displayed in front
			of a backdrop window
Library:		intuition.library
Offset:			-011A (-282) 
Modula-2 Module:	Intuition
Syntax:			ShowTitle(screen, showIt)
C:			void ShowTitle(struct Screen *, long)
Machine Language:	ShowTitle(a0, d0)
Modula-2:		ShowTitle(screen: ScreenPtr; showIt: BOOLEAN)
Arguments:		screen = screen to be affected
			showIt = flag that indicates whether or not to display the screen's
			title bar in front of a backdrop window (TRUE means show the
			title bar; FALSE means hide it)
Result:			none
-------------------------
Signal
Description:		signals a task with specified signals
Library:		exec.library
Offset:			-0144 (-324)
Modula-2 Module:	Tasks
Syntax:			Signal(task, signals)
C:			void Signal(struct Task *, long)
Machine Language:	Signal(d0, d1)
Modula-2:		Signal(task: TaskPtr; signals: SignalSet)
Arguments:		task = task to be signaled
			signals = signals to send
Result:			none
-------------------------
SizeCList
Description:		gets the size of a character list in bytes
Library:		clist.library
Offset:			-0036 (-54)
Modula-2 Module:	none
Syntax:			size = SizeCList(cList)
C:			long SizeCList(long)
Machine Language:	d0 = SizeCList(a0)
Modula-2:      		not available
Arguments:		cList = character list in question
Result:			size = number of bytes in character list
-------------------------
SizeLayer
Description:		changes the size of a nonbackdrop layer
Library:		layers.library
Offset:			-0042 (-66)
Modula-2 Module:	Layers
Syntax:			SizeLayer(dummy, layer, dx, dy)
C:			long SizeLayer(struct Layer_Info *, struct Layer *, long, long)
Machine Language:	d0 = SizeLayer(a0, a1, d0, d1)
Modula-2:		SizeLayer(layer: LayerPtr; dx, dy: LONGINT): BOOLEAN
Arguments:		dummy = unused
			layer = a nonbackdrop Layer structure
			dx = amount to add to layer's horizontal size (may be negative)
			dy = amount to add to layer's vertical size (may be negative)
Result:			TRUE if successful; FALSE if unsuccessful
-------------------------
SizeWindow
Description:		resizes a window
Library:		intuition.library
Offset:			-0120 (-288)
Modula-2 Module:	Intuition
Syntax:			SizeWindow(window, dx, dy)
C:			void SizeWindow(struct Window *, long, long)
Machine Language:	SizeWindow(a0, d0, d1)
Modula-2:		SizeWindow(window: WindowPtr; dx, dy: INTEGER)
Arguments:		window = window to be resized
			dx = amount to add to window's horizontal size (may be
			negative)
			dy = amount to add to window's vertical size (may be negative)
Result:			none
-------------------------
SortGList
Description:		sorts the GEL list by vertical position of each element, prior to
			displaying the GELs
Library:		graphics.library
Offset:			-0096 (-150)
Modula-2 Module:	Gels
Syntax:			SortGList(rastPort)
C:			void SortGList(struct RastPort *)
Machine Language:	SortGList(a1)
Modula-2:		SortGList(rastPort: RastPortPtr)
Arguments:		rastPort = RastPort structure containing the GelsInfo
Result:			none
-------------------------
SPAbs
Description:		obtains the absolute value of a floating-point number
Library:		mathffp.library
Offset:			-$0036 (-54)
Modula-2 Module:	none
Syntax:			fnum1 = SPAbs(fnum2)
C:			float SPAbs(float)
Machine Language:	d0 = SPAbs(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
Result:			fnum1 = absolute value of fnum2 in floating-point format
-------------------------
SPAcos
Description:		obtains the arcosine of a floating-point number
Library:		mathtrans.library
Offset:			-$0078 (-120)
Modula-2 Module:	none
Syntax:			fnum1 = SPAcos(fnum2)
C:			float SPAcos(float)
Machine Language:	d0 = SPAcos(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number representing the cosine of an
			angle
Result:			fnum1 = floating-point value of fnum2 angle in radians
-------------------------
SPAdd
Description:		adds two floating-point numbers
Library:		mathffp.library
Offset:			-$0042 (-66)
Modula-2 Module:	none
Syntax:			fnum1 = SPAdd(fnum2, fnum3)
C:			float SPAdd(float, float)
Machine Language:	d0 = SPAdd(d1, d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
			fnum3 = floating-point number
Result:			fnum1 = fnum2 plus fnum3 in floating-point format
-------------------------
SPAsin
Description:		obtains the arcsine of a floating-point number
Library:		mathtrans.library
Offset:			-$0072 (-114)
Modula-2 Module:	none
Syntax:			fnum1 = SPAsin(fnum2)
C:			float SPAsin(float)
Machine Language:	d0 = SPAsin(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number representing the sine of an angle
Result:			fnum1 = floating-point value of fnum2 angle in radians
-------------------------
SPAtan
Description:		obtains the arctangent of a floating-point number
Library:		mathtrans.library
Offset:			-$0030 (-48)
Modula-2 Module:	none
Syntax:			fnum1 = SPAtan(fnum2)
C:			float SPAtan(float)
Machine Language:	d0 = SPAtan(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number representing the tangent of an
			angle
Result:			fnum1 = floating-point value of fnum2 angle in radians
-------------------------
SPCmp
Description:		compares two floating-point numbers
Library:		mathffp.library
Offset:			-$002A (-42)
Modula-2 Module:	none
Syntax:			flag = SPCmp(fnum1, fnum2)
C:			long SPCmp(float, float)
Machine Language:	d0 = SPCmp(d1, d0)
Modula-2:		not available
Arguments:		fnum1 = floating-point number
			fnum2 = floating-point number
Result:			flag = -1 if fnum1<fnum2; +1 if fnum1>fnum2; 0 if
			fnum1 = fnum2
-------------------------
SPCos
Description:		obtains the cosine of a floating-point number
Library:		mathtrans.library
Offset:			-$002A (-42)
Modula-2 Module:	none
Syntax:			fnum1 = SPCos(fnum2)
C:			float SPCos(float)
Machine Language:	d0 = SPCos(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number representing an angle in radians
Result:			fnum1 = floating-point cosine of fnum2
-------------------------
SPCosh
Description:		obtains the hyperbolic cosine of a floating-point number
Library:		mathtrans.library
Offset:			-$0042 (-66)
Modula-2 Module:	none
Syntax:			fnum1 = SPCosh(fnum2)
C:			float SPCosh(float)
Machine Language:	d0 = SPCosh(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number representing an angle in radians
Result:			fnum1 = floating-point hyperbolic cosine of fnum2
-------------------------
SPDiv
Description:		divides one floating-point number by another
Library:		mathffp.library
Offset:			-$0054 (-84)
Modula-2 Module:	none
Syntax:			fnum1 = SPDiv(fnum2, fnum3)
C:			float SPDiv(float, float)
Machine Language:	d0 = SPDiv(d1, d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point dividend
			fnum3 = floating-point divisor
Result:			fnum1 = floating-point format results of fnum2 divided by fnum3
-------------------------
SPExp
Description:		obtains the exponent of a floating-point number
Library:		mathtrans.library
Offset:			-$004E (-78)
Modula-2 Module:	none
Syntax:			fnum1 = SPExp(fnum2)
C:			float SPExp(float)
Machine Language:	d0 = SPExp(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
Result:			fnum1 = floating-point value representing e (approx. 2.71728)
			raised to the power of fnum2
-------------------------
SPFieee
Description:		converts a single-precision IEEE number to a Motorola fast float-
			ing point number
Library:		mathtrans.library
Offset:			-$006C (-108)
Modula-2 Module:	none
Syntax:			fnum = SPFieee(ieeenum)
C:			float SPFieee(long)
Machine Language:	d0 = SPFieee(d0)
Modula-2:		not available
Arguments:		ieeenum = single-precision floating-point number
Result:			fnum = Motorola fast floating point equivalent to fnum
-------------------------
SPFlt
Description:		converts an integer to floating-point number
Library:		mathffp.library
Offset:			-$0024 (-36)
Modula-2 Module:	none
Syntax:			fnum = SPFlt(inum)
C:			float SPFlt(long)
Machine Language:	d0 = SPFlt(d0)
Modula-2:		not available
Arguments:		inum = signed integer to be converted
Result:			fnum = floating-point equivalent to inum
-------------------------
SplitCList
Description:		splits a character list in two, breaking it at the mark (obtained via
			the MarkList( ) function)
Library:		clist.library
Offset:			-008A (-138)
Modula-2 Module:	none
Syntax:			tailCList = SplitCList(cList)
C:			long SplitCList(long)
Machine Language:	d0 = SplitCList(a0)
Modula-2:		not available
Arguments:		cList = character list to split
Result:			tailCList = new character list that contains the tail end of the
			original character list; -1 if there is not enough memory
-------------------------
SPLog
Description:		obtains the natural logarithm of a floating-point number
Library:		mathtrans.library
Offset:			-$0054 (-84)
Modula-2 Module:	none
Syntax:			fnum1 = SPLog(fnum2)
C:			float SPLog(float)
Machine Language:	d0 = SPLog(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
Result:			fnum1 = floating-point natural logarithm (base e) of fnum2
-------------------------
SPLog10
Description:		obtains the naparian logarithm (base 10) of a floating-point number
Library:		mathtrans.library
Offset:			-$007E (-126)
Modula-2 Module:	none
Syntax:			fnum1 = SPLog10(fnum2)
C:			float SPLoglO(float)
Machine Language:	d0 = SPLog10(d0)
Modula-2:      not available
Arguments:		fnum2 = floating-point number
Result:			fnum1 = floating-point naparian logarithm (base 10) of fnum2
-------------------------
SPMul
Description:		multiplies one floating-point number by another
Library:		mathffp.library
Offset:			-$004E (-78)
Modula-2 Module:	none
Syntax:			fnum1 = SPMul(fnum2, fnum3)
C            float SPMul(float, float)
Machine Language:	d0 = SPMul(d1, d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
			fnum3 = floating-point number
Result:			fnum1 = product of fnum2 and fnum3 in floating-point format
-------------------------
SPNeg
Description:		negates the value of a floating-point number
Library:		mathffp.library
Offset:			-$003C (-60)
Modula-2 Module:	none
Syntax:			fnum1 = SPNeg(fnum2)
C:			float SPNeg(float)
Machine Language:	d0 = SPNeg(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number to negate
Result:			fnum1 = negative fnum2 in floating-point format
-------------------------
SPPow
Description:		obtains the exponentiation of two floating-point numbers
Library:		mathtrans.library
Offset:			-$005A (-90)
Modula-2 Module:	none
Syntax:			fnum1 = SPPow(fnum2, fnum3)
C:			float SPPow(float, float)
Machine Language:	d0 = SPPow(d1, d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
			fnum3 = floating-point number
Result:			fnum1 = floating-point value of fnum2 raised to the power of
			fnum3
-------------------------
sprintf
Description:		outputs a formatted string into a string (Lattice and Manx users: if 
			you link with lc.lib or c.lib, this is not the function you're calling)
Library:		amiga.lib (linked library)
Modula-2 Module:	none
Syntax:			sprintf(destinationString, formatString, values...)
C:			void sprintf(char *, char *, long...)
Machine Language:	move.l #value,-(sp) ;may have several values 
			pea formatString 
			pea destinationString 
			jsr _printf 
			add.l #8,sp ;(2 arguments * 4 bytes = 8)
Modula-2:		not available

Arguments:		destinationString = address of string to receive output
			 formatString = string containing optional C formatting commands
			 (%); if you're passing longword values on the stack (as shown
			 above) be sure to follow the percent symbol with a lowercase L
			 values = values or addresses of strings to print; this routine
			 knows how many values are on the stack by checking the number
			 of formatting commands in formatString argument
Result:			 none
-------------------------
SPSin
Description:		 obtains the sine of a floating-point number
Library:		 mathtrans.library
Offset:			 -$0024 (-36)
Modula-2 Module:	none
Syntax:			fnum1 = SPSin(fnum2)
C:			float SPSin(float, float)
Machine Language:	d0 = SPSin(d0)
Modula-2:		 not available
Arguments:		fnum2 = floating-point number representing an angle in radians
Result:			fnum1 = floating-point sine of fnum2
-------------------------
SPSincos
Description:		 obtains the sine and cosine of a floating-point number
Library:		 mathtrans.library
Offset:			 -$0036 (-54)
Modula-2 Module:	none
Syntax:			fnum1 = SPSincos(fnum2, fnum3)
C:			float SPSincos(float, float *)
Machine Language:	d0 = SPSincos(d1, d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
			fnum3 = pointer to floating point number to receive the cosine of
			fnum2
Result:			fnum1 = floating-point sine of fnum2 (cosine is returned in
			fnum3)
-------------------------
SPSinh
Description:		obtains the hyperbolic sine of a floating-point number
Library:		mathtrans.library
Offset:			-$003C (-60)
Modula-2 Module:	none
Syntax:			fnum1 = SPSinh(fnum2)
C:			float SPSinh(float, float)
Machine Language:	d0 = SPSinh(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number representing an angle in radians
Result:			fnum1 = floating-point hyperbolic sine of fnum2
-------------------------
SPSqrt
Description:		obtains the square root of a floating-point number
Library:		mathtrans.library
Offset:			-$0060 (-96)
Modula-2 Module:	none
Syntax:			fnum1 = SPSqrt(fnum2)
C:			float SPSqrt(float)
Machine Language:	d0 = SPSqrt(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
Result:			fnum1 = floating-point square root of fnum2
-------------------------
SPSub
Description:		subtracts one floating-point number from another
Library:		mathffp.library
Offset:			-$0048 (-72)
Modula-2 Module:	none
Syntax:			fnum1 = SPSub(fnum2, fnum3)
C:			float SPSub(float, float)
Machine Language:	d0 = SPSub(d1, d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
			fnum3 = floating-point number
Result:			fnum1 = fnum2 minus fnum3 in floating-point format
-------------------------
SPTan
Description:		obtains the tangent of a floating-point number
Library:		mathtrans.library
Offset:			-$0030 (-48)
Modula-2 Module:	none
Syntax:			fnum1 = SPTan(fnum2)
C:			float SPTan(float, float)
Machine Language:	d0 = SPTan(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number representing an angle in radians
Result:			fnum1 = floating-point tangent of fnum2
-------------------------
SPTanh
Description:		obtains the hyperbolic tangent of a floating-point number
Library:		mathtrans.library
Offset:			-$0048 (-72)
Modula-2 Module:	none
Syntax:			fnum1 = SPTanh(fnum2)
C:			float SPTanh(float, float)
Machine Language:	d0 = SPTanh(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number representing an angle in radians
Result:			fnum1 = floating-point hyperbolic tangent of fnum2
-------------------------
SPTieee
Description:		converts a Motorola fast floating point number to a single-
			precision IEEE number
Library:		mathtrans.library
Offset:			-$0066 (-102)
Modula-2 Module:	none
Syntax:			ieeenum = SPTieee(fnum)
C:			float SPTieee(float)
Machine Language:	d0 = SPTieee(d0)
Modula-2:		not available
Arguments:		fnum = Motorola fast floating point number
Result:			ieeenum = single-precision floating-point equivalent to fnum
-------------------------
SPTst
Description:		compares a floating-point number with zero
Library:		mathffp.library
Offset:			-$0030 (-48)
Modula-2 Module:	none
Syntax:			flag = SPTst(fnum)
C:			long SPTst(float)
Machine Language:	d0 = SPTst(d0)
Modula-2:		not available
Arguments:		fnum = floating-point number
Result:			flag = -1 if fnum<0; +1 if fnum>0; 0 if fnum=0
-------------------------
SubCList
Description:		copies a substring from a character list
Library:		clist.library
Offset:			-0096 (-150)
Modula-2 Module:	none
Syntax:			cList = SubCList(cList, index, length)
C:			long SubCList(long, long, long)
Machine Language:	d0 = SubCList(a0, d0, d1)
Modula-2:		not available
Arguments:		cList = character list containing substring
			index = starting position of substring
			length = number of bytes to copy
Result:			cList = new character list that contains the substring; -1 if there
			is not enough memory
-------------------------
SUBNUM (macro)
Description:		extracts the menu subitem number from a value
C Include File:		include/intuition/intuition.h
ML Include File:	none
Modula-2 Module:	Intuition
Syntax:			subNumber= SUBNUM(menuValue)
C:			long SUBNUM(long)
Machine Language:	not available
Modula-2:		SUBNUM(menuValue: CARDINAL): CARDINAL
Arguments:		menuValue = 16-bit packed number representing the menu num-
			ber, item number, and subitem number
Result:			itemNumber = item number (0-31); equals NOSUB if no menu
			was selected
-------------------------
SumKickData
Description:		computes the checksum for a Kickstart delta list
Library:		exec.library
Offset:			-0264 (-612)
Modula-2 Module:	Resident
Syntax:			SumKickData( )
C:			void SumKickData(void)
Machine Language:	SumKickData( )
Modula-2:		SumKickData( )
Arguments:		none
Result:			none
-------------------------
SumLibrary
Description:		verifies a library's checksum; alerts user if checksum is incorrect
Library:		exec.library
Offset:			-01AA (-426)
Modula-2 Module:	Libraries
Syntax:			SumLibrary(library)
C:			void SumLibrary(struct Library *)
Machine Language:	SumLibrary(a1)
Modula-2:		SumLibrary(
Library:		LibraryPtr)
Arguments:		library = library to verify
Result:			none
-------------------------
SuperState
Description:		engage supervisor mode using user-defined stack
Library:		exec.library
Offset:			-$0096 (-150)
Modula-2 Module:	Interrupts
Syntax:			sysStack = SuperState( )
C:			long SuperState(void)
Machine Language:	d0 = SuperState( ) 
Modula-2:		SuperState( ): ADDRESS 
Arguments:		none 
Result:			sysStack = pointer to system stack; NULL if already in supervisor 
			mode
-------------------------
SwapBitsRastPortClipRect
Description:		engage supervisor mode using user-defined stack
Library:		layers.library
Offset:			-007E (-126)
Modula-2 Module:	Layers
Syntax:			SwapBitsRastPortClipRect(rastPort, clipRect)
C:			void SwapBitsRastPortClipRect(struct RastPort *, struct ClipRect *)
Machine Language:	SwapBitsRastPortClipRect(a0, a1)
Modula-2:		SwapBitsRastPortClipRect(rastPort: RastPortPtr; clipRect:
			ClipRectPtr)
Arguments:		rastPort = RastPort structure
			clipRect = ClipRect to swap bits with
Result:			none
-------------------------
SyncSBitMap
Description:		copies all bits from a layer's ClipRects into the SuperBitMap
Library:		layers.library
Offset:			-01BC (-444)
Modula-2 Module:	Clip
Syntax:			SyncSBitMap(layer)
C:			void SyncSBitMap(struct Layer *)
Machine Language:	SyncSBitMap(a0)
Modula-2:		SyncSBitMap(layer: LayerPtr)
Arguments:		layer = a locked layer that contains a SuperBitMap
Result:			none
-------------------------
Text
Description:		prints text in a RastPort using the current font
Library:		graphics.library
Offset:			-$003C (-60)
Modula-2 Module:	Text
Syntax:			Text(rastPort, string, length)
C:			void Text(struct RastPort *, char *, long)
Machine Language:	Text(a1, a0, d0)
Modula-2:		Text(rastPort: RastPortPtr; string: STRPTR; length: CARDINAL)
Arguments:		rastPort = RastPort where text is to be output
			string = text to print
			length = number of characters in string
Result:			none
-------------------------
Textlength
Description:		finds the length (in bits) that a string of characters would occupy
			if printed to a RastPort using the current text font
Library:		graphics.library
Offset:			-$0036 (-54)
Modula-2 Module:	Text
Syntax:			size = TextLength(rastPort, string, length)
C:			long TextLength(struct RastPort *, char *, long)
Machine Language:	d0 = TextLength(a1, a0, d0)
Modula-2:		TextLength(rastPort: RastPortPtr; string: STRPTR; length: CARDI-
			NAL): CARDINAL
Arguments:		rastPort = RastPort where text would be output
			string = text to print
			length = number of characters in string
Result:			size = number of pixels (horizontally) required to print the speci-
			fied text
-------------------------
ThinLayerInfo
Description:		converts a 1.1 LayerInfo structure into a 1.0 LayerInfo structure,
			thus returning the extra memory allocate by FattenLayerInfo (this
			is an obsolete function)
Library:		layers.library
Offset:			-$00A2 (-162)
Modula-2 Module:	none
Syntax:			ThinLayerInfo(layerInfo)
C:			void ThinLayerInfo(struct Layer_Info *)
Machine Language:	ThinLayerInfo(a0)
Modula-2:		not available
Arguments:		layerInfo = LayerInfo structure to convert
Result:			none
------------------------- 
Translate
Description:		converts an English string into phonetics
Library:		translator.library
Offset:			-$001E (-30)
Modula-2 Module:	Translator
Syntax:			error = Translate(instring, inlen, outbuf, outlen)
C:			long Translate(char *, long, char *, long)
Machine Language:	d0 = Translate(a1, d0, a1, d1)
Modula-2:		Translate(instring: STRPTR; inlen: LONGCARD; outbuf: STRPTR;
			outlen: LONGCARD): LONGINT
Arguments:		instring = English string to convert
			inlen = number of characters in instring
			outbuf = buffer to hold phonetic codes
			outlen = size of outbuf in bytes
Result:			error = 0 if successful; negative number representing position in
			instring where function was forced to stop because the output
			buffer overflowed
-------------------------
TypeOfMem
Description:		determines the attributes of a given memory address
Library:		exec.library
Offset:			-$0216 (-534)
Modula-2 Module:	Memory
Syntax:			attributes = TypeOfMem(address)
C:			long TypeOfMem(void *)
Machine Language:	d0 = TypeOfMem(a0)
Modula-2:		TypeOfMem(address: ADDRESS): MemReqSet
Arguments:		address = memory address
Result:			attributes = type of memory-MEMF_CHIP, MEMF_FAST,
			MEMF_PUBLIC
-------------------------
UnGetCLChar
Description:		adds a byte to the beginning of a character list
Library:		clist.library
Offset:			-$0048 (-72)
Modula-2 Module:	none
Syntax:			error = UnGetCLChar(cList, byte)
C:			long UnGetCLChar(long, long)
Machine Language:	d0 = UnGetCLChar(a0, d0)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
			byte = byte to add to beginning of character list
Result:			error = 0 if successful
-------------------------
UnGetCLWord
Description:		adds a word to the beginning of a character list
Library:		clist.library
Offset:			-$0060 (-96)
Modula-2 Module:	none
Syntax:			error = UnGetCLWord(cList, word)
C:			long UnGetCLWord(long, long)
Machine Language:	d0 = UnGetCLWord(a0, d0)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
			word = word to add to beginning of character list
Result:			error = 0 if successful; 1 if unsuccessful
-------------------------
UnLoadSeg
Description:		removes a segment from memory
Library:		dos.library
Offset:			-$009C (-156)
Modula-2 Module:	DOSLoader
Syntax:			UnLoadSeg(segment)
C:			void UnLoadSeg(BPTR)
Machine Language:	UnLoadSeg(d1)
Modula-2:		UnLoadSeg(segment: BPTR): BOOLEAN
Arguments:		segment = BCPL pointer to a segment as returned by LoadSeg( )
Result:			none
-------------------------
UnLock
Description:		unlocks a directory or file
Library:		dos.library
Offset:			-$005A (-90)
Modula-2 Module:	DOS
Syntax:			UnLock(lock)
C:			void UnLock(BPTR)
Machine Language:	UnLock(d1)
Modula-2:		UnLock(lock: FileLock)
Arguments:		lock = BCPL pointer to a lock
Result:			none
-------------------------
UnlockIBase
Description:		releases the lock on IntuitionBase so Intuition can change the
			structure as it pleases
Library:		intuition.library
Offset:			-$01A4 (-420)
Modula-2 Module:	IntuitionBase
Syntax:			UnLockIBase(lockNumber)
C:			void UnLockIBase(long)
Machine Language:	UnLockIBase(a0)
Modula-2:		UnLockIBase(lockNumber: LONGCARD)
Arguments:		lockNumber = Intuition lock value as returned by LockIBase( )
Result:			none
-------------------------
UnlockLayer
Description:		unlocks a Layer so the graphics routines can use it
Library:		layers.library
Offset:			-$0066 (-102)
Modula-2 Module:	Layers
Syntax:			UnLockLayer(layer)
C:			void UnLockLayer(struct Layer *)
Machine Language:	UnLockLayer(a0)
Modula-2:		UnLockLayer(layer: LayerPtr)
Arguments:		layer = Layer structure to unlock
Result:			none
-------------------------
UnlockLayerInfo
Description:		unlocks a Layer_Info structure
Library:		layers.library
Offset:			-$008A (-138)
Modula-2 Module:	Layers
Syntax:			UnlockLayerInfo(layerlnfo)
C:			void UnlockLayerInfo(struct Layer_Info *)
Machine Language:	UnlockLayerInfo(a0, a1)
Modula-2:		UnlockLayerInfo(layerlnfo: LayerlnfoPtr)
Arguments:		layerlnfo = Layer_Info structure to unlock
Result:			none
-------------------------
UnlockLayerRom
Description:		unlocks a Layer so the graphics routines can use it (this function
			uses ROM code as opposed to LockLayerRom( )'s RAM-based
			code)
Library:		graphics.library
Offset:			-$01B6 (-438)
Modula-2 Module:	RomLayers
Syntax:			UnLockLayerRom(layer)
C:			void UnLockLayerRom(struct Layer *)
Machine Language:	UnLockLayerRom(a5)
Modula-2:		UnLockLayerRom(layer: LayerPtr)
Arguments:		layer = Layer structure to unlock
Result:			none
-------------------------
UnlockLayers
Description:		unlocks all layers so the graphics routines can use them
Library:		layers.library
Offset:			-$0072 (-114)
Modula-2 Module:	Layers
Syntax:			UnLockLayers(layerInfo)
C:			void UnLockLayers(struct Layer_Info *)
Machine Language:	UnLockLayers(a0)
Modula-2:		UnLockLayers(layerInfo: LayerInfoPtr)
Arguments:		layerInfo = Layer_Info structure
Result:			none
-------------------------
UnPutCLChar
Description:		gets a byte from the end of a character list
Library:		clist.library
Offset:			-$0048 (-72)
Modula-2 Module:	none
Syntax:			byte= UnPutCLChar(cList)
C:			long UnPutCLChar(long)
Machine Language:	d0 = UnPutCLChar(a0)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
Result:			byte = byte from end of character list; -1 no data
-------------------------
UnPutCLWord
Description:		gets a word from the end of a character list
Library:		clist.library
Offset:			-$0066 (-102)
Modula-2 Module:	none
Syntax:			word = UnPutCLWord(cList)
C:			long UnPutCLWord(long)
Machine Language:	d0 = UnPutCLWord(a0)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
Result:			word = word from end of character list; -1 if no data
-------------------------
UpFrontLayer
Description:		moves a layer in front of all other layers
Library:		layers.library
Offset:			-$0030 (-48)
Modula-2 Module:	Layers
Syntax:			success = UpFrontLayer(dummy, layer)
C:			long UpFrontLayer(struct Layer_Info *, struct Layer *)
Machine Language:	d0 = UpFrontLayer(a0, a1)
Modula-2:		UpfrontLayer(layer: LayerPtr): BOOLEAN
Arguments:		dummy = unused
			layer = pointer to Layer to move behind other layers
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
UserState
Description:		return to user state and system stack (do NOT call if computer is
			already in user state)
Library:		exec.library
Offset:			-009C (-156)
Modula-2 Module:	Interrupts
Syntax:			UserState(sysStack)
C:			void UserState(char *)
Machine Language:	UserState(d0)
Modula-2:		UserState(sysStack: ADDRESS)
Arguments:		sysStack = system stack pointer as returned by SuperState( )
Result:			none
-------------------------
Vacate
Description:		releases a semaphore locked by Procure( )
Library:		exec.library
Offset:			-$0222 (-546)
Modula-2 Module:	Semaphores
Syntax:			Vacate(semaphore)
C:			void Vacate(struct Semaphore *)
Machine Language:	Vacate(a0)
Modula-2:		Vacate(semaphore: SemaphorePtr)
Arguments:		semaphore = Semaphore structure to release
Result:			none
-------------------------
VBeamPos
Description:		returns the current position of the vertical video beam
Library:		graphics.library
Offset:			-$0180 (-384)
Modula-2 Module:	Views
Syntax:			pos = VBeamPos( )
C:			long VBeamPos(void)
Machine Language:	d0 = VBeamPos( )
Modula-2:		VBeamPos( ): CARDINAL
Arguments:		none
Result:			pos = current beam position (0-511)
-------------------------
ViewAddress
Description:		returns the address of Intuition's View structure
Library:		intuition.library
Offset:			-$0126 (-294)
Modula-2 Module:	Intuition
Syntax:			view = ViewAddress( )
C:			struct View *ViewAddress(void)
Machine Language:	d0 = ViewAddress( )
Modula-2:		ViewAddress( ): ViewPtr
Arguments:		none
Result:			view = address of the Intuition View structure
------------------------- 
ViewPortAddress
Description:		returns the address of a window's ViewPort structure
Library:		intuition.library
Offset:			-$012C (-300)
Modula-2 Module:	Intuition
Syntax:			viewPort = ViewPortAddress(window)
C:			struct ViewPort *ViewPortAddress(struct Window *)
Machine Language:	d0 = ViewPortAddress(a0)
Modula-2:		ViewPortAddress(window: WindowPtr): ViewPortPtr
Arguments:		window = Window structure
Result:			viewPort = address of window's ViewPort structure
-------------------------
Wait
Description:		waits for one or more signals
Library:		exec.library
Offset:			-$013E (-318)
Modula-2 Module:	Tasks
Syntax:			signals = Wait(signalSet)
C:			long Wait(long)
Machine Language:	d0 = Wait(d0)
Modula-2:		Wait(signalSet: SignalSet): SignalSet
Arguments:		signalSet = set of signals to wait for
Result:			signals = signals that have occurred
-------------------------
WaitBlit
Description:		waits for the blitter to finish what it's doing
Library:		graphics.library
Offset:			-$00E4 (-228)
Modula-2 Module:	Blitter
Syntax:			WaitBlit( )
C:			void WaitBlit(void)
Machine Language:	WaitBlit( )
Modula-2:		WaitBlit( )
Arguments:		none
Result:			none
------------------------- 
WaitBOVP
Description:		waits for the vertical beam to reach the bottom of a ViewPort
Library:		graphics.library
Offset:			-$0192 (-402)
Modula-2 Module:	Views
Syntax:			WaitBOVP(viewPort)
C:			void WaitBOVP(struct ViewPort *)
Machine Language:	WaitBOVP(a0)
Modula-2:		WaitBOVP(viewPort: ViewPortPtr)
Arguments:		viewPort = ViewPort structure
Result:			none
-------------------------
WaitForChar
Description:		waits a specified amount of time for a character to become avail-
			able from a virtual terminal
Library:		dos.library
Offset:			-$00CC (-204)
Modula-2 Module:	DOS
Syntax:			avail = WaitForChar(file, timeout)
C:			long WaitForChar(BPTR, long)
Machine Language:	d0 = WaitForChar(d1, d2)
Modula-2:		WaitForChar(file: FileHandle; timeout: LONGINT): BOOLEAN
Arguments:		file = BCPL pointer to a file handle
			timeout = number of microseconds to wait for character
Result:			avail = TRUE if a character is available
-------------------------
WaitIO
Description:		waits for an I/O request to be executed
Library:		exec.library
Offset:			-$01DA (-474)
Modula-2 Module:	IO
Syntax:			error = WaitIO(ioRequest)
C:			long WaitIO(struct IORequest *)
Machine Language:	d0 = WaitIO(a1)
Modula-2:		WaitIO(ioRequest: ADDRESS): INTEGER
Arguments:		ioRequest = IORequest block
Result:			error = 0 if successful
-------------------------
WaitPort
Description:		waits for a message
Library:		exec.library
Offset:			-$0180 (-384)
Modula-2 Module:	Ports
Syntax:			message = WaitPort(port)
C:			struct Message *WaitPort(struct MsgPort *)
Machine Language:	d0 = WaitPort(a0)
Modula-2:		WaitPort(port: MsgPortPtr): ADDRESS
Arguments:		port = message port to receive message
Result:			message = pointer to first available message
-------------------------
WaitTOF
Description:		waits for the next vertical blank
Library:		graphics.library
Offset:			-$010E (-270)
Modula-2 Module:	Views
Syntax:			WaitTOF( )
C:			void WaitTOF(void)
Machine Language:	WaitTOF( )
Modula-2:		WaitTOF( )
Arguments:		none
Result:			none
-------------------------
WBenchToBack
Description:		moves the Workbench screen behind all other screens
Library:		intuition.library
Offset:			-$0150 (-336)
Modula-2 Module:	Intuition
Syntax:			success = WBenchToBack( )
C:			long WBenchToBack(void)
Machine Language:	d0 = WBenchToBack( )
Modula-2:		WBenchToBack( ): BOOLEAN
Arguments:		none
Result:			success = TRUE if Workbench screen is open
-------------------------
WBenchToFront
Description:		moves the Workbench screen in front of all other screens
Library:		intuition.library
Offset:			-$0156 (-342)
Modula-2 Module:	Intuition
Syntax:			success = WBenchToFront( )
C:			long WBenchToFront(void)
Machine Language:	d0 = WBenchToFront( )
Modula-2:		WBenchToFront( ): BOOLEAN
Arguments:		none
Result:			success = TRUE if Workbench screen is open
-------------------------
WhichLayer
Description:		finds the layer which contains the specified point
Library:		layers.library
Offset:			-$0084 (-132)
Modula-2 Module:	Layers
Syntax:			layer = WhichLayer(layerlnfo, x, y)
C:			struct Layer *WhichLayer(struct Layer_Info *, long, long)
Machine Language:	d0 = WhichLayer(a0, d0, d1)
Modula-2:		WhichLayer(layerlnfo: LayerlnfoPtr; x, y: LONGCARD): LayerPtr
Arguments:		layerlnfo = Layerlnfo structure
			x = horizontal coordinate of point
			y = vertical coordinate of point
Result:			layer = pointer to top-most layer containing this point; NULL if
			point is not in a layer
-------------------------
WindowLimits
Description:		sets the minimum and maximum size of a window
Library:		intuition.library
Offset:			-$013E (-318)
Modula-2 Module:	Intuition
Syntax:			success = WindowLimits(window, minWidth, minHeight,
			maxWidth, minHeight)
C:			long WindowLimits(struct Window *, long, long, long, long)
Machine Language:	d0 = WindowLimits(a0, d0, d1, d2, d3)
Modula-2:		WindowLimits(window: WindowPtr; minWidth, minHeight,
			maxWidth, maxHeight: LONGINT): BOOLEAN
Arguments:		window = window to set size limits for
			minWidth = window's new minimum width
			minHeight = window's new minimum height
			maxWidth = window's new maximum width
			maxHeight = window's new minimum height
Result:			success = TRUE if all limits are set; FALSE if any of the limits are
			out of range, in which case only the legal limits are set
-------------------------
WindowToBack
Description:		moves a window to the back of all other windows
Library:		intuition.library
Offset:			-$0132 (-306)
Modula-2 Module:	Intuition
Syntax:			WindowToBack(window)
C:			void WindowToBack(struct Window *)
Machine Language:	WindowToBack(a0)
Modula-2:		WindowToBack(window: WindowPtr)
Arguments:		window = window to move to back of display
Result:			none
-------------------------
WindowToFront
Description:		moves a window in front of all other windows
Library:		intuition.library
Offset:			-$0138 (-312)
Modula-2 Module:	Intuition
Syntax:			WindowToFront(window)
C:			void WindowToFront(struct Window *)
Machine Language:	WindowToFront(a0)
Modula-2:		WindowToFront(window: WindowPtr)
Arguments:		window = window to move to front of display
Result:			none
-------------------------
Write
Description:		writes bytes of data to a file
Library:		dos.library
Offset:			-$0030 (-48)
Modula-2 Module:	DOS
Syntax:			length = Write(file, buffer, length)
C:			long Write(BPTR, char *, long)
Machine Language:	d0 = Write(d1, d2, d3)
Modula-2:		Write(file: FileHandle; buffer: ADDRESS; length: LONGINT):
			LONGINT
Arguments:		file = BCPL pointer to a file handle
			buffer = pointer to start of buffer containing data to write
			length = number of bytes to write
Result:			length = number of bytes successfully written; -1 if error
			occurred
-------------------------
WriteExpansionByte
Description:		writes a byte to a new-style memory expansion board-nybble by
			nybble
Library:		expansion.library
Offset:			-$0072 (-114)
Modula-2 Module:	Expansion
Syntax:			error = WriteExpansionByte(board, offset, byte)
C:			long WriteExpansionByte(long, long, long)
Machine Language:	d0 = WriteExpansionByte(a0, d0, d1)
Modula-2:		WriteExpansionByte(board: ADDRESS; offset: LONGCARD; byte:
			BYTE): BOOLEAN
Arguments:		board = base of a new-style expansion board
			offset = logical offset from the configdev base
			byte = byte to write to board
Result:			error = 0 if successful
-------------------------
WritePixel
Description:		colors a single pixel with the current foreground drawing pen
Library:		graphics.library
Offset:			-$0144 (-324)
Modula-2 Module:	Pens
Syntax:			error = WritePixel(rastPort, x, y)
C:			long WritePixel(struct RastPort *, long, long)
Machine Language:	d0 = WritePixel(a1, d0, d1 )
Modula-2:		WritePixel(rastPort: RastPortPtr; x, y: INTEGER): INTEGER
Arguments:		rastPort = RastPort structure containing pixel to color
			x = horizontal coordinate of pixel
			y = vertical coordinate of pixel
Result:			error = 0 if successful; -1 if pixel is outside specified RastPort
-------------------------
XorRectRegion
Description:		performs a 2d XOR operation of a rectangle with a region, leaving
			the results in the region
Library:		graphics.library
Offset:			-$022E (-558)
Modula-2 Module:	Regions
Syntax:			status = XorRectRegion(region, rectangle)
C:			long XorRectRegion(struct Region *, struct Rectangle *)
Machine Language:	d0 = XorRectRegion(a0, a1)
Modula-2:		XorRectRegion(region: RegionPtr; rectangle: RectanglePtr):
			BOOLEAN
Arguments:		region = Region structure
			rectangle = Rectangle structure
Result:			status = TRUE if successful; FALSE if out of memory
-------------------------
XorRegionRegion
Description:		performs a 2d XOR operation of one region with a second region,
			leaving the results in the second region
Library:		graphics.library
Offset:			-$026A (-618)
Modula-2 Module:	Regions
Syntax:			status = XorRegionRegion(region1, region2)
C:			long XorRegionRegion(struct Region *, struct Region *)
Machine Language:	d0 = XorRegionRegion(a0, a1)
Modula-2:		XorRegionRegion(region1, region2: RegionPtr): BOOLEAN
Arguments:		region1 = Region structure
			region2 = Region structure
Result:			status = TRUE if successful; FALSE if out of memory
-------------------------