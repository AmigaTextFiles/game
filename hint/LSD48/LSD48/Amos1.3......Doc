Created by HyperEdit

The Amos AmigaGuide help file main subjects:
--------------------------------------------

THE AMOS EMAIL LIST
THE AMOS PROCEDURE LIBRARY
THE AMOS TEAM
SFX SITE

AMOS 1.3 COMMANDS
THE AMOS 1.3 EDITOR

AMOS PRO COMPILER

HINTS AND TIPS
BUGS

    Address: amos-list@ccess.digex.net 
 
    Purpose: For the AMOS programming language on Amiga computers.
    Features source, bug reports, and help from users around the
    world, but mainly European users.  Most posts will be in English
    but there are no limitations to the language used, since AMOS
    is very popular in most European countries.



Programing subject:
  GRAPICS
  SYSTEM
  AMAL

NON PROGRAMING TIPS

PROCESSOR TYPE
PAL-NTSC
VARPTR

Date: 17 Jun 93 18:15:00 EST
From: "Andrew Church" <95ACHURCH@ax.mbhs.edu>
Subject: Re: Processor type
To: "amos-list" <amos-list@ccess.digex.net>

  To find out the type of processor being used, look at the word at offset
296 in ExecBase [=Deek(Leek(4)+296)].  The bits are as follows:

Processor:
  Bit 0 = 68010 or better
      1 = 68020 or better
      2 = 68030 or better
      3 = 68040 or better

Co-processor:
  Bit 4 = 68881 or better
  Bit 5 = 68882 or better

  So, to determine the actual processor, find the highest set bit in each
field.  That bit indicates the processor.

  --Andy Church


Date: Mon, 12 Jul 93 15:46 GMT0BST-1
From: Phil South <snouty@ix.compulink.co.uk>
Subject: Amos Pro Compiler
To: amos-list@ccess.digex.net



This full review will be appearing in Amiga Computing. Or at least a
version of it. Enjoy, my fellow AMOS fiends, or should that be
friends? No I like fiends.

Phil

-------------

Review

AMOS Professional Compiler

Phil South reviews the latest addition to the AMOS family, but when
all the dust settles is it any cop?

This is the AMOS product that's perhaps been more hotly debated and
more eagerly awaited than just about any other. The thing is that
AMOS as a development system was pretty much perfect, and the only
thing missing from Pro, apart from a really good bug fixed version,
was the compiler.
        Now don't get me wrong, I know I'm always banging on about
how Pro is buggy but that's not because it's completely no good. No
no no. It's just that it's at the stage that AMOS was a few years ago 
when it first came out. It just needs a lot of use before all the
bugs in the new features can be ironed out.
        You see AMOS Pro is actually still the basic AMOS program you 
know and love, but there's been a lot of augmentation, and it'll take 
a while for the code to settle down after all the additions have been 
used a lot and all the bugs ironed out. But it will happen, and truth 
be told I'm going to start using Pro a lot more now. I know I said it 
would take a while to make me switch from AMOS Classic, and I know
I'll still have that to fall back on should Pro let me down. But it's 
time to start having a little faith in the new program, and helping
to iron out bugs rather than just sitting here griping about them

New Compiler Old Compiler
The same things I just said about the Pro compiler are true about Pro 
Compiler. It's still basically the same engine under the hood, just a 
new 1993 body and few technical enhancements which affect the way the 
thing drives, a bit like a Mondeo.
        The face is different, that is to say that the front end
program is much altered, and it runs from an icon rather than being
loaded into AMOS, but I guess this just means that the program has
been compiled. The compiler works with previous versions of the AMOS
program like AMOS and Easy AMOS, so you can buy the new compiler even 
if you don't yet have the newest version of the language.

New Commands
The compiler obviously copes with all the new versions of AMOS Pro
and all the new commands which have been added to the language since
the last compiler was built. This obviously takes in all the ANIM
player commands and music player commands too, and the library for
compiled programs to share means small programs if the target
computer for your programs is running the correct amos.library. Even
though you should use the shared library setting if you want to be
sure people can run your programs, this is a big saving on size and
so should be considered if you know everyone who'll be using your
code.
        You can do the usual squash command to compress the files,
but you know every time I use this something goes wrong, not just in
Compiler Pro but in the old Compiler too. I tend to forget that and
use PowerPacker for online compression and decompression. The remove
default screen problem is still there too. If you program uses and
unpack command then the screen is automatically created into your
default screen right? But if there is no default screen the screen
can't be created, so no go.
        You can also load in ASCII files for compilation, which is
handy if you want to develop your programs on a laptop or palmtop
word processor and transfer them for compilation. (I could use my
trusty Portfolio, even!) There is talk too of this compiler being
even faster than the original compiler. That is very hard to test,
and really I couldn't see any difference. (If anyone at Europress can 
send me a reliable benchmark program, I'll be happy to run it, if not 
print it in the next issue!) But the program sizes were very
different with a shared library. 61K including library plays 18k
without. Not bad, but not totally portable to any machine which
doesn't run the amos.library, so not really as good as a fully
optimised compiler which would not include any commands not used in
the program itself.

Free AMOS Pro 2.0
The program comes free with an updater to make your you have the
latest version of AMOS Pro on your machine. I must admit I found this 
a little bit odd. I installed the AMOS Pro program about 10 seconds
before I tried to use the updater, and I got an error message saying
I needed to use the correct path. I was using the correct path,
dammit, and I couldn't get it to change it's tune, so I killed it and 
installed to floppies, then RE-INSTALLED the new version to hard
disk. This got up my nose more than a little, but I still can't
figure out what the problem was.

Conclusion
Despite all these niggles and quibbles I do think the release of this 
program should be applauded, for no other reason than it allows us
serious AMOS users to put our backs into it and see if AMOS Pro
really has what it takes to be the Amiga development system of the
90s.
        Obviously seasoned users will see that this is not anything
new, but rather an upgrade of what has gone before. It's a tool, it
does the job, but as my old man would say "if I wanted something to
write home about I'd have been to the circus." Funny chap, my old
man.


(ENDS)


AMOS 3D
BITPLANES

OM FILEFORMAT

The om fileformat can be found in the file SimStructs on the object modeller disk

AMOS PRO CONFIG FILE

Date: 7 Sep 93 14:32:00 EST
From: "Andrew Church" <95ACHURCH@ax.mbhs.edu>
Subject: Re: Configuration
To: "amos-list" <amos-list@ccess.digex.net>

>What is the name, and location of the configuration file used by AMOS
>Pro? I added an extension, it won't run now, etc. I'm sure there are
>lots of people out there who have had this same problem.

  It's S:AMOSPro_Interpreter_Config.

  --Andy Church


Date: 12 Sep 93 11:41:00 EST
From: "Andrew Church" <95ACHURCH@ax.mbhs.edu>
Subject: Re: PAL/NTSC
To: "amos-list" <amos-list@ccess.digex.net>

>Is there an OS call to change between NTSC and PAL? Or would it be easier
>to Poke something? It can't be too hard, Mode_Switch is only 4K... can
>someone help?

  Just Doke $DFF1DC,x.  For NTSC, x=0; for PAL, x=$20.

  Note that this only works on ECS systems (and probably AGA, although I
haven't been able to test it).

  --Andy Church


MATH
MENUS

Date: 15 Sep 93 12:08:00 EST
From: "Andrew Church" <95ACHURCH@ax.mbhs.edu>
Subject: Re: Amos bugs, and thankyous
To: "amos-list" <amos-list@ccess.digex.net>

>  Another bug I found is with the arccos function (hold on...but you don't NEED
>arccos for vectors.....well, tis fixed now but still).  When you feed in very
>small values (order of about 1*10^-7) it returns ludicrous values.  tsk tsk!

  It seems that a lot of the transcendental functions give bad return values
in certain cases.  Try Cos(90) and see what you get.  It's not 0, but
something like 10^-7, which was enough to make my vertical lines diagonal.

[18-line signature deleted]

  Please, don't get carried away!  Signatures are fine, but not HUGE ones!

  --Andy Church


(DE)ACCELERATION

From: Mikko Makela <mmmakela@c.helsinki.fi>
Message-Id: <199309151748.AA05528@ruuna.helsinki.fi>
Subject: AMAL-routine
To: amos-list@ccess.digex.net
Date: Wed, 15 Sep 1993 20:48:22 +0300 (EET DST)

Quite many of you showed interest with this, so I'm sending
this to the list (it's < 2k).
I decided to make litle demonstration program out of it, just
to make it easier to understand.

--------------------cut here-------------------

'This is a small demo program to show, how to use AMAL's Move-command
'for (de)acceleration of objects.

'Programmed by Mikko Mdkeld

BALL=4 : Rem amount of balls
_TOPSPEED=200 : LOWEST_POSSIBLE_STEPCOUNT=4
'R2 must not > RB (topspeed) 
'RC will tell the lowest possible number of steps in movement. 
Amreg(1)=_TOPSPEED : Amreg(2)=LOWEST_POSSIBLE_STEPCOUNT

   'if ball hits the wall, main program will set R4=1, so 
   'that the Move command will be initiliazed.
A$="AUtotest (If R4=1 Jump Wall "
   'if ball must be stopped, R3 will be set to 1, and 
   'to continue the movement R3->2  
A$=A$+"If R3=1 Jump Hold ;If R3=2 Jump Go on "
   'R2 will be decreased every time the autotest is run, and
   'if it's <1, ball will be stopped. 
   'R2 is also used to count in how many steps will the movement be done. 
A$=A$+"If R2<1 Direct Owait else Let R2=R2-1 eXit "
A$=A$+"Wall:Let R4=0 Direct Begin "
A$=A$+"Hold:Direct Sleep; Go on:Let R3=0 Direct Begin)"
   'Here is the Move command
A$=A$+"Begin:If R2<1 Jump Owait; Move R0,R1,RC*RB/R2; Jump Begin "
A$=A$+"Sleep:Wait ;Owait: If R2>0 J Begin Pause J Owait "

'let's make an boject to move
Circle 100,100,7 : Paint 100,100 : Get Bob 0,1,90,90 To 111,111 : Cls 1

'init each ball
For L=0 To BALL-1
   Channel L To Bob L
   Bob L,80+L*15,80+L*15,1
   Amal L,A$
   Amreg(L,4)=1
Next L
'try different values for speed,range & angle
RSPEED=5000
RANGE=50
ANGLE#=3.3
For L=0 To BALL-1
   Amreg(L,0)=RANGE*Cos(ANGLE#-L*0.1) : Rem x-movemnt
   Amreg(L,1)=RANGE*Sin(ANGLE#-L*0.1) : Rem y-movement 
   Amreg(L,2)=RSPEED/RANGE+1 : Rem speed
   Amreg(L,3)=0 : Rem just to make sure
   Amreg(L,4)=1 : Rem to init movementsequence 
Next L

Synchro Off : Amal On 
Repeat 
   For L=0 To BALL-1
      'test for left screenborder
      If X Bob(L)<1
         Amreg(L,0)=-Amreg(L,0)
         Amreg(L,4)=1
         Bob L,0,,
      End If 
   Next L
   'try without wait! 
   Wait 2
   Synchro 
Until Amreg(0,2)<1
End 



  The AMOS Procedure Library is a library of procedures for use in AMOS
programs.  (Surprise, surprise... :-) )  The procedures were submitted to me
by various people on the AMOS list.  They can be easily merged into your
AMOS programs to save you the time of writing them yourself.  The latest
version of the Procedure Library can be found on AmiNet as
dev/amos/ProcLib20.lha .

  I accept any kind of procedure, large or small.  However, Paul Hickman
came up with the concept of Screen Eaters at one point - routines which
clear the screen in interesting ways.  I was hoping to see some more of
those (hint, hint), and possibly their counterparts, Screen Vomiters.

Date: 1 Oct 93 12:06:00 EST
From: "Andrew Church" <95ACHURCH@ax.mbhs.edu>
Subject: Procedure Library v1.0
To: "amos-list" <amos-list@ccess.digex.net>

  I am in the process of uploading the initial release of the AMOS Procedure
Library to AMINET.  I've run into some problems, but I expect the library to
be available in 2-3 days.  The file is:

/pub/AMINET/dev/amos/ProcLib.lha

  Below is the list of procedures in the library. (ver 1.0)
  A recent list should be sent to THE AMOS EMAIL LIST as soon as it is ready.

  --Andy Church
----------------------------
_DOSERROR[ERR]
  Returns the AmigaDOS error message for the given error code.
_FAST_ELLIPSE[XC,YC,RX,RY,_FILLED]
  Draws an ellipse using integer math.
_FAST_LINE[X1,Y1,X2,Y2]
  Draws a line using integer math.
_MAKEMASK[_SCREEN,_COLOUR,TEMP1,TEMP2,X1,Y1,X2,Y2,_ICON]
  Makes a mask for an icon with a given transparent colour.
OPENFONT[NAME$,SIZE,_REM]
  Opens or closes a font.
_PALETTE_TO_ANTIQUE[_SCREEN]
  Converts palette to "antique photograph" colours.
_PALETTE_TO_BW[_SCREEN]
  Converts palette to black and white.
_PALETTE_TO_NEGATIVE[_SCREEN]
  Converts palette to negative colours.
_SEPARATE_RGB[_SCREEN,X]
  Filters colours in picture.
_SHADOW_TXT[X,Y,_FG,_BG,_TXT$]
  Writes shadowed text to the screen.
_TO_NTSC
  Switches display to NTSC mode.
_TO_PAL
  Switches display to PAL mode.


Date: 21 Sep 93 17:40:00 EST
From: "Andrew Church" <95ACHURCH@ax.mbhs.edu>
Subject: Procedure library (again)
To: "amos-list" <amos-list@ccess.digex.net>

  When you send me a procedure for inclusion in the library, please also
include a short "readme" file (like those on AMINET) that describes what the
procedure's function is.  If possible, I'd also like an example program that
I can use to test the procedure, just to make sure it works.

  I'd prefer that you use the following format for your readme file:

[Required items]
NAME_OF_PROCEDURE
  Description   : A short description of the procedure's function.  1 or 2
                      sentences should be enough in most cases.
  Calling format: How to call the procedure, and what its parameters are.  E.g.
                  MYPROC[num1,num2,sumadr]
                      num1,num2 - numbers to work with
                      sumadr    - ADDRESS of sum (use Varptr())
  Return value  : What your procedure returns.  If none, write "None".
  Author        : Your name, and your e-mail address.
[Optional item]
  Special notes : If your procedure only works with AMOS Pro, or if it requires
                      a special library, or another procedure, say so here.  If
                      there's anything else you think I should know, put that
                      here too.

  --Andy Church


team@lick.clare.tased.edu.au

Date: 22 Sep 1993 17:36:23 -0500 (EST)
From: Tom Plackowski <tom@lms.concept.com.au>
Subject: Re: SoundFX

>Hello, I need some SFX (fairley small if possible) for my game.
>Some good explosions, missile and changun sounds, and the sound of
>a helicopters rotor.

>Does anyone have or know where I can get sounds like these?

Have a poke around at:

      SOUNDS.SDSU.EDU

This is their readme:

This is the brand new (well, almost...) machine which will provide access
to the sun sounds archive.

All sounds are in /sounds.

ATTENTION FRIENDLY HELPFUL ARCHIVE USERS:
I am in need of some help.  As you will notice, each directory now contains
a file called 'INDEX' which is a list of the sounds in that directory
with an optional description.  This discription is to be gotten from the
header of the sound file.  My request is: Most sounds do not have an sort
of info with them.  Could you be so kind to send me some descriptions of
sounds so that I can add them to the headers?  This would really help out
me and other people as well.
The INDEX files are generated nightly by a program I wrote called soundinfo
This program is also available for anonymous ftp in /pub/soundinfo.shar
It also allows one to change the header info string of a sound.

If you have a request for a certain song, please don't mail the request to
me since I am not very likely to have the song on CD.  However, you put
requests in the /sound_requests directory.  If everyone with record
abilities will look in that directory every once in a while and record
some of the requested sounds, it would make a lot of people a lot happier.
(If you do upload a sound that was requested, please remove the original
request, so multiple people do not upload the same sound...)

If you want to know how to play these sounds, how to convert them, or
how to annoy other people with them, please read the README.sounds
file in this directory.

As always keep those sounds coming!
Always upload new sounds in /incoming, please.
I would very much like to expand the database of sound effects, cartoon
sounds and things like that, so if you have some, upload them!

If you have questions/comments/money, send mail to turtle@ciences.sdsu.edu

--Andrew
____________________________________________________________________________
Andrew "Race Turtle" Scherpbier, SysMgr
College of Sciences
San Diego State University
turtle@ciences.sdsu.edu
Voice: (619) 594-5026
Fax:   (619) 594-6381


// Tom

From: sfmcnally@IX.com
Subject: Bitplanes
To: amos-list@ccess.digex.net

Well, bitplanes are how all graphics on the Amiga are stored.
(If you understand Binary numbers it's quite simple)

Every image is made up of a number of bitplanes according to how many
colors it uses, 1 bitplane for 2 colors, 2 planes for 4 colors,
3 planes for 8 colors, and 5 and 6 planes for 32 and 64 colors.
(You can allso go to 7 and 8 planes for 128 and 256 colors on AGA
machines)

In every bitplane, one bit represents one pixel, so a byte (8 bits)
of a bitplane would be 8 pixels across.
At it's simplest, with one bit plane wherever there's a set bit 
in the bitplane that pixel will be in color 1, a binary 0 in
one of the bits means color 0 at that pixel.

To get more colors the system adds up the bits of all the planes
at a certian pixel and that makes the color number.
Say at pixel A plane 1 is set to 0, plane 2 is set to 1, and plane
3 is set to 1, combining those will make the binary number %011
which is 6 in normal numbers, so at that pixel there would be
color 6.

Now to change the colors of bobs you can tell the blitter NOT
to draw certian planes, so if in the above example you told the
blitter NOT to draw plane 2 the color would be %001, or 4.

Now for a turtle on a 16 color screen, you should draw the turtle
images in color 15, 15 is %1111 in binary, so then you can change
the turtle to ANY color JUST by not drawing certian combinations
of planes on the screen!   :)

Lets see...  ::going for manual::

Ok, if you have a bob drawn in color 15, on a 16 color screen,
this bit of code will draw the bob in color "COLOR":

Set Bob 1,,COLOR,
Bob 1,X,Y,TURTLE_IMAGE


Where turtle_image is the image number for the turtle.


:)

Seumas

                    ------------------------

Date: 27 Sep 93 21:23:00 EST
From: "Andrew Church" <95ACHURCH@ax.mbhs.edu>
Subject: Re: Bitplanes
To: "amos-list" <amos-list@ccess.digex.net>

  A little clarification here...

>In every bitplane, one bit represents one pixel, so a byte (8 bits)
>of a bitplane would be 8 pixels across.
>At it's simplest, with one bit plane wherever there's a set bit 
>in the bitplane that pixel will be in color 1, a binary 0 in
>one of the bits means color 0 at that pixel.

  This is right.  However...

>To get more colors the system adds up the bits of all the planes
>at a certian pixel and that makes the color number.
>Say at pixel A plane 1 is set to 0, plane 2 is set to 1, and plane
>3 is set to 1, combining those will make the binary number %011
>which is 6 in normal numbers, so at that pixel there would be
>color 6.

  This is wrong -- you're numbering the planes backwards.  What you should
have said is this:

Say at pixel A plane *2* is set to 0, plane *1* is set to 1, and plane
*0* is set to 1, combining those...

  The plane number is the same as the bit number in the colour.  So plane 0
corresponds to bit 0 (the least significant bit), plane 1 corresponds to bit
1, etc.

  You also don't know as much about binary as you seem to think you know.  The
binary number 011 is equal to 3 in decimal (0*2^2 + 1*2^1 + 1*2^0 = 0+2+1 = 3).

>Now to change the colors of bobs you can tell the blitter NOT
>to draw certian planes, so if in the above example you told the
>blitter NOT to draw plane 2 the color would be %001, or 4.
                                                      ^^^^ NO!!! 1, not 4!!!

  You'd tell it not to draw plane 1 in order to get %001 from the above case.
That is, you'd use "Set Bob N,,%11111101," where N is your bob number.

  --Andy Church


Date: 27 Sep 93 21:34:00 EST
From: "Andrew Church" <95ACHURCH@ax.mbhs.edu>
Subject: Re: Use of Varptr
To: "amos-list" <amos-list@ccess.digex.net>

>  Last night I was stuffing around with passing Varptr's as parameters to
>procedures, trying to pass the address of an array of floating point numbers.
>The problem is that I couldn't just Poke(Varptr(ARRAY)+OFFSET) to get to
>ARRAY(OFFSET).  I noticed that each successive Varptr was 4 units apart, and
>this morning I realized why the values I Poked weren't what was stored.
>  So could someone tell me 

>* How to use Varptr, Poke and Peek to store (properly) and read from an array
>  of integers?

  Writing: Loke Varptr(ARRAY(0))+ELEMENT*4,_VALUE
  Reading: _VALUE=Leek(Varptr(ARRAY(0))+ELEMENT*4)

where ELEMENT is the element number you're using, just like ARRAY(ELEMENT).

  Of course, this is only useful if you've passed the array address, as in

_PROCEDURE[Varptr(ARRAY(0))]

since otherwise you can just use _VALUE=ARRAY(ELEMENT).

>* How to use Varptr, Poke and Peek to store (properly) and read from an array
>  of floats? (Ie, the set up of the float, such as the mantissa length...that
>  sort of garbage, and where they are stored wrt the array's adress).

  They're also stored as 4-byte values, so use the same scheme I described
above to access them.

  The format depends on whether you're using Creator or Pro.  Creator uses FFP:

  31                     876     0
  | - - - mantissa - - - |S| exp |

where m is the mantissa (with an assumed binary point after the first digit),
S is the sign bit and exp is the bias-64 exponent.  In other words,
    exp = exponent+64

  Pro, on the other hand, uses IEEE single-precision.  I'm not entirely sure
about the format for IEEE floats.  If you use Set Double Precision, that
switches Pro to 8-byte double-precision floats, which is something completely
different.

  --Andy Church


Subject: Menus & multitasking
To: amos-list@ccess.digex.net
Date: Tue, 5 Oct 1993 10:44:22 +0200 (EET)

I think I found bug in AMOS menus.
If I try something like this:

Screen Close 0
BEGIN:
Screen Open 0,320,200,16,Lowres
Menu$(1)="First menu"
Menu On 
Wait Key 
Menu Off 
Screen Close 0
Screen Open 1,320,200,16,Lowres
Print "This is screen 1"
Wait Key 
Screen Close 1
Goto BEGIN

...and while the program is running, go to WB, and close a window or
screen, the AMOS program will give "Screen not opened"-error.
Is this a bug, or is there something I should know about using menus
with temporary screens ?

Mikko


Aminet is a huge colection of amiga pd stuff, it is mirrowed to a lot 
places here is a list:

Country           Site                                        Directory
SCANDINAVIA       ftp.luth.se                                 pub/aminet/
SWITZERLAND       amiga.physik.unizh.ch                       pub/aminet/
SWITZERLAND       litamiga.epfl.ch                            pub/aminet/
GERMANY           ftp.uni-kl.de                               pub/aminet/
GERMANY           ftp.cs.tu-berlin.de                         pub/aminet/
GERMANY           ftp.th-darmstadt.de                         pub/aminet/
USA               ftp.etsu.edu                                pub/aminet/
USA               ftp.wustl.edu                               pub/aminet/
USA               oes.orst.edu                                pub/aminet/
 



'                             (AMAL FUNCTION)  =BOB COL(N,S,E)
(AMAL FUNCTION)  =C(N)        (AMAL FUNCTION)  =J0
(AMAL FUNCTION)  =J1          (AMAL FUNCTION)  =K1
(AMAL FUNCTION)  =K2          (AMAL FUNCTION)  =SPRITE COL(N,S,E)
(AMAL FUNCTION)  =V(V)        (AMAL FUNCTION)  =XH (S,X)
(AMAL FUNCTION)  =XM          (AMAL FUNCTION)  =XS(S,X)
(AMAL FUNCTION)  =YH (S,Y)    (AMAL FUNCTION)  =YM
(AMAL FUNCTION)  =YS(S,X)     (AMAL FUNCTION)  =Z(N)
(AMAL)  AUTOTEST              (AMAL)  ANIM
(AMAL)  END                   (AMAL)  FOR TO NEXT
(AMAL)  IF                    (AMAL)  JUMP
(AMAL)  LET                   (AMAL)  MOVE
(AMAL)  PLAY                  (AMAL)  PAUSE
(BOB)  PRIORITY REVERSE ON-OFF=COLOUR
=WINDON                       ABS
ACOS                          ADD
AMAL FREEZE                   AMAL OFF
AMAL ON                       AMAL
AMALERR                       AMOS HERE
AMOS LOCK                     AMOS TO BACK
AMOS TO FRONT                 AMOS UNLOCK
AMPLAY                        AMREG
ANIM FREEZE                   ANIM OFF
ANIM ON                       ANIM ON-OFF
ANIM                          APPEAR
APPEND                        AREG
ASC                           AT
ATAN                          AUTO VIEW
AUTOBACK                      AMAL IMPORTANT INFO
AUTHOR NOTE ON =COL(BOB)      BANK SWAP
BANK TO MENU                  BAR
BCHG                          BCLR
BELL                          BGRAB
BIN$                          BLOAD
BOB CLEAR                     BOB COL
BOB DRAW                      BOB OFF
BOB UPDATE                    BOB
BOB/SPRITE FLIPPING           BOBSPRITE COL
BOOM                          BORDER
BORDER$                       BOX
BREAK OFF                     BREAK ON
BREAK ON-OFF                  BSAVE
BSET                          BTST
CALL                          CDOWN
CDOWN$                        CENTRE
CHANAN                        CHANGE MOUSE
CHANMV                        CHANNEL N TO BOB B
CHANNEL N TO RAINBOW R        CHANNEL N TO SCREEN DISPLAY D
CHANNEL N TO SCREEN OFFSET D  CHANNEL N TO SCREEN SIZE S
CHANNEL N TO SPRITE S         CHANNEL
CHOICE                        CHR$
CIRCLE                        CLEAR KEY
CLEFT                         CLEFT$
CLINE                         CLIP
CLOSE EDITOR                  CLOSE WORKBENCH
CLOSE                         CLS
CLW                           CMOVE
COL                           COLOUR
COP LOGIC                     COP MOVE
COP MOVEL                     COP RESET
COP SWAP                      COP WAIT
COPPER OFF                    COPPER ON
COPY                          COS
CRIGHT                        CRIGHT$
CUP                           CUP$
CURS ON-OFF                   CURS PEN
DATA                          DEC
DEEK                          DEF FN
DEF SCROLL                    DEFAULT PALETTE
DEFAULT                       DEGREE
DEL BLOCK                     DEL CBLOCK
DEL ICON                      DEL SPRITE
DEL WAVE                      DEV FIRST$
DEV NEXT$                     DFREE
DIM                           DIR FIRST$
DIR NEXT$                     DIR
DIR$                          DIRECT
DISC INFO$                    DISPLAY HEIGHT
DO                            DO...LOOP
DOKE                          DOSCALL
DOUBLE BUFFER                 DRAW
DREG                          DUAL PLAYFIELD
DUAL PRIORITY                 EDIT
ELLIPSE                       ELSE
END IF                        END PROC
END                           EOF
ERASE                         ERRN
ERROR                         EVERY OFF
EVERY ON                      EVERY N GOSUB
EVERY N PROC                  EXECALL
EXIST                         EXIT IF
EXIT                          EXP
EMBEDDED MENU COMMANDS        FADE
FALSE                         FIELD
FILL                          FIRE
FIX                           FLASH
FLIP$                         FN
FONT$                         FOR
FOR...NEXT                    FREE
FSEL$                         GET BLOCK
GET BOB                       GET CBLOCK
GET DISC FONTS                GET FONTS
GET ICON PALETTE              GET ICON
GET PALETTE                   GET ROM FONTS
GET SPRITE PALETTE            GET SPRITE
GET                           GFXCALL
GLOBAL                        GOSUB
GOTO                          GR LOCATE
GR WRITING                    GETTING THE SYSTEM DATE
GETTING THE SYSTEM TIME       HCOS
HEX$                          HIDE
HOME                          HOT SPOT
HREV BLOCK                    HSCROLL
HSIN                          HSLIDER
HTAN                          HUNT
HZONE                         I BOB
I SPRITE                      ICON BASE
IF                            IF...THEN...[ELSE]
INC                           INK
INKEY$                        INPUT
INPUT#                        INPUT$
INPUT$(N)                     INSTR
INT                           INTCALL
INVERSE ON-OFF                IMPORTANT TRACKER NOTES:
JDOWN                         JLEFT
JOY                           JRIGHT
JUP                           KEY SHIFT
KEY SPEED                     KEY STATE
KEY$                          KILL
KEYBOARD MACROS               LACED
LDIR                          LED
LEEK                          LEFT$
LEN                           LENGTH
LIMIT BOB                     LIMIT MOUSE
LINE INPUT                    LINE INPUT#
LISTBANK                      LN
LOAD IFF                      LOAD
LOCATE                        LOF
LOG                           LOGBASE
LOGIC                         LOKE
LOOP                          LOWER$
LPRINT                        MAKE ICON MASK
MAKE MASK                     MATCH
MAX                           MEMORIZE
MENU ACTIVE                   MENU BAR
MENU BASE                     MENU CALC
MENU CALLED                   MENU DEL
MENU INACTIVE                 MENU ITEM MOVABLE
MENU ITEM STATIC              MENU KEY
MENU LINE                     MENU LINK
MENU MOUSE                    MENU MOVABLE
MENU OFF                      MENU ON
MENU ONCE                     MENU SEPARATE
MENU STATIC                   MENU TLINE
MENU TO BANK                  MENU X
MENU Y                        MENU$
MID$                          MIN
MKDIR                         MOUSE CLICK
MOUSE KEY                     MOUSE ZONE
MOVE FREEZE                   MOVE OFF
MOVE ON                       MOVE ON-OFF
MOVE X                        MOVE Y
MOVON                         MULTI WAIT
MUSIC OFF                     MUSIC STOP
MUSIC                         MVOLUME
MEMORY BANKS                  NEXT
NO ICON MASK                  NO MASK
NOISE                         NOT
NTSC                          ON ERROR GOTO
ON ERROR PROC                 ON MENU DEL
ON MENU GOSUB                 ON MENU GOTO
ON MENU OFF                   ON MENU ON
ON MENU ON-OFF                ON MENU PROC
ON...GOSUB                    ON...GOTO
ON...PROC                     OPEN IN
OPEN OUT                      OPEN PORT
OPEN RANDOM                   PACK
PAINT                         PALETTE
PAPER                         PAPER$
PARAM                         PARAM#
PARAM$                        PARENT
PASTE BOB                     PASTE ICON
PEEK                          PEN
PEN$                          PHYBASE
PHYSIC                        PI#
PLAY                          PLOAD
PLOT                          POF
POINT                         POKE
POLYGON                       POLYLINE
POP PROC                      POP
PORT                          PRG FIRST$
PRG NEXT$                     PRG STATE
PRINT USING                   PRINT
PRINT#                        PRIORITY OFF
PRIORITY ON                   PRIORITY ON-OFF
PROCEDURE                     PRUN
PSEL$                         PUT BLOCK
PUT BOB                       PUT CBLOCK
PUT KEY                       PUT
RADIAN                        RAIN
RAINBOW DEL                   RAINBOW
RANDOMIZE                     READ
REM                           REMEMBER
RENAME                        REPEAT
REPEAT$                       REPEAT...UNTIL
REQUEST OFF                   REQUEST ON
REQUEST WB                    RESERVE ZONE
RESERVE                       RESET ZONE
RESTORE                       RESUME
RETURN                        RIGHT$
RND                           ROL
ROR                           RUN
SAM BANK                      SAM LOOP
SAM PLAY                      SAM RAW
SAM STOP                      SAM SWAP
SAM SWAPPED                   SAMPLE
SAVE IFF                      SAVE
SAY                           SCAN$
SCANCODE                      SCIN
SCREEN BASE                   SCREEN CLONE
SCREEN CLOSE                  SCREEN COLOUR
SCREEN COPY                   SCREEN DISPLAY
SCREEN HEIGHT                 SCREEN HIDE
SCREEN OFFSET                 SCREEN OPEN
SCREEN SHOW                   SCREEN SWAP
SCREEN TO BACK                SCREEN TO FRONT
SCREEN WIDTH                  SCREEN
SCROLL                        SERIAL BITS
SERIAL BUFFER                 SERIAL CHECK
SERIAL CLOSE                  SERIAL ERROR
SERIAL FAST                   SERIAL GET
SERIAL INPUT$                 SERIAL OPEN
SERIAL OUT                    SERIAL PARITY
SERIAL SEND                   SERIAL SENDING TIPS
SERIAL SLOW                   SERIAL SPEED
SERIAL X                      SET BOB
SET BUFFER                    SET CURS
SET DIR                       SET ENVEL
SET FONT                      SET INPUT
SET LINE                      SET MENU
SET PAINT                     SET PATTERN
SET RAINBOW                   SET SLIDER
SET SPRITE BUFFER             SET TAB
SET TALK                      SET TEMPRAS
SET TEXT                      SET WAVE
SET ZONE                      SGN
SHADE ON-OFF                  SHARED
SHIFT DOWN                    SHIFT OFF
SHIFT UP                      SHOOT
SHOW                          SIN
SLOAD                         SORT
SPACE$                        SPACK
SPRITE BASE                   SPRITE COL
SPRITE OFF                    SPRITE UPDATE
SPRITE                        SPRITEBOB COL
SQR                           START
STEP                          STR$
STRING$                       SWAP
SYNCHRO                       SYSTEM
SAFE AMIGADOS EXECUTE         SPRITES
TAB$                          TAN
TEMPO                         TEXT BASE
TEXT LENGTH                   TEXT STYLES
TEXT                          THEN
TIMER                         TITLE BOTTOM
TITLE TOP                     TRACK LOAD
TRACK LOOP ON-OFF             TRACK PLAY
TRACK STOP                    TRUE
THE EDITOR                    UNDER ON-OFF
UNPACK                        UNTIL
UPDATE EVERY                  UPDATE
UPPER$                        VAL
VARPTR                        VIEW
VOICE                         VOLUME
VREV BLOCK                    VSCROLL
VSLIDER                       VUMETER
WAIT KEY                      WAIT VBL
WAIT                          WAVE
WEND                          WHILE
WHILE...WEND                  WIND CLOSE
WIND MOVE                     WIND OPEN
WIND SAVE                     WIND SIZE
WINDOW                        WRITING
X BOB                         X CURS
X GRAPHIC                     X HARD
X MOUSE                       X SCREEN
X SPRITE                      X TEXT
XGR                           Y BOB
Y CURS                        Y GRAPHIC
Y HARD                        Y MOUSE
Y SCREEN                      Y SPRITE
Y TEXT                        YGR
ZONE                          ZONE$
ZOOM                          


Function keys: f1 - f10

 Run          Test         Indent       Blocks Menu    Search Menu
 Run Other    Edit Other   Overwrite    Fold/Unfold    Line Insert

(Function Keys)  With Shift or Right Mouse.
 Load         Save         Save As      Merge          Merge ASCII
 Ac.New/Load  Load Others  New Others   New            Quit

(Function Keys)  With Ctrl.
 Block Start  Block Cut    Block Move   Block Hide     Save ASCII
 Block End    Block Paste  Block Store  Block Save     Block Print

(Function Keys)  With Alt.
 Find         Find Next    Find Top     Replace         Replace All
 Low<>Up      Open All     Close All    Set Text B.     Set Tab

Special Editor Keys and Functions
 Esc                     Toggle Direct Mode and Edit Screen
 Shift+Back or Ctrl+Y    Delete current line and pull up text
 Ctrl+U                  Undo, when in Overwrite mode
 Ctrl+Q                  Erase text from cursor to end of line
 Ctrl+I                  Insert line at cursor

Cursor Keys
 Shift+Left              Previous word
 Shift+Right             Next word
 Shift+Up                Top of page
 Shift+Down              Bottom of page
 Ctrl+Up                 Up one page
 Ctrl+Down               Down one page
 Shift+Ctrl+Up           Top of text
 Shift+Ctrl+Down         Bottom of text

Program Control
 Amiga+P  Push program into memory and create a new one
 Amiga+F  Flip between two programs in memory
 Amiga+T  Display next program

Cut and Paste
 Ctrl+B   Set beginning of block
 Ctrl+E   Set end of block
 Ctrl+C   Cut block
 Ctrl+M   Move block
 Ctrl+S   Save block
 Ctrl+P   Paste block
 Ctrl+H   Hide block

Marks
 Ctrl+Shift+n    Set mark.  n = 0 to 9
 Ctrl+n          Goto mark n

Search/Replace
 Alt+Up     Search up for next label or procedure
 Alt+Down   Search down for next label or procedure
 Ctrl+F     Find text string
 Ctrl+N     Find next string
 Ctrl+R     Replace text

Tabs
 Tab        Move to next tab
 Shift+Tab  Move to last tab
 Ctrl+Tab   Set/Unset Tab

Key$(n)=command$
command$=Key$(n)

Assign Macro in command$ to function key n.  Keys 11-20 are accessed
by holding down the left Amiga key at the same time.  Alt. + ' will be
interpreted as a return.

x$=Scan$(n[,m])

n is the scancode of a key to be used in a macro string and m is a
mask to set special keys.

   Bit   Special Key

    0    Left SHIFT key
    1    Right SHIFT key
    2    Caps Lock (ON or OFF)
    3    Control
    4    Left Alt
    5    Right Alt
    6    Left Amiga
    7    Right Amiga

Saves about 40k of memory.

Saves about 28k of memory.

Set Buffer n

n represents the variable buffer size in kilobytes.  Must be the first
line in your program excluding REMs

t=Free

Returns amount of available variable space

Dim var(x,y,z,...)[,var$(x,y),var#(x)]

This creates a table of variables or strings for usage.  These tables
may have as many dimensions as you want, but each dimension is limited
to a maximum of 65,000 elements.

In order to access an element in an array you simply put the element's
(x,y) in brackets after the variable name.

Example:  a$=var$(x,y)  a=var(1,3)

See your manual pages 35-38 for variable definations.

Data list of items[,more items]

This statement allows you to set up date fields to be read in by the
READ command.  Please Note, if the data field is without quotes, it
may be mistaken for a variable or expression.

For further notes on READ and DATA types check your manual page 256.

Read list of variables

Read will read to the list of variables a list of data items.  These
items MUST be the same type [string or variable] otherwize an error will
occur.

Also see RESTORE and DATA.  For further notes, see page 256 of your
manual.

d$=Left$(s$,n)  or  Left$(d$,n)=s$

d$=Right$(s$,n)  or  Right$(d$,n)=s$

d$=Mid$(s$,p,n)  or  Mid$(d$,p,n)=s$

If n is not specified then from p to end of string will be affected.

f=Instr(d$,s$ [,p])

Search for s$ in d$.  p is the starting position of the search.

s$=Upper$(n$)   Convert n$ into all upper case.

s$=Lower$(n$)   Convert n$ into all lower case

f$=Flip$(n$)   Reverse order of n$

s$=Space$(n)   s$ will be a string of n spaces

s$=String$(a$,n)   s$ will be the first character of a$ repeated n times

s$=Chr$(n)   Return ASCII character n

c=Asc(a$)   Return ASCII code for a$

l=Len(a$)   Return length of a$

v=Val(x$)   Convert string to a number

s$=Str$(x)   Convert number to a string

Sort a(0)  Sort a#(0)  Sort a$(0)

Sorts array a in ascending order.  "(0)" must be included

r=Match(t(0),s)  r=Match(t#(0),s#)  r=Match(t$(0),s$)

Search array t for s and return position to r

Inc var    Add one to var  (faster then  var=var+1)

Dec var    Subtract one from var  (faster then  var=var-1)

Add v,exp [,base To top]    (eg. Add v,150)  v must be an integer

The second version of ADD works like so:
    v=v+a
    If v<Base Then v=Top
    If v>Top Then v=Base

c#=Acos(n#)

The ACOS function takes a number between -1 & +1 and calculates the
angle which would be needed to generate this value with COS.

c#=Cos(a)
c#=Cos(a#)

The cosine function computes the cosine of an angle.  Normally all
angles are measured in RADIANs.  This may be changed using the DEGREE
command.

t#=Tan(a)
t#=Tan(a#)

TAN generates the tangent of an angle.  Examples:

DEGREE : PRINT Tan(45)
 0.9999998
RADIAN : PRINT Tan(PI#/8)
 .04141

s#=Sin(a)
s#=Sin(a#)

The Sin function calculates the sine of the angle in a.  Note that this
function always returns a floating point number.

t#=Atan(n#)

ATAN returns the Arc TANgent of a number.

s#=Hsin(a)
s#=Hsin(a#)

HSIN computes the hyperbolic SINe of angle a.

c#=Hcos(a)
c#=Hcos(a#)

HCOS computes the hyperbolic coSINe of angle a.

t#=Htan(a)
t#=Htan(a#)

HTAN computes the hyperbolic TANgent of angle a.

Degree

Generally all angles are specified in RADIANs.  Since radians are rather
difficult to work with, it's possible to instruct AMOS to accept angles
in degrees.  From the execution point of DEGREE, AMOS will expect
DEGREES instead of RADIANS to all TRIG functions.

Radian

The Radian command instructs that AMOS is to receive all angles in
Radians.  [This is the default.]  Also see DEGREE.

r#=Log(v)
r#=Log(v#)

LOG returns the logarithm in base 10 (LOG10) of the expression in v/v#.

r#=Exp(e#)

Calculates exponential of e#.

r#=Ln(l#)

LN computes the natural or naperian LOGarithm of l#.

a#=Pi#   Gives the value for pi.

(Square root)

s#=Sqr(v)  Returns the square root of v.

(Absolute value)

r=Abs(v)
r#=Abs(v#)

Removes signs, so -1 would be 1.

(Convert floating point to integer)

i=Int(v#)  If v#=1.32 Then i=1

(Find the sign of a number)

s=Sgn(v)

Returns -1 if negative, 0 if 0, 1 if positive

v=Rnd(n)

Returns a random number between 0 and n inclusive. If n is less then 0
then the last random number will be repeated.

Randomize seed

Set seed for random number generator.  Common pratice is Randomize
TIMER.

r=Max(x,y)   R#=Max(x#,y#)   r$=Max(x$,y$)

Returns the largest value of either x or y.

r=Min(x,y)   r#=Min(x#,y#)   r$=Min(x$,y$)

Returns smallest value of either x or y.

Swap x,y   Swap x#,y#   Swap x$,y$

Swap data between two variables of the same type.

Fix (n)

Changes how floating point numbers are displayed.
If 0<n<16 then n number of decimal places will be displayed.
If n>16 then printout will be proportional and trailing zeros removed.
If n=16 then format will be returned to normal
If n<0 then floating point numbers will be displayed in exponential
format and n determines the number of decimal places displayed.

Def Fn name [(list)]=expression

User defined function.  name is the name used to call the function,
list contains a list of variables separated by commas to be used in
the function, and expression is one line of functions.
(eg.  Def Fn Do_math (x,y,z)=10 * x + z / y  )

Fn name [(variable list)]

Execute user defined function. name is the name of the function and
variable list contains values to be passed to the function.

Poke address,v
Will place value v [1 byte only] into memory location address.

Doke address,v
Will place value v [2 bytes long] into memory location address. 
Address MUST be even or a crash will occur.

Loke address,v
Will place value v [4 bytes long] into memory location address.
Address MUST be even or a crash will occur.

WARNING:  Poking anything into the Amiga is DANGEROUS if you are NOT
          perfectly sure you're actually going where you want, so test
          your address in your program by printing it to the screen and
          doing a WAIT KEY prior to the Poke/Doke/Loke, so you can
          Ctrl-C the program, just incase the Address is wrong.

v=Peek(address)
Will return the value from address [1 byte only] into v.

v=Deek(address)
Will return the value from address [2 bytes long] into v.
Address MUST be even or a crash will occur.

v=Leek(address)
Will return the value from address [4 bytes long] into v.
Address MUST be even or a crash will occur.

Note for LEEK:  If bit 31 of the returned value is on, then v will show
                as being negative.  [Bit 31 is the sign bit, 0 for
                positive and 1 for negative.]

f=Hunt(start To finish,s$)

HUNT will search memory from start TO finish for s$.  If s$ is found, f
will hold the memory address of the start of s$, if not, f will hold 0.

ROR  Rotate Bits Right
ROL  Rotate Bits Left

.B Byte.  [ 8 bits]
.W Word.  [16 bits]
.L Long.  [32 bits]

Rol.B n,v  Will rotate the lowest 8 bits left one.  %10010000=%00100001
Ror.B n,v  Will rotate the lowest 8 bits right one. %10010000=%01001000

With .W [Word] and .L [Long], you can rotate more bits.

h$=Hex$(v [,places])

Set h$ to the hex value of v with places digits in length.

b$=Bin$(v [,places])

Set b$ to the binary value of v with places digits in length.

address=Varptr(v)
address=Varptr(v$)

Returns the address of variable v. Each type of variable is stored
using its own format:

 Integers: VARPTR finds the address of the four bytes containing the
contents of your variable.

 Floating point: VARPTR returns the location of four bytes which hold
the value of the variable in the IEEE single precision format.

 Strings: The VARPTR address points to the first character  of the
string.  Since AMOS Basic does not end its strings with a CHR$(0), you
must obtain the length of the string using something like:

DEEK(Varptr(a$)-2), where a$ is the name of your variable.  You could
also use LEN(a$).

Copy start,finish To destination

Move a section of data in memory.  The addresses must be even.

Fill start To finish, pattern

Fill an area of memory with the four bytes in pattern.  The addresses
must be even.

b=Btst(n,v)

Test the binary digit at position n in the variable v.  If it is 1,
then a value of -1(TRUE) will be returned.

Bset n,v

Set the bit at position n in variable v to 1.

Bclr n,v

Set the bit at position n in variable v to 0.

Bchg n,v

NOT the value of the bit at position n in variable v.

 One byte      Two bytes      Four bytes
 PEEK          DEEK           LEEK
 POKE          DOKE           LOKE

Areg(r)=a
a=Areg(r)

Areg() is a PSEUDO register to the 68000 chip's A0-A6 Address Registers.

Amos allows writing (Areg(r)=a) only to registers 0-2, but allows
reading (a=Areg(r)) for all 0-6.

Dreg(r)=a
a=Dreg(a)

Dreg() is a PSEUDO register to the 68000 chip's D0-D7 Data Registers.

Amos allows reading and writing from all 8 of these registers.

Notes:  When the AMOS commands CALL,DOSCALL,EXECALL,GFXCALL,INTCALL
        are executed, Areg(0)->Areg(2) and Dreg(0)->Dreg(7) are passed
        to the 68000's REAL registers.  Upon exit of the routine, Amos
        will read the 68000's REAL registers back into Areg(0)->Areg(2)
        and Dreg(0)->Dreg(7).  Also, Areg(3)->Areg(7) are reserved for
        use by Amos.

Pload "filename",bank

Reserves the selected memory bank and loads it with machine code.

bank is the bank number to be reserved for your machine code program. 
If it's negative, then the bank will be calculated using the absolute
value of this number and the required memory area will be allocated in
Chip memory.

Once you've loaded a program in this way, you can save it on disk as a
normal ".Abk" file, since the banks created in this manner are
permanent.  It will always be saved with your Amos program.

Your program must consist of machine code in standard Amiga format with
the following restrictions:

o The code MUST be relocatable, as it will be positioned at the first free
  memory location which is available.  [And probably never the same place
  twice.]

o  Only the CODE chunk of your program will be loaded.

o  The program MUST terminate with a single RTS instruction.

Call address[,params]
Call bank[,params]

Execute a machine code program at address or start of bank.

See AREG/DREG for details on Register usage.

Note, when machine code is running, all registers are available for use,
except A7 [Areg(7)].

A3 holds the address to the start of the params list.

All params will be pushed onto the stack at address A3.  Retrieving them
requires you to read pull them in reverse.  [See Manual Page 285 for
more information.]

A5 holds the address to the start of the MAIN Amos data area.

Before attempting these commands, be sure to observe warnings and
guidelines written in the Amiga ROM Kernel Manuals [RKMs].

x=Doscall(offset)  Execute a Dos Library call.
x=Execall(offset)  Execute an Exec Library call.
x=Gfxcall(offset)  Execute a Graphics Library call.
x=Intcall(offset)  Execute an Intuition Library call.

For information on Registers, see AREG/DREG.

offset should be negative.  Although the RKMs show them as being
positive, they are indeed supposed to be negative.

You should only attempt these commands if you're familar with the
Amiga's ROMs.

Restore label   Restore lable$   Restore line    Restore number

Wait n

n is measured in 50ths of a second.

v=Timer
Timer=v

TIMER is a reserved variable which is incremented by 1 every 50th of a
second.  It's most commonly used to help bring a random number:

          RANDOMIZE Timer

v=Not(d)

This does the same as an "Exclusive OR" which changes all the bits in a
digit to their opposite.

d=%101 : v=Not(d) : PRINT d

d will have %1111111111111010

v=True      Returns a value of -1.  [Try- a=0 : PRINT a=0]

v=False     Returns a value of 0.

HELLO           Procedure HELLO            pass no values to procedure
HELLO[n$,25]    Procedure HELLO[Name$,x]   pass values to procedure

End Proc
End Proc[variable]
End Proc[variable$]

End a Procedure.  Optional variables can be passed [ONLY one].  See
PARAM or PARAM$ for more information.

Global variable list

Let procedures use all variables in the variable list.

Shared variable list

Used inside of a procedure, lets procedure use program variables.
Similiar to GLOBAL but is contained to current procedure only.

Param, Param#, Param$

Lets a procedure store a value into the appropriate PARAM that can be
accessed by the main program.  This value is entered by the END PROC
command.   (eg. END PROC[a$+b$+g$])  Only one value can be returned.

Pop Proc

Jumps out of procedure

Goto label   Goto line number    Goto variable    Goto exp
(eg. Goto START_UP    Goto 210    Goto x    Goto a$ + "Hello" )

Gosub label   Gosub line number   Gosub variable  Gosub exp

Return

Exit from a subroutine.  Must be present in all subroutines.

Pop

Removes the return address generated by a GOSUB and allows you to exit
the subroutine any way you like.  (eg. IF x=1 Then Pop : Goto label  )

If conditions Then statements 1 [Else statements 2]

If...[Else]...End If

If tests=TRUE
    list of statements 1
Else
    list of statements 2
End If

Note: It is illegal to use an IF...THEN...ELSE inside an
IF...ELSE...END IF structured test.

For index = first To last [Step inc] : list of statements : Next index

While condition : list of statements : Wend

Repeat : list of statements : Until condition

DO : list of statements : LOOP

Exit [n]
Jumps out of the following structures: FOR...NEXT, REPEAT...UNTIL,
WHILE...WEND and DO...LOOP.  If n is stated then EXIT will jump out of
n number of nested structures.

Exit If
Exit If expression [,n]

Stops program and enters AMOS Basic editor.

Stops program and enters DIRECT mode.

Exits Amos immediately.  Closing any open files/screens/etc in the
process.

Stops program.

On v Proc proc1, proc2, proc3, ... proc n

Note: You can not pass parameters to a procedure using this command.

On v GOTO line1, line2, line3, ... line n

On v GOSUB line1, line2, line3, ... line n

Every n GOSUB label

Subroutine label will be executed every n 50ths of a second.  Your
subroutine must be completed in less then this time.  After a
subroutine has been entered, the system will be automatically
disabled.  The EVERY ON command must be used before the RETURN
statement in your subroutine.

Every n Proc
Every n Proc name

Every On   Every Off  Toggles automatic procedures and subroutines.

Break On   Break Off

Activate/deactivate the Ctrl+C function.

On Error Goto label

On Error Proc
On Error Proc name

When an error occurs, the program will jump to the GOTO/Proc.

Also see RESUME.

Resume          Continue with same command program errored with.
Resume Next     Continue 1 command after the command that caused the error.
Resume line     Continue at "line".  [Program must have line numbers.]
Resume label    Continue at label.

e=Errn

Returns the last error number.

Error n

Creates error number n.

Types of memory banks

  Class       Stores            Restrictions       Type

  Sprites     Sprites and Bobs  Only bank 1        Permanent
  Icons       Icons             Only bank 2        Permanent
  Music       Sound Tracks      Only bank 3        Permanent
  Amal        Amal data         Only bank 4        Permanent
  Samples     Sample data       Banks 1 - 15       Permanent
  Menu        Menu definition   Banks 1 - 15       Permanent
  Chip Work   Temp workspace    Banks 1 - 15       Temporary
  Chip Data   Perm workspace    Banks 1 - 15       Permanent
  Work        Temp workspace    Banks 1 - 15       Temporary
  Data        Perm workspace    Banks 1 - 15       Permanent

Reserve AS type,bank,length     [See MEMORY BANKS for more.]

Listbank   List banks in use    [See MEMORY BANKS for more.]

Erase b    Erase data in bank b   [See MEMORY BANKS for more.]

s=Start(b)   s will hold the starting address of bank b

                [See MEMORY BANKS for more.]

l=Length(b)  l will hold the length of bank b.  If bank b contains
sprites or BOBs then the number of images will be returned.

                [See MEMORY BANKS for more.]

Load "filename"[,n]

If filename contains more then one bank then ALL existing banks will
be erased.  If n is given then only bank n will be overwritten.  If
filename is sprite or bob data then if n=0 current sprite data will be
lost; if n=1 then new sprite data will be appended to current data.

                [See MEMORY BANKS for more.]

Save "filename"[,n]

Save all banks unless n is specified.  Use extension ".ABK"

                [See MEMORY BANKS for more.]

Bsave file$, start To end

eg. Bsave "Test",START(7) To START(7)+LENGTH(7)

Saves a chunk of memory.  START(7) to START(7)+LENGTH(7).

Bload file$, address
  or
Bload file$, bank

If BLOADing into a bank it must already exist.

                [See MEMORY BANKS for more.]

Screen Open n,w,h,nc,mode

Open screen number n (0-7) , with a size of w pixels wide by h pixels
high.  The size of the screen can be larger then the display.  nc sets
the number of colours to be used (2,4,8,16,32,64,4096). mode sets
Lowres or Hires.  If screen number n already exists it will be
replaced by new screen. (eg. Screen Open 3,640,200,16,Hires)

Screen Close n

Delete screen number n

Auto View On   Auto View Off

When AUTO VIEW is on then any new SCREEN that is opened or any changes
to the current screen will be automatically displayed.  Auto View Off
prevents this.

Default

Closes all currently open screens and returns to the default display.

View

Display any changes to the current screen at the next vertical blank
period.  For use when AUTO VIEW is OFF.

Load Iff "filename"[,s]

Load Iff picture called filename into screen number s.  If s is not
specified then picture will be loaded into the current screen.

Save Iff "filename"[,compression]

Save current screen to disk and call it filename. If compression is
set to 1 then standard Amiga file compression is used.  If compression
is set to 0 then extra AMOS data containing screen settings such as
Screen Display, Screen Offset and Screen Hide/Show will be added to
your file.  The default is 0.

Screen Display n [,x,y,w,h]

Display screen number n.  The following modifiers can be added:
x,y sets the screens location in hardware coordinates.  x is rounded
to the nearest 16-pixel boundary.
w,h sets the width and height of current screen in pixels.  w is
rounded to the nearest 16-pixel boundary.

Screen Offset n,x,y

Sets display offset of screen n by x,y pixels.  x and y may be
negative.

Screen Clone n

Clones the current screen to screen n.  This cloned screen can only be
manipulated by the SCREEN DISPLAY and SCREEN OFFSET commands.

Dual Playfield screen1, screen2

Let screen 2 show through colour 0 of screen 1.  The two screens must
be the same resolution.  The palette for both screens will be taken
from screen 1.  The colours for screen 2 will be taken from the half
of the colour registers that are not being used by screen 1.  If
screen 1 and screen 2 both had 8 colours then screen 1 would use
colour registers 0-7 and screen two would use colour registers 8-15.
Anything drawn to screen 2 will automatically have it's colour
register converted to the appropriate number (eg. if you draw to
screen 2 with INK set to register 2, then register 9 will actually be
used.)  The possible screen colour combinations are:

   Screen 1         Screen 2
 No of colours    No of colours
      2                 2
      4                 2
      4                 4
      8                 4        Lowres only
      8                 8        Lowres only
Note: never set SCREEN OFFSET for both screens to 0.

Dual Priority screen1,screen2

Let screen 2 be in front of screen 1. The colour palette will still be
taken from screen 1.

s=Screen

Return current screen number.  Current screen may or may not be
visible.

Screen To Front [s]

Move screen s to front of display.  If s is omitted then the current
screen is move to front.
Note: if AUTO VIEW is OFF then the VIEW command must be used before
the effect can been seen.

Screen To Back [n]

Move screen n back of display.  Default is current screen.

Screen Hide [n]

Hide screen n completely from view.  Default is current screen.

Screen Show n

Show a screen that was previously hidden with Screen HIDE.

h=Screen Height [n]

Returns height of screen n.  Default is current screen.

w=Screen Width [n]

Returns width of screen n.  Default is current screen.

c=Screen Colour

Returns maximum number of colours in current screen.

s=Scin(x,y)

Returns screen number at hardware coordinates x,y.

Default Palette c1,c2,c3,... c32

Set colours in a default palette that will be applied to any
subsequent screens created.  c is the $RGB values for each colour
register.

Get Palette n [,mask]

Load the colour palette from screen n to the current screen.  mask is
a 32-bit binary number that selects which colours you want to copy to
the current screen.  When a bit is set to 1 then the corresponding
colour is copied.
(eg. to get just the first 4 colours  mask=%000001111 )

Cls
Fill current screen with colour 0 and clear any windows that are open.

Cls col
Fill current screen with colour col.

CLS col,x1,y1 To x2,y2
Fill area x1,y1 To x2,y2 with colour col.

Screen Copy scr1 To scr2
Screen Copy screen scr1 To screen scr2

Screen Copy scr1,x1,y1,x2,y2 To scr2,x3,y3 [,mode]

Copy an area of screen scr1 to location x3,y3 on screen scr2. Mode is
a binary number that can set as follows:

  Mode     Effect                                    Bit pattern
  REPLACE  Copy image completely over destination     %11000000
  INVERT   Invert image and copy over destination     %00110000
  AND      Use logical AND                            %10000000
  OR       Use logical OR                             %11100000
  XOR      Use logical XOR                            %01100000

table=Screen Base

Returns the base address of the internal table used to hold the number
and position of your AMOS screen.  See EXAMPLE 20.2 for a simple
demonstration.  [On your AMOS 1.2 Program disk within the Manual Folder.]

Def Scroll n,x1,y1 To x2,y2,dx,dy

Define scroll zone number n (1-16).  x1,y1 to x2,y2 defines the area
to be scrolled. dx is the number of pixels the zone will be scrolled
to the right if positive or to the left if negative.  dy is the number
of pixel the zone will be scrolled down if positive or up if negative.
The scroll is performed every time the SCROLL command is called.

Scroll n

Scroll zone number n as defined in the DEF SCROLL command.

Screen Swap [n]

Swap the physical and logical screens.

This command deals with logical and physical screens.    A physical
screen is the one that is being shown at any given time and a
logical is the screen that all current drawing commands are being
sent to and is not visible.  After all drawing to the logical screen
is done, it can then be swapped with the physical screen and the
process repeats.

address=Logbase(p)

Returns the address for bit-plane p of the logical screen.

This command deals with a logical screen ONLY.    A physical
screen is the one that is being shown at any given time and a
logical is the screen that all current drawing commands are being
sent to and is not visible.  After all drawing to the logical screen
is done, it can then be swapped with the physical screen and the
process repeats.

address=Phybase(p)

Returns the address for bit-plane p of the physical screen.

This command deals with a physical screen ONLY.    A physical
screen is the one that is being shown at any given time and a
logical is the screen that all current drawing commands are being
sent to and is not visible.  After all drawing to the logical screen
is done, it can then be swapped with the physical screen and the
process repeats.

x=Physic   x=Physic(s)

Returns an identification number for the current physical screen to be
used in place of a screen number in the ZOOM, APPEAR and SCREEN COPY
commands.

This command deals with a physical screen ONLY.    A physical
screen is the one that is being shown at any given time and a
logical is the screen that all current drawing commands are being
sent to and is not visible.  After all drawing to the logical screen
is done, it can then be swapped with the physical screen and the
process repeats.

x=Logic   x=Logic(s)

Returns an identification number for the current logical screen.

This command deals with a logical screen ONLY.    A physical
screen is the one that is being shown at any given time and a
logical is the screen that all current drawing commands are being
sent to and is not visible.  After all drawing to the logical screen
is done, it can then be swapped with the physical screen and the
process repeats.

Wait Vbl

Wait for the next vertical blank and then continue.  Also see
MULTI WAIT.

Appear source To destination,effect [,pixels]

Make SCREEN source appear on screen destination.  effect (1-number of
pixels on screen) determines the type of fade.  pixel sets the number
of pixels starting from the top of the screen that will be affected.

Fade speed [,colour list]
Fade the current palette to back or to [colour list].  Speed is the
number of vertical blank periods used to complete the fade.

Fade speed To s [,mask]
Fade the current palette to the palette of screen s.  If s is negative
then it represents the palette of a sprite.  mask is a bit pattern
that specifies which colours should be changed.
(eg. just fade the first 5 colours  FADE 20 To 2,%00011111 )

Flash index,"($RGB,delay)($RGB,delay)($RGB,delay)..."
Make colour register index cycle through each $RGB colour value
listed.  delay is the time measured in 50ths of a second that each
colour will be displayed.  FLASH operates as an interrupt.
Note:  A WAIT command should be used after a FLASH command.  It is
calculated like so:  wait value = fade speed * 15.

Flash Off
Deactivate the FLASH command.

Shift Up delay,first,last,flag

Shift colours from register first to register last up one position at
a time.  delay is the time measured in 50ths of a second between each
shift.  If flag is 1 then the colours loop.  If flag is 0 then the
contents of the first and last registers will be discarded, and the
region between will gradually be replaced by a copy of the first
colour in the list.  SHIFT operates as an interrupt.

Shift Down delay,first,last,flag

Shift colours down.  See SHIFT UP.

Shift Off

Deactivate the SHIFT UP and SHIFT DOWN command.

Zoom source,x1,y1,x2,y2 To dest,x3,y3,x4,y4

Take area defined by x1,y1 to x2,y2 in screen source and make it fit
into area x3,y3 to x4,y4 on screen dest.

addr=Cop Logic

Returns the absolute address to the logical copper list in memory.  This
allows you to poke your copper instructions directly into the buffer,
possibly using assembly language.

(Write a MOVE instruction into the logical copper list.)

Cop Move addr,value
Generates a MOVE instruction into the copper list.

addr is an address of a 16 bit register to be changed.  This must lie
within the normal copper DATAZONE ($7F-$1BE).

value is a word-sized (2bytes) integer to be loaded into the requested
register.

(See COP LOGIC for the addr value.)

(Write a long MOVE instruction into the copper list.)

Cop Movel addr,value

This is identical to the standard COP MOVE command, except that addr
now refers to a 32bit copper register.

value contains a long word (4bytes) integer.

(Reset copper list pointer.)

Cop Reset

COP RESET restores the address used by the next copper instruction to
the start of the copper list.

(Copper WAIT instruction)

Cop Wait x,y[,x mask,y mask]

COP WAIT writes a WAIT instruction into your copper list.  The copper
waits until the hardware coordinates x,y have been reached and returns
control to the main processor.

Note that line 255 is managed automatically by AMOS.  So, you don't have
to worry about it at all.

x mask and y mask are bitmaps which allow you to wait until just a
certain combination of bits in the screen coordinates have been set.  As
a default, both masks are automatically assigned to $1FF.

This freezes the current AMOS copper list and turns off the screen
display completely.  You can now create your own display using a series
of COP MOVE and COP WAIT instructions.

As a default, all user-defined copper lists are limited to a maximum of
12k.  On average, each copper instruction takes up 2 bytes.  So, there
is space for around 6000 instructions.  This may be increased if
required, using a special option from the AMOS CONFIG utility.

Note that all copper instructions are written to a separate logical list
which is not displayed on the screen.  This stops your program from
corrupting the display while the copper list is being constructed.  To
activate your new screen, you'll need to swap the physical and logical
lists around with the COP SWAP command.

It's also important to generate your copper lists in strict order,
starting from the top left of the screen, progressing downward to the
bottom right.  See EXAMPLE 10.15 in the MANUAL folder of your AMOS1.2
PROGRAM disk.

This will cause the logical and physical copper lists to swap
immediately.  [This command is not in the manual!]

COPPER ON restarts the AMOS copper list calculations and displays the
current AMOS screens.  Providing you haven't drawn anything since the
COPPER OFF instruction, the screen will be restored to precisely it's
original state.

Spack s To n [x1,y1,x2,y2]

Compress screen number s into bank number n.  x1,y1,x2,y2 defines the
area to be saved.  The default is the whole screen.  SPACK also saves
the screen's mode, size, offset and display position.  All x
coordinates are rounded to the nearest 8 pixel boundary.

Pack s To n [x1,y1,x2,y2]

Same as SPACK but does not save the screen's mode, size, offset or
position.

Unpack b to s
For use with unpacking SPACKed screens.  Unpacks the image in bank b
to screen number s.

Unpack b [,x,y]
For use with unpacking PACKed screens.  Unpacks the image in bank b to
the current screen at coordinates x,y.  PACKed screen are really
intended to be used with DOUBLE BUFFERing on.

Pen index
Sets colour of text to the colour stored in register index (0-63).

=PEN$(n)
a$=Pen(n)
Allows a colour change within a string.
(eg.  c$ = Pen$(2) + "White " + Pen$(6) + "Blue" )

Paper index
Sets background colour of text to the colour in register index (0-63).

=PAPER$(n)
x$=Paper$(n)
Allows a colour change within a string.

Inverse On   Inverse Off

Swaps text background and foreground colours.

Shade On   Shade Off

Reduces brightness of text.

Under On   Under Off

Turns on-off text underlining.

Writing w1 [,w2]

Changes text writing mode as follows:

  w1=0  REPLACE    New text overwrites anything underneath
  w1=1  OR         Merge text using logical OR
  w1=2  XOR        Merge text using logical XOR
  w1=3  AND        Merge text using logical AND
  w1=4  IGNORE     All printing will be ignored

  w2=0  NORMAL     Text is printed along with its background
  w2=1  PAPER      Only the text background is printed
  w2=3  PEN        Prints text with a background of colour 0

Locate x,y   Locate x,   Locate ,y

Place text cursor at location x,y measured from top left of screen.

Cmove w,h

MOVE text cursor relative to current position.

x$=At(x,y)

Allows you to place text from within a string.
(eg.  x$=At(10,10) : PRINT x$ + "Over Here" )

t=X Text(x)
Converts a normal x coordinate into a text coordinate relative to the
current window.  If x lies outside this window a negative value will
be returned.

t=Y Text(y)
Converts a y coordinate form the standard screen format into a text
coordinate relative to the current window.

g=X Graphic(x)
g=Y Graphic(y)

Converts a relative window coordinate into a screen coordinate.

Home

Move text cursor to 0,0

Cdown

Moves cursor down one line.

x$=Cdown$

Allows a cursor down movement within a string.

Cup

Move text cursor up one line.

x$=Cup$

Allows a cursor up movement within a string.

Cleft

Move text cursor left one space.

x$=Cleft$

Allows a cursor left movement within a string.

Cright

Move text cursor right one space.

x$=Cright$

Allows a cursor right movement within a string.

x=X Curs
y=X Curs

Returns x or y [respective] coordinate of text cursor.

Set Curs L1,L2,L3,L4,L5,L6,L7,L8

Changes shape of cursor.  Each parameter is an eight-bit binary number
representing a line of the cursor starting from the top.

Curs On   Curs Off

Turn the current screen's cursor ON or OFF.

Memorize X   Memorize Y

Saves current cursor position in memory.

                [Also see REMEMBER.]

Remember X   Remember Y

Recalls previous MEMORIZEd cursor position.

Cline [n]

Clear current line of text.  If n is stated then text is erased from
current position to n number of characters.

Curs Pen n

Change cursor colour.

Centre a$

Prints a$ centered on current line.

Set Tab n

Sets tab distance to n spaces.

x$=Tab$

Returns tab control character.

x$=Repeat$(a$,n)

Creates a repeat ESC string for a$ n times and stores result in x$.

k$=Inkey$

Returns whichever ASCII key is pressed on the keyboard.  INKEY$ does
not wait for a key to be pressed.

s=Scancode

Returns the scancode for the key that was entered using the last
INKEY$ function.

t=Key State(s)

Returns a value of -1(TRUE) if key number s has been pressed.  s is a
keyboard SCANCODE.

k=Key Shift

Returns a bit pattern representing which control keys have been
pressed.
   Bit   Key
    0    Left Shift
    1    Right Shift
    2    Caps Lock (on of off)
    3    Ctrl
    4    Left Alt
    5    Right Alt
    6    Left Amiga
    7    Right Amiga (or Commodore key)

Set Input c1,c2

This sets the End-Of-Line characters which will be used to terminate all
input statements.  Normally c1 holds 10 and c2 holds -1.

c1 and c2 hold ascii values which will be used as input terminators.  If
you want to use a single character, set c2 to -1.

x$=Input$(n)

Returns n number of characters from the keyboard.  This command does
not echo these characters to the screen.

Wait Key

Wait for a key to be pressed and then continue.

Key Speed lag,speed

Set the speed of the key repeats.  Both lag and speed are measured in
50ths of a second.  lag is the amount of time between the key press
and the first repeat.  speed is the amount of time between each
successive repeat.

Clear Key

Clears the keyboard buffer.

Put Key a$

Load a string into the keyboard buffer.  Often used for setting
defaults for INPUTs.

Input [a$];[var1,var2,...];

a$ is the optional text to be displayed as a prompt.

Line Input [a$];[var1,var2,...];

Inputs a number of variables separated by the user by pressing return.

a$ is the optional text to be displayed as a prompt.

Print variable list

Print displays the variable list to the current window or screen.

NOTE: all variables must separate themselves with semi colons [;].
      Example:  Print "Your name is";realname$

Print Using format$;variable list

Here is a list of the possible formatting controls:

 ~  Print a single character from a string.
 #  Print a single digit from a variable.  If no digit then space.
 +  Add a plus sign if positive or a minus sign if negative.
 -  Add a minus sign if negative.
 .  Place decimal point.
 ;  Centre a number but don't print a decimal point.
 ^  Print a number in exponential form.

x$=Zone$(a$,n)

Creates zone number n around a$ and stores in x$.  When x$ is printed
it will automatically activate it's zone.

x$=Border(a$,n)

Creates border number n around a$ and stores in x$.  When x$ is
printed it will automatically have a boarder.

Hscroll n

Scroll text in current window horizontally by one character. n can be
one of four values:

   1 = Move current line to the left
   2 = Scroll screen to the left
   3 = Move current line to the right
   4 = Scroll screen to the right

Blank lines are left where gaps are created.

Vscroll n

Same as HSCROLL except this scroll is vertical and the options are
different.  n can be one of the following:

   1 = Any text at the cursor line and below are scrolled down.
   2 = Text at the cursor line and below (if any) are scrolled up.
   3 = Only text from the top of the screen to the cursor line is scrolled
       up.
   4 = Text from top of the screen to the current cursor position is
       scrolled down.

Blank lines are left where gaps are created.

Text x,y,t$

Prints graphic text in t$ at x,y.  All coordinates are measured
relative to the characters baseline which can be determined by the
TEXT BASE command.

Get Fonts

Makes an internal list of available fonts from the current start-up
disk.  This list can be examined using the FONT$ function.  Get FONTS
must be called before SET FONT.

Get Disk Fonts

Search for fonts in the font folder.

Get Rom Fonts

Searches for ROM fonts.

a$=Font$(n)

Returns a string of 38 characters describing font number n.  If font
does not exist then a null string will be returned, otherwise the
string will be in the following format:

  Character   Description

   1-29        Font name
   30-33       Font height
   34-37       Identifier (disk or ROM)

Set Font n

Change current font to font number n

Set Text style

Selects font style. style is a bit pattern:
   Bit  Effect

    0   Underline
    1   Bold
    2   Italic

s=Text Styles

Returns current text style in bit pattern style as in SET TEXT.

w=Text Length(t$)

Returns the width of t$ in pixels using the current font.

b=Text Base

Returns the position of the current font's base line in pixels.

Wind Open n,x,y,w,h [,border [,set]]

Open window number n at graphic coordinates x,y.  x is rounded to the
nearest multiple of 16.    w,h specify the size of the window in
characters.  w and h must be divisible by 2.  border selects one of 16
border styles.  Any borders added to a window will be outside the
defined text area.  set selects the character set number defined by
the SET FONT command.

Wind Save

This feature saves the display under the window created and is
replaced when the window is moved or closed.

Border n,paper,pen

Set the border of the current window. n is the border style (1-16).
paper and pen select the foreground and background colours of the
border.

Title Top t$

Display t$ in the top border of current window.  Only bordered windows
can be titled this way.

Title Bottom b$

Display b$ in the bottom border of current window.  Only bordered windows
can be titled this way.

Window n

Activates window number n.

w=Windon

Returns current window number.

Wind Close

Close current window.

Wind Move x,y

Move current window to graphic coordinates x,y.  x will be rounded to
the nearest 16-pixel boundary.

Wind Size sx,sy

Changes window size to sx,sy measured in characters.  After a window's
size has been changed the text cursor returns to 0,0.

Clw

Clear current window and fill with present PAPER colour.

Hslider x1,y1 To x2,y2,total,pos,size

Draw a horizontal slider in area x1,y1 To x2,y2.  total is the number
of units the slider will be divided into.  pos sets the position of
the slider from the start of the slider in units defined by total.
size sets the size of the slider box in units defined by total.

Vslider x1,y1 To x2,y2,total,pos,size

Similar to HSLIDER.

Set Slider b1,b2,b3,pb,s1,s2,s3,ps

Set colours and patterns for slider boxes.  b1,b2,b3 set the ink,paper
and outline colours for the background of the box.  pb chooses the
fill pattern to be used for these regions.  s1,s2,s3 set the colours
for the slider box and ps selects the pattern it is to be filled with.
bp and ps can be any fill patterns you wish (0-24).

Ink col[,paper][,border]

Selects colours for all subsequent drawing operations.  col is the
register number (0-63), paper is the colour for the background fill
patterns generated by the SET PATTERN command, border is the colour
for outlines added to bars and polygons.  The border is toggled by the
SET PAINT command.  Include commas for excluded parameters.
(eg. INK ,,10)

Colour index,$RGB

Loads colour register index (0-31) with $RGB.  $RGB represents the
red, green and blue intensity of the colour stored in register index.

c=Colour(index)

Return colour stored in register index.

Palette reg0,reg1,reg2,... reg31

Load all colour registers with new colours.  Any register not to be
changed can be skipped by leaving in the corresponding comma.

Gr Locate x,y

Set position of the graphics cursor in screen coordinates.  Any
drawing commands with the starting coordinates omitted will default to
the current graphic cursor position.

x=Xgr  y=Ygr

Returns the current graphics cursor location.

Plot x,y [,c]

Draws one pixel at coordinates x,y using colour c.  If c is included
in this statement then all following drawing commands will use this
colour; otherwise the pixel will be drawn with the current colour.

c=Point(x,y)

Returns the colour register at point x,y

Draw [x1,y1] To x2,y2

Draws a line from x1,y1 to x2,y2.  x1 and y1 default to the graphics
cursor.

Box x1,y1 To x2,y2

Draws a box from x1,y1 to x2,y2.

Polyline x1,y1 To x2,y2 To x3,y3 ...

POLYLINE is simular to DRAW except it draws several lines at once.  It's
capable of drawing complex hollow polygons with one statement.

Circle x,y,r

Draw a circle at point x,y with a radius of r.

Ellipse x,y,r1,r2

Draw an ellipse at point x,y  r1 wide and r2 high.

Set Line mask

mask is a 16-bit binary number that describes how lines made by the
DRAW, BOX and POLYLINE commands will look.  (eg. for a dotted line,
SET LINE %0101010101010101)  This command does not affect CIRCLE or
ELLIPSE.

Paint x,y,mode

Fills an enclosed area starting at point x,y with the current fill
pattern made with the SET PATTERN command.  If mode is 0, filling will
stop at the current border colour. mode 1 will stop filling at any
colour different from the current INK colour.

Bar x1,y1 To x2,y2

Draws a filled rectangle.

Polygon x1,y1 To x2,y2 To x3,y3 ...

Draw a filled polygon.  The last x and y coordinates should be the
same as the first.

                [Also see POLYLINE.]

Set Pattern pattern

Sets fill pattern.  Default 0 is a solid in the current INK colour.
If pattern > 0 then one of 34 built-in fill styles is used. The first
three of which are used for the mouse.  If pattern < 0 the absolute
value of pattern will relate to the sprite number in bank one. Fill
sprites will be truncated as follows:  the width will be clipped to 16
pixels wide, the height will be rounded to the nearest power of 2.
Two-coloured images will be drawn in the current INK colour.
Multi-coloured images' foreground colour will be merged with the
current ink colour using a logical AND; the paper colour of your
pattern is ORed with the image background colour.  If you want to use
your images original colour then set your colours to INK 31,0.  Don't
forget to load your images pallet with the GET SPRITE PALETTE command.

Set Paint n

If n = 1 then outline mode is activated.  All POLYGON and BAR
instructions will be outlined in the boarder colour set with the INK
command.  If n = 0 then outline mode is turned off.

Gr Writing bitpattern

All graphics will be drawn in the style determined by the bitpattern.
The possibilities are:

JAM1 Bit 0=0
Only draws the part of your image that are set to the current ink
colour.  Any parts drawn in the paper colour are ignored.  This
is ideal for merging text over an existing background.

JAM2 Bit 0=1
This is the default.  Any existing graphics will be replaced by
the new image (foreground and background).

XOR Bit 1=1
Changes the colour of the areas of a drawing which overlap an
existing picture.  You can erase an image by XORing it in the
same position.

INVERSEVID Bit 2=1
Reverse image before it is drawn.  Swaps foreground and
background colours of image.

Note: This command does not affect the PRINT and CENTRE commands
which are set by the WRITING command.

It is possible to combine one or more of these styles.
(eg. GR WRITING %101   use JAM2 and inversevid)

Clip [x1,y1 To x2,y2]

Limits all drawing operations to a region of the screen specified by
by x1,y1 TO x2,y2.  It is acceptable to use coordinates outside of the
normal screen boundaries.


Important info:

Four-colour sprites use the colours stored in registers 16 to 31
like so:
          Sprite Number     Colour Registers
               0/1           17/18/19
               2/3           21/22/23
               4/5           25/26/27
               6/7           29/30/31

If your are using 32 or 64 colours on a screen then the sprites
will share the above color registers.  This does not apply to
fifteen-colour sprites.

Note: If computed sprites are in use then make sure each sprite uses
the same colours.

Sprite n,x,y,i

Display sprite number n (0-63) at hardware coordinates x,y using image
number i.  n values that are grater then 7 relate to computed sprites.

Get Sprite Palette [mask]

Loads sprite palette into current palette.  mask is a bit-pattern used
to select certain colours.

Set Sprite Buffer n

Eliminate any redundant memory used by the sprite buffer. n (16-256)
should be set to the number of pixels in your longest sprite.

Sprite Off [n]

Turn off all sprites or just sprite number n.

Sprite Update Off
Turn off automatic sprite updating.

Sprite Update
Update any sprites that have been moved.  For use when Sprite Update
is OFF.

Sprite Update On
Turn automatic sprite updating back on.

x=X Sprite(n)
y=Y Sprite(n)

Returns current x or y [repsective] hardware coordinate of sprite n.

Get Sprite [s,] i,x1,y1 To x2,y2

Grab area x1,y1 TO x2,y2 form screen s (default is current screen) and
store in sprite bank as image i.

Del Sprite s [TO f]

Delete SPRITES/BOBs from bank.

x=X Screen([s,] xcoord)
y=Y Screen([s,] ycoord)

Translate a hardware coordinate into a screen coordinate relative to
the current screen or screen s.

x=X Hard([s,] xcoord)
y=Y Hard([s,] Xcoord)

Translate a screen coordinate into a hardware coordinate.

image=I Sprite(n)

Returns the current image number for sprite number n.  0 will be
returned if the sprite is not displayed.

table=Sprite Base(n)

Provides the address of the internal data list for sprite n.  If sprite
n does not exist, then the address of table will be 0.

Negative values for n return the address of the optional MASK associated
with your sprite.  table will now contain one of three possible values
depending on the status of this mask:

table<0   Indicates that there is no mask for this sprite.

table=0   Sprite n does have a mask, but the system has yet to generate
          it.

table>1   This is the address of the MASK in memory.  The first Long
          Word [see LEEK] of this area holds the lenght of the mask
          and the following locations is the actual mask defination.

See EXAMPLE 20.3 for a simple demonstration.  [On your AMOS 1.2 Program
disk within the Manual Folder.]

Bob n,x,y,i

Place BOB number n at screen coordinates x,y using image number i.  n
is normally limited to 63 at the most but this value can be changed
with the AMOS setup program.

Double Buffer

Create a logical screen for the current physical screen.

Set Bob n,back,planes,minterms

Set drawing parameters for BOB number n.  If back = 0 then the BOB can
be moved around without corrupting the background.  If back > 0 then
then area beneath the BOB will be replaced by colour back-1.  This is
useful if a BOB is moving on a solid coloured background.  If back < 0
then the redrawing process is turned off and its up to the user to
replace and backgrounds destroyed by the BOB.  planes is a binary mask
representing which bit-planes the BOB will be drawn on.  minterm is
the blitter mode used to draw the BOB.  Normal settings are %11100010
if the BOB is used with a mask or %11001010 if no mask has been set.
Note: it is a good idea to use the SET BOB command before turning a
BOB on.

No Mask [n]

Turn of masks for all BOBs or just BOB number n.

Autoback n

Coordinate drawing functions with BOBs.  n sets the AUTOBACK mode.  If
n = 0 then AUTOBACK is turned off.  All drawing commands are sent to
the logical screen only.  If n = 1 then graphical operations are sent
to the physical and logical screens at the same time.  No account is
taken of the BOB on the screen.  It is best to keep graphical
operations away from BOB when in this mode.  If n = 2 then graphical
operations are now synced with the BOB updates and will appear behind
them.  However, in this mode, graphical operations will take twice as
long to complete.

Bob Update On
Turn on the automatic BOB update function.  BOBs will be drawn every
50th of a second.

Bob Update Off
Turn off the automatic BOB update function.  This allows all BOBs to
be placed before they are drawn.  To draw BOBs use Bob Update (below).

Bob Update
Draws all BOBs.  Note:  Bob UPDATE draws all BOBs to the logical
screen.  In order to see them a SCREEN SWAP command must be called.

Bob Clear

Clear all BOBs from the screen and redraw the background regions
underneath.  This is intended for use with BOB DRAW to provide an
alternative to the standard BOB UPDATE command.

Bob Draw

Draw all BOBs.  BOB CLEAR and BOB DRAW give finer control over BOB
updates then the BOB UPDATE command.

x1 =X Bob(n)
y1 =Y Bob(n)

Returns the x or y [respective] screen coordinate of BOB number n.

im=I Bob(n)

Returns the current image number used by BOB number n.  The value will
be 0 if BOB number n is not displayed.

Limit Bob [n,] x1,y1 To x2,y2

Limit the visibility of all BOBs or just BOB number n to an area
defined by x1,y1 to x2,y2 in screen coordinates.  x will be rounded to
the nearest 16 pixel boundary.  This area must be greater then the
width of your BOBs or an error message will be returned.

Get Bob [s,] i,x1,y1 To x2,y2

Grab an an image in area x1,y1 to x2,y2 on screen s and store it as
BOB image number i.

Put Bob n

Draw BOB number n to the screen at its current location for good.
Background image is not preserved.  Note:  Its a good idea to use a
WAIT VBL after this command.

Paste Bob x,y,i

Draw image number i to the current screen at screen coordinates x,y.
A WAIT VBL command is not needed after this command.

Bob Off [n]

Turn off all BOBs or just BOB number n.

Hide [On]

Hide the mouse pointer.  A record of the number of times this function
has been used is kept and it takes an equal number of SHOW commands
before the mouse is visible again.  HIDE On will hide the pointer
regardless of how many times the SHOW command has been called.  Even
though the pointer is invisible, its location can still be read with
the X MOUSE and Y MOUSE functions.

Show [On]

Show the mouse pointer.  A record of the number of times this function
has been used is kept and it takes an equal number of HIDE commands
before the pointer will be hidden.  SHOW On will show the pointer
regardless of how many times the HIDE command has been called.

Change Mouse m

Change the pointer image number m.  If m = 1 then pointer is an arrow.
If m = 2 then pointer is a crosshair.  If m = 3 then pointer is a
clock.  If m > 3 then pointer will be image number m-3.  The mouse
image can not be wider then 16 pixels and contain no more then four
colours.

k=Mouse Key

Returns a bit pattern representing which key(s) of the mouse have been
pressed.  Bits 0-2 represent mouse buttons 1-3.

c=Mouse Click

Returns a bit pattern representing which key(s) of the mouse have been
clicked.  The register is set back to zero after it has been checked
so it will only detect one key press at a time.

x1=X Mouse    X Mouse=x1
Returns current x hardware coordinate of the mouse pointer, or assigns
pointer to coordinate x1.

y1=Y Mouse    Y Mouse=y1
Returns current y hardware coordinate of the mouse pointer, or assigns
pointer to coordinate y1.

Limit Mouse x1,y1 To x2,y2

Restrict mouse movement to area x1,y1 to x2,y2.

d=Joy(j)

Returns a bit pattern that represents the direction of joystick j
(0-1).  The pattern is as follows:

    Bit Number    Direction
        0            up
        1           down
        2           left
        3           right
        4         fire button

x=Jleft(j)

Returns a value of -1(TRUE) if joystick number j is moved to the left,
otherwise 0(FALSE) is returned.

x=Jright(j)

Returns a value of -1(TRUE) if joystick number j is moved to the
right, otherwise 0(FALSE) is returned.

x=Jup(j)

Returns a value of -1(TRUE) if joystick number j is moved up,
otherwise 0(FALSE) is returned.

x=Jdown(j)

Returns a value of -1(TRUE) if joystick number j is moved down,
otherwise 0(FALSE) is returned.

x=Fire(j)

Returns a value of -1(TRUE) if fire button on joystick j is down,
otherwize 0(FALSE) is returned.

c=Sprite Col(n [,s To e])

Returns -1(TRUE) if sprite number n has collided with any other
sprites or just a range of sprites from s to e.
Note: the MAKE MASK command must be called before this function can be
used.

c=Bob Col(n [,s To e])

Returns -1(TRUE) if BOB number n has collided with any other BOB or
just a range of BOBs from s to e.

c=Spritebob Col(n [,s To e])

Returns -1(TRUE) if sprite number n has collided with any BOBs or just
a range of BOBs form s to e.

Note: this function only works in low res.

c=Bobsprite Col(n [,s To e])

Returns -1(TRUE) if BOB number n has collided with any sprites or just
a range of sprites form s to e.

Note: this function only works in low res.

c=Col(n)

COL is an array containing the collision detection data.  Each element
relates to a sprite or BOB.  The first element will be set to -1 if a
collision has been detected with sprite or BOB number 1 and so on
through the array.

Also see AUTHOR NOTE ON =COL(BOB).

Hot Spot i,x,y

Sets the hot spot for image number i to x,y measured in pixel from the
top left corner of the image.  A hot spot is the "handle" by which a
image is positioned.

Make Mask [n]

Make a mask for all images in the SPRITE/BOB bank or just image n.
Masks are used for collision detection.

Reserve Zone [n]

Reserve memory for n number of ZONEs.  If n is not provided then all
zones are removed from memory.

Set Zone z,x1,y1 To x2,y2

Create zone area number n at screen coordinates x1,y1 to x2,y2.  The
RESERVE ZONE command must be called before any zones are set.

t=Zone([s,] x,y)

Returns the zone number at screen coordinates x,y on screen s.  This
only detects the first zone at these coordinates.

t=Hzone([s,] x,y)

Returns the zone number at hardware coordinates x,y on screen s.

x=Mouse Zone

Returns the zone number at the current mouse position.

Reset Zone [z]

Deactivate all zones or just zone number z.  This does not fee any
memory used by the RESERVE ZONE command.

Priority On   Priority Off

Normally BOBs are drawn in the order they are numbered.  When Priority
in ON then the BOBs with the greater y coordinates are given priority.
This means that the BOB lower on the screen have priority over the
BOBs higher on the screen.  PRIORITY OFF set BOB priority calculation
back to normal.

Update   Update On   Update Off

Same as SPRITE UPDATE and BOB UPDATE except this command controls both
SPRITEs and BOBs at the same time.

Paste Icon x,y,n

Draw icon number n at graphic coordinates x,y.
Note: if DOUBLE BUFFER is on then icons will be drawn to both the
physical and logical screens.  To speed this up, turn AUTOBACK to 0
before drawing icons.  This way they are only drawn to the logical
screen.

Get Icon [s,] i,x1,y1 To x2,y2

Grab icon number i from area x1,y1 to x2,y2 form screen s.

Get Icon Palette

Use icon palette.

Del Icon n [TO m]

Delete icon n to m.

Make Icon Mask [n]

Make a mask for all icons or just icon number n.

table=Icon Base(n)

Returns the address for icon n.  The format for this information is
exactly the same as the SPRITE BASE command.

Get Block n,x,y,w,h [,mask]

Grab block number n from location x,y to width w and height h.  If
mask is set to 1 then a mask will be made for the block.

Put Block n [,x,y]
Draw block number n at its original coordinates or at x,y.  x and y
are rounded to the nearest 16-pixel boundary.

Put Block n,x,y,planes [,minterms]
Draw block number n at x,y.  planes is a bit pattern dictating which
planes the block is drawn on.  minterms selects the blitter mode.

Del Block [n]

Delete all blocks from memory or just block number n.

Get Cblock n,x,y,w,h

Grab compressed block number n from location x,y to width w and height
h.  x will be rounded to the nearest multiple of eight.

Put Cblock n [,x,y]

Draw compressed block number n at its original coordinates or at x,y.
x will be rounded to the nearest multiple of eight.

Del Cblock [n]

Delete all compressed blocks or just number n.

Boom

Make a boom sound.

Shoot

Make a gun shot sound.

Bell

Make a bell sound.

Volume [v,] intensity

Change volume of all sound channels or just channel number v.
intensity can be set from 0(off) to 63(full volume).

Sam Play s    Sam Plap v,s    Sam Play v,s,f

Play sample number s with voice v at a frequency of f.  v is a bit
pattern representing the 4 voice channels.

Sam Bank n

Select a new memory bank to be used for samples.

Sam Raw v,addr,len,freq

Play a raw sound sample from anywhere in memory using voice v.
Starting at address addr, play len number of samples at a frequency of
freq.

Sam Loop On    Sam Loop Off

All subsequent samples are to be continuously looped.

Play [voice,] pitch,delay

Plays the single note pitch for a length of delay.  The optional voice
is a bit pattern which allows you to select one or more voices.

For full details, it's recommended that you read page 240-241 in your
manual for the listing of the notes and voice settings.

Set Wave wave,shape$

This provides you with the ability to design your own instruments.  The
WAVE command then allows you to use the wave with a voice.

In most musical programs [Sonix, DMCS, etc], you have the ability to use
a WAVEform, so you now do with AMOS.  As usual, these waveforms are a
list of values from 0 to 255 and of a length of 256 values.

For more information, it is suggested to read pages 241-243 of your
manual to see what a WAVEform is.

Wave w To v

This instructs the voice(s) v that it is to use the WAVEform w while
playing notes with the PLAY command.  v contains the standard bitmap
format for selecting voices.

Noise To v

This instructs the voice(s) v that it is to use the Amos WHITE NOISE
WAVEform for the selected voice(s) v.  v contains the standard bitmap
format for selecting voices.

Del Wave n

This deletes user created WAVEforms that were created using the SET WAVE
command.  All voices using deleted WAVEform will be reset to the
standard SINE WAVEform (default).

Sample n To v

This allows a digitized WAVEform to be used as a WAVEform for v.  The
sample is a standard sample that the SAM PLAY would play.

For more details, see page 245 of your manual.

Set Envel wave,phase To duration,volume

wave is the WAVEform that you wish to change the Envelope of.  This also
immediately will change any voice playing this WAVEform to the current
settings.

It is recommended to read the information in the manual on page 245-246
for further information on Attack, Decay, Sustain and Release.

Say t$ [,mode]

SAY will cause your amiga to speak t$ to you.

mode can be one of two modes:

0  (default) means AMOS must wait for the SAY command to finish speaking.

1  allows AMOS to continue while the SAY command speaks, but this slows
   down AMOS, so use as you see fit.

Set Talk sex,mode,pitch,rate

The following is the format for:

sex   is:      0 for male [default], 1 is for female

mode  is:      a rythmic effect added to the speech.
                 0  (default) is off
                 1  turns on the rythmic effect.

pitch is:      changes the pitch of the voice from 65 (low) to
               320 (incredibly high)

rate  is:      amount of words/minute ranging from 40 to 400.

Any of the above can be omitted, as long as commas are left as required.

Example:  Set Talk ,,,65

Music n

Play music number n.  Only one piece of music can be played at a time,
but up to four can be active and waiting on a stack.  All music files
must first be translated to AMOS format using one of the conversion
programs.

Music Stop

Stop playing the current piece of music.

Music Off

Turn off all music.  If restarted, the music will play from the
beginning.

Tempo s

Set tempo for music to s (1-100).

Mvolume n

Change the music volume to n (0-63).

Voice mask

Set which voices are to be used by the music.  mask is a bit pattern
representing the four voice channels.

s=Vumeter(v)

Returns the volume of the current note being played.  The value
returned can range form 0 to 63.

Led On   Led Off

Turn the audio filter on or off.  This also controls the power light
on the Amiga.

Menu$(n)=title$
Set menu titles that will appear in the menu bar.  Leave a space at
the end of each title to space them out.
(eg.  Menu$(1)="First menu " : Menu$(2)="Second menu " )

Menu$(t,o)
Menu$(t,o)=normal$ [,selected$][,inactive$][,background$]
Set option number o under title number t to normal$.
(eg. Menu$(1,1)="First option" : Menu$(1,2)="Second option" )
selected$ sets what the option will look like when it is selected.
The default is inverse text.  inactive$ sets what the option will look
like when it is inactive.  The default is italic text.  background$
sets the background for the menu.  background sets any back ground
that can be drawn with embedded drawing commands explained later.

Menu On
Activate menu defined in the Menu$ commands.

Menu On [bank]
Activates a menu that has been defined.  If bank number is included
then the menu in the appropriate memory bank will be used.

select=Choice
Returns a value of -1(TRUE) if something has been selected from the
menu.  CHOICE is set to 0(FALSE) after every check.

item=Choice(c)
Returns the option number that was selected at level number c.

On Menu Proc proc1 [,proc2][,proc3]...

Executes the procedure in the list that corresponds with menu title
that has been selected.  (eg. if the 3rd menu item was selected then
the 3rd procedure in the list will be executed.)  This is an interrupt
command and is checked every 50th of a second.

On Menu Gosub label1 [,label2][,label3]...

Similar to ON MENU PROC.

On Menu Goto label1 [,label2][,label3]...

Similar to ON MENU PROC.

On Menu On
Activate the automatic menuing system created by the On Menu
Proc/Gosub/Goto commands.  Every time an On Menu Proc/Gosub/Goto
function is called, the automatic system is turned off.  It must be
turned back on with an On Menu On command before the end of a
procedure or subroutine if you want it to stay on.

On Menu Off
On Menu Off turns off the automatic menuing system.  Its a good idea
to do this before disk access.

Clear the current automatic menuing system so that another can be
defined.  A ON MENU OFF command must be used before this one.

Menu Key(,,) To c$
Create a keyboard short cut to a menu selection.  c$ is a single
character.

Menu Key(,,) To scan [,shift]
Create a keyboard short cut to non ASCII keys.  scan is a keyboard
scancode:

    Scancode     Keys
     80-89        Function keys F1-F10
     95           Help
     69           Esc
shift is an optional bitmap that checks for control keys:

  Bit    Key
   0     Left Shift Key
   1     Right Shift Key
   2     Caps Lock (On or Off)
   3     Ctrl
   4     Left Alt
   5     Right Alt
   6     Left Amiga
   7     Right Amiga (or Commodore key)

Menu Off

Turn off the menu bar.

Menu Del [(,,)]

Delete all menus or just those listed.

Menu To Bank n

Save current menu tree to bank number n.  Bank number n must not
already exist.  When a menu tree has been saved to a bank, it will
automatically be saved and loaded along with the main program.  This
means that the original program lines defining the menu can be
deleted, saving memory.

Bank To Menu n

Load a menu tree saved in bank n.  To activate the new menu, use the
MENU ON command.

Menu Calc

Rearranging a large menu can take some time.  Wait for an appropriate
time, then turn off the menu with MENU OFF, rearrange the menu, use
MENU CALC, and then turn the menu back on with MENU ON.

Menu Inactive level    Menu Inactive(,,)

Set an entire level of the menu to inactive or an individual option by
addressing its position in the menu tree.

Menu Active level    Menu Active(,,)

Activate an entire menu level or an individual option by addressing
its position in the menu tree.

Menu Line level    Menu Line(,,)

Display menu as a horizontal line.

Menu Tline level    Menu Tline(,,)

Display menu as a horizontal line that goes right across the screen.

Menu Bar level    Menu Bar(,,)

Display menu as a vertical bar.

Menu Movable level    Menu Movable(,,)

Allow menus to be moved by the user.

Menu Static level    Menu Static(,,)

Stop user from rearranging the menus.

Menu Separate level    Menu Separate(,,)

Allow each item in a menu to be treated as a separate element.

Menu Link level    Menu Link(,,)

Reverse the MENU SEPARATE command.

Menu Base x,y

Set the starting point of the first level of menus to x,y.

Set Menu (,,) To x,y

Place the top left corner of a menu to x,y measured relative to the
previous level.

Menu Mouse On    Menu Mouse Off

Display menus at the current mouse pointer location.  The position of
the menus can be offsetted by the menu base command.

Menu Called(,,)

This automatically redraws the selected menu item 50 times a second
whenever it is displayed on the screen.  It's usually used in junction
with a menu procedure to generate animated menu items which change
infront of your eyes.

See EXAMPLE 16.11 in the MANUAL folder of your AMOS1.2 PROGRAM disk.

Menu Item Movable level
Menu Item Movable(,,)

This command is simular to the MENU MOVABLE command except that it
allows you to re-arrange the various options in a particular level.  So,
all the items in a menu bar may be individually repositioned by the
user.  See your manual page 230 for detailed information on this
command.

Menu Item Static level
Menu Item Static(,,)

This command locks one or more menu items firmly into place and is the
default setting.

Menu Once(,,)

Turns off the automatic updating system started using the command
MENU CALLED.  From that point on, the menu item selected will only be
drawn once when on screen.

x=Menu X(,,)
This function allows you to retrieve the position of a menu item
relative to the previous option on the screen.  You can use this
information to implement powerful menus such as the one found in EXAMPLE
16.13 in the MANUAL folder on your AMOS1.2 PROGRAM disk.

y=Menu Y(,,)
Returns the Y coordinate of the menu option.  Note that all coordinates
are measured relative to the previous item.  So this is NOT a standard
screen coordinate.

Important Info:

The following embedded menu commands can be added to your menus
by including them in round brackets () in the menu definition
string. (eg. MENU$(1)="(locate 10,10 : INK 1,1) Hello"  )

BOB
BOb n
Display BOB number n at the current cursor location.  The HOT SPOT of
the BOB is not taken into account.

ICON
ICon n
Draw icon number n at the current cursor location.

LOCATE
LOcate x,y
Place the graphics cursor at x,y measured relative to the top left
corner of the menu line.  After a graphics operation the new cursor
location will be at the bottom right corner of the last object drawn.

INK
INk n,index
Change the colour register of the PEN, PAPER or OUTLINE to index.  If
n= 1 then the PEN is affected, 2 for the PAPER and 3 for the OUTLINE.

SFONT
SFont n
Set current font to graphics font number n.

SSTYLE
SStyle n
Set font style to n.  n is a bit pattern.  Bit 0 sets underline, 1
sets bold and 2 sets italic.

LINE
LIne x,y
Draw a line from the current cursor position to graphics coordinates
x,y.

SLINE
SLine p
Set line style to bit pattern in p.  p should be entered as a decimal.

BAR
BAr x,y
Draw a rectangular bar from the current cursor location to x,y.

PATTERN
PAttern n
Set fill pattern to n.

OUTLINE
OUtline flag
If flag is 1 then outline mode is on.  0 turns it off.

ELLIPSE
ELlipse r1,r2
Draw an ellipse with the center at the current cursor position radii
or r1 and r2.

Dir [PATH$][/W]

W will cause the directory to be printed in two columns.

s$=Dir$   Dir$=s$

Return or set the current directory.

Parent

Jump up one directory.

Set Dir n [,filter$]

Set directory listings to n characters wide.  filter$ contains a list
of path names separated by / to be excluded from the directory list.
(eg. SET DIR 10,".INFO/*.INFO/*.*.INFO" )

f=Dfree

Returns the number of bytes free on the current disk.

Mkdir f$

Make a new folder.

Kill f$

Erase a file on disk.

Rename old$ To new$

f$=Fsel$(path$ [,default$][,title1$,title2$])

Calls up the file requester and returns the selected file name or ""
if QUIT was selected.

Run f$

Run program f$ from disk.

flag=Exist(f$)

Returns a value of -1(TRUE) if file f$ exists on disk.

file$=Dir First$(path$)

Returns the first file name at location path$.

file$=Dir Next$

Returns the name of the next file in the directory.  DIR FIRST$ must
be called before this command.  If there is not another file, then ""
is returned.

Open Out c,n$

Open channel number c for output to file n$.  If the file already
exists then the old one will be erased.

Append c,n$

Open channel number c for appending output to file n$.

Open In c,n$

Open channel number c for input from file n$.

Open Port channel,"PAR:"  (Opens channel to the Parallel interface.)
Open Port channel,"SER:"  (Opens channel to the Serial interface.)
Open Port channel,"PRT:"  (Opens channel to the Printer interface
                           chosen from Workbench Preferences.)

OPEN PORT allows you to communicate with external devices such as
printers.  All the standard sequential file commands can be preformed as
normal, except for commands like LOF or POF which are obviously only
relevant to disc operations.

n=Port(channel)

Tests to see if an input device is ready to send you some information. 
If the device is ready for you to read it, n will have a -1(TRUE)
value or a 0(FALSE) value otherwize.

Open Random channel,f$

Opens a RANDOM ACCESS file called f$.  When you're using this
instruction, you should always define the record structure immediately
after using the FIELD command.

Field channel,length1 As field1$,length2 As field2$,...

Field allows you to define a record which will be used for a random
access file.  This record can be up to 65535 bytes in length.

Get channel,r

This loads the FIELD selected strings with the information of out of
the random access file channel from record r.  Note that you can only
use GET to retrieve records which are actually on disc.  If you try to
grab a record which does not exist, then an error will be generated.

Put channel,r

PUT moves a record from the Amiga's memory [following the FIELD
command's list of strings and sizes] to the record number in r to the
random access file channel.  Before using the PUT command, the strings
defined by the FIELD command should be defined.

Close [n]

Close channel number n.  IF n isn't supplied, Close will close all open
files.

Print#c,variable list

Print data to channel c.

Input#c,variable list

Input data from channel c.

Line Input#c,variable list    LINE Input#c,separator,variable list
Same as INPUT#, but allows you separate your list of data using any
character you wish.  If separator is omitted then the default is the
return character.

x$=Input$(f,count)

Read count number of characters from device number f.

flag=Eof(c)

Returns -1(TRUE) if the end of the file in channel c has been reached.

length=Lof(c)

Returns the length of the file in channel c.

pos=Pof(c)

Reads the current reading or writing position of the file in channel
number c.

Lprint variable list

Print a list of variables.

Ldir [path$][/W]

Print a directory.

Up to 16 AMAL programs can be run at the same time using
interrupts.  more may be executed but they will not be running on
interrupts.  Only the capital letters of an AMAL command are
significant.  Each AMAL program has its own set of 10 internal
registers.  Each register starts with the letter R and is
followed by a number from 0 to 9 (eg. R1,R2,R3...).There are 26
external registers that can be accessed by other AMAL programs or
directly from Basic.  They begin with the letter R and are
followed by another letter from A to Z (eg. RA,RB,RC...).

Special Registers
X and Y are internal registers and always contain the location of the
object being controlled by an AMAL program.  Another internal register
is A.  It contains the number of the image that is displayed by a
SPRITE or BOB.

Operators
AMAL expressions can include all the normal arithmetic operations,
except MOD.  You can also use the following logical operations:
   &   logical AND
   |   logical OR

Move deltaX, deltaY, n

Move object to deltaX,deltaY relative to the objects current position
in n number of steps.  If deltaX is positive the object will move to
the right, else to the left.  If deltaY is positive then the object
will move down, else up.  The smoothest movements are made when both
deltaX and deltaY are multiples of n.

Anim cycles,(image,delay)(image,delay)...

Animate an object.  cycles is the number of times the animation will
be repeated.  If cycles is 0 then the animation will be looped until
told to stop.  image is the image number to be displayed and delay is
the time measured in 50ths of a second that it will remain until the
next image is displayed.  After an animation command has been
initialized, AMAL will continue with the next instruction.

Let reg=exp

Save a value in an AMAL register.  Possible AMAL registers are R0-R9
and RA-RZ.

Jump L

Jump to label L.  Labels are defined as a single letter followed by a
colon.  A label name can be padded with lowercase letters to help them
read easier but make sure that the first letter of each label in an
AMAL program is different. (eg.  Start:  and  Shoot:  would be
considered the same thing and would cause an error.)

If exp Jump L

Perform a test and if the result is TRUE, then Jump to label L.
exp can be any logical expression  =,  <>,  <,  >.  Its common
practice to pad out this instruction with lowercase commands like
"then" or "else". (eg. If X>100 then Jump Label else Let X=X+1 ).
 If exp Direct L     If exp eXit
The above variations of the If command are used by the (AMAL)  AUTOTEST
feature explained later.

For reg=start To end ...Next reg

It is legal to have nested loops in an AMAL program but the step size
of the loop is always set to one.  Only one step of a loop is
performed every vertical blank period.

PLay n

Play series number n of movements stored in the AMAL bank.  These
movements are created using the AMAL accessory.  When the PLay command
is used R0 holds the tempo of the movements.  larger the number in R0,
the faster the object will move.  R1 controls the direction of the
movements.  If R1=1 then the movements are play forward.  If R1=0 then
the movements are played backward.  If R1= -1 then the movements are
stopped and AMAL continues with the next command.

End

Terminates the AMAL program and turns off the (AMAL)  AUTOTEST feature if
its been defined.

Pause

Wait for the next vertical blank period.  It is good practice to use a
Pause command before a (AMAL)  JUMP.

AUtotest (list of test)
AUtotest is a list of commands that are executed every 50th of a
second just before the main AMAL program is run.  The possible
commands that can be used in an AUtotest list are:

Let
Let reg=exp
Same as the regular AMAL command

Jump
Jump label
Same as the regular AMAL command except label must lie inside the
Autotest list.

eXit
eXit
Leave Autotest and continue with the main program.

Wait
Wait
Turn off the main AMAL program and only execute the AUtotest.

If
If exp Jump label   If exp Direct label   If exp eXit
Jump is the same as the regular AMAL command.  Direct will Jump
to a part of the main AMAL program after the AUtotest.  eXit will
leave AUtotest and continue with the main program.

On
On
Restart the main AMAL program after a Wait command.

Direct
Direct label
After AUtotest is complete, the main AMAL program will continue
at label.  label must lie outside of AUtotest.

Returns the X hardware coordinate of the mouse.

Returns the Y hardware coordinate of the mouse.

Returns a value of -1(TRUE) if the left mouse key has been pressed.

Returns a value of -1(TRUE) if the right mouse key has been pressed.

Returns a bit map containing the right joystick status.  See JOY for
more details.

Returns a bit map containing the left joystick status.  See JOY for
more details.

Returns a random number from 0 to n.

Converts screen coordinate x on screen s to a hardware coordinate.

Converts screen coordinate y on screen s to a hardware coordinate.

Converts hardware coordinate x to a screen coordinate on screen s.

Converts hardware coordinate y to a screen coordinate on screen s.

Identical to the BOB COL command.  Returns a value of -1(TRUE) if BOB
number n has collided with BOBs s to e.  This command can not be used
with an interrupt driven AMAL program.  See SYNCHRO for information on
non-interrupt AMAL programs.

Similar to (AMAL FUNCTION)  =BOB COL(N,S,E), above.

Returns a value of -1(TRUE) if object n has collided with another
object.  For use after an SpriteCol or BobCol command.

See (AMAL FUNCTION)  =BOB COL(N,S,E)
 or (AMAL FUNCTION)  =SPRITE COL(N,S,E).

Returns the volume (0-255) of the current voice.

Amal n,a$
Assign a$ to AMAL channel number n.  If n > 16 then the AMAL program
will not be interrupt driven.

Amal n,p
Assign AMAL program number p in the AMAL bank to AMAL channel n.

Amal n,a$ To address
Copy the contents of registers X, Y and A into an area of memory
starting at address.  The information will be saved like so:

  Location     Effect
  Address      Bit 0 is set to 1 if the X has changed.
               Bit 1 is set to 1 if the Y has changed.
               Bit 2 is set to 1 if the A has changed.
  Address+2    Is a word containing the latest value of X.
  Address+4    Holds the current value of Y.
  Address+6    Stores the value of A.

Amal On [n]    Amal Off [n]

Turn on all AMAL programs or just program number n.

Amal Freeze [n]

Stops all AMAL programs or just number n.  The AMAL programs can be
restarted with the AMAL ON command.  Its a good idea to freeze all
AMAL programs before disk access.

r=Amreg(n [,c])    Amreg(n [,c])=exp

Read an AMAL register or pass a value to an AMAL register. n is the
number of the register.  Possible values range from 0 to 25
representing RA to RZ.  If c is present then the internal registers of
the AMAL program in channel c can be accessed.  In this case n must be
between 0 and 9 representing R0 to R9.

Amplay tempo,direction[s To e]

Set parameters for AMAL play sequences in all channels or just
channels s to e.  tempo set the delay in 50ths of a second between
each movement.  direction is as follows:

    Value   Direction
     >0      Forwards
      0      Backwards
     -1      Stop movement pattern and continue with next AMAL command

s=Chanan(c)

Returns a value of -1(TRUE) if the Anim sequence in channel c is still
active.

s=Chanmv(c)

Returns a value of -1(TRUE) if the Move command in channel c is still
active.

p=Amalerr

Returns the position of an error in the current AMAL program.

Assign an AMAL channel to an object.

Assign sprite number s to AMAL channel n.  The X and Y registers
in the AMAL program will now control the hardware coordinates of
the sprite.

Assign BOB number b to AMAL channel n.  The X and Y registers in
the AMAL program will now control the screen coordinates of the
BOB.

Assign screen number d to AMAL channel n.  The X and Y registers
in the AMAL program now control the screen position in hardware
coordinates.

Assign screen number d to AMAL channel n.  The X and Y registers
in the AMAL program now control the screen offset.

Assign screen number s to AMAL channel n.  The X and Y registers
in the AMAL program now control the width and height of the
screen.

Assign rainbow number r to AMAL channel n.  The X register
controls the BASE of the rainbow and Y controls the starting line
and A stores the height.  X and Y are hardware coordinates.

Update Every n

Force AMAL programs to update only every n 50ths of a second.  This
may free up some time for the main program and a result could make
things run faster.

Rain(n,line)=c
c=Rain(n,line)

Set or Read the colour at line from rainbow n at any time.

Rainbow n,base,y,h

RAINBOW activates Rainbow n starting base lines into the rainbow
defination at hardware screen location y with a length of h lines.

See your manual page 141 for further information reguarding safeguards.

Set Rainbow n,colour,length,r$,g$,b$

SET RAINBOW defins a rainbow effect which can be subsequently displayed
using the RAINBOW command.  It works by changing the shade of a colour
according to a series of simple rules.

n is the number of your rainbow.  Possible values range from 0 to 3.

colour is the colour index which will be changed by the instruction. 
Note only 15 colours can be manipulated in this manner.

length is the size of the table used to store your colours.  There's one
entry in this table for each colour value on the screen.  The size can
range from 16 to 65500.  If length is less than the physical height of
your rainbow, then the colour pattern will be repeated for the full
length.

r$, g$, b$ are command strings which change the intensities of red,
green and blue respectively.  Each entry controls a single screen line.

Each string can contain a whole list of commands.  These will be cycled
until the final rainbow pattern is produced.  The format is:

"(n,step,count)(n,step,count)..."

n sets the number of lines to be assigned to the specific colour value
in the rainbow.

step holds the number to be added to the colour component [RGB] mod 15.
     [Each component can go from 0 to 15, if a value exceeds 15, it is
      set to 0.  As well, if a value goes below 0, it's set to 15.]

count is the number of times the current operation is to be repeated.

Synchro Off   Synchro On    Synchro

Release AMAL updating to Basic control.  If more then 16 AMAL channels
are going to be used then SYNCHRO must be used.  First, call SYNCHRO OFF
before defining the AMAL programs.  Then use SYNCHRO to activate the
next step in all the AMAL programs.  To return to normal interrupts
use SYNCHRO On.

Move X n,m$
Move Y n,m$

Define a movement for animation channel n.

m$ is the defination of movements.

Definations are as follows:

"(speed,step,count)(speed,step,count)...[E#/L]"

The E directive allows you to have your object stop when it reaches a
certain location on the screen, such as "E100" will ensure that the
current x or y stops at 100.

The L directive allows the MOVE command to loop back to the first entry.

speed is the delay in 50ths of a second between each step.  speed's range
is 1 (mega fast) and 32767 (super mega slow).

step is the amount the object will move.  [Positive or negative pixels.]

count is the amount of times you want to do this movement.

Example:  Move X 1,"(3,-4,10)E100"  will move the X -4 pixels every
          3/50th of a second for 10 times.  E100 will ensure that X never
          goes beyond 100.

See MOVE ON-OFF for more details.

Move On-Off [n]
Move On [n]
Starts MOVE n or all movements.  [Previously created using either the
MOVE X or MOVE Y command.]

Move Off [n]
Stops MOVE n or all movements.  [They can't be resumed after a stop.]

Move Freeze [n]

This will stop movement n or all movements.  [This is not perminant like
the MOVE OFF command.]

To resume movements, use the MOVE ON command.

x=Movon(n)

This returns a -1(TRUE) if the current channel has movement [a MOVE
command is running, not an AMAL movement].  Otherwize a 0(FALSE) is
returned.

Anim n,a$

Define an image animation for animation channel n.

a$ is the defination of the image animation, which is executed every 50th
of a second like AMAL animations.  Except these animations change the
object's image # [in a SPRITE/BOB Bank].

Definations are as follows:

"(image,delay)(image,delay)...[L]"

The L directive allows the ANIM command to loop back to the first entry.

image is the image # within a SPRITE/BOB Bank to be displayed for
the delay period.

delay specifies the amount of time the image remains (in 50ths of a
second).

Also see ANIM ON-OFF.

Anim On-Off [n]
Anim On [n]
Starts ANIM n or all image animations.  [Previously created using the
ANIM command.]

Anim Off [n]
Stops ANIM n or all image animations.  [They can't be resumed
after a stop.]

Anim Freeze [n]

This will stop movement n or all movements.  [This is not perminant like
the ANIM OFF command.]

To resume movements, use the ANIM ON command.

Track Load "Name_Of_The_Module",Bank

Load up a tracker module into a chip memory bank. It will of course it
reserve the bank for you, and choose the correct bank size.

If AMOS detects a Startracker synthetic instrument file (which must have
a ".NT" extension appended to the file name), it will load it AS WELL
into the bank. In fact you don't have to worry about it.

Track Play [Bank],[Pattern]

Plays a tracker module loaded into a bank.

"Bank" is the number of the bank to be played. If omitted, it is the last
loaded with the TRACK LOAD instruction, or upon running, bank number 5.

"Pattern" is the first pattern to be played. Use this with caution, as NO
CHECK is done on the number of the pattern. You can very simply crash the
computer by giving a bad value. This parameter is intended to allow you
to have more than one music in a tracker bank...

Track Loop On-Off

Enable or disable looping when the tracker music is finished.

Track Stop

Stops a tracker music being played.


The Tracker-playing instructions are implemented to give you a quick way
of playing modules. It is not as powerful as the normal AMOS music system.

For example:

* Do not play a normal AMOS music while playing a tracker module,
  this can lead to unpredictable results.

* Do not start any sample, or sound effect when a Tracker module is played.

* A Tracker module uses and initialises all four voices, even if your music
  is only on 3 or 2. So do not play any sample on the other voices you think
  are free. They are not!

* VOLUME instructions do not have any effect on the Tracker music, but
  =VUMETER works fine with a Tracker module.

... if you want to make sound effects while a music is playing, then you
should use the Soundtracker converter, and the normal AMOS Music system...

Sload File_Number,Length To Address

A new instruction intended to load parts of a sample, but it can be used
in many other ways.

This instruction is an extended BLOAD.

"File_Number" is the number of a file opened previously with the
OPEN IN File_Number,"Name" instruction.

"Length" is the number of bytes to load. If this number is bigger than
the actual size of the file, then only the remaining bytes are loaded,
without errors. You'll get an error if you try to load once more after
the end has been reached.

"Address" is the destination address. Of course, the memory must have
been previously reserved.

The advantage of this instruction, is that you can set the position of
the file pointer with the POF()= instruction before using SLOAD. As you
can see, this instructions can have a lot more usage than just loading
samples...

Sam Swap Voices To Address,Length

This instruction initialise the sound-swapping. The actual swapping will
only occur when the actual buffer has been totally played through the
speaker. The swap is done under interrupts, so you will not hear any tick
in the sample.

"Voice" is a bit pattern to define the voice concerned, just like in the
SAM RAW instruction.

"Address" is the address of the next buffer to play. Of course, it must
be in chip memory.

"Length" is the number of bytes to play.

=Sam Swapped(Voice_Number)

This function returns a boolean value (TRUE -1, or FALSE 0). It is the
key function in synchronising double buffer players.

"Voice_Number" is the number of the voice you want to have information
about (0 to 3). Do not make mistake, is it NOT a bitpattern.

It returns TRUE if the sample swapping has occurred, it means the new
buffer you have initialised with the SAM SWAP instruction is being
played at the very moment. It returns FALSE if not.

Practically, you can only load a new part of the sample in the free
buffer, when the SAM SWAPPED instruction returns you a TRUE value. It
returns FALSE if the sample swapping has NOT happened.

Sam Stop [Voice_Pattern]

This simple instruction seems to have been forgotten in the instruction
set since the beginning. The only way to stop a sample playing, was to
use the PLAY instruction!

"Voice_Pattern" is a bit pattern defining the voices to be stopped, like
in the SAM RAW instruction. All voices will be affected if you omit it.


NOTE: it is perfectly possible to have an AMOS music bank playing on 2
voices, and double-buffered samples playing on the last 2. (hey, but not
a Tracker module, if you remember what I told you!)


Well, in fact, it is not a new instruction, but a good enhancement to the
collision detection method.
To detect a collision, I remind you, you have to use one of the collision
detection functions (=BOB COL(), =SPRITE COL(), =BOBSPRITE COL(),
=SPRITEBOB COL()). When this function returns a TRUE value, you have
to explore the =COL() reserved array to find out which bob or sprite
created the collision.
The problem, is that you had to write a loop exploring sequentially all
the COL() array. This was eating a lot of processor time. You could see
certain games slowing down when some bobs were colliding.

I wanted to do something to correct it. But what? The problem with AMOS,
is that if I change the syntax or the behaviour of one instruction to
please certain people, it may (and surely will) not be compatible with
thousand of existing programs!
So I found a -rather tricky- solution to this problem.

=COL(Number) behaves normally if you send it a POSITIVE number as an
argument, this keeps it compatible with all existing programs.

If "Number" is negative, AMOS will first remove the sign, i.e. turn it
into a positive number.
Then it will explore the COL() array himself, and find the first
non-zero value higher than -Number. Then it will not return Z0B3TRUEB0Z: or Z0B3FALSEB0Z;
as it used to, but the actual number of the bob colliding.
To get the next bob colliding, simply call it again with a this number,
minus one..

Example, this small and fast loop, will give all bobs colliding with bob
zero:

B=Z0B3Bob ColB0Z<(0)
BB=0
Z0B3RepeatB0Z=
   BB=Z0B3ColB0Z>(-(BB+1))
   Z0B3IfB0Z? BB
      Z0B3PrintB0Z@"Bob";BB;" is colliding..."
   Z0B3End ifB0ZA
Z0B3UntilB0ZB BB=0

You can certainly remark that with this method, it is impossible to get the
collision of bob number zero. That's why I say this was not perfect...

=Disc Info$("Name")

...is a new instruction that returns information on any disc.

"Name" is the name of a file or a directory of the disc you want to have
information about. The string returned has the following form:

"NAME_OF_THE_DISC:XXXXXXX" , where XXXXXXX is the free space on the disc.

To get both, use this simple method:

A$=DiscInfo$("Df0:")
C=INSTR(A$,":")
N$=LEFT$(A$,C)
F=VAL(A$,C+1)
PRINT "Name of the disc :";N$;" Free space:";F

=Prg State (returns the current status of a program)

=Prg State

This little handy function let you know how your program was launched.
It returns three possible values:

  0 : if your program was run under the AMOS interpreter.
  1 : if your program was run under RAMOS run-only.
 -1 : if your program is compiled.

Bgrab b

b is the bank that Bgrab "borrows" from the current program being
edited.  [This only works from within an Accessory.]  If there is a bank
already in the accessory, it's erased and replaced with the new one. 
When you exit the Accessory, the "borrowed" bank will be returned to the
main program along with any changes.  [Bank #'s 1 to 15.]

Note:  This instruction can only be done in an Accessory.  If you
attempt it otherwize, you'll get an appropriate error.

Prun "filename"

This is identical to choosing the Run Other from the Editor's menu.

Also, all screens/sprites/bobs/music will need to be kept prior to using
the PRUN command and restored by your program after the PRUN has
finished, to ensure your data remains intact.  See EXAMPLE 3.3 in the
MANUAL folder on your AMOS1.2 PROGRAM disk.

p$=Prg First$

This returns the name of the first AMOS basic program in memory [loaded
with the Load Other editor option].  It's used in conjunction with the
PRG NEXT$ command to create a full list of available programs.

p$=Prg Next$

This is used after the PRG FIRST$ command to continue to read the
available AMOS basic programs in memory [loaded with the Load Other
editor option].  When the list is complete, a string of "" will be
returned.

n$=Psel$("filter",[default$,title1$,title2$])

PSEL$ calls up a program selector simular to the one used by Run Other,
Load Others, Edit Others and New Others.  This can be used to select a
program in the usual manner.  The selected file will be returned in n$,
which can be PRUN.  If QUIT was selected, n$ will be set to "".

filter sets the type of programs which will be listed by this
instruction.  These can be:

"*.ACC"   List Accessories.
"*.AMOS"  List Amos programs.
"*.*"     List All files.

For further details, see the FSEL$ and DIR commands.


You will find on your updated disc (1.34) a program called "GET_TIME.AMOS".
This program includes two procedures to get the time and date from
the system.

  Time.
  -----
Call the procedure, and you'll have in Param$ the current clock time under
the following format: 00:00:00

_TIME$
PRINT Param$
...
11:04:04


You will find on your updated disc (1.34) a program called "GET_TIME.AMOS".
This program includes two procedures to get the time and date from
the system.

  Date.
  -----
This procedure returns the current date in Param$:

_DATE$
PRINT Param$
...
21/06/1991

Safe AmigaDos EXECUTE.

It is perfectly possible to launch an external program from AMOS. But in
order to do so, you have to know some of the AmigaDos internal functions.
That's why you will find on your updated disc a small program with a
procedure called _EXECUTE.
Just transmit an AmigaDos command to this procedure, and it will launch
it out of AMOS. To run an external program, use:

_EXECUTE["RUN >NIL: <NIL: Program_Name.AMOS"]

You can launch other CLI commands (like "Assign"). Of course
if you want to see the display, you have to perform an AMOS TO BACK
instruction.

As the Amiga is a multitask machine, your AMOS program will go on running
as well as the launched program. Of course the speed will be bit reduced,
depending on the other program.

NO Icon MASK [number] (Remove the mask from an icon).

This instruction has simply been forgotten in the manual. It simply
does the same job as NO MASK, but for icons.

Rainbow Del [Number] (Delete on or all rainbows).

Another instruction forgotten in the manual, but very useful when you
want to get rid of a rainbow!
"Number" specify the number of the rainbow to remove, or all if omitted.

Multi Wait  (Force a multi-task wait vbl)

To make effective multi-tasking programs, you must not grab most of the
processor time, leaving only a limited amount of power for other tasks.
MULTI WAIT does a MULTI-TASK wait vbl. You should use it in your
programs main loop, when you wait for example, for a menu item to be
selected.

   Note that you should not use this instruction to make accurate
screen synchronisation as it is designed to multi-task. This instruction
is not consistent at all! It may skip many VBLs, depending on the number
of running tasks at the time.

   If you missed it elsewhere in the manual, Multitasking can be
activated by pressing Amiga+A to flick between AMOS and the CLI or
Workbench environments. This allows systems with at least 1 meg to run
AMOS and programs like DPaint III at the same time!

Amos To Back  (Hide AMOS from view and show the Workbench)

This will bring forward the Workbench display, allowing you to access
other programs.

Amos To Front  (Switch AMOS to the display)

AMOS is forced back onto the display with this command, leaving the
Workbench hidden.

x=Amos Here  (Report which task is on display)

This returns TRUE if AMOS is currently displayed and FALSE if the
Workbench is in view.

Amos Lock (Locks AMOS in front position)

This instruction first does an "AMOS TO FRONT", and then disable
the AMIGA-A system. Use this instruction if you do not want people
to know your program was written in AMOS.

Amos Unlock (make AMIGA-A active)

Just restores the AMIGA-A Workbench/AMOS flipping. You may want people to
stay under AMOS during certain parts of your program for example, to
see your name (!) and then free them.

Bank Swap number1,number2

This instruction will swap the pointers of the two banks. Useful if you
want to turn an icon bank into a sprite bank. Example:

   Bank Swap 1,2

or have more than one music bank at the same time, for example:

   Bank Swap 3,5

Laced (Function to open an interlaced screen)

To open an interlaced screen use the following syntax:

SCREEN OPEN 0,320,200,16,LACED [+HIRES] [+LOWRES]

LACED is a function that returns 4.

Important: As soon as one screen is opened with Interlace, all the other
screens turn to interlace. The interlacing will only truly effect the
screen actually opened with LACED. All the others will just have their
vertical lines doubled on the screen to adjust to the special mode.

   Interlaced mode is perfect for displaying pictures, but
animation runs at half normal speed. Games should not be written in
Interlace!

   As soon as the last interlaced screen is closed the whole
display returns to normal mode. Your TV monitor might not like lots of
fast switching from normal mode to Interlace, so you are advised not to
do this excessively.

   All normal operations are available in interlaced screens:
SCREEN OFFSET, SCREEN DISPLAY and so on. The only problem that arises is
due to interlacing being software driven in AMOS. The bitplanes are
changed during the vertical blank and this particular interlace process
is forbidden during copper list calculation.

   So if you have a large copper list (i.e.. four screens, one
interlaced, and a rainbow), and have a copper calculation to do, the
interlaced screen will display only half of the picture during the
calculation. Nothing can be done to solve this, it is simply a
limitation of the whole system.

There are two extra screen commands in AMOS now. These allow a program
to work out what type of display it is being run on:

=Display Height  (Report how tall a screen can be)

This command returns 311 in PAL and 263 in NTSC.

=Ntsc (Flags the type of display in operation)

This returns TRUE if the system is in NTSC mode or FALSE if in PAL.
Ideal for international software development!

   NTSC refreshes the screen at 60 times a second whereas PAL
screens refresh at only 50 times a second. However, AMOS1.3 compensates
for this and now music runs at exactly the same speed in PAL and NTSC

   AMAL also relies on the interrupt routine but is not slowed down
to comply with PAL speeds. You must therefore be careful not to
synchronise music and animations by just relying on the speed they run
at. Check that an animation frame has been reached or the music has
played a certain note. Using this technique you'll ensure the software
executes at the right points on all systems.

Request On (Generate a requester routine)

This will make AMOS use its own requester routine and is the
default.

See REQUEST WB for important usage notes.

Request Off

AMOS will always select the CANCEL button of the requester if this
command is used. The actual requester will not be displayed, so this is
ideal for error trapping within a program.
See REQUEST WB for important usage notes.

Request Wb

This tells AMOS to switch back to Workbench's system requester. You'll
come back to AMOS as soon as you have chosen one of the options.

Note: If you don't load up the Requester (by deleting it from the
extension list using the config file), the normal Workbench requester
will be used for displaying messages.

This does have a bad side-effect though, AMOS will seem to have crashed
when a requester appears. If this happens you must simply press Amiga+A
to return to the Workbench, answer the question and press Amiga+A once
again to return to AMOS. It's only best to avoid loading the requester
when memory is very low!

Bob and sprite flipping commands.

In a great number of games, the main character needs to animate left to
right, and up and down. Up to now, you were obliged to keep in the
sprite bank reversed copies of small animation sequences for the main
character. As the main character usually has the best animation, you
lose an enormous amount of space!

   For the game RanXerox, for which AMOS author Franois Lionet
wrote the sprite routines, a flipping routine was developed which
allowed just one copy of the main character to be kept in the bank. This
routine has been enhanced and placed into AMOS.

   How does it work? Imagine your character is walking to the left
and then back to the right. You would only have in your bank the image
of him walking to the right. To display this right image, you simply
refer to the image number in the bank as usual.

   To display the image reversed in the X axis (left walking
image), you set bit number 15 of the image number to 1. Don't panic, you
can simply do it with:

   $8000+Image number

So:

   BOB 1,160,100,1

will display your character walking right, and:

   BOB 1,160,100,$8000+1

will display it walking left. The same principle is used for vertical
reversing. For this, bit number 14 is used - add $4000 to the image
number. To have a vertical and horizontal reversing, use $C000.

   The symmetry is a full symmetry: The hot spot of the bob is also
reversed. For example, if we had put the hot spot in X under the feet of
our character, the reversed version would also have it under his feet.
So be careful if you set the hot spot on the top left corner on a bob,
the reversed image will be displayed at the top left!

   You might say that $8000 and $C000 are a bit weird to use. We
have provided special functions to give a better AMOS interface:

   =Hrev(image)      adds $8000 to the image
   =Vrev(image)      adds $4000
   =Rev(image)       adds $C000

Use them in place of the hex values:

   Bob 1,160,100,10
   Bob 1,160,100,Hrev(10)
   Bob 1,160,100,Vrev(10)
   Bob 1,160,100,Rev(10)

To allow easy use of the bob flipper in AMAL, we have implemented
Hexadecimal evaluation. So you can use hex notation to refer easily to
reversed bobs. If hex frightens you, just add $8000, $4000 or $C000
before all references in your AMAL strings. Example:

Old AMAL string:

   "Anim 0,(1,2)(2,2)(3,2)(4,2)"

New reversed string:

   "Anim 0,($8000+1,2)($8000+2)($8000+3)($8000+4)"

or

   "Anim 0,($8001,2)($8002,2)($8003,2)($8004,2)"

If you use a register to calculate the image number, do not try to
modify the calculation itself, but only when you assign the register to
the image.

Old AMAL string:

   For R0=1 To 10; Let A=R0; Next R0

New one:

   For R0=1 To 10; Let A=$C000+R0; Next R0


How does the flip routine work?

It is really important for you to understand how it works internally, so
that you do not ask this system to do things it is not designed to do.

   The reversing system is designed to free memory before trying to
be fast (although we would not mind if it was actually fast, would we?).
Concessions had to be made to have it fast, and at the same time easy
and powerful.

   The routine actually works right in the middle of the bank, and
does not use any extra memory. The bobs are flipped during the update
process, just before a bob is redrawn on the screen. AMOS looks to see
if the image needs to be flipped in the bank. If it does, it is flipped
and a flag is set within the bank. On the next update, if the bob image
has not changed, it will not be flipped, thus saving a lot of time.

   If you understand the above, you will also realise one big
limitation. It is not wise to use more than one flipped bob pointing to
the same image. Let's see the next example:

   BOB 1,160,100,1
   BOB 2,160,150,$8001
   BOB 3,20,20,$4001
   BOB 4,20,100,$C001
   UPDATE

During the Z0B3UPDATEB0Z: process, AMOS will first draw bob number 1. No
problem, it is in the right position. Then bob number 2 - AMOS needs to
reverse it in X. Bob number 3 needs a Y and an X reversing (to put the
bob back to normal in X!). Then bob number 4 needs an X flipping.

   On the next update, providing the bob's image has not changed,
to display bob 1, AMOS will have to flip it in X and Y, then bob 2...

   As you can see, for each Z0B3UPDATEB0Z;, that is, every 50th of second,
if the bobs move they need to be reversed! This will work, but will take
a lot of processor time, and the animation will be disastrous.

   So the golden rule is, use the reversed bobs for objects alone
on a screen (or be sure that normal and reversed images are not
displayed at the same time on the screen). If you want, you can have two
bobs like this - experiment!

   We told you before that this system was for use with bobs. Yes,
it is totally automatic with bobs. But as it directly affects the sprite
bank, you can also use it with sprites.

   When a hardware computed sprite is calculated, AMOS looks into
the sprite bank and gets the image from it. If the image is reversed at
that moment, the hardware sprite will display a reversed image. You can
therefore have reversed hardware sprites using this method. But you
cannot do this for example:

   Z0B3SpriteB0Z< 1,200,200,$8001


Pasting flipped bobs

Z0B3PASTE BOBB0Z= also accepts reversed images. A simple trick to reverse an
image in the bank without having to display a bob, is to PASTE the
reversed image outside of the screen. Example:

   Z0B3Paste BobB0Z> 500,500,$C000

This will reverse image 4 in the bank, without any output (and quite
fast).

Collision detection

This is an important point, and you have to be very careful when you
detect collisions with reversed bobs!

   The collision detection uses the shapes in the bank at the very
moment it is called. Let's see an example that will never work:

   Z0B3BobB0Z? 1,160,100,1
   Do
         Z0B3BobB0Z@2,XScreen(XMouse),YScreen(YMouse),$8001
         Z0B3Wait VblB0ZA
         Z0B3ExitB0ZB if Z0B3Bob ColB0ZC(1)
   Loop

Why doesn't it work? We have two reversed images of the same definition
in the bank. After the updating process, the image in the bank is left
reversed. So the Z0B3Bob ColB0ZD instruction will take bob shape 1, the reversed
image, and this will not work!

   So remember: Thou shalt never use collision detection with more
than one reversed image on the screen!

How is it coded into the sprite bank?

Two bits of each images X Hot Spot are used to flag the flipping (at
Z0B3SPRITE BASEB0ZE+6).

Bit number 15 for X  0 if normal, 1 if reversed
Bit number 14 for Y  0 if normal, 1 if reversed

Before RUN and SAVE, the bank is restored to its normal state, so that
it is still compatible with version 1.1.

Hrev Block  (Flip a block horizontally)

Hrev Block image

Flips block number image horizontally.

Vrev Block  (Flip a block vertically)

Vrev Block image

Flips block number image vertically.

Priority Reverse On-Off  (Change the order in which Bobs are printed to
the screen)

Priority Reverse On
Priority Reverse Off

Priority Reverse On, reverses the entire bob's priority table. This
means that bob number 1 will be the first one drawn in front of all
other bobs, 2 will come in second etc... This priority list is
compatible with STOS.

   This instruction has another feature when used in conjunction
with the PRIORITY ON command. The bobs are not printed from TOP to
BOTTOM any more, but from BOTTOM to TOP! The highest bob on the screen
will be displayed in front of the others.

Serial Open (Opens a channel for Serial I/O)

Serial Open channel, port_no [,shared, xdisabled, 7wires]

Opens a communication channel to a serial device.

Channel This is an identification number which will be used for all
subsequent communication commands. Allowable values range from 0 to 3.

Port_no Specifies the logical device number of the serial port.
Normally, this value should be set to zero. However, if you've plugged a
MULTI SERIAL card into your Amiga, you can access your additional ports
using the numbers from one onwards.

Shared (optional) This is a flag which informs AMOS that the device can
be shared with other tasks which are currently running on your Amiga.
It's used in multitasking. A value of FALSE (zero) will grab the channel
for AMOS Basic, and will deny access to any other program. If it's is
set to TRUE (-1), the serial port can be shared between several programs
in memory. Beware: This system must be used with extreme care or the
Amiga could easily crash!

Xdisabled (optional) Toggles XON/XOFF checking during transmission of
your data over the serial line. It's essential to set this flag when you
are first opening the device, even if it will only be required later.
The default value is FALSE (0) and disables the system. If you want to
enable the checking, use a value of TRUE (-1). After the port has been
opened, you'll then need to set the XON and XOFF characters using a
separate call to the Serial X command.

7Wires (optional) A value of TRUE (-1) tells the device to use the 7
wires system as explained in the official Commodore documentation. The
default is FALSE (0).

When you call the Serial Open command for the first time, it will
automatically load the SERIAL.DEVICE library from your system disc. So
make sure it's available from the current drive.

Default settings depends on the number in "Port_no":

-Port_no=0 refers to the default serial port, it will be opened using the
parameters set in the "Preference" workbench program. You should open this
port if you use the workbench.

-Port_no=1 refers to the built in serial port. Every Amiga has one. This
is the port you should open. The default settings will be set for this port
to use the French minitel: 1200 Baud, 7 bits, 1 stop bit, Even parity.
This can be easily changed using the SERIAL SPEED, SERIAL BITS or
SERIAL PARITY instructions if required.

-Port_no>1 can only be used if you have a multi-serial card.

Serial Close (Closes one or more serial channels)

Serial Close [channel]

If you don't include the channel number, Serial Close will close all
currently opened serial channels with absolutely no error checking. The
optional channel number allows you to close a single channel and uses
all the normal error checks.

Note: Whenever a program is RUN from AMOS Basic, any opened channels
will be automatically closed for you.

Serial Send  (Output a string via a serial channel)

Serial Send channel, t$

Sends the string t$ straight to the specified serial channel. It does
not wait for the data to be transmitted through the actual port. You'll
therefore need to use the =SERIAL CHECK(Channel) function to detect when
the transmission has been completed.

Serial Out  (Outputs a memory block via a serial channel)

Serial Out channel, address, length

This is identical to SERIAL SEND except that it works with RAW data.

Address is the address of your data in memory.
Length is the number of bytes to be sent.

Serial Get  (Gets a byte from a serial device)

=Serial Get(channel)

Reads a single byte from the serial device. If nothing is available a
value of -1 will be returned.

Serial Input$  (Gets a string from the serial port)

=Serial Input$(channel)

Reads an entire string of characters from the serial port. If there's no
data, the command will return an empty string "". Otherwise the string
will contain all the bytes which have been sent over the serial line up
to the present time.
   Be careful when using this command with high speed transfers
(such as MIDI). If you wait too long between each Serial Input$ command,
you can overload the system completely, and generate annoying errors
such as "string too long" or "serial device buffer over-run".

Serial Speed  (Sets the transfer baud rate for a serial channel)

Serial Speed channel, baud rate

Sets the current transfer rate of the appropriate channel. The same
value will be used for both reading and writing operations. Note that
you can't set split baud rates for a single channel. If the baud rate
you have specified is not supported by the current device, it may be
rejected by the system.

Serial Bits  (Sets the Nbit & Stopbit part of a protocol)

Serial Bits channel, nbits, stopbits

Assigns the number of bits which will be used for each character you
transmit.

Nbits is the number of bits
Stopbits is the number of STOP bits

Serial Parity  (Sets the parity checking, correct version)

Serial Parity channel, parity

Sets the parity checking you are using for the current serial channel.
Here's a list of the available options.

Parity can have 5 different states:

   -1 : no parity
    0 : EVEN parity
    1 : ODD parity
    2 : SPACE parity
    3 : MARK parity

See the Commodore documentation for a full explanation of this system.

Serial X  (Sets XON/XOFF)

Serial X channel, xmode (Activates/deactivates the XON/XOFF handshaking
system)

A value of TRUE for Xmode disables handshaking. Any other value turns it
on. Xmode should be loaded with the correct control characters. These
must be specified in the following format:

   Xmode=XON*$10000000+XOFF*$10000

Check Commodore's documentation for more information.

Serial Buffer  (Sets the size of the serial buffer)

Serial Buffer channel, length

Allocates length bytes of buffer space for the required channel. Note
that the default value is 512 bytes and the minimum allocation is 64
bytes.

   It's a good idea to increase the buffer size for high speed
transfers.

Serial Fast  (Switches on FAST transfer mode)

Serial Fast channel

This sets a special fast flag in the current device and disables a lot
of internal checking which would otherwise slow down the communication
process. Use it for high speed transfers such as MIDI.

Warning: When you call this command, the protocol will be changed to:
PARITY EVEN,NO XON/XOFF and 8 bits.

Serial Slow  (Switches serial transfer back into SLOW mode)

Serial Slow channel

Slows the serial device back to normal speed and reactivates all the
error checks.

Serial Check  (Reports on current serial device activity)

=Serial Check(channel)

Asks the device for a read-out of its current status. You can use it to
check whether all the information you've transferred with a previous
SERIAL SEND command has been sent.

   CHECK=FALSE (0) -> if the last serial command is still being
executed.

   CHECK=TRUE (-1) -> All done!

Serial Error  (Reports success or failure of last transfer)

=Serial Error(channel)

Looks for the ERROR byte in the serial device. A value of zero indicates
that everything is fine. Otherwise, the last transmission was faulty.

Sending large strings

Transmitting a large string may take quite a long time, especially at
low baud rates. As AMOS is multitasking, your program will continue to
run AFTER a SERIAL SEND instruction.

   It's essential to avoid provoking a garbage collection before
the transfer has been completed, otherwise your data will be corrupted.
So:

   Use the =SERIAL CHECK function before doing a lot of string work.
   Perform a garage collection using X=FREE to ensure that your program
will not provoke one automatically.

   Use the SERIAL OUT channel,address,length instruction
with 'address' containing the location of a previously reserved memory
bank.

More information about the Amiga's serial system can be found in the
Commodore ROM KERNEL Reference Manual, Library and Devices. This will
allow expert users to make maximum use of the serial device.

=Dev First$  (Get first device from the current device list)

dev$=Dev First$("filter")

Works the same as DIR FIRST$ and DIR NEXT$, but reports back the device
list. Note that you should remove the spaces with -" " to get the right
name.

=Dev Next$  (Get the next device satisfying the filter)

dev$=Dev Next$

Gets the next device from the device list. A null string indicates the
end of the list has been reached. Example:

   PRINT DEV FIRST$
   Do
         A$=Dev Next$
         A$=A$-" "
         IF A$="" THEN END
         PRINT A$
   Loop

Set Tempras [address,size]

Warning, due to the nature of this instruction, it is suggested you
re-read the command in your manual and all of it's associated commands.

Set Tempras is in your manual on page 71.

Rem Comment.
' Comment.

Note the ' shortform can only be used at the beginning of a line.


