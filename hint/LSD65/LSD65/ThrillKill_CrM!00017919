
                             Thrill Kill
                             ~~~~~~~~~~~
                             
    Disclaimer
    Read first/Introduction
    Requirements
    General usage
    The preferences
    The editor
    Command description - alphabetically
    Command description - sorted by groups
    Argument description
    How to make a NMI-button
    Registration/Demo limits/How to order
    Yet known bugs
    History
    Contact
    Future


    Disclaimer

    THERE IS NO WARRANTY FOR THE  PROGRAM,  TO  THE  EXTENT  PERMITTED  BY
    APPLICABLE  LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
    HOLDER AND/OR OTHER  PARTIES  PROVIDE  THE  PROGRAM  "AS  IS"  WITHOUT
    WARRANTY  OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  FOR
    A   PARTICULAR  PURPOSE.  THE  ENTIRE  RISK  AS  TO  THE  QUALITY  AND
    PERFORMANCE OF THE PROGRAM IS  WITH  YOU.  SHOULD  THE  PROGRAM  PROVE
    DEFECTIVE,  YOU  ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
    CORRECTION.

    IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN  WRITING
    WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY REDISTRIBUTE THE
    PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU  FOR  DAMAGES,  INCLUDING
    ANY  GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT
    OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT  LIMITED
    TO  LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED
    BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM  TO  OPERATE  WITH
    ANY  OTHER  PROGRAMS),  EVEN  IF  SUCH  HOLDER OR OTHER PARTY HAS BEEN
    ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

    ----------------------------------------------------------------------
    Thrill Kill - Read first/Introduction
    ----------------------------------------------------------------------

    If you do not know what a debugger, freezer is or if  you  have  never
    programmed  in  assembler  -  forget  it  -  i do not think that TK is
    something for you -(except if you just want to train some games..)

    You probaly know the famous action replay. It was cool! However it was
    slow, partly bugged and missed major commands. When aga came out there
    was no toy for those machines. No real update came out - the  software
    version  of the action replay was buggy like... . TK is a freezer like
    the action replay, a lot commands have the same syntax.  If  you  were
    used  to  ar then you will find usage very easy. TK supports a maximum
    of freezer possibility,  if  you  take  the  time  to  check  out  all
    available  functions/settings.  This  means  you  have  to  have major
    knowledge of your amiga-hardware. If you do not have it then  i  doubt
    that  you  can  use  the real power of this toy! Of course, TK can not
    offer such kind of invisibility like the ar as  it  does  not  need  a
    'special'  hardware  (beside  a  NMI-button).  If  you  enjoy the demo
    version, think its useful and do not want to register do not wait  for
    a  cracked  version.  Every  registrated  version  of  TK  has its own
    personal id. Any misuse of  a  registered  version  will  be  punished
    (!!!).

    Just  a  last  note! TK patches nearly the whole system! It can not be
    compatible with any hardware configuration available (eg  gfxcards..).
    I give no warranty for any damage caused by TK! You use it on your own
    risk!

    BTW: The html-documentation is best viewed with NETSCAPE3.0, else read
    the text version!

    Enough said...check out the demo..

    ----------------------------------------------------------------------
    Thrill Kill - Requirements
    ----------------------------------------------------------------------

    TK was designed to run on a system with a mmu, but it  also  works  on
    non-mmu system. I use tk on a A4000 with 68030/25/68882 (with mmu) and
    2 meg chip and 8 meg fast memory. I personally  think  it  works  very
    stable.  However  even some A4000 have strange behaviour when acessing
    non existing memory. (eg Goldmans' machine:  accessing  memory  higher
    $0fffffff  will  cause  not  a  bus-error  (set to dsack) but it kicks
    around with the custom-regs - they are defintly lost.) As you are a
    talented
   user  you  can  change  the  settings  to  suit  for  your
    configuration (eg disable the memory  detection  for  the  $1dc00000++
    memory) and load them before TK is initialized!

    TK was tested on:

       A4000/30.25.mmu/68882/2mb-chip/8mb-fast at $7800000++
       A4000/30.25.mmu/2mb-chip/16mb-fast at $7000000++
       A1200/30.50.mmu/2mb-chip/8mb-fast at $1dc00000++
       (blizzard3, however Icarus reported trouble with the blizzard2..
        i will check this )
       A1200/30.50.mmu/2mb-chip/4mb-fast at $200000++ (mtec)
       A500/00.7.nommu/1mb-chip/1.5mb-'fast' at $c00000
       A4000/40.25.mmu/2mb-chip/8mb-fast at $7800000++
       (thanx to apollo for lending me his card, i hope it stills runs on
        040 as i patched a lot of stuff since then)

    I can not promise that TK will run immediatly on your system.  However
    if  you  have  problems  contact  me,  i  will  try  to fix any
    incompatibility! So if the demo-version runs on your computer then the
    registered version will also work fine.

    Before  i  forget  it  you  need  kickstart 3.0++ to use all functions
    (especially the ones to privatize memory). It  works  also  fine  with
    kick  2.04  (some functions will not work), but i do not think it will
    run suitable on kickstarts less 2.04! TK does not like programms  that
    use the mmu (like vmm programms) TK does not support gfx-cards!

    I  hope it will also run on a 68060...not checked yet (also i think it
    should if it works on 68040..)

    ----------------------------------------------------------------------
    Thrill Kill - General usage
    ----------------------------------------------------------------------

    Here is a list of some (maybe) interesting topics:

    Breakpoints (=brp) can be manipulated by B, BS, BD,  BDA.  Breakpoints
    can  be  marked with illegal or trap codes (see preferences). Whenever
    you enter TK all breakpoints are removed, when you leave TK  they  are
    set   again.   Do   not  forget  that  the  breakpoints  run  via  the
    +$10/$80..$bc vectors.

    MemoryAccessRanges (=mar) can be used to get out which command  did  a
    read/write  access  to the selected memory. The programm will be trace
    step-by-step and the commands will be analyzed.It will  return  to  TK
    before  the  specified memory is accessed. MARs are very slow and will
    not catch interrups. (If you want to catch interrupts than  eg  set  a
    breakpoint  to  the  first command of the interrupt code..) Check MAV,
    MAS, MAD, MADA .

    MemoryWatchPoints (=mwp) can be used to get out which command modified
    the  selected  memory.  The  programm  will  be traced step-by-step to
    determinate  all  manipulations.  It  will  return  to  TK  after  the
    specified  memory  has  benn  modfied. (so check the previous command)
    MWPs are slow and will not catch interrupt routines. (If you  want  to
    catch  interrupts than eg set a breakpoint to the first command of the
    interrupt code..) Check MV, MS, MD, MDA .

    The VBR-Faker installs a own vbr who  simulates  the  origional.  This
    will allow you to enter programms who manipulate the vectors at $0 and
    do not change the vbr. If the programm should change the  vbr,  loacte
    the  command,  set  a breakpoint and adjust the vbr manually, skip the
    command and leave -  all  should  be  fine.  (In  AR4,HRTMON  this  is
    default,  but  not  in  TK!) Do this also if the programm move the vbr
    anywhere else. (see preferences)

    MMU-Catchlists can be changed by MMUV, MMUS, MMUSW,  MMUD,  MMUDA  and
    check  the  preferences . The function allows you a quick and reliable
    way to get out all commands which access a certain memory range.  This
    slows the system just a bit down. Interrupt code is also checked. Make
    sure that the +$8 (bus-error) vector is not destroyed by the programm.
    The  functions  are  only  available  in  to  professional version and
    require a MMU!

    The ByteValueTrainer (=bvt) allows to search single byte  values.  The
    trainer  is  started  with the TS, command. Whenever the watched value
    changes run the T command.(also if you think this would eliminate some
    address)  This  will  eleminate  all  invalid address and scan yet not
    checked address. You must increase the size of the  trainer-buffer  if
    you  would like to scan the whole memory in one pass. Check TS, T, TX,
    TV, TB, TBD, TBV. Each stored address needs about 2 bytes.


    The  DeepTrainer  (=dt)  allows  you  to  search staying/changing byte
    values. The trainer is started with  the  TDS  command.  Whenever  the
    watched  value  changes  run  the TDC command to eliminate all address
    which have not changed. Use the TDS command to  elimnate  all  address
    which have changed. After TDS/TDS the yet unchecked memory is checked.
    Each stored address needs about 3 bytes. This trainer mode needs a lot
    of  memory.  In  general its advised to use an external trainer buffer
    (TB, TBV, TBD) Check also TDS, TDC, TDX, TDV

    The usage of a external TrainerBuffer is recommended whenever you want
    to   scan  a  memory  range  in  a  few  passes,  especially  for  the
    deep-trainer. Its not unusual to have buffers with a size  of  4MB  or
    more..

    Privatizing  is  a preference option which allows you to remove memory
    from the system. This memory can be used for trainer-buffer, to freeze
    the programm or for other purpose. Check also INFO .

    MMU-CustomBackup  is  a  option  which  simulates  a  mirror  ram  for
    $dff000-$dff200. By this way we do not need an external hardware which
    does  exactly this. The only disadvantage is that the system is slowed
    down and the +$8(bus-error) vector is used.

    Labels are just a little short-cut for often used address,  etc.  They
    can be easily in any expression. Check LAB, DLAB, DLABA.

    FileSystemManagement   is   supported   for   DD/HD-disks   and   also
    IDE-harddisk-partitions.  Only  DOS\0,   DOS\1,   DOS\2,   DOS\3   are
    supported.  However also DOS\4, DOS\5 can be read. Soft-/Hardlinks are
    not supported. Check CD, DIR, DELETE, MAKEDIR, TYPE, LM, SM.

    The programm 'TK.REV' allows  you  to  load  TK  to  the  end  of  the
    available  memory.  This  needs kickstart 3.0++. The effect is that TK
    will not lay somewhere in the middle of a memory page  (especiilly  if
    you privatize memory). Make sure 'TK.EXE' is in the same path.

    'TK.EXE'  will not do dynamic allocation of memory. This means you can
    relocate the code eg to $7f00000 and load its  binary  image  to  this
    address.

    ----------------------------------------------------------------------
    Thrill Kill - The preferences
    ----------------------------------------------------------------------

    The preferences can be loaded and saved by the

    LE
      and

    SE
      commands

    In the TK-surface you have to press <F3> to enter the preference  menu
    If    you    launch    TK    from    shell   and   use   as   argument
    '-<your-prefs-file-any-path>' the selected prefs will be loaded before
    TK  is  started. This allows you to disable/enable functions which may
    cause conflicts. In the prefs-menu you can  manipulate  the  following
    commands:

    Freezer preferences:

    Custom-backup:

    Minimum:

    Only custom-register  that  are  destroyed  by  TK  are  backuped  and
    restored.  This  will  work with games like soccer-kid. (check out the
    copper faker)

    Maximum:

    Most custom-register are backuped  and  restored,  including  register
    that  are not destroyed by TK. This is necessary for saving a complete
    programm. If you do not  have  a  mmu/hadrware  you  must  adjust  the
    register manually by the

    E command.

    If you want to save a freezed programm the option should  be  enabled.
    Make sure that you have enabled mmu-custom-backup or something equal.

    CIA-backup:

    Fast:

    The CIA-register are backuped in a fast way (eg the disksync interrupt
    bit in the ICR will not be backuped)

    Most:

    This will try to backup most register. However, not all  register  can
    be backuped without an immense time consumption (like the ALARM regs).
    You can manully manipulate the CIA-register with the

    W command.

    DrivesOn:

    Selected:

    When you enter TK and some disk-drives where on, only drives  selected
    in PRB/CIA-B will be enabled again.

    All:

    All drives will be turned on. (but not selected)

    Brp-Entrance:

    Illegal:

    Sets the breakpoint-code to illegal (dc.w $4afc) and vector +$10. This
    may conflict with other running debuggers (eg monam)

    Trap #x:

    Sets the breakpoint-code to trap#x (dc.w $4e4x) and  vector  +$80+4*x.
    Make sure that the traps are not used be the programm you debug.

    ExecValid:

    Yes:

    Make the asumption that system is running and exec,etc.. is available.
    If  system is not available this may cause major errors (loops...etc).
    Set only if you want to use a system-command, you know system is alive
    and TK thinks its not available.

    no:

    Make the asumption that system is not running. All system-command  are
    not available.

    check:

    This will try to determinate if system is running or not.

    MemAccess:

    RAM:

    Your can read/write/access only the memory that was  detected  by  TK,
    check the

    INFO command.

    RAM+ROM:

    Your can read/write/access only memory that was detected  by  TK  plus
    the ROM-area.

    ALL:

    You can read/write/access the whole memory.Make sure you  access  only
    memory that will not let your machine crash.

    VBRFaker:

    YES:

    This will exchange the freezed-programm-vbr with an own vbr-simulator.
    This  will  allow  you to enter programms which modify the NMI-vector.
    However if you programm changes the vbr itself you will not be able to
    enter  TK  again  (in  general).  If  you  find  such  a command set a
    breakpoint there, then adjust the vbr manually and skip the command  -
    works fine.

    NO:

    If the vbr-simulator was active  it  will  be  removed,  else  nothing
    happens. (default)

    ROM-Avoid(NMI):

    YES:

    This disables entries via NMI if the freezed programm is currently  in
    a ROM memory.

    NO:

    You can enter TK via NMI at any time.

    TK-Memaccess:

    YES:

    This allows you to read/write/access the TK memory.

    NO:

    You can not read/write/acess the TK memory.

    Editor preferences:

    Scrolling:

    BLITTER:

    The blitter will be used to scroll. If you want real-time scrolling on
    68000  then  enable  this option. The disadvantage is that the blitter
    register will be destroyed!  The  blitter  register  can  be  modified
    manually by the

    E command.

    CPU:

    The cpu will be used  to  scroll.  This  is  faster  than  blitter  on
    68020++. Also if you want to scroll in real-time on bigger screen this
    option must be enabled.

    Insert-Mode:

    YES:

    If you hit a key the chars left from the current cursor location  will
    be  shifted left before the new char is inserted. The last char in the
    row is lost.

    NO:

    If you hit a key the char at the current cursor loaction  is  replaced
    with the hit key. Use <TAB> to force a insert.

    Show-Page:

    If enabled and you jump to a new page, the page number will be written
    to the right-top corner of the screen.

    Cursor-Type:

    LINE:

    The cursor will have the form of a line

    DOUBLE:

    The cursor will have the form of a thick line

    BLOCK:

    The cursor will have the form of a block

    Keyboard:

    GERMAN:

    The german keymap will be active.

    US:

    The us keymap will be active.

    BackGroundColor:

    The  default  background  color  of  the  TK-surface  can  be  set  in
    12-bit-RGB format

    CharColor:

    The default char color of the TK-surface  can  be  set  in  12-bit-RGB
    format

    CharColor2:

    The default char color for the

    MP command.

    WaitingColor:

    The default background color in hold-mode for the  TK-surface  can  be
    set in 12-bit-RGB format

    BlinkColor1:

    The first cursor color (alternating) of the TK-surface can be  set  in
    12-bit-RGB format

    BlinkColor2:

    The second cursor color (alternating) of the TK-surface can be set  in
    12-bit-RGB format.

    BlinkTime:

    Amount of frames between alternating the cursor  color  (swap  between
    BlinkColor1 and BlinkColor2)

    KeyRepeatDelay:

    Amount of frames before a key is repeated

    KeyRepeatSpeed:

    Amount of frames between each key repeat

    Screenmode preferences:

    Screenmode:

    NTSC:

    A NTSC screen (640x200,60Hz) will be used

    PAL:

    A PAL screen (640x256,50Hz) will be used

    CUSTOM:

    The register in the CUSTOM area will be used to set up screen

    EURO72:

    A EURO72 screen (640x400,70Hz) will be used

    DBLPAL:

    A DBLPAL screen (640x512,50Hz) will be used

    CUSTOM2:

    The register in the CUSTOM2 area will be used to set up screen

    ScreenBlank:

    If enabled and you use a aga-screen mode then the border-color will be
    black,  else  the  border  has the same color as the background If you
    know how to setup a screen by hardware  then  you  can  optimize  your
    screen. This is not described here, check out ecs/aga documentation.

    NO WARRANTY FOR ANY DAMAGE!

    Reset preferences:

    Screenmode:


    PAL:

    The boot-picture will be shown on a PAL-screen

    NTSC:

    The boot -picture will be shown on a NTSC-screen

    MemorySequence:

    SKIP:

    No special operation is done.

    TEST:

    The detected memory is checked for any ram-failure.

    CLEAR:

    The detected memory is filled with the clear-pattern.

    TEST&CLEAR:

    The detected memory is checked and filled with the clear-pattern.

    ClearPattern:

    The pattern used to fill memory. Usefull to find a suitable place  for
    patch-routines.

    External-BusTimeoutMode:

    IGNORE:

    If you have not a A4000 then this option should be enabled.

    DSACK:

    If you access not-available memory on a A4000 usually a  bus-error  is
    generated (and a long delay). With this option you can set it to DSACK
    which results in no bus-errors and short delays.

    BUSERR:

    This is the system-default TimeoutMode for the A4000

    KickStartPatch:

    This will enable all patches done when the kickstart is  launched.  If
    this option is disabled all private-functions are disabled.

    ChipMemStart:

    Defines the location where the chip-memory starts  (eg  at  $100000-).
    Unused memory will be privatized.

    ChipMemEnd:

    Defines the location where the chip-memory ends. Unused memory will be
    privatized.

    ExpansionMemoryX-Private:

    This option allows you to deactivate memory used by the system. Unused
    memory will be privatized.

    ClearBreakpoints:

    All breakpoints will be cleared on reset.

    ClearMemoryWatchpoints:

    All memory-watchpoints will be cleared on reset.

    ClearMemoryAccessranges:

    All memory-accessranges will be clear on reset.

    DetectChipmem:

    Specifies the memory-range TK searches for chip-memory.

    DetectExpansionMemoryX:

    Specifies the memory-range TK searches for fast-memory. If your memory
    is not detected by default then you can add your memory manually. Also
    usefull if you get conflicts raised by illegal memory accesses.

    Misc preferences:

    AutoVerify:

    If enabled all disk-write operations will be verified.

    Support HD-disks:

    If enabled you can read/write  high-density  disks.  This  needs  more
    internal   memory.   Disable   if   you  want  eg  a  larger  internal
    trainer-buffer.

    Internal-TimeoutBusMode:


    IGNORE:

    If you have not a A4000 then this option should be
               enabled.

    DSACK:

    This option should be enabled if you have a  A4000,  else  the  memory
    detection will hang up your system.

    BUSERR:

    This is the system-default TimeoutMode for the A4000

    HighestTrack:

    Here you can overwrite the upper tracklimit,  so  that  you  can  also
    read/write tracks 80-85.

    NO WARRARNTY FOR ANY DAMAGE CAUSED BY TK!!

    Add EjectTask:

    Add a Eject-Task to system which will do a automatic  'diskchange'  to
    any media modified in TK.

    CustomFrom:

    USER:

    The user has to adjust the custom-register before he leaves TK.

    SYSTEM:

    Some destroyed custom-register are read from system. Only possible  if
    system is intact.

    HARDWARE:

    If you have  hardware  installed  it  will  be  used  to  restore  the
    custom-register.

    MMU:

    The MMU will be used to restore the  custom-register.  Make  sure  the
    PrivateMMU option is enabled

    CustomMMU-Flicker:

    If enabled, the freezed programm will do a little flicker  whenever  a
    write operation to a custom register is done.

    Default Valuemode:

    HEX:

    The default value base is 16. Like in the action-replay

    DEC:

    The default value base is 10. Like in asm-one.

    ParseCpuReg:

    TRY:

    The parser tries to match a valid cpu-register  in  every  expression.
    (eg 'd d0' will not disassemble at $d0)

    SLASH:

    If you want to use cpu-register in expressions just by a  leading  '\'
    you have to enable this.

    ParsePriority:

    OPERATOR:

    Each operator has a specific priority, which is used  to  calculate  a
    expression. (eg '2+3*4'='14')

    LEFT-ASSIGNED:

    The 'left' operator has always a greater priority. (eg '2+3*4'='24')

    CatchCustomBootBlock:

    Whenever the system tries to boot from a non-default disk-bootblock it
    will enter TK before execution. The pc will point to the first command
    of the bootblock.

    PrivateMMU:

    If enabled a own mmu-pagetable is set up. Must be enabled to  use  the
    CustomMMU function. Do no enable if you run a VMM programm.

    ALT-FX:

    Here you can define the fast-macros. Multiple command are possible.

    ----------------------------------------------------------------------
    Thrill Kill - The editor
    ----------------------------------------------------------------------

    The basic surface  for  TK  is  the  so  called  editor.  Its  like  a
    system-shell  with  special  commands and functions. The keyboard type
    can be changed by the


    preferences  .  Beside  the  usual  keys  the  following functions are
    available:

    <F1> : Clear screen
    <F2> : Toogle Insert-/Overwritemode
    <F3> : Enter preferences
    <F4> : Repeat last command
    <F5> : Enter 'debugger'
    <F6> : Jump to page 1
    <F7> : Jump to page 2
    <F8> : Jump to page 3
    <F9> : Jump to page 4
    <F10> : Jump to page 5
    <SHIFT>+<F6> : Copy actual page to page 1
    <SHIFT>+<F7> : Copy actual page to page 2
    <SHIFT>+<F8> : Copy actual page to page 3
    <SHIFT>+<F9> : Copy actual page to page 4
    <SHIFT>+<F10> : Copy actual page to page 5
    <ALT>+<FX> : Execute fast macro x, (macros can be modified in  in  the
    preferences)
    <AMIGA>+<F5> : Make snapshot and save it
    <ESC> : Abort/Cancel current running commands (if supported)
    <TAB> : Insert space at current position
    <HELP> : Show internal help
    <SHIFT> : Hold/Pause current command (if supported)
    <AMIGA>+<SHIFT>+<ESC> : Emergency exit!! This command  allows  you  to
    leave  TK  any  any  time. This can be useful to return when a command
    (should) hang up.

    BE WARNED!

    You can abort the write-commands, too, this can cause major damage  to
    your harddisk etc..

    Some  commands  support  'fast  signs'.  This means that if you scroll
    up/down and in the top/bottom line is a 'fast sign' the programm  will
    automatically  generate  the  previous/next  line.  Eg. you can easily
    disassemblel up/down.(check out)

    ----------------------------------------------------------------------
    Thrill Kill - Command description
    ----------------------------------------------------------------------

    Command index - alphabetically

    ? <Value>

    A <Address>

    ADD <Bytes>,<Start> <End>

    AND <Bytes>,<Start> <End>

    AVAIL

    B

    BOOTCHK <Address>

    BD <Address>

    BD #<BreakpointNumber>

    BDA

    BITCHK <Address>

    BLKCHK <Address>

    BS [#<BreakpointNumber>] <Address>

    BT #<TrapNumber>

    BTI

    CATCHFILE <StringPattern>

    CD [Path]

    COMP <Start> <End> <Destination>

    D [#<Mode>]<Address>

    DELETE <Filename>

    DEVS

    DEVICES

    DIR [Path]

    DISKLEN [#Unit] [LOW <Track>] [HIGH <Track>]

    DLAB <Labelname>

    DLABA

    E[<CUSTOM-REG>]

    EOR <Bytes>,<Start> <End>

    F <Bytes> [,Range]

    FA <Address> [,Range]

    FAQ <Address> [,Range]

    FAR <Start> <End> [,Range]

    FARQ <Start> <End> [,Range]

    FC [Range]

    FCQ [Range]

    FD <DisassemblyPattern> [,Range]

    FDQ <DisassemblyPattern> [,Range]

    M[.<B|W|L] [#<Entries per row>]

    <Address>

    FP <PBytes> [,Range]

    FR <Bytes> [,Range]

    FS <Bytes> [,Range]

    G <Address>

    GETKEY

    HELP

    INFO

    INTS

    INTERRUPTS

    LA <Address>

    LAB <Labelname>=<Value>

    LABS

    LABELS

    LE <Filename>

    LESS <Filename>

    LIBS

    LIBRARIES

    LM <Filename>,<Start> [<End>]

    LS [Path]

    M[.<B|W|L] [#<Entries per row>] <Address>

    MA

    MAD <Start> <End>

    MADA

    MAKEDIR <Path>

    MAS <Start> <End>

    MD <Address>

    MDA

    MEM

    MFMC <Start> <End> <Destination>

    MFMD <Start> <End> <Destination>

    MFMR [#<Unit>] [INDEX] [SYNC=<SYNC>] <Track> <DMA-Length> <Dest>

    MFMSL <Start> <End> <Destination> <BitShift>

    MFMSR <Start> <End> <Destination> <BitShift>

    MFMSS <Start> <End> <Destination> <Sync>

    MFMW [#<Unit>] [INDEX] <Track> <DMA-Length> <Source>

    MKDIR <Path>

    MMUD <Start> <End>

    MMUDA

    MMUS <Start> <End>

    MMUSW <Start> <End>

    MMUV

    MORE <Filename>

    MP

    MS [.<B|W|L] <Address>

    MV

    N [#<Entries per row>] <Address>

    NO <Offset>

    <Bytes>,<Start> <End>

    OR <Bytes>,<Start> <End>

    PORTS

    Q <Start> <End> <Destination>

    R [<CPU-REG> <Value>]

    RB <Filename>,<Start> [<End>]

    RD [#<Unit>] <DiskOffset> <Length> <Destination>

    RESET

    RES

    RESOURCES

    RF [<FPU-REG> <Value>]

    RM [<MMU-REG> <Value>]

    RS [#<Unit>] <Sector> <SectorAmount> <Destination>

    RT [#<Unit>] <Track> <TrackAmount> <Destination>

    SA <Start> [<End>]

    SE <Filename>

    SETX

    SETEXCEPTIONS

    SHOWSTACKFRAME

    SI [<Count>]

    SIM <Rawkey>

    SM <Filename>,<Start> <End>

    ST [<Count>]

    T <Value>

    TASKS

    TB <Start> <End>

    TBD

    TBV

    TDC

    TDS [Range]

    TDV

    TDX

    TR [<Count>]

    TRACKER [<START>]

    TRANS <Start> <End> <Destination>

    TS <Value> [,Range]

    TV

    TX

    TYPE <Filename>

    USEBLIT

    USECPU

    VERSION

    W [<CIA-REG>]

    WB <Filename>,<Start> <End>

    WD [#<Unit>] <DiskOffset> <Length> <Source>

    WN [<Count>]

    WPC <Address>

    WS [#<Unit>] <Sector> <SectorAmount> <Source>

    WT [#<Unit>] <Track> <TrackAmount> <Source>

    X

    Y [#<Entries per row>] <Address>

    ----------------------------------------------------------------------

     Command index - sorted by command groups

     Commands for manipulation

     Commands for searching data

     Commands for manipulating breakpoints

     Commands for 'Trace' actions

     Commands for MMU manipulation

     Commands for 'Training' actions

     Commands for io-access

     Commands for diskio-access only

     Commands for mfm manipulation

     Commands for misc usage

     Commands for sys usage

    -------------------------
    Commands for manipulation
    -------------------------

    A <Address>

    ADD <Bytes>,<Start> <End>

    AND <Bytes>,<Start> <End>

    CATCHFILE <StringPattern>

    COMP <Start> <End> <Destination>

    D [#<Mode>]<Address>

    E[<CUSTOM-REG>]

    EOR <Bytes>,<Start> <End>

    G <Address>

    M[.<B|W|L] [#<Entries per row>] <Address>

    N [#<Entries per row>] <Address>

    NO <Offset>

    LA <Address>

    <Bytes>,<Start> <End>

    OR <Bytes>,<Start> <End>

    Q <Start> <End> <Destination>

    R [<CPU-REG> <Value>]

    RF [<FPU-REG> <Value>]

    RM [<MMU-REG> <Value>]

    SA <Start> [<End>]

    SETEXCEPTIONS

    SETX

    SIM <Rawkey>

    TRANS <Start> <End> <Destination>

    W [<CIA-REG>]

    X

    Y [#<Entries per row>] <Address>

    ---------------------------
    Commands for searching data
    ---------------------------

    F <Bytes> [,Range]

    FA <Address> [,Range]

    FAQ <Address> [,Range]

    FAR <Start> <End> [,Range]

    FARQ <Start> <End> [,Range]

    FC [Range]

    FCQ [Range]

    FD <DisassemblyPattern> [,Range]

    FDQ <DisassemblyPattern> [,Range]

    FP <PBytes> [,Range]

    FR <Bytes> [,Range]

    FS <Bytes> [,Range]

    -------------------------------------
    Commands for manipulating breakpoints
    -------------------------------------
 
    B

    BD <Address>

    BD #<BreakpointNumber>

    BDA

    BT #<TrapNumber>

    BTI

    BS [#<BreakpointNumber>] <Address>

    ----------------------------
    Commands for 'Trace' actions
    ----------------------------

    MA

    MAD <Start> <End>

    MADA

    MAS <Start> <End>

    MD <Address>

    MDA

    MS [.<B|W|L] <Address>

    MV

    SI [<Count>]

    ST [<Count>]

    TR [<Count>]

    WN [<Count>]

    WPC <Address>

    -----------------------------
    Commands for MMU manipulation
    -----------------------------

    MMUD <Start> <End>

    MMUDA

    MMUS <Start> <End>

    MMUSW <Start> <End>

    MMUV

    RM [<MMU-REG> <Value>]

    -------------------------------
    Commands for 'Training' actions
    -------------------------------

    T <Value>

    TB <Start> <End>

    TBD

    TBV

    TDC

    TDS [Range]

    TDV

    TDX

    TS <Value> [,Range]

    TV

    TX

    ----------------------
    Commands for io-access
    ----------------------

    CD [Path]

    DELETE <Filename>

    DIR [Path]

    LESS <Filename>

    LM <Filename>,<Start> [<End>]

    LS [Path]

    MAKEDIR <Path>

    MORE <Filename>

    RB <Filename>,<Start> [<End>]

    SM <Filename>,<Start> <End>

    TYPE <Filename>

    WB <Filename>,<Start> <End>

    -------------------------------
    Commands for diskio-access only
    -------------------------------

    BITCHK <Address>

    BLKCHK <Address>

    BOOTCHK <Address>

    RD [#<Unit>] <DiskOffset> <Length> <Destination>

    RS [#<Unit>] <Sector> <SectorAmount> <Destination>

    RT [#<Unit>] <Track> <TrackAmount> <Destination>

    WD [#<Unit>] <DiskOffset> <Length> <Source>

    WS [#<Unit>] <Sector> <SectorAmount> <Source>

    WT [#<Unit>] <Track> <TrackAmount> <Source>

    -----------------------------
    Commands for mfm manipulation
    -----------------------------

    DISKLEN [#Unit] [LOW <Track>] [HIGH <Track>]

    MFMR [#<Unit>] [INDEX] [SYNC=<SYNC>] <Track> <DMA-Length> <Dest>

    MFMW [#<Unit>] [INDEX] <Track> <DMA-Length> <Source>

    MFMC <Start> <End> <Destination>

    MFMD <Start> <End> <Destination>

    MFMSL <Start> <End> <Destination> <BitShift>

    MFMSR <Start> <End> <Destination> <BitShift>

    MFMSS <Start> <End> <Destination> <Sync>

    -----------------------
    Commands for misc usage
    -----------------------

    ? <Value>

    DLAB <Labelname>

    DLABA

    GETKEY

    HELP

    INFO

    LAB <Labelname>=<Value>

    LABS

    LABELS

    LE <Filename>

    MP

    RESET

    SE <Filename>

    SHOWSTACKFRAME

    TRACKER [<START>]

    USEBLIT

    USECPU

    VERSION

    -------------------------
    Commands for system usage
    -------------------------

    AVAIL

    DEVS

    DEVICES

    INTS

    INTERRUPTS

    MEM

    LIBS

    LIBRARIES

    PORTS

    RES

    RESOURCES

    TASKS
 
    -------------------------------
    Commands description - no order
    -------------------------------

    Syntax:

    ? <Value>



    Description:

    Print value <Value> in differnt bases. This function can be used as  a
    simple calculator.

    Example:

    ? (!123*345%4|234)<<3

    ---------------------------------------------------------------------

    Syntax:

    A <Address>

    Description:

    Start assembly  at  <Address>.  The  command  uses  the  dis/assembler
    specified with the

    D command.

    Example:

          a 100000
            ^$00100000 movec vbr,d0
            ^$00100004 btst #6,$bfe001
            ^$0010000c bne 100004

    ----------------------------------------------------------------------

    Syntax:

    ADD <Bytes>,<Start> <End>

    Description:

    Add given pattern <Bytes> bytewise to memory from <Start> to <End>.

    Example:

           add "Mok",80000 90000

    ----------------------------------------------------------------------

    Syntax:

    AND <Bytes>,<Start> <End>

    Description:

    And given pattern <Bytes> bytewise to memory from <Start> to <End>.

    Example:

          and "Samir",80000 90000

    ----------------------------------------------------------------------

    Syntax:

    AVAIL MEM

    Description:

    Lists all currently available memory nodes and total memory usage.

    Example:

         avail

    ----------------------------------------------------------------------

    Syntax:

    B Description:

    Display all current breakpoints and breakpoint method.

    Example:

         b

    ----------------------------------------------------------------------

    Syntax:

    BD #<BreakpointNumber> BD <Address>

    Description:

    Either delete breakpoint at <Address>  or  breakpoint  with  specified
    <BreakpointNumber>. The value of <BreakpointNumber> must be one of

    Example:

          bd pc
          bd 80000
          bd #!31

    ----------------------------------------------------------------------

    Syntax:

    BDA

    Description:

    Delete all breakpoints.

    Example:

    bda

    ----------------------------------------------------------------------

    Syntax:

    BITCHK <Address>

    Description:

    Correct bitmapblock-checksum for bitmapblock at <Address>.

    Example:

          bitchk 10000

    ----------------------------------------------------------------------

    Syntax:

    BLKCHK <Address>

    Description:

    Correct datablock-checksum for datablock at <Address>.

    Example:

          blkchk 10000

    ----------------------------------------------------------------------

    Syntax:

    BOOTCHK <Address>

    Description:

    Correct bootblock-checksum for bootblock at <Address>.

    Example:

          bootchk 10000

    ----------------------------------------------------------------------

    Syntax:

    BS [#<BreakpointNumber>] <Address>

    Description:

    Set breakpoint at <Address>. If <BreapointNumber>  is  not  given  the
    next  free breakpoint is used. The value of <BreakpointNumber> must be
    one of

    Example:

          bs 80000
          bs #!31 80000

    ----------------------------------------------------------------------

    Syntax:

    BT #<TrapNumber>

    Description:

    Set breakpoint method to 'trap #<TrapNumber>' (dc.w $4e4<TrapNumber>).
    The value of <Trapnumber> must be one of

    Example:

         bt #f

    ----------------------------------------------------------------------

    Syntax:

    BTI

    Description:

    Set breakpoint method to 'illegal' (dc.w $4afc) opcode.

    Example:

         bti

    ----------------------------------------------------------------------

    Syntax:

    CATCHFILE <StringPattern>

    Description:

    The function will patch the current LoadSeg() function  from  the  the
    dos-library.  If  the  system  now tries to load a executable with the
    specified  pattern/name  TK  will  return  before  the  executable  is
    started.  The  patch  is  removed  and  the pc will point to the first
    instruction of the executable.

    Example:

         catchfile *tk.exe ; this will catch all executables, including eg
           'C:tk.exe'
         catchfile tk.exe ; this will
     not
     catch eg 'C:tk.exe' !!

    ----------------------------------------------------------------------

    Syntax:

    CD [Path]

    Description:

    The command will try to set the current-directory to  given  path.  If
    [Path] is not given it will just show the current path.

    Example:

          cd
          cd hd1:tk/

    ----------------------------------------------------------------------

    Syntax:

    D [#<Mode>]<Address>

    Description:

    Disassembly memory at <Address>. If address is zero the current pc  is
    used.  (like  in  the  AR).  The  <Mode>  argument  allows  you to use
    different dis- and assembler; default mode is zero.

    0 : usual 680x0 dis/assembler
    1 : RNC mode 1 (old)
    2 : RNC mode 2

    Example:

          d f800d2

    ----------------------------------------------------------------------

    Syntax:

    DELETE <Filename>

    Description:

    Delete file <Filename>.

    Example:

          delete "hd1:tk/tk.exe"

    ----------------------------------------------------------------------

    Syntax:

    DEVS

    DEVICES

    Description:

    Lists all currently available devices.

    Example:

          devs

    ----------------------------------------------------------------------

    Syntax:

    DIR [Path] LS [Path]

    Description:

    The command will display the directory for given [Path]. If [Path]  is
    not given it will use the current path.

    Example:

          dir hd1:tk/

    ----------------------------------------------------------------------

    Syntax:

    DISKLEN [#<Unit>] [LOW <Track>] [HIGH <Track>]

    Description:

    The function will determinate the disk-speed. Note that  the  data  on
    the disk is lost (so use a empty one).

    Example:

          disklen

    ----------------------------------------------------------------------

    Syntax:

    DLAB <Labelname>

    Description:

    Delete label <Labelname>.

    Example:

          dlab mfmload

    ----------------------------------------------------------------------

    Syntax:

    DLABA

    Description:

    Delete all labels.

    Example:

          dlaba

    ----------------------------------------------------------------------

    Syntax:

    E [<CUSTOM-REG>]

    Description:

    If no paramter is specified it will show the  first  CUSTOM  register.
    The  output  can  be  edited  (hit  return  to accept new values). The
    following flags exist:

    'R': a read only register; just for information; no change possible
    '-': reg has not been touched by TK; its kept at its original value;
      can be changed to '*'
    '*': reg has been backuped correctly and will be written back
    '?': reg has not been fully backuped but will be written back.
      (probably the reg was used by TK, too) It may be necessary to adjust
      it manually! (eg set $1dc to $20/$1bb8 for a PAL/MULTISCAN screen)

    Example:

         e 1dc ; show/edit beamcon0

    ----------------------------------------------------------------------

    Syntax:

    EOR <Bytes>,<Start> <End>

    Description:

    Eor bytewise memory from <Start> to <End> with given pattern <Bytes>.

    Example:

          eor "Mok",80000 90000

    ----------------------------------------------------------------------

    Syntax:

    F <Bytes> [,Range]

    Description:

    Find all locations in [Range] where <Bytes> occures.

    Example:

          f 4e 7b 00 f8 00 00
          f "Hello" ; will find 'Hello' but not 'HELLO','hello'

    ----------------------------------------------------------------------

    Syntax:

    FA <Address> [,Range] FAQ <Address> [,Range]

    Description:

    Find all commands in [Range] which refer to <Address>.  This  code  is
    analyzed  and all commands accessing <Address> are reported. Note that
    the current registers are used for scanning. If  quick  mode  is  used
    then the range-pointer is always increased by the command-size instead
    of 2. This means that you may loose valid locations.

    Example:

          fa f800d2

    ----------------------------------------------------------------------

    Syntax:

    FAR <Start> <End> [,Range] FARQ <Start> <End> [,Range]

    Description:

    Find all commands in [Range] which refer to  memory  from  <Start>  to
    <End>.  This  code  is  analyzed  and all commands accessing specified
    memory are reported. Note that the  current  registers  are  used  for
    scanning,  too. If quick mode is used then the range-pointer is always
    increased by the command-size instead of 2. This means  that  you  may
    loose valid locations.

    Example:

          far dff09a dff09c,f80000 f90000

    ----------------------------------------------------------------------

    Syntax:

    FC [Range] FCQ [Range]

    Description:

    Find all commands in [Range] which match to the internal library.

    Example:

          fcq

    ----------------------------------------------------------------------

    Syntax:

    FD <DisassemblyPattern> [,Range] FDQ <DisassemblyPattern> [,Range]

    Description:

    Find all commands in [Range] which match to given pattern. The  output
    of  the disassmbler is check for given pattern. Note that you can also
    search  for  multiple  commands.  If  quick  mode  is  used  then  the
    range-pointer  is  always  increased by the command-size instead of 2.
    This means that you may loose valid locations.

    Example:

          fdq "\move.l $*,(a?)\\tst.l #?"

    ----------------------------------------------------------------------

    Syntax:

    FP <PBytes> [,Range]

    Description:

    Find all locations in [Range] where pattern <PBytes> occures.

    Example:

          fp 4e ?? 00 ?8 00 0? ; will find eg $4e $4e $00 $f8 $00 $0f

    ----------------------------------------------------------------------

    Syntax:

    FR <Bytes> [,Range]

    Description:

    Find all locations in [Range] where  relative  <Bytes>  occures.  This
    means  that  only  a 'differnce-pattern' is searched. The given offset
    can be used for the NO command.

    Example:

          f r "Hello" ; will find eg 'Hello','Ifmmp',..

    ----------------------------------------------------------------------

    Syntax:

    FS <Bytes> [,Range]

    Description:

    Find all locations in [Range] where uppercased <Bytes>  occures.  This
    means that eg 'f' and 'F' is treated as same.

    Example:

          fs "HeLLo" 0,80000 90000 ; will find eg 'HELLO','hello'

    ----------------------------------------------------------------------

    Syntax:

    G <Address>

    Description:

    Exit freezer programm and continue the freezed programm at <Address>.

    Example:

          r sr 2700
          g f800d2

    ----------------------------------------------------------------------

    Syntax:

    GETKEY

    Description:

    The function will output the rawkey-code of  every  pressed  key.  (No
    need to look into a book)

    Example:

          getkey

    ----------------------------------------------------------------------

    Syntax:

    HELP

    Description:

    Show help-page. Press the <Help> key for the same effect.

    Example:

          help

    ----------------------------------------------------------------------

    Syntax:

    INFO

    Description:

    Show global system-information like  available  mem,  privatized  mem,
    cpu,  fpu,  mmu,  current  trackpos  of  drives,  head  pos, available
    devices, to be ejected devices and much more (check out).

    Example:

          info

    ----------------------------------------------------------------------

    Syntax:

    INTS

    INTERRUPTS

    Description:

    Lists all currently available interrupts. The first value is a pointer
    to the interrupt node and the second one is a pointer to the interrupt
    code.

    Example:

          ints

    ----------------------------------------------------------------------

    Syntax:

    LA <Address>

    Description:

    Load frozen programm-data from memory at <Address>. A programm can  be
    saved using the

    SA command.

    Example:

          la 7c00000

    ----------------------------------------------------------------------

    Syntax:

    LAB <Labelname>=<Value>

    Description: Define label <Labelname> and set it to value <Value>.  If
    the label already exists it will be redefined.

    Example:

          lab sync=$9521
          lab mfmload=824

    ----------------------------------------------------------------------

    Syntax:

    LABS

    LABELS

    Description:

    Show all current defined labels.

    Example:

          labs

    ----------------------------------------------------------------------

    Syntax:

    LE <Filename>

    Description:

    Load envirement from given file <Filename>. Only  settings  that  have
    been saved with the current programm version can be used. Settings can
    be genereated by the

    SE command.

    Example:

          le "hd1:tk/tk.prefs"

    ----------------------------------------------------------------------

    Syntax:

    LIBS

    LIBRARIES

    Description:

    Lists all currently available libraries.

    Example:

          libs

    ----------------------------------------------------------------------

    Syntax:

    LM <Filename>,<Start> [<End>] RB <Filename>,<Start> [<End>]

    Description:

    Load data-file <Filename> to memory starting at <Start>. If  <End>  is
    given, data will only be loaded upto <End>.

    Example:

         lm "hd1:tk/tk.exe",100000

    ----------------------------------------------------------------------

    Syntax:

    M[.<B|W|L] [#<Entries per row>] <Address>

    Description:

    Display memory  at  <Address>  as  <Entries  per  row>  byte/word/long
    depending on the [.<B|W|L] parameter. The command uses the byte offset
    defined by the Y command. Using optional  paramters  will  define  the
    default  paramter.  The  optinal  parameter  can be reseted by illegal
    values or just be using '#'.

    Example:

          m.b #5 80000 $0080000 $41 $42 $43 $44 $45 "ABCDE"

    ----------------------------------------------------------------------

    Syntax:

    MA

    Description:

    View all current memory access ranges.

    Example:

          ma

    ----------------------------------------------------------------------

    Syntax:

    MAD <Start> <End>

    Description:

    Delete memory access range at area from <Start> to <End>.

    Example:

          mad dff000 dff200

    ----------------------------------------------------------------------

    Syntax:

    MADA

    Description:

    Delete all memory access ranges.

    Example:

          mada

    ----------------------------------------------------------------------

    Syntax:

    MAKEDIR <Path> MKDIR <Path>

    Description:

    Creates a directory with for given <Path>.

    Example:

          makedir "hd1:tk/tk.dir"

    ----------------------------------------------------------------------

    Syntax:

    MAS <Start> <End>

    Description:

    Set memory access range to area from <Start> to <End>.

    Example:

          mas dff000 dff200

    ----------------------------------------------------------------------

    Syntax:

    MD <Address>

    Description:

    Delete memory watch point at <Address>.

    Example:

          md 80000

    ----------------------------------------------------------------------

    Syntax:

    MDA

    Description:

    Delete all memory watch points.

    Example:

          mda

    ----------------------------------------------------------------------

    Syntax:

    MFMC <Start> <End> <Destination>

    Description:


    Code data from <Start> to <End> into mfm-data stored at <Destination>.
    Each read long is coded into two mfm-longs (odd/even). This means that
    <End>-<Start> must be a multiple of four.

    Example:

          mfmc 80000 82000 84000

    ----------------------------------------------------------------------

    Syntax:

    MFMD <Start> <End> <Destination>

    Description:

    Decode mfm-data from  <Start>  to  <End>  to  normal  data  stored  at
    <Destination>.  Each  two  read  long  (odd/even) are decoded into one
    long. This means that <End>-<Start> must be a multiple of eight.


    Example:

          mfmd 84000 88000 90000

    ----------------------------------------------------------------------

    Syntax:

    MFMR [#<Unit>] [INDEX] [SYNC=<Sync>] <Track> <DMA-Length> <Dest>

    Description:

    Read <DMA-Length> words of mfm-data from track <Track> of disk in unit
    <Unit>   to  memory  at  <Destination>.  The  default  <Unit>  is  the
    current-device-unit. By default data will not  be  read  on  index  or
    sync.  Using  keywords  'INDEX'  or  'SYNC=<SYNC>'  will  enable these
    functions. Mfm-data is read directly by DMA. <Destination> may only be
    in chip-memory.

    Example:

       mfmr #0 index sync=4489 0 2000 100000 ; will read $2000 words=$4000
       bytes !!

    ----------------------------------------------------------------------

    Syntax:

    MFMSL <Start> <End> <Destination> <BitShift>

    Description:

    Shift data from <Start> to <End> by <Bitshift> bits left and store  it
    at  <Destination>. Of course, this command can also be used for normal
    data. <Bitshift> must be lower than 16.

    Example:

          mfmsl 84000 88000 90000 3

    ----------------------------------------------------------------------

    Syntax:

    MFMSR <Start> <End> <Destination> <BitShift>

    Description:

    Shift data from <Start> to <End> by <Bitshift> bits right and store it
    at  <Destination>. Of course, this command can also be used for normal
    data. <Bitshift> must be lower than 16.

    Example:

          mfmsr 84000 88000 90000 3

    ----------------------------------------------------------------------

    Syntax:

    MFMSS <Start> <End> <Destination> <Sync>

    Description:

    Search word <Sync> in data from <Start> to <End>. If <Sync>  is  found
    all  following  data  are copied to <Destination>, including the found
    sync. This command is very usefull for 'sync-read-by-hand'.

    Example:

          mfmr 0 2000 80000
          mfmss 80000 84000 90000 4489

    ----------------------------------------------------------------------

    Syntax:

    MFMW [#<Unit>] [INDEX] <Track> <DMA-Length> <Source>

    Description:

    Write <DMA-Length> words of mfm-data to track <Track> of disk in  unit
    <Unit>   with   memory   at   <Source>.  The  default  <Unit>  is  the
    current-device-unit. By default data will not  be  written  on  index.
    Using  keyword  'INDEX' will enable this function. Mfm-data is written
    directly by DMA. <Source> may only be in chip-memory.

    Example:

       mfmw #0 index 0 2000 100000 ; will write $2000 words=$4000 bytes !!

    ----------------------------------------------------------------------

    Syntax:

    MMUD <Start> <End>

    Description:

    Delete mmu catchlist from <Start> to <End>.

    Example:

          mmud 81234 81235

    -----------------------------------------------------------------------

    Syntax:

    MMUDA

    Description:

    Delete all mmu catchlists.

    Example:

          mmuda

    ----------------------------------------------------------------------

    Syntax:

    MMUS <Start> <End>

    Description:

    Add memory from <Start> to  <End>  to  mmu  catchlist.  The  specified
    memory is added as read/write catch.

    Example:

          mmus 81234 81235

    ----------------------------------------------------------------------

    Syntax:

    MMUSW <Start> <End>

    Description:

    Add memory from <Start> to  <End>  to  mmu  catchlist.  The  specified
    memory is added as write catch.


    Example:

          mmusw 81234 81235

    ----------------------------------------------------------------------

    Syntax:

    MMUV

    Description:

    Show current mmu catchlist.

    Example:

          mmuv

    ----------------------------------------------------------------------

    Syntax:

    MP

    Description:

    Start the memory-peeker. This tools allows you  to  scan  through  the
    memory  and  'browse  around'. Its also possible to view non-chipmem .
    Use the modulo feature to  adjust  the  srceensize  (eg.  for  finding
    images).

          The following keys functions are available:

          <CURSOR-DOWN>: Scroll one line down
          <CURSOR-UP>: Scroll one line up
          <CURSOR-DOWN>+<SHIFT>: Scroll a 3/4 screen down
          <CURSOR-UP>+<SHIFT>: Scroll a 3/4 screen up
          <CURSOR-LEFT>: Scroll 32 bit left/down
          <CURSOR-RIGHT>: Scroll 32 bit right/up
          <ESC>: Back to TK
          <TAB>: Cycle to next memory-page
          <DEL>: Reset modulo to zero
          <DEL>: Decrease modulo by 2
          <HELP>: Increase modulo by 2

    Example:

          mp

    ----------------------------------------------------------------------

    Syntax:

    MS [.<B|W|L] <Address>

    Description:

    Set memory watch point to byte/word/long at <Address>. Default size is
    byte.

    Example:

          ms.l 80000
          ms 60000

    ----------------------------------------------------------------------

    Syntax:

    MV

    Description:

    View all current memory watch points.

    Example:

          mv

    ----------------------------------------------------------------------

    Syntax:

    N [#<Entries per row>] <Address>

    Description:

    Display  memory  at  <Address>  as   line   of   <Entries   per   row>
    ascii-codes.The command uses the byte offset defined by the Y command.
    Using optional paramters will define the default paramter. The optinal
    parameter can be reseted by illegal values or just be using '#'.

    Example:

          n #$10 $80000
            $0080000 "ABCDEFGHIJKLMNOP"

    ----------------------------------------------------------------------

    Syntax:

    NO <Offset>

    Description:

    Set the ascii-offset for the M/N command. The offset is added to every
    read byte and subtracted from every written byte. Only the low byte of
    <Offset> is used!

    Example:

          n $80000
            $0080000 "ABC"
          no 1
          n $80000
            $0080000 "BCD"

    ----------------------------------------------------------------------

    Syntax:

    <Bytes>,<Start> <End>

    Description:

    Fill memory from <Start> to <End> with given pattern <Bytes>.

    Example:

          o "Mok" 0 "!" !10 0,0 20000

    ----------------------------------------------------------------------

    Syntax:

    OR <Bytes>,<Start> <End>

    Description:

    Or bytewise memory from <Start> to <End> with given pattern <Bytes>.

    Example:

          or "Mok",80000 90000

    ----------------------------------------------------------------------

    Syntax:

    PORTS

    Description:

    Lists all currently available ports and its owner tasks.

    Example:

          ports

    ----------------------------------------------------------------------

    Syntax:

    Q <Start> <End> <Destination> COMP <Start> <End> <Destination>

    Description:

    Compare memory from <Start> to <End> with memory at <Destination>.

    Example:

          q f80000 f90000 80000

    ----------------------------------------------------------------------

    Syntax:

    R [<CPU-REG> <Value>]

    Description:

    If arguments are not given the current registers  will  be  shown.  If
    arguments  are  used  the  cpu-register  <CPU-REG> can be set to value
    <Value>. If you want to change MMU/FPU registers take a  look  at  the
    RM/RF command.

          The following registers are available:

          68000: d0-d7,a0-a7,sr,pc,ssp,usp
          68010: d0-d7,a0-a7,sr,pc,ssp,usp,vbr,sfc,dfc
          68020: d0-d7,a0-a7,sr,pc,isp,usp,msp,vbr,sfc,dfc,caar,cacr
          68030: d0-d7,a0-a7,sr,pc,isp,usp,msp,vbr,sfc,dfc,caar,cacr
          68040: d0-d7,a0-a7,sr,pc,isp,usp,msp,vbr,sfc,dfc,cacr
          68060: d0-d7,a0-a7,sr,pc,isp,usp,msp,vbr,sfc,dfc,cacr

    Example:

          r ssp \ssp+4
          r d0 44894489

    ----------------------------------------------------------------------

    Syntax:

    RD [#<Unit>] <DiskOffset> <Length> <Destination>

    Description:

    Read <Length> bytes from  diskoffset  <DiskOffset>  of  disk  in  unit
    <Unit>   to  memory  at  <Destination>.  The  default  <Unit>  is  the
    current-device-unit. <DiskOffset> can also be odd.

    Example:

         rd #0 !880*200 4 80000 ; read first 4 bytes to $80000 from sector
         !880

    ----------------------------------------------------------------------

    Syntax:

    RES

    RESOURCES

    Description:

    Lists all currently available resources.

    Example:

          res

    ----------------------------------------------------------------------

    Syntax:

    RESET

    Description:

    The function will immediatly perform a reset.

    Example:

          reset

    ----------------------------------------------------------------------

    Syntax:

    RF [<FPU-REG> <Value>]

    Description:

    If arguments are not given the current registers  will  be  shown.  If
    arguments  are  used  the  fpu-register  <FPU-REG> can be set to value
    <Value>.

    The following registers are available:

    68881/68882/68040: fp0-fp7,fpsr,fpcr,fpiar (Currently they can not  be
    modifed!)

    Example:

          rf

    ----------------------------------------------------------------------

    Syntax:

    RM [<MMU-REG> <Value>]

    Description:

    If arguments are not given the current registers  will  be  shown.  If
    arguments  are  used  the  mmu-register  <MMU-REG> can be set to value
    <Value>.

    The following registers are available:

    68000/68010: none 68851/68030: tt0,tt1,srp (lower  long),srp.0  (lower
    long),  srp.1  (upper long),crp (lower long),crp.0 (lower long), crp.1
    (upper long),sr,tc 68040/68060: itt0,itt1,dtt0,dtt1,srp,urp,tc,sr

    Example:

          rm tc 81235678
          rm dtt0 0

    ----------------------------------------------------------------------

    Syntax:

    RS [#<Unit>] <Sector> <SectorAmount> <Destination>

    Description:

    Read <SectorAmount> sectors from sector <Sector> and following of unit
    <Unit>   to  memory  at  <Destination>.  The  default  <Unit>  is  the
    current-device-unit.

    Example:

          rs !880 1 80000

    ----------------------------------------------------------------------

    Syntax:

    RT [#<Unit>] <Track> <TrackAmount> <Destination>

    Description:

    Read <TrackAmount> tracks from track <Track> and following of disk  in
    unit  <Unit>  to  memory  at  <Destination>.The  default <Unit> is the
    current-device-unit.


    Example:

          rt !80 1 80000

    ----------------------------------------------------------------------

    Syntax:

    SA <Start> [<End>]

    Description:

    Save current programm to memory starting from <Start>.  <End>  is  the
    upper boundary for the programm data. If not given it will use as much
    memory as needed. Freezed programm-data can be reloaded using  the  LA
    command.

    Example:

          sa 7c00000 7fa0000

    ----------------------------------------------------------------------

    Syntax:

    SE <Filename>

    Description:

    Save envirement to given file <Filename>. The settings can  be  loaded
    using the LE command.

    Example:

          se "hd1:tk/tk.prefs"

    ----------------------------------------------------------------------

    Syntax:

    SETX

    SETEXCEPTIONS

    Description:

    This command  will  install  a  exception-'handler'  into  the  actual
    programm.  If the programm should crash now it will come back into TK.
    You can check  out  what  happend  and  maybe  solve  the  'bug'.  The
    following vectors are patched:

          +$08: BUS-ERROR exception
          +$0c: ADDRESS-ERROR exception
          +$10: ILLEGAL-COMMAND exception
          +$14: DIVISION BY ZERO exception
          +$24: TRACE exception
          +$28: LINA-A exception
          +$2c: LINE-F exception (no fpu/mmu?)

    Example:

          SETX

    ----------------------------------------------------------------------

    Syntax:

    SHOWSTACKFRAME

    Description:

    Show the stackframe of the freezed program.

    Example:

          showstackframe

    ----------------------------------------------------------------------

    Syntax:

    SI [<Count>]

    Description:

    Skip <Count> command (eg jsr/bsr is one command).  The  default  value
    for <Count> is one. Note that the disassembly is used to calculate the
    new address.

    Example:

          si 5

    ----------------------------------------------------------------------

    Syntax:

    SIM [<Rawkey>]

    Description:

    The function will install a faked NMI-simulator  into  the  system  by
    patching  directly the +$68 keyboard interrupt vector. If the user now
    presses the selected key it will simulate a NMI. This will  only  work
    if  the  interrupt  is not disabled and the vector is not changed. The
    specfied key must be given as a rawkey  code.  Check  out  the  GETKEY
    function.  If  no argument is given and the simulator is not installed
    the patch is added with the default rawkey $5d ('*' on the keypad). If
    no  argument is given and the simulator is installed the patch will be
    removed. In the other cases the rawkey will be redefined.

    Example:

          sim

    ----------------------------------------------------------------------

    Syntax:

    SM <Filename>,<Start> <End> WB <Filename>,<Start> <End>

    Description:

    Save memory from <Start> to <End>  to  data-file  <Filename>.  If  you
    overwrite  a  file  the  old filename is not changed! (eg. old 'AbCd',
    save 'ABCD', result 'AbCd')

    Example:

          sm "hd1:tk/tk.exe",100000 120000

    ----------------------------------------------------------------------

    Syntax:

    ST [<Count>]

    Description:

    Exit and execute <Count> command. Programm is traced step by step  (eg
    trace into jsr/bsr). The default value for <Count> is one.

    Example:

          st
          st !100000

    ----------------------------------------------------------------------

    Syntax:

    T <Value>

    Description:

    Remove all address in buffer for training which do not  hold  <Value>.
    Then  continue  collecting  all  address  which  hold <Value>. Scanned
    memory was set by the  TS  command.  Multiple  use  is  possible.  The
    command can only be used in byte-value-trainer-mode.

    Example:

          ts 5,780000 7c00000
          x
          t 4

    ----------------------------------------------------------------------

    Syntax:

    TASKS

    Description:

    Lists all currently  available  tasks.  The  tasks  are  listed  in  3
    categories  :  ready,waiting,running.  A 'P' indicates a process and a
    'T' a task. The first value is pointer to the task/process  structure,
    the  second  one  is  a pointer to the stack of the process (the first
    long at this address points to the routine that will be executed  when
    the task is running again (must be in the wait-list for that))

    Example:

    tasks.. P: $07989c88 $0798fd94  MagicWB-Demon  {C:MagicWB-Demon}  ;  a
    process,   task  node  at  $7989c88,  first  call  to  *798fd94,  name
    'Magic..', Process command 'C:Magic..)

    ----------------------------------------------------------------------

    Syntax:

    TB <Start> <End>

    Description:

    Set location of buffer for training to memory from <Start> to <End>.

    Example:

          tb 7c00000 7f80000

    ----------------------------------------------------------------------

    Syntax:

    TBD

    Description:

    Reset location  of  buffer  for  training  to  default.  The  internal
    reserved memory is used.

    Example:

          tbd

    ----------------------------------------------------------------------

    Syntax:

    TBV

    Description:

    View current location of buffer for training.

    Example:

          tbv

    ----------------------------------------------------------------------

    Syntax:

    TDC

    Description:

    If the deep-trainer-mode is already  active  all  stored  address  are
    compared  to their current value. If the value has changed the address
    is kept in the buffer, so only address that have changed are  kept  in
    the  buffer. As usual the command tries to continue scanning the given
    [Range] . See also the TDS command. The command can only  be  used  in
    the deep-trainer-mode.

    Example:

          tdc

    ----------------------------------------------------------------------

    Syntax:

    TDS [Range]

    Description:

    If deep-trainer-mode is not  active,  it  will  be  enabled  now.  All
    address  in  [Range] are stored in the buffer for training. If [Range]
    can not be scanned in one pass you can repeat the operation  by  using
    the  TDS/TDC  command.  If the deep-trainer-mode is already active all
    stored address are compared to their current value. If the  value  has
    changed  the address is removed, so only address that have not changed
    are kept in the  buffer.  As  usual  the  command  tries  to  continue
    scanning  the  given [Range] . Note that eg 'TDS 80000 90000' will not
    restart the deep-trainer if it was already active, in  this  case  the
    [Range]  paramter  is  ignored!. Using the command the first time will
    enable the deep-trainer-mode. This function needs around  three  bytes
    per stored address.

    Example:

          tds 780000 7c00000
          tds

    ----------------------------------------------------------------------

    Syntax:

    TDV

    Description:

    View all address in the buffer for  training.  See  also  the  TDS/TDC
    command. The command can only be used in the deep-trainer-mode.

    Example:

          tdv

    ----------------------------------------------------------------------

    Syntax:

    TDX

    Description:

    Free  buffer  for   training,   so   that   it   can   be   used   for
    byte-value-trainer-mode.  All  address  in  the  deep-trainer-mode are
    lost. The command can only be used in deep-trainer-mode.

    Example:

          tdx

    ----------------------------------------------------------------------

    Syntax:

    TR [<Count>]

    Description:

    Exit and execute  <Count>  command.  Programm  is  traced  command  by
    command  (eg  no trace into jsr/bsr). The default value for <Count> is
    one.

    Example:

          tr
          tr 5

    ----------------------------------------------------------------------

    Syntax:

    TRACKER [<Start>]

    Description:

    Start the module-ripper. The memory  is  scanned  for  known  modules.
    Currently  the  usual 31-sample noise/protracker, prorunner v2 and the
    player6.1a is included. If <Start> is specfied the scan is started  at
    the given address (only chipmem!)

    Example:

          tracker

    ----------------------------------------------------------------------

    Syntax:

    TRANS <Start> <End> <Destination>

    Description:

    Copy memory from <Start> to <End> to memory at <Destination>.

    Example:

          trans f80000 f90000 80000

    ----------------------------------------------------------------------

    Syntax:

    TS <Value> [,Range]

    Description:

    Init buffer for training and collect all address in [Range] which hold
    the  byte  <Value>.  If [Range] can not be scanned in one pass you can
    repeat the operation by using the T command. The command  enables  the
    byte-value-trainer-mode. This function needs around 2 bytes per stored
    address.

    Example:

          ts 5,780000 7c00000

    ----------------------------------------------------------------------

    Syntax:

    TV

    Description:

    View all address in buffer for training. The command can only be  used
    in the byte-value-trainer-mode.

    Example:

          ts 5,780000 7c00000
          x
          t 4

    ----------------------------------------------------------------------

    Syntax:

    TX

    Description:

    Free  buffer  for  training,  so  that  it  can  be   used   for   the
    deep-trainer-mode.  All  address  in  the  byte-value-trainer-mode are
    lost. The command can only be used in byte-value-trainer-mode.

    Example:

          ts 99
          tx
          tds

    ----------------------------------------------------------------------

    Syntax:

    TYPE <Filename> LESS <Filename> MORE <Filename>

    Description:

    Type text-file <Filename> to screen.

    Example:

          type "df0:s/startup-sequence"

    ----------------------------------------------------------------------

    Syntax:

    USEBLIT

    Description:

    Use the blitter for scrolling. On  slow  machines(68000)  this  method
    allows  realtime scrolling on small screens. The major disadvantage is
    the loss of the blitter custom-regs, so use with care!

    Example:

          useblit

    ----------------------------------------------------------------------

    Syntax:

    USECPU

    Description:



    Use the processor for  scrolling.  On  faster  machines(68020++)  this
    method allows realtime scrolling on big screens, too. Also the blitter
    custom-regs are not touched.

    Example:

          usecpu

    ----------------------------------------------------------------------

    Syntax:

    VERSION

    Description:

    The current version number is shown.

    Example:

          version

    ----------------------------------------------------------------------

    Syntax:

    W [<CIA-REG>]

    Description:

    If no paramter is specified it will show the first CIA  register.  The
    output  can be edited (hit return to accept new values). Usually there
    are just $10 regs per CIA but they are multiplexed; so there are  some
    more. The following flags exist:

    '*': reg has been backuped correctly and will be written back
    '?': reg has not been fully backuped and will not be written back;

    Example:

          w 7 ; show/edit TimerB-High

    ----------------------------------------------------------------------

    Syntax:

    WD [#<Unit>] <DiskOffset> <Length> <Source>

    Description:

    Write <Length> bytes to diskoffset <DiskOffset> of disk in unit <Unit>
    with    memory    at    <Source>.    The   default   <Unit>   is   the
    current-device-unit. <DiskOffset> can also be odd.

    Example:

          wd #0 !880*200 1 80000

    ----------------------------------------------------------------------

    Syntax:

    WN [<Count>]

    Description:

    Exit and return when the <Count>-th command after current position  is
    executed.Note  that  the  disassembly  is  used  to  calculate the ned
    address. Programm is not traced, instead  a  temporary  breakpoint  is
    set. The default value for <Count> is one.

    Example:

          wn 5

    ----------------------------------------------------------------------

    Syntax:

    WPC <Address>

    Description:

    Exit and return when command at <Address>  is  executed.  Programm  is
    traced and works also in ROM area.

    Example:

          wpc f800d2

    ----------------------------------------------------------------------

    Syntax:

    WS [#<Unit>] <Sector> <SectorAmount> <Source>

    Description:

    Write <SectorAmount> sectors to sector <Sector> and following of  disk
    in  unit  <Unit>  with  memory  at <Source>. The default <Unit> is the
    current-device-unit.

    Example:

          ws !880 1 80000

    ----------------------------------------------------------------------

    Syntax:

    WT [#<Unit>] <Track> <TrackAmount> <Source>

    Description:

    Write <TrackAmount> tracks to track <Track> and following of  disk  in
    unit  <Unit>  with  memory  at  <Source>.  The  default  <Unit> is the
    current-device-unit.

    Example:

          wt !80 1 80000

    ----------------------------------------------------------------------

    Syntax:

    X

    Description:

    Exit freezer programm and continue the freezed programm.

    Example:

          x

    ----------------------------------------------------------------------

    Syntax:

    Y [#<Entries per row>] <Address>

    Description:

    Display memory at <Address> as <Entries per row> binary  bytes.  Using
    optional  paramters will define the default. The optinal parameter can
    be reseted by illegal values or just be using '#'.

    Example:

          y #1 80000
            $0080000 %01011111

    ----------------------------------------------------------------------
    Thrill Kill - Argument description
    ----------------------------------------------------------------------

    <Value>, <Count>, <Offset>, <Entries per row>, <TrapNumber>,

    <BreakpointNumber>, <Length>, <SectorAmount>, <TrackAmount>, <Sync>,

    <DMA-Length>,<BitShift>,<Rawkey>

    <Address>, <Start>, <End>, <Destination>, <Source>

    <String>,<Labelname>

    <StringPattern>

    <Bytes>

    <PBytes>

    <Range>

    <DisassmeblyPattern>

    <Path>

    <Filename>

    <Unit>

    <DiskOffset>

    <Sector>

    <Track>

    ----------------------------------------------------------------------

    Argument:

    <Value>, <Count>, <Offset>, <Entries per row>, <TrapNumber>,
    <BreakpointNumber>, <Length>, <SectorAmount>, <TrackAmount>, <Sync>,
    <DMA-Length>,<BitShift>,<Rawkey>

    Description:

    These arguments are the base for  almost  every  other  argument.  The
    argument  parser  supports many operators (listed below). The operator
    priority is 'left-assigned' or is defined by the  used  operator  (see
    prefs  setting).  The  base  for  any input is 10(dec) or 16(hex) (see
    prefs setting).

    Simple values:

    '!' <digits> : Parse digits following in dec-mode(base 10) (eg.
      '!123456789', '!10'='$a')
    '$' <digits> : Parse digts following in hex-mode (base 16) (eg.
      '$44899521', '$10'='!16')
    '%' <digits> : Parse digts following in bin-mode (base 2);dots are
      skipped for a better overview (eg. '%1111'='$f',
      '%00001111.11110000.00000000.11111111'='$0ff000ff')
    '\<CPU-REG>' : The value of the specfied register is returned. The
      '\' is necessary if specified in the preferences. See the R command
      for available cpu-register.
    '"<ascii-digits>"' : The value of the ascii-string is returend (eg.
      "A"='$41',"ABCD"='$41424344')
    <labelname> : The value of the label is returned

    Unary operators:

    '~' <Value> : Exor following value (eg. '~$ff'='$ffffff00')
    '+' <Value> :Do not negate following value, dummy operator (eg.
      '+$100'='$100')
    '-' <Value> : Negate following value (eg '-1'='$fffffffe')
    '{' <Value>, '*' <Value>: Dereference following value. The longword
      at <Value> is fetched. (eg. '*4'=*execbase)

    Unary end operators:

    <Value> '.B' : Extend <Value> from byte to longword (signed
      operation) (eg. '$80.b='$ffffff80')
    <Value> '.W' : Extend <Value> from word to longword (signed
      operation) (eg. '$8000.w'='$ffff8000')
    <Value> '.L' : Extend <Value> from longword to longword (dummy
      operation)

    Binary operators (first operator in list has the lowest priority,  the
    last one has the highest)

    <Value1> = <Value2>, <Value1> == <Value2> : If <Value1> is the same
      as <Value2> result is 1 (true), else 0(false) (eg. '!10==$10' is
      false, '!10==$a' is true)
    <Value1> != <Value2> : If <Value1> is the not the same as <Value2>
      result is 1 (true), else 0(false) (eg. '!10!=$10' is true, '!10!=$a'
      is false)
    <Value1> < <Value2> : If <Value1> is less (signed) than <Value2>
      result is 1 (true), else 0(false) (eg. '!10<$10' is true)
    <Value1> <= <Value2> : If <Value1> is less same (signed) than
      <Value2> result is 1 (true), else 0(false) (eg. '!10<=$10' is true)
    <Value1> > <Value2> : If <Value1> is greater (signed) than <Value2>
      result is 1 (true), else 0(false) (eg. '$10>!10' is true)
    <Value1> >= <Value2> : If <Value1> is greater same (signed) than
      <Value2> result is 1 (true), else 0(false) (eg. '$a>=!10' is true)
    <Value1> && <Value2> : If <Value1> and <Value2> are true the result
      is 1 (true), else 0(false) (eg. '0&&1' is false)
    <Value1> || <Value2> : If <Value1> or <Value2> is true the result is
      1 (true), else 0(false) (eg. '1||0' is true)
    <Value1> & <Value2> : The result is <Value1> (bitwise) and <Value2>
      (eg. '$101&$ff'='1')
    <Value1> ! <Value2> : The result is <Value1> (bitwise) or <Value2>
      (eg. '$101!$ff'='$1ff')
    <Value1> ~ <Value2> : The result is <Value1> (bitwise) xor <Value2>
      (eg. '$101~$ff'='$1ff')
    <Value1> + <Value2> : The result is <Value1> plus <Value2> (eg.
      '2+4'='6')
    <Value1> - <Value2> : The result is <Value1> minus <Value2> (eg.
      '2-4'='-2')
    <Value1> * <Value2> : The result is <Value1> multiplied with <Value2>
      (eg. '2*4'='8')
    <Value1> / <Value2> : The result is <Value1> divided by <Value2> (eg.
      '5/2'='2')
    <Value1> % <Value2> : The result is the rest of <Value1> diveded by
      <Value2> (eg. '5%2'='1')
    <Value1> << <Value2> : The result is <Value1> shifted by <Value2>
      bits left (eg. '1<<!31'='$80000000')
    <Value1> >> <Value2> : The result is <Value1> shifted by <Value2>
      bits right (eg. '$80000000>>!31'='1')
    <Value1> ^ <Value2> : The result is <Value1> to the power of <Value2>
      (eg. '2^!31'='$80000000')

    Example:

          *4 ; address of execbase
          *((*(*4+$9c)+$17c)+$28) ; cuurent beamcon0
          (2+3*4==2+(3*4)) ; is true if operator priority is enabled

    ----------------------------------------------------------------------

    Argument:

    <Address>, <Start>, <End>, <Destination>, <Source>

    Description:

    These arguments are parsed the same like <Value>. The received address
    is  then  validated.  If  the  address  conflicts with the the current
    memory-mode (see prefs setting)  it  will  report  an  error.  If  eg.
    <Start>  and  <End> is used then <End> must be higher than <Start> and
    both must be in a continous memory-block.  (eg  not  from  $1f0000  to
    $f80000 -depends on the mmeory-mode!)

    Example:

          $10000+4*100

    ----------------------------------------------------------------------

    Argument:

    <String>,<Labelname>

    Description:

    A plain string can be started either with " or a ' and must of  course
    end  with  it.  However,  if  you  do  not  use ",' the string will be
    uppercased and will terminate at the first space or tab.

    Example:

          "amiga"
          "amiga'
          amiga ; identicall to "AMIGA"

    ----------------------------------------------------------------------

    Argument:

    <StringPattern>

    Description:

    The argument <StringPattern> is  just  a  <String>  which  holds  some
    special  symbols.  The  following wildcards are available: '?' (single
    wild-char)  and  '*','#?'  (multiple  wild-chars).  The   pattern   is
    incasesensitive.

    Example:

          '*dir'

    ----------------------------------------------------------------------

    Argument:

    <Bytes>

    Description:

    The argument is usually use for searching mutliple bytes.  <Bytes>  is
    build  up  of  multiple <Value> or <strings> seperated by a space. The
    value must be given is hex-mode! Only the low  bytes  of  a  value  is
    used. However, strings will be converted to multiple bytes.

    Example:

          $45 45 ; same as 45 45
          45 890 45 ; same as 45 90 45
          "password" 00
          "diskname" 0 "sync" $0a $00 ; searches what it means!

    ----------------------------------------------------------------------

    Argument:

    <PBytes>

    Description:

    The argument is given in the same ways as in argument <Bytes>. If  the
    parsed  value  (byte  sized)  included a '?' the upper/lower nibble is
    marked as a wildcard.

    Example:

    ?? 00; same as if you would search just $00 "d"  ??  ??  ".library"  ;
    will find eg 'dos.library' 8? ?? ?? ?8 "SXI!" "diskname" ?? "sync" $??
    $00 ; searches what it means!

    ----------------------------------------------------------------------

    Argument:

    <Range>

    Description:

    The argument <Range> is build up  of  a  list  of  <Address>.  If  the
    argument <Range> is not used all available memory pages are scanned. A
    single address as argument means that  the  scan  will  start  at  the
    specfied address (instead of $00000000). A additional (second) address
    is used to determinate when to stop. (check out the memory setting)

    Example:

          <no arg> ; scan all available pages
          $80000 ; scan all available pages starting at $80000
          $1f8000 $7880000 ; may scan $1f8000-$200000,$7800000-$7880000

    ----------------------------------------------------------------------

    Argument:

    <DisassmeblyPattern>

    Description:

    The argument <DisassemblyPattern> is just a <String> which holds  some
    special  symbols.  The  following wildcards are available: '?' (single
    wild-char)  and  '*','#?'  (multiple  wild-chars).  The   pattern   is
    incasesensitive.  A space is extended to a '*' wildcard. If the parser
    encounters a '\' it will use the pattern for the next command.

    Example:

    "movec ,vbr","MOVEC*,vbr*" ; same pattern  "move.l  ,?0"  ;  finds  eg
    "movea.l   $7c.w,a0"   but   not  "movea.l  $7c.w,a0"  (check  out  if
    destination is a address reg!) "cmp*.l  #$????????,*\b*\"  ;  find  eg
    "cmp.l #$12345678,-$10(a7)\beq.l $80000"

    ----------------------------------------------------------------------

    Argument:

    <Path>

    Description:

    The argument <Path> is just a <String> which holds the device path. If
    no  absolute path is used it is appended to the current path. The path
    my not point to a file!

    Example:

          "df0:tk/","df0:tk" ; absolute path
          "tk" ; relative to the current path

    ----------------------------------------------------------------------

    Argument:

    <Filename>

    Description:

    The argument <Filename> is just a <String> which holds  the  filename.
    If  no  absolute  path is used it is appended to the current path. The
    filename may not point to a directory!

    Example:

          "df0:tk.exe" ; absolute path
          "tk.exe" ; relative to the current path

    ----------------------------------------------------------------------

    Argument:

    <DiskOffset>

    Description:

    The argument <DiskOffset>  is  just  a  <Value>  which  addresses  the
    diskdata  as one continous memory block. It must be lower than $dc0000
    (DD-Disk)/$1b8000(HD-Disk).

    Example:

          !880*200 ; root block (DD)
          $c ; eg read data from diskoffset !12 (bootblock code)

    ----------------------------------------------------------------------

    Argument:

    <Unit>

    Description:

    The argument <Unit> is just a <Value> which determinats the  drive  to
    be used. <Unit> can only be 0(DF0),1(DF1),2(DF2),3(DF3).

    Example:

          0 ; "df0:" (what to say else??)

    ----------------------------------------------------------------------

    Argument:

    <Sector>

    Description:

    The argument <Sector> is just a <Value>  which  addresses  data  on  a
    disk.  It must be lower than 1760(DD-Disk)/3520(HD-Disk). A sector has
    a size of $200 bytes.

    Example:

          !880 ; root.-block

    ----------------------------------------------------------------------

    Argument:

    <Track>

    Description:

    The argument <Track> is just a <Value> which addresses data  on  disk.
    It   must   be   lower   than  80(DD/HD-Disk).  A  track  consists  of
    11(DD-Disk)/22(HD-Disk)  sectors.  So  a  track  has   a   length   of
    $2c00/$5800 bytes.

    Example:

          !80 ; track with root-block (DD)

    ----------------------------------------------------------------------
    Thrill Kill - How to make a NMI-button
    ----------------------------------------------------------------------

    If you want to use TK you must have a NMI-button, else you will not be
    able  to  enter  TK  at  any  point,  because the software patches are
    usually eliminated by eg NDOS-programms. If you  have  never  soldered
    anything  try  to  find someone who can do it for you, though its very
    easy (in my opinion..) You need the following stuff:

       1 x button (on/off)
       3 x diodes (no special type required, (at least 10V/100mA, i think)
       eg: 1N4148, 1N4001-7 or any universial diode)
       some wires and the usual equipment to solder

    You must connect a ground signal to one pin  of  the  button  and  the
    other  button  pin to every cathode of thediodes and from their anodes
    to the IPL0, IPL1, IPL2 signal, so quite easy. (If the instruction for
    your computer is missing do it yourself or find someone...). Make sure
    that the black ring of the diodes point to the button and not  to  the
    ipl lines. It should look like this

       IPL0 -----------------------|>|----\
       IPL1 -----------------------|>|------------ BUTTON ----- GROUND
       IPL2 -----------------------|>|----/

    Note:


     '..--|>|--.. ' is a diode which anode is left and cathode is right!


    LAST WARNING! NO WARRANTY FOR ANY INSTRUCTION LISTED BELOW!!

    A1200:

    I would advise to use the  internal  150-pin  expansion  connector.The
    ipl-lines are at pin 81, 82, 83 and the ground is eg at pin 79 (take a
    look at your A1200 manual for verification). If you  have  a  cpu-card
    installed  try  so  solder  on  the  connector  of  it.  The expansion
    connector looks like this:

                                     ...|IPL1|...
                                          |
         (upper half) |2|4|6|8|..........|82|......|148|150|
         (lower half) |1|3|5|7|.......|79|81|83|...|147|149|
                                       /   |   \
                                ...|GROUND|IPL0|IPL2|...

         (PIN 81) IPL0 -------|>|----\
         (PIN 82) IPL1 -------|>|------- BUTTON --- GROUND (PIN 79)
         (PIN 83) IPL2 -------|>|----/


    A4000 (and maybe A3000):

    I would advise to use the internal 200-pin expansion connector of  the
    cpu-card,  because all other connectors do not support the ipl-signals
    (including the Zorro2/3 slots!!). Unfortunatly, i  have  not  found  a
    description  where all signals are described with correct pin numbers,
    so i will just give a exact pin-location. If you have a  manual  where
    the  pins  are  described  try to contact me. You should solder on the
    upper side (the one where the  connector  pins  are  soldered  to  the
    card).  The following instructions were tested on a A4000 with a 68030
    and 68040 original cpu card. It should also work with  the  cyberstorm
    cards!  (not  tested yet!, no warranty!) The expansion connector looks
    like this:

         /--------------------------------------------------------------\
         |                                                              |
         |   x x x x ... x x x x x x x x x       x x x x ... x x x x    |
         |    x x x x ... x x I J K x x x x       x x x x ... x x x x   |
         | O x x x x ... x x x x x x x x x       x x x x ... x x x x O  |
         |    x x x x ... x x x x x x x x         x x x x ... x x x G   |
         |                                                              |
         | ()                                                        () |
         .                                                              .
         .                                                              .
         | ()                                                        () |
         \--------------------------------------------------------------/


    I,J,K: IPL signals, G:GROUND signal

         I(IPL) ------- |>|----\
         J(IPL) ------- |>|------- BUTTON --- G (GROUND)
         K(IPL) ------- |>|----/

         BTW: I use this hardware patch!

    A500/A2000:

    I would advise to use the external  86 - pin expansion connector.  The
    ipl-lines are at pin 40, 42, 44 and the ground is eg at pin 37 (take a
    look at your A500 manual for verification).  The  expansion  connector
    looks like this:

                                ...|IPL0|IPL1|IPL2|...
                                       \  |   /
         (upper half) |2|4|6|8|.......|40|42|44|.....|84|86|
         (lower half) |1|3|5|7|....|37|..............|84|85|
                                    |
                              ...|GROUND|...

         (PIN 40) IPL0 ------- |>|----\
         (PIN 42) IPL1 ------- |>|------- BUTTON --- GROUND (PIN 37)
         (PIN 44) IPL2 ------- |>| ----/

    The internal 86-pin-MMU-connector  of  the  A2000  has  the  same  pin
    assignment  as  the  A500  86-pin  connector. However if want to use a
    Zorro2-slot then you need just to connect the  EINT7-signal  (pin  40)
    directly  via  a button to a ground signal (eg pin 37). Take a look at
    your A2000 manual for verification.

    ----------------------------------------------------------------------
     Thrill Kill - Registration/Demo limits/How to order
    ----------------------------------------------------------------------

    If you run the demo version the following restrictions are active:

    No write operations are possible (SM, MFMW, SE, SA, WT, WS, WD,..)
    No external trainer buffer! (TB, TBD)
    No deep-trainer! (TDS/TDC)

    Assembling is not possible! (A)

    The demo version is basically a crippled standard version of TK Max 10
    entries  into  TK, then TK will lock you system. You will have to do a
    reset to get out!

    If you register you can decide between  two  versions  available,  the
    standard and the professional. The professional versions includes some
    commands which are used very seldom or need special  equipment  (eg  a
    working  mmu).  The  following  commands  are  only  available  in the
    professional version:

    All mmu functions (MMUV, MMUS, MMUSW, MMUD, MMUDA)
    A dis-/assembler for special code (A, D)
    Commands for direct-ram-freezing (LA, SA)
    Any programm launched from system can be catched before execution
    (CATCHFILE)

    Find disassembly allows multiple line matching (FD)
    Probably find special code (FC) (but not with my lib!)

    Notice the following rules:

    The money can only be send to my bank-account (no  mail-queues  etc..)
    You  pay  in  advance, then you get the software You should contact me
    before  sending  the  money  I  prefer  sending   the   software   via
    e-mail/internet  or  via modem (the fastest method) Its not impossible
    to send TK via snail (ask'n'hope) If you order  from  outside  germany
    make  sure  that the correct amount of german marks will be transfered
    by your bank

    NO WARRANTY FOR ANY DATA LOST BY USING TK !

    If you order please include a short description about your
    system-configuration (not necessary)

       cpu
       mmu
       fpu
       memory + its location
       amiga model

    The standard version costs 200-DM. Yet i am not sure about  the  price
    for the professional version, just ask!

    Finally  if  you  want  to  order  contact me (or Goldman) and leave a
    message with your wish. You will receive a bank-account nr to send the
    money to.

    ----------------------------------------------------------------------
    Thrill Kill - Yet known bugs
    ----------------------------------------------------------------------

    The following bugs are yet known:

    1. No support for graphics-cards, and other kewl equipment. Tk can
       not support every available hardware.
    2. TK does not like programms who also use the MMU, especially on
       68040++.
    3. Strange things happen if you access memory higher $0ffffff on some
       A4000 (but not mine :)).. all custom regs are gone and much more.
       TK gives its best to restore the custom regs, but however its not a
       magican. (you have to generate an own setting which does not do a
       memory detect for $1dc00000++)
    4. TK can not debug programms who misuse the stackpoiner (a general
       problem of all freezers!)
    5. The simple NMI-button cause multiple instances of NMIs. They may
       blow up the internal/external stack.

    ----------------------------------------------------------------------
    Thrill Kill - History
    ----------------------------------------------------------------------

    Version 1.04:

          first real public release

    ----------------------------------------------------------------------
    Thrill Kill - Contact
    ----------------------------------------------------------------------

    Information about registration, bug reports, new featues  or  anything
    else  available  can  be  obtained  via  e-mail:  Leave  a  message to
    'ajunk@uni-paderborn.de' with subject 'TK' and your question. (be very
    patient...)

    WWW:
     (will be soon available..be patient)

    BBS:
      Call 'Straight Hate' and use the 'c' command to leave me (ferox) or
      goldman a message (use login:'customer', password:'kill')

    IRC:
     You may find me in one of the following channels: 'AmiElite',
     'AmigaSCNE', 'Amiga', 'AmigaGER' (my nick is 'ferox') I will try to
     setup a channel named 'ThrillKill' for TK-support.

    Leave a message to 'Goldman' (my beta-tester NR 1) on a scene bbs
    (especially the Sunflex Inc. boards).

    You may also try to post a message to 'ferox' on some bbs (be warned!
    i do not visit them often).

    ----------------------------------------------------------------------
    Thrill Kill - Future
    ----------------------------------------------------------------------

    The following things are (not) planned:

    1. Improved freezer ability (there are still some games which could be
       freezed 100%)
    2. More compatibility (just how..)
    3. Better OS-filesystem support (to less fun..)
    4. A better NMI-button hardware (the easy NMI-button has major
       disadvantages, tough its very easy to implement)
    5. A amigaguide documentation (Has anyone a html-to-amigaguide
       converter??)
    6. A PPC dis- and assembler (not even started yet)
    7. A PPC version (not even started yet)
    8. Maybe a hardware version (but not for the 680x0 versions)
    9. No picture saver (For what ? Only if really many many would request
       it...)

    ----------------------------------------------------------------------

