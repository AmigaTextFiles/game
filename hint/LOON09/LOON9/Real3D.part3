


			    PART 3
		     Follow On From Part 2




5.15 OBJECT ATTRIBUTES AND RENDERING

The object attributes include several features for controlling the
rendering of objects. Some of the flags are intended for speed
optimizations and some are for special rendering effects.

You can set these flags using the Modify/Properties/Attributes function.

5.15.1 Scene gadget

The "Scene" gadget of the Attributes requester makes selected objects.
Invisible in the first phase ray tracing. This means that you cannot see
the object directly, but you can see its shadows, reflections, etc. This
may sound a bit strange but consider the following problem: a shiny,
golden logo moving in a black space looks good but unfortunately black
space produces no reflections! The solution is to create an environment
which creates rich reflections for the logo, and then make the environment
invisible using the Scene-function.

5.15.2 Backdrop and Matte Objects

The "Matte" gadget of the object attributes requester controls "matte"
shading of objects. An object having this attribute set is shaded using
the background colours. This may sound strange, but actually this feature
is very useful when combining 3D computer graphics with video graphics or
other 2D graphics.

                             - TUTORIAL 5.14 -

It allows you to create "backdrop layers", as demonstrated in the next
example in which a "UfO" is flying around your house:

1. Digitize a picture of your house (use a scanner, video digitizer, or
   a paint program).

2. Open a suitable rendering screen with a borderless View and a Select
   window; for example a 16 colour HIRES-Lace screen is suitable.

3. Select View/Observer/Create Camera. Position the camera approximately
   so that it corresponds to the camera position where the original
   picture was taken. You may use exact 3D coordinates for this purpose
   or a cube shape representing roughly the shape of the house so that
   you can visually adjust the camera position. When the camera is set,
   delete the cube. The scale should be adjusted carefully to match the
   camera lens angle. The purpose of this step is get roughly equal
   perspective in the backdrop image and the true 3D scene.

4. Open the render settings requester for the View and select for example
   Environment mode. Activate the Backdrop image gadget and enter the name
   of the picture of the house to the backdrop image field.
   Then select OK.

5. Hit <RAM>r to render the view. The backdrop image should fill the
   display.

6. When the View is rendered, select Create/Visibles/Polygon and draw a
   polygon along the profile of the house; the polygon should match the
   shape of the house as accurately as possible.

7. Select Modify/Properties/Attributes and activate the "Scene" gadget for
   the polygon. Then press OK button to close the requester.

8. Create the "UfO"; a flat sphere is suitable.

9. Hit <RAM>z to get the top view and use Animate/Create/Rotation to make
   the UfO rotate around the polygon.

10. Use View/Observer/Observer->View function to get the camera view back.

11. Render the animation. The UfO flies around the house disappearing
    behind it and then re-appearing from the opposite side.

As you see, you can cleverly blur the boundary between true 3D animation
and digitized images. It is even possible to synchronize a series of
backdrop images with a camera flight, providing that more accurate matte
shapes are used.

Note:
That the Matte object feature is designed to work well with the Alpha
channel support: matte objects have a full Alpha transparency. This means
that you can use video systems instead of digitized images to get such
effects as demonstrated above.

5.16 OPTIMIZATIONS

Rendering time plays a major role in animation production. Time
limitations should be considered when you are designing the scene. By
default, REAL 3D can simulate reality accurately without compromise.
For example, the user does not have to specify that an object

                             - TUTORIAL 5.15 -

casts a shadow onto another object. Normal mode rendering calculates all
the shadows automatically and it is up to the user to eliminate objects
from shadow calculations to speed up rendering if desired.

In general, it is easy to create scenes which require very long ray
tracing times. The trick is to adjust your scene so that you take
advantage of the time saving features and that you realise the situations
that will increase or decrease your rendering time. For example, create
one thousand wooden objects and render them, the rendering time may be 15
minutes. Then with one single adjustment in the material editor, make the
wood transparent, the scene could take 15 hours. There is nothing
mysterious in this, you just asked REAL 3D to do something 100 times more
complex.

Knowing what is practical and possible and what is not in terms of
rendering time is an interesting question and will depend on your hardware
and your understanding of the software. Fortunately, it is always possible
to manipulate the scene to achieve remarkable time savings. Some 3D
animation programs only produce a "scanline" render which is not a full
ray trace.

This mode is sometimes useful because it can be rendered fairly quickly.
In REAL 3D V2, you are able to perform "scanline" rendering if you wish
but you are also able to freely adjust the intensity of the rendering to
fully suit your needs.

5.16.1 Rendering Mode

The most immediate control over rendering time is provided by rendering
mode selection as described in the chapter 5.5 "Rendering Modes".
Environment mode always renders the scene relatively quickly, rendering
time being typically less than 15 minutes per frame. Starting from Normal
mode, then trying Shadowless, Lampless and finally Environment mode, you
will see the different speeds involved. It is possible to use tricks to
obtain extra realism with simple rendering modes. For example, you can use
shadow maps to create artificial shadows and texture/environment maps to
create artificial but fast reflections; ultimately you can re-create a
"Normal mode" using tricks but then the "manual" work required to obtain
the extra level of realism may take more time (and especially more effort)
than when letting the program render the image with a full level of
realism.

5.16.2 Resolution

Image resolution is another significant factor affecting the rendering
time. If you use PAL resolution of 736*584, the rendered time is
guaranteed to be at least 5 times longer than when using a 320*256 HAM
screen. Unfortunately it is difficult to reduce the resolution without
losing quality. Typically, the maximum time savings obtained this way is
of a of magnitude 2.

Note:
That colour resolution (6 bit HAM instead of 24 bit quality) does not
affect the rendering time that much except that a smaller amount of data
is faster to save.

5.16.3 Recursion

The recursion depth value of the render settings requester affects the
rendering time significantly when large areas of the image are covered by
transparent objects. When light hits a boundary between two materials it
is divided into components, which are studied individually. This results
in an exponential growth in rendering time.

                             - TUTORIAL 5.16 -

5. 16.4 Re-interpreting B-splines

If the scene contains B-Spline surfaces, rendering can be accelerated
using the B-Spline->Phong function of the render settings requester.
This affects the rendering quality, but when the object is simple, an
adequate quality can be obtained using a higher Subdivision value.

Secondly, you can lower the Subdivision setting for B-Spline shading;
often the value 1 is quite sufficient. If the quality requirements or
memory limitations do not allow the previous methods, you may try applying
Modify/Freeform/Reparametrize to the B-Spline meshes and then rendering
the scene with 1 lower Subdivision value. The quality is reasonably
maintained but rendering is faster.

5.16.5 Reflections & Not Reflected.

The "Not reflected" object attribute is an accurate and efficient way to
improve rendering time. You can set this attribute using the Modify/
Properties/Attributes function.

"Not reflected" property specifies that an object is not considered in
reflection/refraction calculations. You can see the object, but you cannot
see it in a mirror or through a glass window.

The most typical application for the feature is a scene including one
large and complex transparent/mirror-like object. When you set the
attribute for the object itself, you can see the rest of the scene in
reflections and refractions, but the object does not reflect itself, which
can be hard to notice anyway.

For example:
if you have a large B-Spline modelled statue, say, a human head made of
glass, standing on a simple checker floor surface, activating "Not
reflected" attribute of the head may accelerate the rendering up to 20
times! This is because the reflection computations consider only the
simple floor object instead of hundreds of complex B-Spline patches of the
head. Usually every scene contains numerous minor details which are not
necessary to be seen in reflections. Making them "not reflected" can
accelerate rendering very significantly. It is even possible to add
simpler "Scene" objects for creating the reflections and make the actual
complex visible objects "Not reflected".

5.16.6 Shadows

The "Cast shadows" object attribute makes it possible to define for each
individual object or light-source its shadow casting property. Rendering
time can be shortened significantly using this feature. You can access the
feature using Modify/Properties/Attributes function;

Note:
That "Cast Shadows" property is set by default and you can unset it to
obtain the optimization.

If a visible object has this attribute unset, it does not cast a shadow at
all. You can eliminate the shadows from small details of a scene and
achieve remarkable time savings that way. For example: if you have a
detailed model of a house, it may be enough that the walls cast shadows,
it may not be necessary that doors, windows and other smaller parts cast
shadows, too. This simplification may reduce the number of objects
considered in shadow calculations to a small fraction. Also, sometimes
the user may know that an objects shadow does not fall within the scene
and therefore it is not necessary to cast the shadow. The program cannot
understand the contents of the scene and do the optimization
automatically. For example, if you create a relatively smooth and low
fractal landscape surface and the light falls from above, the ground
surface cannot cast any shadows on any object, although trees and other
objects may cast shadows on it. In this case, the only consequence of
clearing the "Cast shadows" attribute of the ground is much faster
rendering, no shadows are lost.

                             - TUTORIAL 5.17 -

Secondly, if a light source has the attribute unset, no shadows are
generated from that light source. You can use this feature to add numerous
light sources to a scene to get complicated lighting effects, and still
have reasonable rendering times.

Non-pointwise light sources, which produce smooth shadows, usually slow
down rendering. The basic rule is that generating smooth shadows with the
"Lightsamples" value of 1 will triple the rendering time. Therefore, be
careful in your application of this effect which admittedly increases
the photorealism, and use the lowest possible value producing sufficient
quality.

5.16.7 Other Optimizations

- Use quadric primitives and compound tools instead of free-forms whenever
  possible.

- Motion blur is a nice effect, but it is one of the most time-consuming
  rendering features.

- Anti-aliasing level 3 is usually sufficient. Textures with strong colour
  variations combined with a high anti-aliasing level may slow rendering.

5.17 USING ALPHA CHANNEL

When you want to render images using the Alpha channel support features of
REAL 3D, do the following:

1. Create the scene. If the scene includes transparent objects, you may
   define a non-zero alpha level for them using the Modify/Properties/
   Alpha Channel function. For example, a glass object may have an Alpha
   value 128.
   The higher the Alpha value, the more you see through the object when
   the image is combined with another images (e.g. live video background).

2. Prepare a View window for the rendering (camera position etc...)

3. Open the render settings requester and select Targa file output.
   Specify the file name. Then activate the "Alpha output and "No bar.
   initial" gadgets. Use any rendering mode except Outline or Draft. Using
   background gradients and backdrop images do not make much sense because
   the background will have full Alpha transparency.

4. Start rendering.

Alternatively, you can render to the External screen; REAL 3D can write
the Alpha information to the output target. Of course, the External screen
device must have the Alpha channel feature. Remember to select "Targa+A"
saving mode (Project/External Screen/Settings) before saving the image
from the External screen.

32-bit true colour Targa format uses four bytes to store each pixel of
which one byte is for Alpha information.
This means that the Alpha transparency can be expressed using 256 levels.

Note:
That the anti-aliasing algorithms anti-aliase the Alpha information as
well. This means that when you combine computer graphics with a live video
background, the edges of objects in computer generated images are smoothly
blended to video images. Also motion blur and depth of field blur work
correctly: blur against background is partly Alpha transparent.

                             - TUTORIAL 5.18 -

It is usually important to select "No bgr. antial." gadget when using
Alpha channel. That gadget instructs REAL 3D not to anti-aliase with the
background colour. Otherwise the edges of objects get influenced by the
background colour.

For those users who do not have a frame buffer with the Alpha channel
support, there is another method available for using Alpha transparency
information. This method is based on 1-bit mask images. To use this
technique:

1. Create the scene. This time mediumlevel alpha transparency does not
   have much significance (any non-zero value will be fully transparent).

2. Prepare a View window for the rendering (camera position etc...)

3. Use the render settings requester to select the IFF file output.
   Specify the file name. Then activate the "Alpha output" and "No bgr.
   antial" gadgets. Use any rendering mode except Outline or Draft.

4. Start rendering. REAL 3D renders two images of each frame, one 24-bit
   image and one 1-bit mask image. Both images have identical resolutions.

5.l8 RENDERING FIELDS

When very smooth animation is required, 25 frames (or even 30 fps) may not
be enough. The extra smoothness of motions can be achieved by showing a
new image in each video field. The PAL system, for example, shows 50
individual fields per second. Nevertheless, because of the interlaced
nature of the PAL system, each field includes only one half of the
vertical picture lines.

Therefore, rendering full video resolution images for field-rate recording
means wasting one half of the rendering time and picture information.

REAL 3D includes a special function for more efficient field rendering.
For example, if you want to render an animation using a HIRES-Interlaced
Amiga screen mode:

1. Create the animation.

2. Select Project/Environment/Open Screen and select a suitable HIRES
   screen mode. Do NOT select an Interlaced screen mode. After opening the
   screen, open a borderless View on it.

3. Open the render settings requester for the View window, and define
   normal settings as you wish.

4. Activate the "Field rendering" gadget.

5. Render the animation.

If you want to render fields using the External screen, its library must
   support non-interlaced (or vertically halved) resolutions.

When rendering fields to disk files, do the following:

1. Create the animation.

2. Open the render settings requester for the View window, which you are
   going to use in rendering. Set the output to a file and define other
   settings as you wish.

3. Activate the "Field rendering" gadget.

                             - TUTORIAL 5.19 -

4. Define the image resolution and use the halved vertical resolution.
   For example Width = 736, Height = 282.

5. Define the aspect ratio. It should be twice the normal ratio: for PAL,
   Pixel h/w = 2.0 is quite suitable.

6. Render the animation.

5.19 MOTION BLUR

The following example shows how to use the motion blur effect in your
animations.

1. Create the animation as normal. The effect is visible (and necessary)
   only when the animation contains objects moving quite fast. As a
   general rule, an object should move at least 10-20 pixels between two
   frames before the blur produces noticeable results.

2. Select the objects to which you want to apply motion blur, select the
   function Modify/Properties/Attributes and activate the "Motion blur"
   gadget. Then select OK. Use the effect only to the objects which are
   moving the fastest because motion blur calculations require significant
   amounts of extra rendering time and ram memory.

3. Define the render settings as usual, but set the anti-aliasing to
   level 2 or higher. The anti-aliasing factor affects the motion blur
   calculations.

Note:
That Draft and Outline modes do not support motion blur.

4. Open the animation window and define its settings. Adjust the "Smpl."
   gadget (temporal sampling) to the value 1 instead of 0.

5. Render the animation.

You may have to increase the temporal sampling value and the anti-aliasing
factor (try 3 or 4) if a blurred object is moving very fast.

5.20 TROUBLESHOOTING

The following list shows some possible problem situations and how to
recover from them.

5.20.1 Not Enough Memory

The rendering engine of REAL 3D uses ram memory to speed up rendering.
This means that rendering of complex scenes uses all the memory available.
When multiple windows are ray-traced simultaneously (e.g. when rendering
an animation), some rendering tasks may run out of memory.

Suggestions:

1. Close other programs.

2. Close unused windows and screens in your REAL 3D environment. If you
   render an animation, leave only one screen with one View window open.

3. Check Render settings

- Try using simpler rendering mode, e.g Lampless instead of Normal.

- If you use mesh surfaces, check that B-spline->Phong gadget is not
  selected, or use lower Subdivision value.

                             - TUTORIAL 5.20 -

- Check Memory usage menu function. If your environment has been created
  in another workstation and fixed memory usage is specified, the
  rendering engine will make the wrong assumptions of the amount of total
  memory. Select "Relative" memory handling with 100% usage (sometimes
  lowering the memory percentage may help because the renderer may end up
  using low memory algorithms instead of fastest possible ones).

- Use a lower light sampling value if you are using line/wall light
  sources.

4. Simplify the model:

- Use B-Splines meshes instead of dense Phong shaded meshes.

- Use less dense meshes.

- Use quadric primitives instead of meshes.

- Use smaller texture maps files with materials

5. Do not use motion blur, or use lower "smpl" value.

6. Switch Undo feature off before rendering.

5.20.2 Disappearing objects

If an object, whose wireframe you can see, does not exist in shaded
images, check the following points:

1. Use Modify/Properties/Attributes to check the object attributes.
   Deselect the RT-invisible, Light-source and Mapping gadgets. Also,
   check the object attributes of parent objects.

2. Make sure that none of the objects outside Boolean operation levels has
   the "Inverted" attribute set. An inverted, finite object in the
   beginning of the hierarchy tree may fill the whole space and replace
   other objects with its volume.

3. If you are using transparent, overlapping objects, check the hierarchy
   order. For example, a planet inside a gas cloud should be ordered so
   that the planet is above the gas cloud in hierarchy.

4. Make sure that you are not using the "View/Render/Selected" option.

                             - TUTORIAL 5.21 -

Chapter 6 ANIMATION SYSTEM
--------------------------

In this chapter you will be acquainted with basic features of the
animation system of REAL 3D. The approach is very example oriented and
after a few pages, you will be able to create animations of swimming
fishes, walking robots, flying birds and so on.

This section is not meant to be a tutorial for freeform modelling or any
other object construction techniques, so all objects we will use are very
easy and fast to create.

The animation examples can be found from the software package. It might be
a good idea to take a look at them before you go any further, just to
verify that you know where to find them while following the tutorial. All
the scene files are included, so if you cannot create any of these
examples, you can compare your objects to those found from the "Examples/
Animation" directory and find out the reason for the failure.

Right, it is time to pop into the first example. Start REAL 3D with one
View and one Select window. Because we are going to render our animations
using only wireframes, use a four color screen (depth = 2) to keep window
refreshing rates high.

6.1 PATH

One common way to create animations is to move objects along a path. A
path can be a straight line, a smooth curve, an ellipse, a perfect circle
or whichever three dimensional path you might like to create. The method
called PATH is designed for that purpose and can be used for defining all
kinds of motions for objects.

6.1.1 Move Object along a Path

Let's create a simple logo text which moves along a path.

1. Create one level object called "Logo" by selecting the menu Create/
   Structure/Level and renaming it with the function Modify/Properties/
   Name.

2. Create four 3D characters under "Logo" level using the function Create/
   Visibles/Polyhedron.

3. Create one method object at the same level with "Logo" object: select
   the menu Create/Structure/Method, select PATH and click OK. Rename your
   object as "Mover" so you can easily recognize it later.

4. Create one closed curve (e.g. Controls/B-Spline Closed) under the
   method object. This curve defines the path for the logo.

   Your animation is now ready, as far as REAL 3D is concerned. In order
   to play it, select the menu Animate/Control/Play_Forwards and you will
   see how your 3D logo text follows the path.

Figure T6-1: 3D Logo Following a B-Spline Path.  (PICTURE: T6-1)

                             - TUTORIAL 6.1 -

Lets go through the terminology used in this example. Make sure you fully
understand the following description because we will use these terms
throughout this section.

- Objects to be animated are called "target" objects. They can be all
  kinds of objects like primitives, light sources, textures or perhaps
  other animated hierarchical objects.

- A "Method" object modifies "target" objects so that the result is an
  animation.

- The curve inside the method object is called a "parameter" object.
  Method objects use "parameter" objects to decide how to animate targets
  (in this case, what kind of path the logo text should follow). A
  parameter object can be any "evaluable" object like a polygonal line,
  circle or even a freeform mesh.

In other words, "method" objects modify "target" objects according to the
"parameters" of "methods".

6.1.2 Move Objects along a Path Like a Snake

In the previous example, all 3D characters were created inside one level
object called "Logo" so there was only one target object for "Mover".
If we created all characters at the same level with "Mover", the result
would be quite different. Lets try this:

1. Delete the current project with Project/Project/New and create four 3D
   characters under the root object.

2. Create PATH method object at the same hierarchy level with the
   characters.

3. Create a B-Spline curve under the method object so the curve passes
   through all the characters.

Figure T6-2: "Move along a Path like a Snake" Animation.  (PICTURE: T6-2)

Animate/Control/Play_Forwards the animation and the PATH method object
moves the target objects individually.

6.1.3 Bouncing Sphere

As you have probably already noticed, the PATH method can produce
accelerations and decelerations according to distances between subsequent
knot points of the parameter curve used longer the distance for defining
the motion. The between subsequent knots, the higher the speed and vice
versa.

This example shows one advantage of the Real's animation system: all
information needed for animating objects is a natural part of the object
itself. When duplicating an object (e.g. bouncing sphere), all animation
data will be duplicated as well, ie. the result will be two bouncing
spheres. Bouncing spheres (or any other animated objects) can be saved and
loaded back and they still continue "bouncing".

                             - TUTORIAL 6.2 -

To create a bouncing sphere:

1. Create one sphere to the top left edge of the window.

2. Now we define a motion for the sphere, as shown in the following
   picture. Select the function Animate/Create/Path and draw a B-Spline
   control polygon curve, which defines the motion for the sphere. By
   creating triple points, it is possible to define zero speeds;
   therefore, click the three first control points to the center point of
   the sphere so the speed of the sphere in the beginning will be zero.
   The deeper the sphere falls, the higher the speed ie. longer the
   distance between the control points should be. Finish the curve by
   <RMB> click.

3. REAL 3D creates a level under which it puts the sphere and the method
   with its parameter path. Rename the new level object as "Boing".

Figure T6-3: Bouncing Sphere. The higher the distance between the knots
             the higher the speed.  (PICTURE: T6-3)

4. Now your have created a bouncing sphere which consists of a actual
   sphere primitive and one PATH method. Play it and it bounces.

5. Animate/Control/Play_Backwards the animation.

6. Now, duplicate the "Boing" object, move it a bit and play the
   animation. The result is two bouncing spheres.

7. When you played the animation, both spheres started to move immediately
   and they reached the end points of their paths at the end of the
   animation. However , this can be changed by defining start and end
   times for methods. Select the method moving the first sphere, select
   Modify/Properties/Animation and activate Start and End gadgets. Change
   end time from its default (1) to 0.7. This means that the method starts
   to work immediately but stops when the time reaches 0.7. Do the same
   for the method of the second sphere, but now use values Start=0.4,
   End=1.0.

Play the animation and the spheres bounce.

6.1.4 Hierarchical Animations and Bouncing Sphere

In this example we will learn how to create hierarchical animations. In
other words, how to animate objects which are already animated.

Let's consider the following situation: a sphere bounces up and down by
following a circular path while another method moves the whole system
along another path.

1. Create one sphere and select the menu Animate/Create/Path. Define a
   nice path which moves the sphere only up and down. Use <BACKSPACE> key
   to close the curve. Then rename the level object "ellipsoid" to
   "UpDown".

                             - TUTORIAL 6.3 -

2. Select the method object (you find it under "UpDown") and redefine the
   Frequency of it to 10 using the Modify/Properties/Animation requester.

3. Animate/Control/Play_Forwards the animation; the sphere bounces up and
   down 10 times during the animation.

4. Select Animate/Control/Goto Beginning to reset the time back to zero.

5. Select the object "UpDown" and define a new horizontal motion for it
   using the function Animate/Create/Path.

Play the animation and the sphere bounces up and down while it follows
another path.

Figure T6-4: A hierarchical animation. An object moves along a path while
             they both follow another path.  (PICTURE: T6-4)

6.1.5 Move Elastic B-Spline Mesh along a Path

This example shows how a B-Spline can be subdivided using groups, and
how these groups can be animated so the mesh moves along a path; a bit
like a flying carpet.

1. Create a mesh using the function Create/Freeform/Mesh. The default
   size of 8x8 is fine.

2. Select the function View/Drawing_Set and set the C.Polyg gadget and
   deselect the Curve gadget. This allows you manipulate B-Spline mesh
   through its control polygon.

3. Make the mesh the current level by double clicking it on the Select
   window. Make sure it is still selected.

4. Subdivide the mesh horizontally to subgroups (create "columns", not
   "rows") by dragging while holding the <CTRL> and <SHIFT> keys.

5. Select the menu Create/Structure/Method, choose the PATH method and
   click OK, to create a path method to the same level with the groups.

6. Make the PATH method object the current level and create a path using
   the function Create/Control/B-Spline_Ctrlp. Close the path with
   <BACKSPACE> and end it with <RMB>.

Play the animation and your mesh will follow the path looking very
elastic.

Figure T6-5: Elastic Mesh Following a Path.  (PICTURE: T6-5)

                             - TUTORIAL 6.4 -

6.1.6 Talking Head

This example demonstrates how path and groups can be used for creating
animated freeform objects like talking heads. The idea is very simple:
a group refers to desired points of the head and follows a path.

1. Because a good 3D head would take some minutes to create, let's use
   just one B-Spline curve representing the profile of a face. That can
   be done in seconds. Make the curve the current level.

2. Select desired points by dragging and holding down the <SHIFT> key,
   or use the Extras/Vectors/Lasso function.

3. Create a group object by selecting the menu Create/Structure/Group.

4. Select the menu Animate/Create/Path and define a motion for the mouth.

Play the animation and your head talks.

Figure T6-6: Freeform Morphing Implemented by Moving a Group along
             a Path.  (PICTURE: T6-6)

6.1.7 Moving Objects along a B-Spline Mesh

The idea of using B-Spline meshes for defining motions for objects is
simple and obvious: you don't have to define separate motion for an object
in order to make it climb over a mountain. Instead, the mountain itself
can be used for that purpose.

1. Create three spheres to be moved along a mesh.

2. Create a PATH method object at the same level with spheres by selecting
   the menu Create/Structure/Method.

3. Create a B-Spline mesh inside the method object by selecting the menu
   Create/Freeform/Mesh.

4. Play the animation and your spheres will move along the mesh. Note that
   it can take some time before spheres start to move. Be patient, next
   play starts immediately once all necessary data is defined.

You can modify the mesh freely and the spheres will still move along it.
Make it look like a mountain and your spheres will climb over it.

Figure T6-7: Move Objects along a Mesh.  (PICTURE: T6-7)

6.1.8 Customized Paths

The PATH method requires one parameter which is simply used for defining
how target objects should be moved. The type of the parameter can be any
"evaluable" primitive like a circle, a polygonal line, a B-Spline curve or
even a mesh. Almost all kind of motions can be defined using these paths.
Furthermore, motions can be accumulated by creating hierarchical
animations as we did in the example 6.1.4 "Hierarchical Animations and
Bouncing Sphere".

Before we get into the point, remember that the following description
shows you how you can create new "evaluable" primitives. In other words,
you can use them with all methods, not only with PATH.

For this example, you have to create one sphere and animate it using the
function Animate/Create/Path. We will use the B-Spline curve to define a
path for the sphere, and a formula to fine-tune the path so the sphere
vibrates while it moves along the path.

1. Select the B-Spline curve and select the menu Modify/Properties/Tags.
   Add the following TAG to the curve:

   SFOR x+=0.2*sin(t*20*PI), y+=0.2*cos(t*20*PI)

2. Play the animation and sphere vibrates while it moves along the curve.

The variable "t" is a time, and "x", "y" and "z" define points in the
curve corresponding the time. See the reference section for full
description of variables for evaluable parameters.

Now you can save this customized curve and whenever you need this kind of
vibrating curve, just load it in.

If formulas cannot be used for solving your problem, you can write a RPL
function where you can use conditional expressions like IF ELSE ENDIF,
loops like DO LOOP, variables, etc. to define desired motions for your
objects. Lets consider the following situation: a sphere follows a
B-Spline path and when animation reaches the middle point, the sphere
starts to vibrate. In order to do this, you have to create a RPL program
which uses IF ENDIF structure:

1. Start you favorite text editor, write the following RPL program and
   save it as "vibrapath.rpl":

     : VibratePath
      t F@ 0.5 F> (if t > 0.5)
      IF
        "x+=0.2*sin(t*20*PI), y+=0.2*cos(t*20*PI)"
      EVAL DROP
   ENDIF
   ;

2. Create another sphere following another path and attach the following
   tag to the B-Spline curve:

   SRPL VibratePath

3. Execute your RPL program by selecting the menu Project/Macros/Execute
   Named and by selecting the file "vibrapath.rpl".

Play the animation and the sphere starts to vibrate as soon as the time
reaches the value 0.5.

It is about time to leave PATH method now (there is still 23 other methods
to go through). Examples we have gone th rough so far should give you some
ideas about how to solve all possible and impossible "move along"
problems.

                             - TUTORIAL 6.6 -

6.2 ROTATION

Where PATH method can be used for moving objects along parameter objects,
ROTATION method allows you to rotate objects around parameters. As a
default, target objects are rotated one revolution with a constant speed.

Use Perspective projection in the following examples so it easier to see
how objects are rotated.

6.2. 1 Rotating Objects Around an Axis

1. Create a Cube

2. Create a ROTATION method: select the menu Create/Structure/Method,
   choose ROTATION from the method list and press OK.

3. Create an axis inside the method object by selecting the menu Create/
   Controls/Axis.

Play the animation and your cube will rotate around the axis.

Figure T6-8: A Cube Rotates around an Axis with a Constant Spegd.
             (PICTURE: T6-8)

The only non-obvious thing here is the direction of the rotation. It is
defined using so called Right Hand Rule: if the thumb of your right hand
points along the axis, your fingers show the direction of rotation. In
other words, if you change the direction of the axis by mirroring it,
the rotation direction will be reversed, too.

6.2.2 Rotating with Different Speeds and Directions

In this example, we are going to create several objects rotating with
different speeds and directions.

1. Create one cube, one polyhedron and one pyramid

2. Select the cube and the menu Animate/Create/Rotation. This function
   allows you to define rotations by defining a "coordsys" primitive.
   Play the animation and you cube will be rotated around the "x" axis of
   the coordsys primitive. Then select Animate/Control/Goto Beginning.

Figure T6-9: Modifying Rotation Attributes.  (PICTURE: T6-9)

                             - TUTORIAL 6.7 -

3. Select the method object which makes your cube to rotate and select the
   menu Modify/Properties/Animation. Activate Start, End and Frequency
   gadgets and define following values for them:

     Start     = 0.0
     End       = 0.3
     Frequency = 0.33

This makes your cube to rotate only one third of the full cycle during the
time interval 0 ... 0.3. Then it will stop.

4. Now select the polyhedron and apply Animate/Create/Rotation to it.
   Then select the new method and define following values for Start,
   End and Frequency.

     Start     = 0.3
     End       = 0.6
     Frequency = 0.5

This will freeze the polyhedron until the time reaches the value 0.3.
Then the polyhedron rotates 180 degrees and stops when the time reaches
the value 0.6.

5. Select the pyramid, apply the function Animate/Create/Rotate to it
   and define following values for its ROTATION method:

     Start     = 0.6
     End       = 1.0
     Frequency = -1

This will make the pyramid rotate -360 degrees when the time reaches
the value 0.6.

Play the animation and see how the objects perform their rotations one
after another.

6.2.3 Hierarchical Rotations

Rotations can be hierarchically nested just like paths can.

1. Create a rectangle

2. Make it rotate around its left edge by selecting the menu Animate/
   Create/Rotation.

3. Select the function Modify/Structure/Copy; this copies the rotating
   rectangle to the clip buffer.Then make the level containing the
   original rectangle and the rotation method the current level.

4. Paste the rotating rectangle from the clip buffer using Modify/
   Structure/Paste. Move the pasted copy to the left a bit and make it
   the current level.

5. Paste and move once more and play your animation. It will behave very
   nicely.

Figure T6-10: Hierarchically Animated Rectangles.  (PICTURE: T6-10)

                             - TUTORIAL 6.8 -

6.2.4 Tornado

Before trying the following example, select the menu View/Drawing Set and
switch off the Curve gadget and turn on the C.Polyg gadget. This allows
you to handle your B-Spline mesh through control polygon and speeds up
screen refreshing.

1. Create a B-Spline tornado (do it by rotating a profile curve around
   an axis using the function Create/Freeform/Rotate).

2. Make the tornado mesh the current level and subdivide it vertically
   to subgroups using the functions Vector/Lasso and Create/Structure/
   Group. Create one group for each horizontal isoparametric curve of
   the mesh.

Figure T6-11: Tornado Mesh Subdivided to sub-groups.  (PICTURE: T6-11)

3. Switch the orientation of the view window so you can see the tornado
   from the top and apply Animate/Create/Rotate to all groups so that
   they will rotate around their center points.

4. Now define different speeds for different levels of the tornado (the
   upmost circle should rotate once, the second circle twice etc.). As
   you can remember, this can be accomplished just by modifying the
   frequency of methods.

5. Change the orientation of the View window so that you can see the
   tornado from the side. Open the View/Drawing Set requester, turn on
   the Curve drawing, turn off the Ctrl Polyg. drawing and set Surface
   Subdivision to 5. Then play your animation. Wow, just like a tornado!

6.3 SWEEP

Sweep method is designed for rotating objects with arbitrary accelerations
and decelerations. Actually, the sweep is one of the most powerful tools
when creating "character animations", such as walking human beings and
robots.

The sweep method requires two parameters: the first one defining a center
point for the rotation and the second one defining how the object is
rotated. Rotation is executed exactly the same way as when the user
rotates objects using the mouse and the function Modify/Linear/Rotate.
Thus the first parameter is usually just an offset primitive, and the
second some kind of curve defining a route for some point of the object.
The method tries to move that point along the defined path while keeping
the point defined by the first parameter fixed, making the object rotate.

6.3.1 Walking Legs

1. Draw a thigh-bone profile using a B-spline curve.

2. Select the function Animate/Create/Sweep and define the center point
   for rotation. Because your thigh-bone usually rotates about hip-bone,
   click <LMB> over the upper end of the bone.

3. Draw a closed path for the knee (lower end of the thigh-bone); use
   <BACKSPACE> and <RMB> to close and end the path definition.

                             - TUTORIAL 6.9 -

4. Make the new level created by the Sweep function the current level
   and create the shin-bone at the same hierarchy level with the
   thigh-bone.

5. Apply the function Animate/Create/Sweep to the shin-bone so the shin-
   bone will be rotated about the knee-cap.

Figure T6-12: Structure of a Leg.  (PICTURE: T6-12)

The upper end of the thigh-bone is fixed to the hip while the knee
follows a B-Spline curve. The upper end of the shin-bone is fixed to the
knee while a route for the ankle is defined by a B-Spline. Because of
hierarchical construction, the parameters used for rotating shin-bone are
rotated with the thigh-bone.

Play the animation and your leg should behave a bit like a real leg.
However, in order to make it work perfectly, we have to analyze how a real
leg works.

The first observation is that the shin-bone and the thigh-bone comprise a
straight line until the leg starts to return back from its back position.
In other words, our shin-bone should not be rotated until the time reaches
the value 0.5. So, define the Start time value of the hip-bone sweep
method to that value, set the End time value to 1.0 and play the
animation. Now the shin-bone should not be rotated until the leg starts
to rotate back to its starting position. How to create another leg?

1. Duplicate the leg. Now you have two equally functioning legs.

2. Select the method rotating the thigh-bone of the duplicated leg and
   define the Phase = 0.5 using the function Modify/Properties/Animation.

Play the animation and ... you have walking legs.

6.3.2 Tracking Guns

In this example, we will show you how to use "Links" to use same objects
to define motions for different methods. Any parameter object of a method
can be replaced by a link object which points to the actual parameter.
The parameter can be everywhere in the object hierarchy and more than one
link can point to it.

Lets consider the following situation: a sphere follows a path and no
matter where it goes, gun always points towards it. To do this:

1. Create a sphere and define a path for it using Animate/Create/Path.

2. Create a level object and name it as "Gun", at the same level with the
   moving sphere object. Make it the current level.

3. Create a gun object under the level, pointing to the sphere.

4. Select Create/Structure/Method and create a SWEEP method. Create it at
   the same level where the gun shape is; the purpose is to animate the
   gun. Make the method level the current level.

5. Define a center of rotation for the gun by creating an offset primitive
   under the method level; this is the first sweep parameter.

                             - TUTORIAL 6.10 -

6. Select the B-Spline curve used for defining a motion for the sphere and
   select the function Create/Structure/Link. Select the "link" and
   Modify/Structure/Cut it. Then make the gun sweep method the current
   level and Modify/Structure/Paste the link under the method. The link
   will act as the second sweep parameter.

Play the animation, and your gun is rotated so it always points to the
sphere.

Create another gun by duplicating the original gun (the whole sweeping
gun), move it to another place and rotate it so it still points to the
sphere, and when you play the animation, both guns follow the sphere.

Figure T6-13: Four Guns Pointing to a Sphere.  (PICTURE: T6-13)

The rotations for all guns as well as the motion for the sphere are all
defined by the same curve.

Now, modify the sphere path using Modify/Freeform/Move Knotpoint function
and play the animation. All guns have automatically changed their behavior
so they still keep pointing to the sphere!

6.4 SIZE

The size method can be used for sizing objects during animations. It takes
two parameters: the first one (usually the offset primitive) is used for
defining the center point of sizing and the second (usually some sort of
curve) defines how target objects are sized about the center point.

Whenever you have to change the size of an object in your animation, this
method can be used for that purpose.

6.4.1 Beating Spheres

1. Create a sphere

2. Select the menu Animate/Create/Size and click the mouse once over the
   center point of the sphere. Then define a long, arbitrary curve which
   starts from the surface of the sphere. To create a cyclic animation,
   close the path with <BACKSPACE> key.

Play the animation and your sphere "beats".

Figure T6-14: A Beating Sphere  (PICTURE: T6-14)

                             - TUTORIAL 6.11 -

Just to raise our enthusiasm a bit, let's create some more beating
spheres:

1. Create ten beating spheres by duplicating and moving the copies so the
   spheres form a circular path (use a duplicate+rotate macro, if you
   have mastered macros).

2. Change the Phase (Modify/Properties/Animation) of each size method so
   the phase of the first method is 0, the second is 0.1 etc.

Play the animation and you have ten nicely beating spheres, producing a
kind of wave effect.

6.4.2 Bubbles

Let's create an animation, where a bubble gets bigger and bigger until it
becomes unfastened and starts to move up, like a steam bubble in a
boiling water.

1. Create a sphere representing a bubble near the bottom edge of the
   View window.

2. Select the function Animate/Create/Size while the sphere is selected
   and click the mouse in the point where the sphere is fastened (to a
   hypothetical pot).

3. Draw an open path defining a growing size for the bubble; remember to
   start the path from the surface of the sphere. As usual, REAL 3D
   creates a level an puts the sphere and the new method under it.

4. Find the size method under the new level, select the method and set
   Start time to 0 and End time to 0.5 using the function Modify/
   Properties/Animation. This prevents the bubble from growing after the
   animation has reached its middle point.

5. Select the whole growing bubble level and define a path for it as
   shown in the picture below.

6. Select the path method object created by the previous action, select
   the function Modify/Properties/Animation and change Start time to 0.5
   so the method starts to move the bubble as soon as the bubble has
   become big enough.

Figure T6-15: Bubble gets bigger and bigger until it is starts to move
              up.  (PICTURE: T6-15)

6.5 STRETCH

This method can be used for stretching objects in three directions
separately.

Stretch method requires two parameters: a coordsys primitive which defines
the three directions for stretching, and one curve which defines how the
object is stretched.

6.5.1 Elastic Cube

This example is the simplest possible. One cube is stretched in three
dimensions by using B-Spline curve.

1. Create one cube

2. Select the menu Create/Structure/Method and Create a stretch method.

                             - TUTORIAL 6.12 -

3. Create a coordsys primitive under the method level so its origin
   matches one corner of the cube and the axes match three edges of the
   cube.

4. Create a B-Spline curve under the method so it begins from the corner
   of the cube opposite to the corner where the origin of the coordsys is.

Note:
That you can draw a three dimensional curve by swapping the orientation
of your View window while outlining the curve.

Figure T6-16: Elastic Cube  (PICTURE: T6-16)

Play the animation. One corner of the cube follows the curve while another
corner is fixed to the origin of the coordsys.

6.5.2 Bouncing Elastic Sphere

We have already created one bouncing sphere. However, it did not act like
an elastic sphere. We can use the stretch method to add the elasticity
effect to sphere bouncing:

1. Create a sphere near the top left edge of the window.

2. Select the menu Animate/Create/Stretch and create a closed curve which
   stretches the sphere nicely.

3. Select the stretch method and modify its start/end times so stretching
   starts when the time reaches the value 0.4 and stops when the time
   reaches 0.6.

4. Select the level which contains both the sphere and the stretch method
   and apply Animate/Create/Path function to it. Define a path similar to
   one we defined in our earlier bouncing sphere example.

Figure T6-17: A Bouncing Sphere with Collision Deformation.
              (PICTURE: T6-17)

Play the animation and the sphere starts to fall until it hits the floor
at the time of 0.4 and rebounds back nicely.

6.6 DIRECTION

Welcome to the world of swimming fishes and wriggling snakes! The
DIRECTION method works like the path method, except that it also rotates
target objects so that their orientation changes according to the
curvature of the parameter path.

                             - TUTORIAL 6.13 -


6.6.1 Move a Logo Text along a Direction Path

In order to make the difference clear to the path method, we will create
exactly the same object as we did in the example 6.1.2 "Move objects
along a path like a snake", except that now we use the direction method.

1. Create some 3D characters.

2. Create a DIRECTION method to the same hierarchy level with the
   characters.

3. Create a closed B-Spline curve under the direction method level (see
   the figure below).

Play the animation and all the characters move along the path while they
are rotated according to the curvature of the path.

Figure T6-18: Logo Text Following a Directed Path.  (PICTURE: T6-18)

It is this rotation feature which makes this method very valuable when
animating freeform objects.

6.6.2 Swimming Fish 

Let's create a fish:

1. Create a freeform fish (or a snake or any other creature whose length
   it greater than its thickness).

2. Make the fish the current level and subdivide it to groups from the
   tail to the head.

3. Create a DIRECTION method to the same level with the groups.

4. Create a closed B-Spline path representing the route the fish swims,
   at the same level with the fish primitive (one level upwards from the
   groups).

5. Select the B-Spline curve representing the path for the fish, select
   the menu Create/Structure/Link and Cut and Paste it under the method
   object.

Play the animation to make the fish swim along the path.

Figure T6-19: Swimming B-Spline Fish  (PICTURE: T6-19)

Note:
That a curved path makes your fish swim like a fish. If the curve contains
no small bends, your creature acts like a slug: it does not wriggle. It
may take some time to fully learn to know the nature of this method, but
the results are worth the effort!

                             - TUTORIAL 6.14 -

6.7 MOVE & DIR

As you probably have already realized, the direction method is a very
powerful way to create many kinds of nice animations. However, there are
situations where you have to control the direction of the object
independently from the motion; that is not possible with the direction
method, because it uses the same curve to define both the direction and
the motion. MOVE & DIR method is designed for these situations.

The move & dir method uses two parameters: the first one defines a motion
for target objects just as the path method parameter does, and the second
parameter defines the direction for the targets just as the direction
method parameter does. This means that if both parameter curves are equal,
the method will work exactly the same way as the direction method does and
if the parameter defining the direction is a straight line, the method
works similar to the path method (because the direction of the object
remains constant).

6.7.1 Rocking Logo Moving along a straight Line

In this example we will create a logo which consists of characters. Each
character follows a perfectly straight path (an axis). A B-Spline curve
is used for defining the direction information so that the logo will move
very nicely.

1. Create four small 3D characters as shown in the picture below.

2. Create a MOVE & DIR method to the same level with the characters.

3. Use Create/Controls/Axis to create a Straight line under the method
   level, so it passes through the characters.

4. Create a B-Spline curve under the method level. In the beginning, the
   curve should follow the axis accurately but then starts to oscillate.

Figure T6-20: Rocking Logo Following a Straight Line.  (PICTURE: T6-20)

Play the animation, and if you are not happy with the way the characters
are rotated while they follow the straight line, just modify the second
curve. If you don't like the straight line, use any other curve type or
even a mesh (just like we did in the "Move Along a Mesh" example).

Note that you can use the second curve to define rotations in all three
dimensions! The direction curve does not have to be planar as it was in
this example. Naturally, the curve can define rotations which are
perpendicular to the motion direction (rocking boat...).

6.7.2 The Rally Driver

In this example we will show you how "Move & Dir" method can be used for
creating "driving car like crazy" effects.

1. Create a car

2. Create a MOVE & DIR method object to the same hierarchy level.

                             - TUTORIAL 6.15 -

3. Create a B-Spline curve representing the road under the method level.

4. Duplicate the "road" curve. If you now played the animation, the result
   would be just "driving car like a reasonable person".

5. Modify the second curve so the car starts to behave more aggressively
   as shown in the following picture.

Figure T6-21: "Driving like crazy".  (PICTURE: T6-21)

The first curve represents the road and another curve the direction of the
car in the corresponding road positions.

Note that without showing knotpoints it is difficult to solve which points
of the motion and the direction curves correspond to each other, because
the speed of the object is defined by the distance of the knots.

6.8 CONTROL CURVES

This method can be used for defining paths for objects by using two
curves. Target objects are moved, rotated, and stretched according to the
curves.

This method is very suitable for defining motions for cameras, aeroplanes,
etc. where accurate control over banking angle is needed. Just as in the
PATH, DIRECTION and MOVE & DIR methods, the distance between knot points
determines the speed of target objects.

Naturally, control curves can be any evaluable objects, like circles,
ellipses or just straight lines. The ability to define whether or not the
second control curve should be used also for scaling target objects make
the number of possible applications for this method huge.

6.8. 1 Beating and Moving Slime Ball

In this example, we will create a simplest possible example demonstrating
control curves: one object moving between control curves. The distance
between control curves varies causing object to pulsate like a "slime
ball".

1. Create a sphere representing a slime ball.

2. Create a CONTROL CURVE method object at the same level.

3. Create two closed B-Spline curves by drawing one, duplicating it, and
   modifying the duplicated curve so the distance between the curves
   varies. Then Animation/Control/Play Forwards the animation, and after
   that, select Animation/Control/Goto Beginning.

Figure T6-22: A Slime Ball Stretched and Moved by Control Curves.
              (PICTURE: T6-22)

                             - TUTORIAL 6.16 -

Now, lets create more slime balls. This is exactly what you should do:

1. Create two new spheres to different positions and make sure they fit
   perfectly between the control curves (see the figure above).

2. Select the method object. Select the menu Modify/Properties/Tag, click
   the "ISKE" tag string (one should exist after playing the animation)
   and click DEL button to delete the tag; then select OK. This asks Real
   to define "VPHS" tags automatically when you play the animation next
   time.

Play the animation and you have three elastic slime balls.

6.8.2 Elastic Flying Carpet

In this example we will show you how to create freeform mesh, which moves
along control curves like an elastic rubber carpet (if you have not seen
rubber carpets before, don't worry. I'm sure there are such things as
rubber carpets). We also demonstrate the use of links just to make sure
that you get familiar with them.

1. Create a mesh using the function Create/Freeform/Mesh.

2. Make the mesh the current level by double-clicking it on the Select
   window; as usual, we will put sub-groups under the freeform level
   itself.

3. Subdivide the mesh horizontally to groups, so each group consists of
   a column of control points. Note that you have to turn Drawing Set/C.
   Polyg. representation on (deselect "Curve" gadget at the same time)
   in order to get access to the control points of the mesh.

4. Create a CONTROL CURVES method object.

5. Create two control curves to the same level with the the mesh.

6. Create two links pointing to the control curves (multi-select the
   control curves and use the menu Create/Structure/Link).

7. Modify/Structure/Cut the links, make the CONTROL CURVES method the
   current level and Modify/Structure/Paste the links back.

Figure T6-23: Flying Elastic Carpet.  (PICTURE: T6-23)

Now, use the function View/Drawing_Set to switch the "Curve"
representation on and "C. Polyg." off and play the animation. The carpet
should fly very nicely.

6.8.3 Flying Viewpoint

In this example, we will show you how to define motions for objects
without stretching them. For example, when creating motions for view-
points, aeroplanes etc., the possibility to fully control banking is a
valuable feature. This example also demonstrates how to use viewpoint and
aimpoint primitives to define the orientation for the camera.

1. Create one cube in the middle of the View window so that we have
   something to watch in the animation.

                             - TUTORIAL 6.17 -

2. Select the perspective projection (View/Type/Perspective) and find a
   good viewing angle by using the cursor keys.

3. Create aimpoint and viewpoint primitives by selecting the menu View/
   Create Camera. REAL 3D creates the camera representing the current
   orientation of the View window. The camera object consist of two sub-
   objects: an aimpoint and a viewpoint. We are going to animate only the
   viewpoint, so delete the aimpoint primitive. This makes the camera
   always point to the origin point of the space.

4. Create a CONTROL CURVES method at the same level with the viewpoint
   (Under the "camera" object).

5. Create two control curves under the method so that they show the route
   for both "eyes" of the viewpoint.

6. Select the method object and add the following tag to it:

     FOR I=1

which tells to the method not to use stretching (for full description of
"I" variable, see the reference section).

7. Activate the View/Observer/Camera View function. You may also use
   Modify/Properties/Attributes/WF-Invisible to make the camera wireframe
   invisible during the animation play.

Play the animation and the eyes of the viewpoint will follow the control
curves. However, because the aimpoint does not exist, the camera is aiming
at the origin (at the cube) all the time.

Figure T6-24: Motion for a Viewpoint Defined by Two Control Curves.
              (PICTURE: T6-24)

Note:
That there are easier ways to create camera flight animations (for example
key framing), but the ability to control banking accurately may sometimes
make this method more suitable.

Lets enter the following section, which leads us into the world of
Character Animations.

6.9 SIMPLE SKELETON

The idea behind skeletons is quite straight forward: a skeleton is a
simple object which is somehow connected to more complex object(s).
When the skeleton is modified, the target object is modified accordingly.
The fact that it is much easier to modify these skeletons than actual
(often very complex) target objects, makes the skeletons a very powerful
animation tool.

REAL 3D contains two skeleton types which differ from each other in the
way they manipulate target objects to make them match the skeleton object.
So, lets first create a SIMPLE SKELETON example and then have a look how
it works.

                             - TUTORIAL 6.18 -

6.9.1 A SIMPLE SKELETON and a Logo Text

In this example, we will create a logo text and a skeleton which works as
an elastic baseline for the text.

1. Create four 3D characters.

2. Create a SIMPLE SKELETON method to the same level with the characters.

3. Create a B-Spline curve (a skeleton curve) under the method level. The
   curve should match roughly the baseline of the text.

4. Select the menu Animate/Control/Refresh.

Our first skeleton object example is now complete. When you selected the
menu Animate/Control/Refresh, REAL 3D calculated all information needed to
keep target objects on the skeleton from now on. So, lets try to modify
the skeleton curve in order to test how the skeleton works.

5. Select the skeleton curve and move it. Now the skeleton is dislocated
   from its targets. Select the menu Animate/Control/Refresh and you logo
   text is pulled to the skeleton.

6. Modify/Linear/Stretch the skeleton curve and Animate/Control/Refresh.
   The distance between the characters is stretched, too.

7. Bend the skeleton curve, refresh the animation system and your logo is
   bent, too.

Figure T6-25: An Object after Bending the Skeleton.  (PICTURE: T6-25)

As you noticed, the SIMPLE SKELETON method does not rotate or stretch
target objects in any way. They are just moved back to their original
positions on the skeleton. In other words, the SIMPLE SKELETON uses only
"move" transformation to manipulate its targets. This makes this
skeleton type suitable for animating objects whose direction should not
be changed during the animation.

Another observation was that the SIMPLE SKELETON requires one parameter
which describes the shape of the skeleton. This parameter can be any
evaluable object like a polygonal line, a B-Spline curve, a circle, a
point or even a freeform mesh. Furthermore, it is even possible to create
customized skeletons by creating a new evaluable object, just like we did
in the PATH example 6.1.8 "Customized Paths".

The SIMPLE SKELETON method pulls all target objects to the skeleton, so
that the COG of the target object in question is pulled to the skeleton,
and the position on the skeleton is defined by the VPHS tag associated
with the target. For example, if the VPHS value for a target object is 0,
then the object is pulled to the beginning point of the skeleton curve.
If VPHS is 1.0, then the target is pulled to the end point of the
skeleton. The value 0.5 pulls the target to the middle point of the
skeleton. These values are

                             - TUTORIAL 6.19 -

called "parameter values" of the parameter object. The skeleton object
also redefines the COG for target objects so that it lies exactly on the
skeleton curve.

When you selected the menu Animate/Control/Refresh the first time, the
method automatically defined these tags for each target object by finding
the parameter value of the skeleton curve where the distance between
curve and target object was shortest. This was done only once. The method
created and associated the "ISKE" tag with itself to indicate that all
necessary tags are now updated and need not be refreshed any more.

This is the whole theory behind the simple skeleton. As you have already
noticed, you don't have to know anything about these tags as long as you
are not going to define positions for target objects manually. Just create
all necessary objects and let REAL 3D do the rest.

Lets play with this example a bit more. Select any of the target objects
and move it apart from the skeleton. Refresh the animation system and the
object is pulled back to the skeleton!

Now, suppose that the first target object was positioned improperly and
you have to change it to a different position in the skeleton. How to move
targets so that the skeleton method will not pull them back to their
original positions? The answer is: just delete the tag ISKE associated
with the method object (or set its value to zero), move target objects to
the desired positions and refresh the animation system.

So far, we have actually only tested how the skeletonally controlled
objects can be manipulated interactively. Now it is time to create our
first skeleton animation.

6.9.2 Rotate a Simple Skeleton around an Axis

Because skeleton objects are just ordinary objects, they can be animated
just like any other objects. So, lets create such an animation:

1. Create simple logo text consisting of some characters.

2. Create a SIMPLE SKELETON method to the same hierarchy level.

3. Create a B-Spline curve, passing through the logo characters, under the
   method.

4. Create a ROTATION method to the same level with the skeleton so that
   the skeleton curve is target for it.

5. Create an axis primitive under the path method to define the rotation
   axis.

Figure T6-26: A B-Spline curve rotating around an axis while skeletonal
              control keeps the logo characters attached to the curve.
              (PICTURE: T6-26)

Play the animation. The ROTATION method moves the skeleton, while the
skeleton method keeps the target objects on its parameter curve.

                             - TUTORIAL 6.20 -

6.9.3 Elastic Skeleton and Logo Text

In this example we are going to add some elasticity to skeletons by moving
points using groups.

1. Create a logo consisting of four characters.

2. Create a SIMPLE SKELETON method to the same level with the characters.

3. Create a skeleton curve (B-Spline) under the method.

4. Make the skeleton curve the current level and create a point group
   object, consisting of some points of the skeleton.

5. Create a PATH method object to the same level with the group.

6. Define a motion for the group by creating a B-Spline curve under the
   path method.

Figure T6-27: A Skeleton Modified by a Group.  (PICTURE: T6-27)

6.9.4 Moving Objects along a Skeleton

As you already know, the VPHS tag associated to a target object defines
where the target lies on the skeleton . However , it is possible to define
this value dynamically using the tag SFOR. This means you can change the
position of the target during the animation just by writing the formula
which refers to the time!

So, let's test this by creating "Move along a Path" animation based on the
skeleton method.

1. Create a sphere (a target object).

2. Create a SIMPLE SKELETON method object at the same level.

3. Create a B-Spline curve under the method object.

4. Selecting the sphere, then select the menu Modify/Properties/Tags.
   Click ADD gadget and then enter the following tag string: SFOR x=t
   Hit return and select OK.

Play the animation and your target object will move along the skeleton,
because its position on the skeleton is directly defined by the time.

Figure T6-28: A Sphere Moving along a Skeleton.  (PICTURE: T6-28)

                             - TUTORIAL 6.21 -

Well, we could do this simply by using a PATH method, too. However, there
is a big difference between these two implementations. The PATH defines
relative motion for targets whereas SKELETON defines absolute position.
This means that you can move the curve used with the PATH method without
changing the motion of the targets (because it still defines equal
relative motion), but if you move the skeleton curve, targets follow a
different route because they are always pulled back to to the skeleton.

So, lets analyze what made the sphere actually move along the skeleton.
The formula "x=t" assigned the current time to the variable "x". The
skeleton method uses this variable to redefine the value of VPHS tag.
Actually, the parameter space is three dimensional and also variables
"y" and "z" are defined, but because we used a B-Spline curve, only the
first dimension is relevant. A bit later we will show you how to use
freeform meshes as skeletons, and then we need two dimensions (variables
x and y) to define a position for the target (for full description of
variables and methods, see the Reference section).

All right, lets practice a bit more, by creating a formula which is bit
more complex and produces a more interesting motion.

6.9.5 Rocking Spheres

The following example demonstrates how to create accelerations by using
"cos()" function in a formula.

1. Create two spheres, one white and one black.

2. Add the following tags to the spheres:

   White sphere: SFOR x=t*0.5+(t)*(0.5+0.5*cos(8*PI*t))
   Black sphere: SFOR x=t*0.5+(1-t)*(0.50.5*cos(6*PI*t))

3. Create a SIMPLE SKELETON method to the same level with the spheres.

4. Create a B-Spline curve under the method level as shown in the picture
   below.

Figure T6-29: Spheres Rocking along a Skeleton Curve.  (PICTURE: T6-29)

Play the animation and the spheres will behave in a very natural way.

Lets analyze the formulas we attached to the target objects. The time (t)
goes from 0 to 1 in our example when the animation is played. Thus, in
the beginning, the first part of the formula, "t*0.5", has no effect at
all. When the animation proceeds, the term "t*0.5" approaches 0.5.
On the other hand, the rest of the formula "(1-t)*(0.5+0.5*cos(8*PI*t))"
gets weaker and weaker because "(1-t)" approaches 0. So, in the beginning,
the function "cos()" causes the sphere to roll up and down in its full
power but in the end, it does not affect the position of the sphere at
all.

If math is not one of your strong points, don't worry, there will be lot
of nice ready-made formulas available very soon!

                             - TUTORIAL 6.22 -

6.9.6 A Hydrogen Atom and its Electron Orbit

When creating atom simulations, it is necessary to understand the theory
involved. If you don't know that theory, don't worry, this example can
still give you some ideas.

Some theory first. A hydrogen atom consists of one proton and one
electron. The way how an electron "rotates" around the proton can be
described by using a formula which is well known by scientists. Nobody
knows where the atom is at a certain time value, but a formula can be
used for calculating probability for that. There are only a few possible
states the electron can represent.

So, lets try to implement this.

1. First we need an electron. I don't know what a real electron looks
   like, but I assume it looks a bit like a sphere. So, create a sphere.

2. Then we have to define the formula describing the so called probability
   distribution for the sphere. For simplicity, we use just a random value
   for that. The variable "rnd" can be used for that purpose. Therefore,
   select the sphere, select the menu Modify/Properties/Tags and add the
   following tag to it:

   SFOR x=rnd

This generates random values between 0 and 1.

3. Create a SIMPLE SKELETON method to the same level with the electron.

4. Then we need a new evaluable primitive which represents possible states
   of the electron. For hydrogen (if I remember correctly) it is a sphere
   whose radius represents these possible states of electron. However, let
   us use a circle, whose mathematical formula is very similar to the
   formula of the sphere, but is shorter and faster to write. The
   mathematical formula defining a circle is:

   x = r*sin(2*PI*t)
   y = r*cos(2*PI*t)

where "r" is radius of the circle and "t" is the parametrization of it.
When t goes from 0 to 1, x and y coordinates define a perfect circle.

Use Create/Controls/Offset to create an offset primitive under the method,
representing the center point of the circle. Assuming that the radius
remains the same during the animation, say 0.5, add the following tag to
the offset:

   SFOR x+=0.5*sin(2*PI*t),y+=0.5*cos(2*PI*t)

This way, we can manipulate the offset so that instead of a single point,
the result is an orbit for the electron (in this case, a circle).

The animation is now ready. When you play it, the time goes from 0 to 1
and the formula attached to the electron object returns random parameter
values. The skeleton method object uses these values to evaluate a point
from its parameter, describing possible positions for the electron, and
then moves the electron to that point.

                             - TUTORIAL 6.23 -

6.10 SKELETON

The SKELETON method is somewhat similar to the SIMPLE SKELETON; it pulls
the target objects to its skeleton parameter. However, SKELETON can also
rotate objects, so that their directions match the curvature of the
skeleton, thus opening new possibilities for exciting new animation
effects.

Because of this rotation feature, the SKELETON method requires two
parameters instead of one. They are called as "primary" and "secondary"
skeletons. The primary skeleton defines the actual direction and position
for target objects, while the second skeleton is used for defining how
target objects are oriented around the primary skeleton (the "torsion").
For example, if the secondary skeleton object is just a static object
defining a fixed direction, the targets are just bent according to the
primary skeleton. If the secondary skeleton is animated so that the
direction it defines changes during the animation, target objects are
rotated around the primary skeleton accordingly.

6.10.1 Another Logo Text Animation

Lets re-create the logo text animation of the example 6.8.3 "Elastic
Skeleton and Logo Text", but now using general skeleton. This example
demonstrates the difference between the two methods well.

1. Create a logo text

2. Create a SKELETON method to the same level with the characters, using
   Create/Structure/Method.

3. Create a B-Spline curve under the method. for example using Create/
   Controls/ B-Spline Ctrlp, so that the curve passes through all the
   target characters.

4. Make the B-Spline skeleton curve the current level and create a group
   referring to some points of the curve.

5. Apply Animate/Create/Path to the group.

6. Create the second parameter for the skeleton method, to the same level
   with the primary skeleton curve. Note that the direction of the
   secondary skeleton should be somewhat perpendicular to the primary
   skeleton. You can use an axis primitive (Create/Controls/Axis).

Figure T6-30: Logo Text Controlled by the General SKELETON Method.
              (PICTURE: T6-30)

Play the animation and compare it to the corresponding SIMPLE SKELETON
animation. Your logo is bent along the primary skeleton curve and
individual characters of it are rotated to match the curvature of the
skeleton.

                             - TUTORIAL 6.24 -

6.10.2 Rotating Skin wound Bones

The purpose of this example is to demonstrate and clarify the purpose of
the secondary skeleton required by the general skeleton method, and how it
can be used for rotating target objects around the primary skeleton.

1. Create a freeform tube by rotating a curve around a horizontal axis
   (Create/Freeform/Rotate). Stretch the tube so that the cross-section of
   it is ellipse. This helps you to visualize the animation when it will
   be played.

2. Make the freeform tube mesh the current level and subdivide its control
   polygon to sub-groups horizontally (each sub-group should be an ellipse
   around the axis of the tube).

3. Create a SKELETON method to control the sub-groups (so put it to the
   same hierarchy level with them).

4. Create the primary skeleton curve, following the axis of the tube,
   under the method.

5. Create the secondary skeleton by using the function Create/Controls/
   Axis; draw the axis perpendicular to the primary skeleton.

6. Select the menu Animate/Control/Refresh so REAL 3D matches the targets
   with the skeletons.

7. Now, bend the primary skeleton curve and refresh the animation system.
   The freeform tube is bent accordingly.

8. Swap the orientation of the View window so you look along the primary
   skeleton, select the secondary skeleton and apply the function Animate/
   Create/Rotate to it. This makes the secondary skeleton rotate around
   the primary skeleton, making the "skin" (= the tube surface) also
   rotate accordingly around the "bones" (= the primary skeleton).

Figure T6-31: Secondary Skeleton Rotates a Freeform Tube around its
              Primary Skeleton.  (PICTURE: T6-31)

Play the animation; try rotating the View window so you can see how the
freeform tube rotates around its "elastic axis".

Let us leave the SKELETON method now and enter the next example section
which demonstrates the use of INVERSE KINEMATICS.

6.1 1 INVERSE KINEMATICS

Whenever you decide to switch you computer on, you just push the power
switch with your finger-tip. Let's analyze from animator's point of view,
what happens when you switch your computer on.

All kinds of muscles in your shoulder rotate your upper arm around your
shoulder. Also your biceps rotate your forearm around the elbow. Finally
muscles in the forearm bend your finger around its joints so that your
finger-tip eventually pushes the button,

                             - TUTORIAL 6.25 -

This means that the position of your finger-tip is determined by the
positions of the bones between the finger-tip and the shoulder. In other
words, the way your muscles modify the bones makes the finger-tip hit the
power-switch.

This is not how Inverse Kinematics works. When using Inverse Kinematics,
you don't have to define how the bones should be rotated in order to
produce a desired route for the finger-tip. You just define the position
or route for the finger-tip and Inverse Kinematics solves the problem, how
the bones should be positioned.

6.11.1 Curl a Finger

In this example we will create a simple finger by using a conical tube
tool and control it by using the INVERSE KINEMATIC and SKELETON methods.

If you are already familiar with the conical tube tool, you know it
creates its objects by combining quadrics, such as cones, cylinders and
spheres. Because this tool is suitable for modelling robots, the question
"how to keep joints stuck to each other" is quite an interesting one.

The idea of this example is the following: an object created by a tube
tool represents one finger. A SKELETON method is used for controlling many
finger objects and the skeleton curve is animated by defining the path of
its end point using INVERSE KINEMATICS. This is quite a common way to use
inverse kinematics with skeletons.

1. Create a polygonal line using the function Create/Controls/Open Line.
   This line represents the bones of your finger, hence it consists of
   four points. It will be used as a primary skeleton curve.

2. Create a tube representing your finger by selecting the menu Create/
   Compound Tools/Conical. Because you use quadrics, the skeleton must
   perfectly match the tube. So, use dragging when you define center
   points for conical tube joints. Because inverse kinematics allows you
   to define the position for the END point, make sure that the direction
   of your tube is the same as the direction of your skeleton. Otherwise
   you would define the position for a finger-root, not for a fingertip.

3. Make the tube object the current level and create a SKELETON method to
   the same level with the component primitives of the tube.

4. Use Cut and Paste to move the skeleton curve under the method object
   in the hierarchy.

5. Create the secondary skeleton by creating an axis primitive
   perpendicular to the primary skeleton. Now the skeleton is ready, so
   select the menu Animate/ Control/Refresh. This instructs REAL 3D to fix
   the target objects to their current positions on the skeleton.

6. Now, select the primary skeleton curve and the function Modify/Special/
   Inverse Kinematics and modify the end point of the skeleton. Then
   refresh the animation system and, as you can see, the finger is pulled
   to the skeleton and all the joints of the finger remain connected.

7. Create an INVERSE KINEMATICS method at the same level with the skeleton
   curves; the skeletons will be targets for the INVERSE KINEMATICS
   method.

8. The INVERSE KINEMATICS method requires only one parameter, which
   defines the end point of the target curve. So, create a B-Spline curve
   defining the route for the end

                             - TUTORIAL 6.26 -

Figure T6-32: INVERSE KINEMATICS moves the end point of the skeleton while
              the skeleton determines the position of the finger.
              (PICTURE: T6-32)

Play the animation, and the finger tip follows the defined curve (unless
the curve is too far so that the finger cannot follow it; then the finger
just reaches out as much as possible).

Okay, let's improve this animation a bit. So, jump to the next example but
don't delete this one.

6.11.2 Push a Button with the Finger-tip

Lets create an animation where a finger pushes a button. This can be
accomplished by using the same object to define motions for the button and
the finger-tip.

To do this:

1. Create a level object called "button" under the root level and a cube
   representing a button under the button level.

2. Create a PATH method object under the button level.

3. Create a motion for the button by using a stretched circle: create a
   circle under the path method and use Modify/Linear/Extend to stretch it
   horizontally so that it becomes just a straight line.

4. Create a link pointing to the stretched circle (select the circle and
   use the menu Create/Structure/Link).

5. Modify/Structure/Cut the link. Modify/Structure/Delete the original
   path under the INVERSE KINEMATICS method and Modify/Structure/Paste the
   link to replace it. The INVERSE KINEMATICS method now uses the circle
   to define the end point of the skeleton .

Figure T6-33: The Button and the Finger use the same Path.
              (PICTURE: T6-33)

Make sure that the finger is close enough to the button and play the
animation. Because the same primitive is used for defining the motion for
the both objects, the result gives an impression that the finger pushes
the button.

6.11.3 Interactively Controlled Hierarchical Skeletons

This example demonstrates how to create a hierarchical skeleton, and how
to control it interactively using inverse kinematics.

                             - TUTORIAL 6.27 -

It is not difficult to find examples of hierarchical skeletons. Just look
at your hand and you can see one example.

The ability to fork one skeleton to several sub-skeletons is often needed,
especially when creating character animations. Actually, great deal of
power provided by skeletons is based on this feature.

So, how to create hand-like hierarchical skeletons? The answer is simple:
skeletons can be targets to another skeletons.

So, lets examine how to create such a hierarchical skeleton object and how
it can be controlled and modified.

1. Create a polygonal line (Create/Controls/Open Line) consisting of three
   points representing your arm: shoulder, elbow, wrist.

2. Create an arm using the Conical Tube tool. Snap the joints of the tube
   to the points of the polygon using dragging, to get perfect matching.

3. Create a SKELETON method under the tube object so that all primitives
   of the tube will be targets for the method. Use Cut and Paste to move
   the skeleton line under the method. Also create the secondary skeleton
   (Controls/Axis). Later, we will rotate the secondary skeleton to make
   the robot rotate its wrist.

4. Select Animate/Control/Refresh and now the arm is fixed to the
   skeleton. Select the skeleton curve and use Modify/Special/Inverse
   Kinematic to modify it. Refresh the animation system again, just to
   make sure that the skeleton really works. Note that if you have
   installed the default key-bindings, you can use hot keys to do that.
   This makes the interactive handling of skeletons much more convenient
   compared to corresponding menu selections.

5. Select Modify/Structure/Copy while the entire arm object is selected.
   We are going to create all fingers by duplicating and scaling the arm.

6. Create a new level object at the same level with the SKELETON method
   and rename it as "fingers". Make it the current level.

7. Select the menu Modify/Structure/Paste. Modify the pasted arm smaller
   so that it represents a finger.

8. Create the second and third fingers by duplicating and rotating the
   first one.

9. Now, set the value of tag ISKE associated with the SKELETON method
   controlling the arm to 0. This tells REAL 3D that the situation is
   changed, and the information of the relationship between the targets
   and the skeleton should be redefined. Select the menu Animate/Control/
   Refresh and your "Robot Arm" is complete.

Figure T6-34: A simple robot arm. Skeletonally controlled fingers are
              sub-objects of skeletonally controlled arm. (PICTURE: T6-34)

After practising this a couple of times, it should not take more than a
minute or two to build up this kind of hierarchical robot arm.

So, let's have a look how this arm can be controlled by using inverse
kinematics (naturally you can use all normal modify/animation functions
to manipulate it, too).

                             - TUTORIAL 6.28 -

In order to move its wrist to another place, just select the skeleton line
used for controlling the upper arm and the forearm and move its end-point
with the Modify/Special/Inverse Kinematic modification, then select
Animate/Control/Refresh and the arm, including all fingers, is pulled back
to the skeleton.

If you want to define a new position for a finger-tip, just select the
skeleton line used for controlling the finger in question, use Modify/
Special/Inverse Kinematics and refresh the animation system.

In order to define the same position for all finger-tips, select the
"fingers" object (in other words, the object containing all the fingers),
and use Modify/Inverse Kinematics etc.

But how to rotate the wrist of the arm? Select the secondary skeleton
curve of the skeleton method controlling the arm and rotate it using any
suitable function . Refresh the animation system and fingers are rotated
accordingly.

As you already noticed, the inverse kinematics function always modifies
the end point of the skeleton. So how to define a position for the other
end? Just swap the direction of the skeleton using the function Modify/
Freeform/Swap Direction, use inverse kinematics and swap the direction
back.

We will need this arm in the next example, so don't delete it yet.

6.11.4 An Animated Robot Arm

In this example we will define fixed positions for all the finger-tips
and a motion for the wrist.

1. Create three offset primitives under the root level. We will use these
   offsets for defining fixed positions for the finger-tips. The reason
   why we create the offsets above the arm level is that when we animate
   the arm, it should not animate these offsets (because we want that
   they stay fixed).

2. Create an INVERSE KINEMATICS method under the skeleton method of each
   finger.

3. Create a link to each offset and Cut&Paste it under the corresponding
   INVERSE KINEMATICS method.

4. Create an INVERSE KINEMATICS method under the skeleton method used for
   controlling the entire arm, and create a B-Spline curve defining a
   motion for the wrist, under the new method.

Figure T6-35: A Skeletonally controlled arm. The wrist is moving, while
              the finger-tips and the shoulder remain fixed.
              (PICTURE: T6-35)

Before we leave these Inverse Kinematics examples, it should be noted that
examples we have gone through so far could only scratch the surface of all
the possibilities which inverse kinematics and skeletonal control offer.
For example, they are very important tools when animating mechanical
devices, such as engines of cars and especially when building up
mechanical connections.

                             - TUTORIAL 6.29 -

6.12 MORPHING

Actually, we have already created some morphing examples. However, it is
time to acquaint you with two methods which are designed especially for
morphing. They allow you to morph objects as well as materials.

Morphing methods are based on key framing. This means that you can
determine the shape of an object by defining two or more key-frames for
it. When the animation is played, the shape of the object is modified from
the first key frame towards the last. REAL 3D automatically interpolates
intermediate frames for you, using extremely "smooth" B-Spline
interpolation. This means that the objects and points do not move along a
straight line between corresponding key frame positions but along a
B-Spline curve. This feature is very valuable, especially when morphing
camera positions.

Morphing methods can also be applied to texture maps and materials.

6.12.1 Second Talking Head

Let's create the example presented in the Path example 6.1.6, a talking
head, but now using morphing.

1. Create a head; just a profile curve will do, to make modelling simple.

2. Create MORPHING OPEN method to the same level so the profile curve
   will be target of the method.

3. Copy the profile curve using Modify/Structure/Copy and paste it under
   the method object four times and modify the copies (actually the mouth;
   the purpose was to make the head talk) so they all look different.
   These are the key frame objects.

Figure T6-36: Morphing Applied to a Freeform Shape.  (PICTURE: T6-36)

Play the animation and you see the head talking.

As you have already figured out, morphing defines the shape of the target
object by using its parameters, in other words, key frame objects.

Just like any other method, the morphing method can have more than one
target. In other words, you can use one morphing method to morph more than
one object.



6.12.2 Singing Heads

Lets create two heads singing the same song. This means that the only
difference between heads is that they are in different positions, but the
song is the same for both of them.

1. Create a talking head as described in the previous section.

2. Duplicate the target object so the morphing method has two targets
   instead of one.

Note:
That the order between the targets and the method is irrelevant.

                             - TUTORIAL 6.30 -

3. Add the following tag to the second head:

     VOFF 1.5 0 0

This shifts the second head from the position defined by the key frames.

Figure T6-37: Two Heads are Morphed by the Same Information.
              (PICTURE: T6-37)

Play the animation and the result is two singing heads.

6.12.3 Sing the Same Song Ten Times

Because we used MORPHING OPEN method in all the previous morphing
examples, the head started from the first key shape and stopped to the
last shape. However, in order to create a head singing the same song more
than once, the MORPHING CLOSED method should be used so all motions repeat
smoothly and continuously.

So, lets create a head which sings the same song ten times.

1 . Create one singing head as described in the first morphing example,
    but use MORPHING CLOSED method instead of MORPHING.

2. Modify the method by using the function Modify/Properties/Animation:
   set the frequency to 10.

Play the animation and your head sings the song ten times.

Figure T6-38: Closed Morphing  (PICTURE: T6-38)

6.12.4 Morphing Hierarchical Objects

In this example, we will show you how to morph hierarchical objects and
objects containing other than freeform objects.

When applying morphing to hierarchical objects, the hierarchy is used for
detecting what parts of the targets and the key objects correspond each
other. This means that the hierarchical structure should be the same
(otherwise the result may be unpredictable).

As an example, we create a morphed hierarchical candlestick created with
the Lathe tool.

                             - TUTORIAL 6.31 -

1. Use Create/Compound Tools/Lathe to create a nice candlestick. This tool
   uses cylinders, cones, ellipsoids, spheres and hyperbolics to construct
   the shape defined and automatically creates a new hierarchy level,
   placing all primitives under it.

2. Create a MORPHING CLOSED method to the same level with the candlestick.

3. Copy the candlestick and paste it inside the method object as many
   times as you wish. Modify all key candlestick shapes so they look
   different.

Note:
That there are no restrictions for the number of keys or the depth of the
key object hierarchy.

4. Because it probably is not desirable to see the key objects, select the
   method object, select the function Modify/Properties/Attributes and set
   the gadgets WF-Invisible and RT-Invisible so only the result object
   will be visible. Of course, it is possible to create an animation where
   the key objects as well as the result are visible too!

Figure T6-39: Morphing A Hierarchical Candlestick  (PICTURE: T6-39)

5. Play the animation.

6.12.5 Morphing Texture Maps and Materials

If you are already familiar with REAL 3D texture mapping, you know that
textures are mapped on objects by using mapping primitives like rectangles
and cylinders. Because the mappings are just ordinary primitives in the
object hierarchy, they can be animated just like any other objects.
You can define all kinds of transformations for mappings using all
available methods, and morphing is not an exception. However, there is one
difference between morphing and other methods. Morphing does not only
change the shapes of mapping primitives, but properties of materials
referred by the mappings too! In other words, if a target object for a
morphing method is a mapping, also the material associated with the target
mapping is morphed, using materials associated with the corresponding key
frame mappings as "key materials".

Let s practice this a bit by creating an animation where some material
properties are morphed.

1. Create three materials named as "result", "color" and "bump", each
   having for example a wooden texture map. We are going to use the last
   two as keys for defining the material properties for the "result". Set
   Bump height to zero for the "color" and to maximum for the "bump" so
   you can see the difference when result material is interpolated through
   the key materials. Set the Color and Bump gadgets for the "result".

2. Create a sphere.

3. Create a level at the same level with the sphere and rename it as
   "mappings". Use the function Modify/Properties/Attributes and set the
   "Mapping" gadget.

                             - TUTORIAL 6.32 -

The object now consists of one sphere and one level which will be used for
defining materials for the sphere. (Remember the philosophy: a moving car
consist of a car shape and the motion; a wooden sphere consists of a
sphere and wood). By setting the Mapping flag for the level, you instruct
REAL 3D to look inside the level to seek possible material references.

4. Make the level object the current level and create one mapping
   primitive inside it by selecting the function Create/Mapping/Parallel;
   use the material "result". This means that the texture associated with
   the result material will be projected over the sphere using parallel
   mapping.

5. Create a MORPHING method to the same level with the previous mapping.

6. Create two parallel mappings under the MORPHING method. Use the
   material "color" with the first mapping and "bump" with the second.

Figure T6-40: Morphing Applied to Materials  (PICTURE: T6-40)

Your material morphing animation is now complete and ready to be played.
Before you play it, open a Material window and load the material "result"
so you can see how properties will change during the animation.

6.12.6 Camera Flight Animation

This example demonstrates how camera flights can be easily created with
the MORPHING method.

1. Create a cube, just to have something to look at in the animation.

2. Create a level object called "camera_here"

3. Set the perspective projection type (View/Type/Perspective) and select
   the menu View/Observer/Create Camera. This creates a level object
   consisting of the aimpoint and the viewpoint primitives.

4. Create a MORPHING OPEN method to the same level with the camera and
   make it the current level.

5. Find a suitable viewing angle using the cursor keys. When found, create
   the first key object by selecting the menu View/Observer/Create_Camera.

6. Modify the viewing angle and create a new key object, using View/
   Observer/Create_Camera. Repeat this until the desired key positions
   are included.

7. Activate the menu View/Observer/Camera_View. This instructs the View
   window in question to use orientation defined by the camera objects.

Play the animation; the orientation of the View window is fetched from
the first viewpoint and aimpoint, which in turn are modified by the
MORPHING method. The result is a camera flight animation.

                             - TUTORIAL 6.33 -

6.13 TRANSFORM

The TRANSFORM method is different from other methods: it is used for
modifying the time. In other words, it is a sort of time machine capable
of modifying time so that it becomes non-linear; it can even make the
time to go backwards. All objects after the method in the hierarchy will
see the modified time.

6.13.1 Piston

1. Create a level object called "up&down".

2. Create a cylinder representing a piston under "up&down" level.

3. Create a PATH method to the same level with the piston.

4. Create a vertical axis under the method level. Play the animation and
   the piston will move along the axis with constant speed ... no good.

5. Create a TRANSFORM method at the same level with the "up&down" object.
   Multi-select the TRANSFORM method and "up&down" and select Modify/
   Structure/Swap to change their order in hierarchy; the method should
   be above "up&down".

6. Create an axis and a circle inside the transform method as shown in
   the picture below.

Figure T6-41: TRANSFORM Method Modifies the Time.  (PICTURE: T6-41)

Play the animation and the piston will act like a real piston.

7. Use Modify/Properties/Animation to change the frequency of the
   TRANSFORM method to 4 and the piston will run up and down four times.

Let's try to understand why the piston started to go up and down just
like any real piston.

The transform objects requires two parameters; in this example an axis and
a circle. The method evaluates a point from the circle corresponding the
current time. Then it projects the point to the axis and the parameter
value corresponding the projected point on the axis is the new time.
For example, if the projection of the evaluated point hits the beginning
point of the axis, the new time would be 0.0. If the point hits the end
point of the axis, the new time would be 1.0.

In this example we used a circle, but it is possible to use any other
evaluable object as well.

                             - TUTORIAL 6.34 -

6.13.2 Hesitating Piston

The purpose of this example is to show in an intuitive manner how the
TRANSFORM method actually works.

We will use a small sphere and a horizontal axis to show how the point
is evaluated from the transformation curve and projected to the axis.
This is done simply by using the transformation curve to also define a
motion for the sphere object.

1. Create one level object called "piston" and create the piston example
   presented in the previous example section under that level; use a
   B-Spline curve instead of the circle to define a time transformation
   (see the picture below).

2. Create a new level to the same level with the "piston" object.

3. Create a sphere, a horizontal axis and a PATH method under the new
   level. Place the sphere and the horizontal axis at the beginning of
   the B-Spline curve.

4. Create a link which points to the B-Spline curve of the transform
   method and move (Cut/Paste) it under the PATH method. This makes the
   PATH method move the small sphere and horizontal axis along the same
   curve which is used for time transformation.

Figure T6-42: A Time Transformation  (PICTURE: T6-42)

When you play the animation, by following the sphere you can see how the
time transformation works: the current position of the sphere shows the
current point evaluated from the transformation curve. The point is
projected to the vertical time transformation axis - you can "read" the
projection value by checking where the horizontal line hits the axis. The
distance from the crossing point to the beginning of the time axis in
proportion to the whole time axis length defines the new local time for
the objects affected by the TRANSFORM method. When the B-Spline curve
turns downwards, the crossing points move downwards, too; this means the
time starts to run backwards.

6.13.3 Three Dimensional Time

Multi-dimensional time ... sounds terrible, but it is true. It is possible
to fork one dimensional time to three dimensional time. This example
demonstrates how to do it and how to use this possibility.

In order to understand three dimensional time, we have to understand how
the animation system of REAL 3D works.

                             - TUTORIAL 6.35 -

Curves, such as B-Splines and circles, can be defined using so called
parametric representation: each point on the curve is represented by a
parameter value between 0 and 1. The value 0 corresponds the start point
of the curve, and the value of 1 corresponds the end point of the curve.
In other words, when the parameter value runs from zero up to one, the
corresponding point moves from the beginning of the curve to the end
point.

When an animation is played, the time runs from 0 to 1. Methods use this
time for evaluating points on their parameter(s). If a new time value is
given, the method knows that it should do something to make the target
objects match the new situation. For example, the PATH method knows that
it should move its target objects as much as the evaluated point has
moved from the previous frame.

As long as the parameter object can be fully parametrized by using only
one value, we need only one dimensional time. But, there are lot of
objects which cannot be represented by one parameter. For example, a
B-Spline mesh is such an object.

To clarify this further, we compare a B-Spline curve and a B-Spline mesh
and illustrate how the parametrization works for them.

A B-Spline curve can be parametrized using only one value. We could use
the term "length" for that value. The reason why only one dimensional
parameter value is enough is that any position on the curve can simply be
specified by mentioning the distance from the beginning point of the curve
to the point along the curve.

This is not possible with a B-Spline mesh. Instead, we need two values for
describing all possible points on the surface. These values could be
called as "width" and "height". For example, if the value pair 0,0
corresponds the top left edge of the surface, then the value pair 1,1
corresponds the bottom right corner of it. 0.5,0.5 corresponds the middle
point of the surface etc.

The time can be forked to three dimensions using a coordsys primitive as a
parameter for the TRANSFORM object instead of an axis. A Coordsys includes
3 axes to project the evaluated point to, instead of one.

It is possible to move objects along a B-Spline mesh by defining the
motion using dimensional time and the mesh as a method parameter. Let's
stop the theoretic discussion now and demonstrate this in practice.

1. Create a TRANSFORM method.

2. Create a coordsys primitive under it.

3. Create a B-Spline curve under the method so that it begins from the
   origin of the coordsys and wriggles between X and Y axes of the
   coordsys, as shown in the picture below.

4. Create a level object, at the same level with the transformation
   object, and make the level the current level.

5. Create a small sphere

6. Create a PATH method, animating the sphere.

7. Create a B-Spline mesh under the PATH method level.

Figure T6-43: Sphere Moves along a B-Spline Mesh.  (PICTURE: T6-43)

                             - TUTORIAL 6.36 -

The route of the sphere is defined in the parameter space of the mesh
using the transform method.

Play the animation and the sphere moves along a mesh. The path of the
sphere is similar to the shape of the B-Spline curve, which is used as
a parameter for the TRANSFORM method.

8. Bend the mesh so that it is not planar. The consequence is that the
   route of the sphere is bent accordingly: the sphere still moves along
   the mesh, no matter how much you stretched or bent it.

If you have read the presented transform examples carefully, you have
probably already invented some new ideas how to use the method. However,
if you are familiar with some other high-end animation systems, you might
ask a question: why is this "transform thing" an object, not a separate
nice window? Here is the answer: because it is an object, it can be
animated by using all possible animation methods. This allows you to
even create animations with "feed-back".

Well, it is time to go to the next chapter. And I promise, the following
examples are worth reading.

6.14 RADIAL FORCE

Welcome to the world of force fields and particles.

We could write a separate book of all possibilities and possible
applications for this subject. But while waiting for that book, and before
explaining any of the theory behind particles and those sorts of things,
lets get started by creating the first particle system oriented animation.

6.14.1 Gravity

The RADIAL FORCE method generates a force field which affects the target
objects, so that the direction of the force field is defined by the line
between the "center point" of the method and the particle. If the radial
force field is positive, it pulls all targets towards it. If it is
negative, it pushes targets away from it. This makes this method very
suitable for simulating effects like electrical forces, magnetism and
gravity.

So, let's create a particle system which uses the RADIAL. FORCE method for
generating a gravity field. Our example consists of some particles, a
RADIAL FORCE method and a PROCESSOR method.

1. Create one circle, activate macro recording, duplicate the circle,
   move the circle a bit, end macro recording and repeat the current
   macro 10 times. The circles are the particles.

2. Create a RADIAL FORCE method at the same level with the circles.

3. The RADIAL FORCE method requires one parameter, which is the position
   of the force "source". Use Create/Controls/Offset to create the
   parameter under the method.

4. Create a PROCESSOR method to the same level with the force method.

Figure T6-44: A simple particle system. The gravity field pulls particles
              towards it.  (PICTURE: T6-44)

                             - TUTORIAL 6.37 -

Play the animation and all particles start to fall down towards the
gravity point.

First, what is a "particle system"?

Traditional particle systems consist of a large number of particles
(usually just points represented by their velocity, color etc.) acting
under the influence of external force fields, such as gravity or wind.
However , the particle system of REAL 3D is not what could be described
as "a traditional particle system". The biggest differences are that force
fields in REAL 3D are properties of objects themselves, and any object can
be used as a particle. One could almost say that there is no particle
system at all in REAL 3D. There are just objects which interact with each
other and the animation is the result of such interaction process.
But that is the situation in the Real world, too!

Because the particle system is implemented using methods, it is fully
integrated to the animation system. This allows you to mix particle
system oriented methods with all other methods. For example, if you have
a walking robot, you can move it forwards using a force method.

Because of historical reasons, we use the term "particle" in the following
examples instead of "target object". Anyway, a particle is just a target
object of a particle oriented method.

So, how then do the "particle oriented" methods of REAL 3D work?

Particle oriented methods, such as RADIAL FORCE, generate a force field.
This force field affects the "velocity" attribute of the object. The
longer the force field affects the object, the more the velocity of the
target is changed. This all happens according to Newton's laws of motion.
If you recognize the formula

     F=m*a

this all should be very clear to you. The term "F" in the formula
describes, how strong the force field affecting the particle is. The term
"m" is the mass of the particle and the term "a" is the resuming
acceleration. In other words, if the force "F" affects the particle whose
mass is "m", the acceleration for that particle will be "a".

What exactly is "acceleration"? Acceleration describes how much the
velocity of the particle changes ("dv") during one second and can be
solved from the following formula:

          dv
     a = ----
          dt

By combining these two formulas, we can solve how much the velocity of a
particle is changed during the time "dt".

                    F * dt
     F*dt=m*dv=>dv= ------
                      m

So, if the strength of the force field generated by a force method is
1000 N, if the mass of the particle is 100 kg and if the time between
subsequent frame is 0.1 s, the velocity of the object is changed

         1000 kgm/s*0.1s
     dv= --------------- =1.0m/s
             100 kg

So, the purpose of the RADIAL FORCE method is just to change the velocity
of target objects in very natural manner. By default, the method generates
a force field which behaves like gravity. The formula used for that is:

          m1*m2
     F=g* -----
            s

where m1 is the mass of the particle, m2 is the mass of the gravity point
and "s" is the distance between them. "g" is the so called gravity factor
whose value is 1.0. However, you can define the strength of the force
field by associating custom formulas with the method object, as we will
see later.

                             - TUTORIAL 6.38 -

Attributes, such as mass, acceleration and velocity itself, do not move
objects. To change the attributes to real motions, the PROCESSOR method is
needed. This method reads all relevant attributes of target objects and
moves (and rotates) the targets accordingly.

So, in order to create a particle animation, we need some particles,
perhaps one particle system oriented method which modifies velocities and
other properties of particles, simulating the Newtons laws of motion, and
finally we need a PROCESSOR method which transforms the attributes of
target objects to real motions.

If you have read all text above, you recognize the term "dt" and know that
it means the time in seconds. So, how many seconds is the entire
animation?

Open the animation window. The Seconds field describes the length of the
animation in seconds. If the Resolution (number of frames) is 40 and
Seconds is 1.0, this means that the "dt" between two subsequent frames is
1.0s / 40 = 0.025s.

Lets demonstrate the purpose of the Seconds field with an example.

6.14.2 The Simplest Possible Particle Animation

Next we create an animation without any force fields. The question is, how
to generate motions if there are no force field methods present?
The answer is: we define the velocity attribute for particles manually.

1. Create a sphere (a particle)

2. Select the sphere and select the function Modify/Properties/Velocity.

This function allows you to define a line which represents the velocity
vector of the particle. In other words, the particle will move that much
in one second.

3. Create a PROCESSOR method.

4. Play the animation, and the particle moves.

Now, double the value of the Seconds field of the animation window. Play
the animation again and the particle will move twice as far, in other
words, twice as fast.

You can also modify the velocity attribute by selecting the particle and
selecting the function Modify/Properties/TAGs. There should be a tag WEL
associated with the particle describing its velocity. If it does not
exist, the particle's velocity is zero (in other words, the particle is
static).

Now, select the sphere and the function Modify/Properties/Spin. This
function allows you to define three values in radians, representing three
component spins. The value 3.14 makes the particle rotate 180 degrees
around the corresponding axis in one second. Note that the rotation is
defined in "object space". This means that if you rotate an object using,
for example, the Modify/Linear/Rotate function, the spin axes are also
rotated accordingly.

Define some spin values and play the animation. Now your sphere moves and
rotates.

6.14.3 Customized Radial Force

As we have already mentioned, it is possible to define a custom formula
which defines the strength of force fields produced by particle methods.

In this example, we will create a particle "flock" which acts under the
influence of such a customized force field.

1. Create a particle flock consisting of circles.

2. Create a RADIAL FORCE method to the same level with the circles and add
   the following tag to it:

     SFOR f=100000*(s-2)

                             - TUTORIAL 6.39 -

3. Create an offset under the RADIAL FORCE method so that the distance
   between the particles and the offset is greater than 2 m.

4. Create a PROCESSOR method to the same level with the RADIAL FORCE
   method.

5. Open the animation window and set the Resolution to 200 frames (this
   gives you more time to analyze what will happen).

Play the animation. Because in the beginning, the distance between the
particles and the force source is greater than 2.0, s-2 is positive and
the method pulls particles towards it. As soon as the distance to any
particle gets shorter than this value, the method starts to push it away.

For more information about all possible variables for RADIAL FORCE see the
Reference section.

6.15 DIRECTED FORCE

The DIRECTED FORCE method can be used for generating force fields with
arbitrary and variable directions. Thus, it can be used for simulating
wind, turbulence etc.

The DIRECTED FORCE requires only one parameter, which describes the
direction of the force field during the animation. When the animation
is played, the method evaluates a point and a corresponding direction from
the parameter curve. The distance between the evaluated point and the
particles is used for determining the strength for the force. Thus, the
closer the particle is the parameter object, the stronger the force.

6.15.1 Turbulence

The purpose of this example is to demonstrate how the direction and the
strength of the force is defined.

1. Create a particle flock. One very easy way to do it is to use Create/
   Compound Tools/Object-Pixel Tool.

2. Create a DIRECTED FORCE method.

3. Create a B-Spline curve under the method. The direction of the force is
   the direction of the curve corresponding the current time. When the
   animation is played, the time runs from 0 up to 1 and the direction of
   the force varies according to the curvature of the method parameter.
   If the parameter is just a straight line, it generates a force field
   with constant direction, because the direction of the curve is the same
   everywhere. A Circle makes the force field rotate etc.

4. Create a PROCESSOR method at the same level with the force method.

Figure T6-45: A Directed Force Field Defined by a B -Spline Curve.
              (PICTURE: T6-45)

5. Set the Seconds field of the Animation window to 2.0.

Play the animation. The shorter the distance between the particle and the
parameter object, the stronger the force field.

                             - TUTORIAL 6.40 -

6.15.2 Snow in the Wind

The purpose of this example is to demonstrate use of multiple methods at
the same hierarchy level. This means that more than one force field
affects the particles and the result force is the sum of several forces.

First we need a force field which pulls the snow down (the gravity). This
can be implemented using a straight line as a parameter for the DIRECTED
FORCE method.

Then we need a force field representing the wind.

One way to create wind is to use several force methods at the same level
so that different parts of the particle mass are affected by different
methods; the closer a particle is to a method, the more that method
affects it. This naturally causes some turbulence to the particle mass.

However, in this example we will create a customized force field. The
direction of the wind depends on the position of the particle causing
the particle mass behave like snow in a storm.

1. Create particles representing snow flakes. The more memory you have,
   the more snow you can have.

2. Create a DIRECTED FORCE method and rename it as "gravity".

3. Add the following tag to the method:

     SFOR f=9.81

This means that the strength of the gravity is always 9.81. In other
words, the distance between the parameter object and particles does not
determine the strength of the force. The value 9.81 is very close the
force field generated by the earth.

4. Create a straight line under the method object, representing the
   direction of the gravity (it should point downwards).

5. Create another DIRECTED FORCE method to the same hierarchy level with
   the first one and add the following tag to it:

     SFOR f=10, fx=sin((y+t)*10), fy=cos((x+t)*10), fz=0

Variables fx, fy and fz are used for defining the direction of the force
and they are initialized to reflect the direction defined by the parameter
of the method. Here we override the original values by using sin() and
cos() functions.

6. Create an offset primitive under the method. We can use any evaluable
   object here, because our custom formula overrides the direction anyway.

7. Create a PROCESSOR method to the same hierarchy level with the other
   methods.

Figure T6-46: Snow particles are affected by two separate force fields:
              one simulating the gravity and one simulating the wind.
              (PICTURE: T6-46)

                             - TUTORIAL 6.41 -

Open the animation window, set Resolution to 100 and Seconds to 10, and
play the animation. If the result is not what you expected, cancel it and
use Undo feature to restore the situation. Note that you cannot play the
animation backwards to restore the situation; particle methods are such by
their nature that running the time backwards does not produce the same
events in reversed order, but results in a new situation.

If things do not happen fast enough in the animation, increment the
"Seconds" value. If too much is happening, decrement Seconds and/or
increment frame resolution.

You may also save the project before you play the animation; it is safer
than using Undo, whose depth may not be sufficient if you make too many
mistakes.

For more information about the variables for the DIRECTED FORCE, see the
Reference manual.

6.16 TANGENT FORCE

The third force type is the TANGENT FORCE. The direction of the force
field is always perpendicular to the parameter object and the line between
the target object and the center point of the force. The right hand rule
can be used for visualizing the direction, so that if the thumb of your
right hand represents the parameter object direction and your first finger
points to the particle, your second finger shows the direction of the
force.

Figure T6-47: Tangent Force  (PICTURE: T6-47)

This method can be used for simulating rotating force fields like those
found from electrical equipment, generators etc.

Because the generated force field rotates target objects around the
parameter object, the centrifugal force tries to explode the particle
mass just like in the real world.

6.16.1 Centrifugal Force

The purpose of this example is not just to demonstrate how to create a
tangential force field, but also to demonstrate how hierarchical animated
objects can be used as targets for particle oriented methods, and how
these traditional and particle oriented methods can be mixed with each
other.

In this example we will use a "mechanically" animated object as a particle
and let a tangential force field rotate such particles. Because of the
centrifugal force, particles will disappear quite soon, but who cares.

1. Create a level and rename it as "particle".

2. Create animated legs (just as in the example 6.3.1 Walking Legs), under
   the "particle" object.

3. Duplicate "particle" so that you have several walking legs.

4. Create a TANGENTIAL FORCE method to the same level with the particles.

5. Create an axis primitive under the force method.

6. Create a PROCESSOR method to the same level with the TANGENTIAL FORCE
   method and the particles.

                             - TUTORIAL 6.42 -

Figure T6-48: Walking Legs as Particles Acting under the Influence of a
              Rotating Force Field.  (PICTURE: T6-48)

Set Resolution=100 frames, Seconds=10 and play the animation. Tangential
force starts to rotate walking legs; because of the centrifugal force,
all the walking legs go away.

Now we have gone through all three force methods by studying just one or
two simple examples of each of them. The reason for this is not that there
are no more things to tell you about these methods, but these kind of
force simulations require some basic knowledge of mathematics and physics,
and it would require an entire book to go through all different features
and possible applications. So, it is time to leave these force methods
now and enter the next section.

6.17 INTERACTIVE COLLISION DETECTION

The collision detection methods allow you to create extremely impressive
animations. For example, throw a football down the stairs and it bounces
down just like it does in the real world. Put a sphere on a table, tilt
the table and the sphere rolls along the table, falls down and rebounds
from the floor. The list of possible examples is infinite.

Interactive collision detection means that collisions are detected between
all particles (objects).

6.17.1 Colliding Spheres

1. Create two spheres

2. Select the second sphere and define a velocity for it: select Modify/
   Properties/Velocity and draw a line starting from the sphere, passing
   through the second sphere. This will make the spheres collide.

3. Create one INT COLLISION to the same level with the spheres.

4. Create a PROCESSOR method (you should already know to which level...).

Figure T6-49: Collision Detection Applied to Two Spheres. (PICTURE: T6-49)

Play the animation (if you continue from the previous example, first reset
Seconds to 1.0). The second sphere moves towards the first one until they
collide. After the collision, the first sphere also moves. This all
happens according to Newton's laws of motion.

                             - TUTORIAL 6.43 -

6.17.2 Multiple Collisons

This example is very similar to the previous one except that now we use a
chain consisting of several spheres and a cube. The first sphere collides
to the second, the second to the third and so on. The purpose of the cube
is to show how collisions change the velocity as well as the spin of
objects.

1. Create several spheres and one cube so that the first sphere will hit
   the cube, after colliding with other spheres. If the sphere-cube
   collision point is not on the line between the centers of gravity of
   the objects, the collision makes the cube spin, too.

2. Define a velocity for the first sphere towards the other spheres. Make
   sure that the velocity is high enough (the velocity vector is long
   enough).

3. Add a tag "FMAS 500" to the first sphere. This redefines the mass of
   the sphere so that it is heavier than other spheres. If there is no
   FMAS tag associated with an object, the default mass, 100 kg, is used.

4. Create INT. COLLISION and PROCESSOR methods.

Figure T6-50: A Heavy Sphere Producing Multiple Collision.
              (PICTURE: T6-50)

Save the whole collision object and play the animation. If the velocity
was not high enough, select Project/Project/New and reload the collision
object. Again, remember that if you play the animation backwards, you
won't get back the original situation. So, the best way to test particle
animations and collision detection is to save the original situation and
load it back when necessary (or use Undo).

6.17.3 Bowling Alley

In this example we will create a complete bowling alley. When you play
it, the bowling ball moves towards the pins while gravity makes it collide
with the bowling alley . The bowling ball starts to rotate along the
bowling alley due to the friction between the ball and the alley. Finally
the ball collides with the pins, the pins collide with each other and all
you have to do yourself is to write down the scores.

After some practising, it should take only a couple of minutes to
construct this kind of animation.

1. Create the bowling alley floor (e.g. a cube) and redefine the mass of
   it to be extremely high by adding "FMAS 100000000" tag to it. It must
   be very heavy because we don't want the bowling ball and the pins to
   affect the floor too much.

2. Set the "Modify/Properties/Attributes/Protected" flag of the bowling
   alley. We have to do this, because we don't want the gravity which
   pulls the pins and the ball against the alley to affect the alley
   itself. By setting this protected field, we can fix the position of
   the alley.

3. Create the pins on the bowling alley by using Create/Compound/Lathe
   and duplicate functions.

                             - TUTORIAL 6.44 -

4. Create a bowling ball about 0.5 meter above the bowling alley, as if
   it has just been thrown towards the pins.

5. Use the function Modify/Properties/Velocity to define the horizontal
   velocity for the ball. The velocity vector should be almost twice as
   long as the alley.

6. Create an INT COLLISION method.

7. Create a DIRECTED FORCE method and use an axis primitive to define
   the direction for the gravity (downwards!). Add the following tag to
   the force method:

     SFOR f=10

This makes the strength of the force constant, just as real gravity is in
bowling alley scale. The gravity force on the earth is actually not
constant, it varies e.g. according to the distance from the centerpoint
of the planet. Nevertheless, the gravity variations on the bowling alley
surface are so small that they can be ignored in the bowling simulation.

Now your bowling alley is ready. Save it and then play it, using e.g. 100
frames, because this complicated simulation requires quite an accurate
temporal resolution. After playback, replace the scene with the original
one (load or undo).

Figure T6-51: Bowling  (PICTURE: T6-51)

By default, the friction between the ball and the alley is very low. This
means that when the ball collides with the alley, it does not start
rotating much. So, let's redefine the friction for the ball and the alley
so as soon as the ball hits the alley, it starts to roll.

7. Select the ball and the alley and add following tags to them:

     FFRI 0.5

FFRI stands for FRIction, which depends on the type and the quality of the
surface of the object. Note that you can define different friction factors
for different objects, in which case the collision is processed using
their average. To be physically correct, the value of this tag should be
between 0 and 1. However, you can use higher values (or even negative
ones), but the result of such unusual friction no longer corresponds real
world.

If your sphere collided improperly with the alley, you can increase the
collision detection accuracy. There are several ways to do this. The first
one is to increase the "Smpl" value in the animation window. This makes
the animation system use higher internal resolution when playing the
animation. The value of Smpl affects the quality of motion blur and the
accuracy to which particle animations represent the laws of physics.

The second way is to increase the Resolution value of the animation
window. The more frames you specify, the shorter the time sampling
interval between two consecutive frames becomes, and the better the
accuracy which can be obtained.

The third way is to add the tag ICSM to those objects between which higher
accuracy of collision handling is needed. The value of the tag can be 0, 1
or 2 (default is 0). If the value of this tag is different between the
objects under consideration, the minimum is used. For example, by adding
this tag to the alley and the ball, the collision between them is
processed in high accuracy, but collisions between the ball and the pins
are processed using the default accuracy (because there is no ICSM tag
associated with pins).

                             - TUTORIAL 6.45 -

The third way is usually suitable because you can use it selectively.

8. So, add the tag ICSM 2 to the alley and the ball.

Now your animation should work perfectly. Save it, play it and enjoy.

6.17.4 Drop a Ball to a Tube

In this example, we will throw a sphere through a long curved tube.

1. Create a curved tube using the function Create/Compound_Tools/Circular_
   Subdivided.

2. Multi-select all cylinders, select Modify/Properties/Attributes, and
   activate Hollow, No 1 st BP and No 2nd BP gadgets to make the tube
   hollow.

3. Define very high mass for the tube by adding the FMAS 1000000 tag to
   the tube object.

4. Create INT COLLISION and PROCESSOR methods to the same level with the
   tube.

Figure T6-52: A Sphere is Guided through the Tube by Collision Detection.
              (PICTURE: T6-52)

5. Create a sphere and "throw" it to the tube by defining a suitable
   velocity towards the beginning of the tube with the function Modify/
   Properties/Velocity.

6. Add the tag ICSM 2 to the tube and the ball.

7. Play the animation (1 Seconds, Resolution 100 frames).

One important fact related to collision animations (and other particle
oriented animations, too) should be noted: the result of such animations
depend essentially on the detection accuracy adjustments, for example on
the amount of frames specified when playing the animation. Therefore, it
may be wise to use the final resolution all the time.

The reason for this is that even minor changes result in an accumulative
sequence of further chances. In fact, this is the situation in the real
world, too: even the simplest collision systems are "chaotic" by their
nature.

6.17.5 A Rolling Ball

In this example, we will create a table and some spheres on it. When the
table is tilted, spheres start to roll and fall down rebounding from the
floor. We will use the SWEEP method to tilt the table. DIRECTED FORCE
(gravity) and collision detection take care of the rest.

1. Create an object consisting of a floor and a table cover. Make the
   object very heavy by adding the tag FMAS 1000000 (one million
   kilograms!) to it and nail it to the universe by setting its Protected
   flag (use Modify/Properties/Attributes). Rename the object consisting
   of the table and the floor as "table&floor".

                             - TUTORIAL 6.46 -

2. Create table tilting mechanism using Animate/Create/Sweep. Set the
   Start time of the sweep method (Modify/Properties/Animation) to 0.05 so
   that it starts to tilt when the time reaches that value. This gives you
   time to see how collision detection keeps the spheres on the table. Set
   the End time of the method to 0.5.

3. Create some spheres on the table. Put them to the same hierarchy level
   with the "table&floor" object.

4. Create a gravity field by using a DIRECTED FORCE method and an axis
   parameter.

5. Create INT COLLISION and PROCESSOR methods.

Figure T6-53: Tilt the Table and the Spheres Fall Down.  (PICTURE: T6-53)

6. Add the tag FFRI 1.0 to the table and the spheres. This makes the
   spheres also rotate (they don't just slide along the table).

7. Before we play the example, let us take a look at a tag called FREB. It
   allows you to define so called "rebounding factor" which defines how
   much a colliding object loses kinetic energy in the collision. The
   default is 1.0, which means that it does not lose kinetic energy at
   all. The value 0 causes object to lose all its kinetic energy making
   particles to stick to each other. So, save the animation now and play
   it. Then reset the time to 0, replace the object with the original one,
   add FREB 0.5 tags to the spheres and play the animation again.

6.18 NON-INTERACTIVE COLLISION DETECTION

As was already mentioned in the previous section, in interactive collision
detection, collisions are detected between all objects. However, sometimes
this is not necessary or even desirable especially when animating particle
flocks consisting of thousands of particles. For example, when a man walks
in snow, collisions between the man and individual snow particles should
be detected and processed but snow particles need not collide with each
other.

Non-interactive collision detection method is designed for these kind of
applications. It processes collisions which occur between target objects
and parameter objects of it. However, collisions between target objects
or collisions between parameter objects are not processed.

So, let's practise this.

                             - TUTORIAL 6.47 -

6.18.1 A Planet and Meteorites

In this example we will create a planet and several meteorites. The
gravity of the planet causes meteorites to collide with the planet.
However, collisions between meteorites are not detected.

1. Model meteorites using small spheres

2. Create a COLLISION method to the same level with them.

3. Create a planet under the COLLISION method. Add the tag FMAS 10000000
   to the sphere to make it very massive.

4. Create a RADIAL FORCE method to the same level with the meteorites.
   Create an offset primitive under it defining the position for the
   force. Create it in the middle of the planet.

5. Create a PROCESSOR method.

Figure T6-54: Collisions only Between the Planet and the Meteorites.
              (PICTURE: T6-54)

6. Play the animation. Depending on the size of the objects, you may have
   to adjust the frame count; if meteorites move so fast that they get
   through the planet surface, just increment animation Resolution value.

6.19 FRICTION

Let's imagine a situation where a force affects an object. The force
accelerates the object according to the Newton's law of motion: F=ma.
This means that the longer the force affects to the object, the faster the
object moves. However, this is not what appears to happen in the real
world. The reason for this is that usually there are some other forces
involved, making it very difficult to generate very fast motions. For
example, the air is a such a resisting element. These resistive forces are
called friction forces.

The FRICTION method can be used for adding these "resistive" forces to the
virtual reality of REAL 3D. If the velocity of an object is 0, the
friction method does not affect it at all. The higher the velocity of the
object, the more the friction affects it, direction of the friction force
being always opposite to the velocity of the object. The strength of the
resisting force is proportional to the velocity squared.

The strength of the force depends on the size of the object, too. The
bigger the object, the higher the friction force. However, the size has
less dramatic effect to the force than the velocity attribute; the
strength of the force is increased only linearly proportionally to the
size.

The mass of the object naturally determines how much the friction force
can affect its velocity. The higher the mass, the less sensitive the
object is to the friction force.

The strength of the force generated by the friction method is defined
using the following formula:

                d * e
     f = Fmax * ---------
                d * e+ 1

                             - TUTORIAL 6.48 -

where d is the diameter and e is a total energy (kinetic+spin) of the
object. The Fmax is the force needed to stop the object during the time
interval between two subsequent frames. The formula can never produce
bigger forces than this maximum force.

The friction method does not require parameters.

6.19.1 Friction and Spheres with Different Sizes

1. Create three spheres with different sizes and define equal velocities
   for them by using the function Modify/Properties/Velocity.

2. Create two spheres with an equal size and add the tag FMAS 10 to the
   second one.

3. Create a FRICTION method to the same level with the spheres.

4. Create a PROCESSOR method.

Figure T6-55: The Effect of the FRICTION Method on Different Objects.
              (PICTURE: T6-55)

Play the animation and "air resistance" slows down the spheres. The bigger
the sphere, the higher the friction . The higher the velocity, the higher
the friction. The bigger the mass, the less the friction can change its
velocity.

6.19.2 Customized Friction

The FRICTION method can be customized, just like any other method, by
adding a custom formula or procedure defining the strength of the friction
force to it. This way it is easy to create some nice effects, like
friction whose strength depends on the position (non-homogenous friction
fields).

So, let's create simple particle animation where radial force moves a
number of particles while one customized friction method resists their
motions.

1. Create a set of spheres.

2. Create a RADIAL FORCE method. Create an offset primitive, defining the
   center of the force field, under the method.

3. Create a FRICTION method and add the following tag to it:

     SFOR if(x<0,f=f*2,f=0)

The variable "x" reflects the current position of the particle in
question. So, the formula uses a conditional expression where f is either
duplicated or set to zero, depending on the position of the particle.

4. Create a PROCESSOR method and play the animation.

All particles on the left side (where the x coordinate values are less
than zero) are affected by the friction, but particles on the right are
not.

                             - TUTORIAL 6.49 -

Figure T6-56: A Non-homogeneous Friction Field.  (PICTURE: T6-56)

6.20 CREATION

The CREATION method is a "procedural" object creation tool. This means
that it can create new objects during animations. As a matter of fact, it
can control the whole process of "birth and death". For example, phenomena
like boiling water or fireworks are perfect applications for this method.

The CREATION method accepts any number of parameter objects. The method
uses the parameter objects as a samples for creating new copies. The
copies are inserted to the same hierarchy level with the method itself so
that they will be targets of it. The method can also delete target
objects.

The rules controlling this process are mainly defined using two tags
associated with parameters and/or target objects: SCRE and SDEL.

Whenever the tag SCRE is found from a parameter object, it is evaluated
and the value of the "I" variable is used for determining whether or not
a copy of the object should be created. If the value is zero (or if there
is no SCRE tag associated with the parameter object), the copy is not
created.

If the tag SDEL is included in the target object and if the value of the
variable "I" is other than zero, the target object is deleted.

6.20.1 A Sphere Tube

This is perhaps the simplest possible example of using the CREATION
method: a sphere which follows a path leaving copies of itself behind.

1. Create a CREATION method.

2. Create a sphere under it.

3. Add the following tag to the sphere:

     SCRE I=1

4. Create a PATH method to the same level with the sphere (under the
   CREATION method) and a B-Spline curve under the PATH method.

Figure T6-57: A Moving Sphere as a Parameter for the CREATION method.
              (PICTURE: T6-57)

Play the animation and the PATH method moves the "sample" object along the
path while the CREATION method creates one new sphere in each animation
frame. The target objects created by the method have all the properties
of the sample object.

                             - TUTORIAL 6.50 -

6.20.2 Boiling Water

Another good example of procedural creation is boiling water. When the
temperature reaches a certain level, bubbles begin to appear randomly
inside the water and start to go up until they reach the surface of the
water and disappear.

Right, let's do this.

1. Create a CREATION method.

2. Create a bubble under the method and add the following tags to it:

     SCRE I=1
     SDEL I=y>0.0

Because the value of the "I" variable in the SCRE tag is always 1, a new
bubble is created in each frame. The SDEL tag defines that the bubble will
be deleted as soon as its y coordinate reaches the value 0.

3. Use the function Modify/Properties/Velocity to define a velocity for
   the bubble. The idea is that as soon as the bubble is created, it will
   start to go upwards.

4. Create a PATH method to the same level with the bubble. Set the
   Frequency of the method to 5, and draw a strongly oscillating curve
   under the PATH method. The way we define the original position for the
   bubbles is quite "deterministic", but if the path is very curved and
   complicated, it will look as if the bubbles were created randomly all
   over the water (We will demonstrate you later how to use a real random
   function to define the position for the bubbles using RPL).

5. Create the PROCESSOR method to the same level with the CREATION method.
   As mentioned earlier, an attribute itself (such as mass, velocity etc.)
   does not move the object anywhere. The PROCESSOR method is needed for
   converting the attributes to real motions. Because we did not create a
   PROCESSOR method at the same level with the sample bubble, the sample
   won't go up (the velocity is there, but it is not converted to a
   motion).

6. Create a pot and a circle inside it representing the surface of the
   water in the pot. Note that we used the conditional expression "y>0"
   to define when bubbles should disappear, so the circle representing the
   level of the water should be placed to that height.

7. Make the CREATION method object invisible, to make the bubbles appear
   out of nothing.

Figure T6-58: Boiling Water  (PICTURE: T6-58)

Now our boiling water example is ready. I strongly suggest that you save
this project now and spend some time to render it photo-realistically.
Use an animated bumpmap on the water surface and with these bubbles, the
boiling water should look pretty good.

6.20.3 A Wriggling Snake

This example demonstrates how the age of the object can be used for
determining the time when the object should "die". As soon as the object
gets old enough, it disappears. The sample object is moved along a
B-Spline curve just like we did in our first CREATION example, but now we
will also delete target objects so that the earlier an object is born,
the earlier it dies.

                             - TUTORIAL 6.51 -

1. Create the objects described in the example 6.19.3 but now add also
   the SDEL tag to the sample sphere:

     SDEL I=t-fx>0.1

The variable "fx" defines the time when the object was created. The
variable "t" represents the Current time. So, the age of the object is
t-fx and when the age gets greater than 0.1, the object is old enough for
the deletion.

Save and play the animation and in the beginning, it resembles our first
CREATION example. However, soon the oldest spheres start to die and the
number of spheres comprising the tube no longer rises.

Figure T6-59: CREATION Method Animation  (PICTURE: T6-59)

Let's experiment with this animation a bit more. Reload it and try the
following formula with SDEL tag:

     SDEL I=t-fx>0.2*sin(12*t)*0.1

Play the animation and the length of the "snake" varies while it moves
along the path.

6.21 PROCESSOR

If you have gone through all animation examples so far, you are already
familiar with this method. It is used for converting particle system
oriented object attributes like the "velocity" to real motions.

Let's consider a particle system which consists of a sphere, a radial
force and a processor method and take a look at what actually happens
when the animation is played.

1. The global time is increased by a value depending on the frame
   resolution and all methods are to be informed about the new time.

2. The RADIAL FORCE manipulates the velocity attribute of the sphere.
   Because the radial force knows how strongly (F) it affects the sphere
   and how long the time (dt) has affected the sphere since the last
   frame, it can calculate how much (dv) the velocity of the sphere
   having a certain mass (m) should be changed.

This all happens according to the Newtons laws of motion:

                dv     F * dt
     F=m*a=>F=m*--=>dv=------
                dt       m
                      ========

If the formula "F=m*a" tells you nothing, you probably didn't understand
everything presented above. However, the formula can be described in a
more understandable form: if we know how long a certain force affects an
object with a certain mass, we can solve how much the velocity of the
object changes.

3. Then the PROCESSOR method reads the current velocity of the sphere and
   calculates how far (ds) the sphere has travelled since the last frame
   (dt) with its current velocity:

                             - TUTORIAL 6.52 -

        ds
     v=---- =>  ds=v*dt
        dt      =======

In a human readable form, this could be something like: if you drive your
car and you know how long you have driven and how fast, you can calculate
how far you will get.

6.22 RPL

The RPL method allows you to create your own RPL procedures and associate
them with objects. When the animation is played, your procedure is
executed in each frame and it is totally up to your procedure to decide
what to do when this happens.

Because RPL is a full featured programming language, there is not much
you could NOT do with it. In a way, this method is one of the most
powerful ones found in the program, but naturally, in order to take full
advantage of it, you have to know how to write RPL programs. All built-in
methods, such as PATH, SIZE, RADIAL FORCE etc. can be easily implemented
using the RPL method.

Because this subject is huge, we will go through only a basic example
here. For more information about how to write new animation methods using
RPL, see the RPL tutorial and the Reference manual.

6.22.1 An Easy Way to Write a RPL Procedure

The easiest way to write such a procedure is to use the Macro function.
So, let's try this:

1. Create a sphere.

2. Record a macro in which you move the object a bit.

3. Create a RPL method to the same level with the sphere.

4. Add the following tag to the method:

     SRPL "t:macro.rpl" LOAD

Play the animation and the sphere moves. The RPL function LOAD loads the
current macro "t:macro.rpl" and executes it.

Whenever you use this method, there must be the tag SRPL associated with
it. The contents of this tag is executed in each frame and it must be a
RPL program. Usually the tag contains a function call to the actual
procedure, which is a speed-efficient way.

6.23 WAVE

The WAVE method can be used for creating waves. If the first parameter of
it is an axis primitive, then the method creates "radial" waves. If the
first parameter is a coordsys, then the waves can be defined separately in
each direction. The second primitive can be any evaluable object defining
the shape of the waves. For example, a circle creates sine waves.

6.23.1 Waving Sea

This example demonstrates the effect when the wave method is applied to
freeform objects.

1. Create a mesh representing the surface of water.

2. Create a WAVE method to the same level with the mesh.

3. Create an axis under the method so that it is perpendicular to the
   mesh.

                             - TUTORIAL 6.53 -

4. Create a circle under the method so that the axis splits it to two
   halves.

Figure T6-60: Waving Sea  (PICTURE: T6-60)

Play the animation and waves are created over the entire mesh. Because
the first parameter is an axis, the height of the wave depends on the
distance between the point of the wave and the axis.

6.23.2 A Water Drop

This example demonstrates radial waves, too, but now we use the surface
which is constructed by rotating a curve around an axis, The radial nature
of the generated waves can be more clearly seen in this kind of surface.

1. Create a "disk" mesh by using the function Create/Freeform/Rotate: just
   rotate a straight line of 10 points around an axis.

2. Create a WAVE method object with an axis and a circle. Note that you
   can use the same axis which you used for creating the mesh.

Figure T6-61: Radial Waves  (PICTURE: T6-61)

Play the animation, Now the radial waves can be seen clearly.

6.23.3 Parallel Waves

If the first parameter is a coordsys, then the profile of the wave remains
the same when moving along an "y" axis. The shape of the wave depends on
the distance between a point and the origin of the coordsys in "x"
direction. The length of the "x" axis defines the wave-length and the
length of the "z" axis defines the wave-height.

1. Create a mesh.

2. Create a method with a coordsys and a circle as shown in the following
   figure.




			     END OF PART 3





