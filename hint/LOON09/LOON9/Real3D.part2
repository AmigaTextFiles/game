



                                PART 2
			 Follow On From Part 1



                             - TUTORIAL 3.2 -

Now you have created the second material, marble. It includes a texture
map, which defines the color pattern of marble surface: if you look at
the high column of gadgets at the left side of the material editor, you
can see that only Color map gadget is activated. The tile gadgets were
used to repeat the marble pattern in both x and y directions on the
surface of the object.

At this point, you have both shapes and materials created, but there is
still no connection between the two. As it was already mentioned, this
connection is expressed by using the hierarchy tree. You can proceed in
the following way:

14. Select the object ellipsoid.

15. Select function Create/Boolean/OR. This creates a new level and puts
    the sphere under the level.

16. For the sake of clarity, now select the function Modify/Properties/
    Name and type the new name "shiny_sphere" for the new level.

17. Double-click the name shiny_sphere on the select window. You can see
    the original object "sphere" on selection window.

18. Select the function Create/Mapping/Default. The list selector of
    REAL 3D is opened, displaying the names of the materials in the
    material library.

19. Click the material name "shiny" and Click OK.

Now the material of the sphere is defined. The hierarchy tree is this:

     Root
        cube
        shiny_sphere
          ellipsoid
          shiny(T)

The symbol(T) after the name shiny denotes the type of the object as
"mapping". We chose the mapping type Default, because the material shiny
does not require any mapping geometry definition: there are no patterns
painted to the sphere which we would like to position accurately.
The marble texture is different, because you may want to define, for
example, the density (or size) of the marble pattern. To apply the marble
texture, do the following:

20. Select the cube, and use Boolean/OR to create a new level containing
    the cube. Again, you may modify the name of the new level to be
    "marble_obj".

21. Open the new marble obj level by double-clicking on it in the select
    window.

22. Select the function Create/Mapping/parallel.

23. Select the material marble and Click OK.

24. This time, a mapping geometry is needed. The function waits for you
    to shape a rectangle in a view window. Define the rectangle by
    clicking on top left corner and on bottom right corner of it.
    The size of the rectangle that you shape will define the size of the
    first "tile".

Now the marble mapping is created; hit return to refresh the display. You
see a new item on select window, "marble (T)", and a rectangle drawn with
a dotted line is visible in the view window.

Note:
It is possible to control the wireframe visibility of textures by using
View/Drawing Set function. So, if you do not initially see the dotted
texture rectangle, select View/Drawing Set and make sure that the Mapping
gadget is selected.

                             - TUTORIAL 3.3 -

The final hierarchical structure of the example is this:

     Root
        marble_obj
          cube
          marble(T)
     shiny_sphere
        ellipsoid
        shiny(T)

Support example:
Examples/Marble&Shiny.

Now it is time to render the scene. Activate the view window you want to
use for rendering, use the arrow keys to find a suitable viewing position,
select View/Render/Settings and set mode to Lampless, accept the rendering
setting by hitting OK and then select View/Render/Window.

If you have successfully performed the actions described earlier, you
should get an image where the material properties are clearly visible.
Often, when using parallel texture mapping on cubes, the image can contain
surfaces where the texture pattern looks striped even though that is not
the purpose. This artifact can be avoided by modifying the mapping object
in a suitable way. We can experiment this in the following way:

25. Select the mapping object "marble(T)" using the select window.

26. Activate a view window and hit <RAM>X to get the front view.

27. Select Modify/Linear/Rotate and rotate the mapping rectangle, say, 30
    degrees.

28. Change the viewing direction for example by using <RAM>Y, and rotate
    the mapping again.

29. Experimentally adjust the density of the marble pattern, select
    Modify/Linear/Size and increase the size of the mapping rectangle.

Now render a new image; you should see a different result. After rotating
the marble mapping rectangle, it is no longer parallel to any of the sides
of the cube. Therefore, each side gets a nicely varying color pattern.

We will now modify this example further in order to demonstrate how the
hierarchy and materials depend on each other. Do the following
modifications:

30. Use the select window to make the level "marble_obj" the current or
    active level.

31. Create a new object, for example a cylinder, under the marble_obj.

32. Go to the level "shiny_sphere", select shiny(T), and select Modify/
    Structure/Cut.

33. Go to the root level, and select Modify/Structure/Paste.

Now the hierarchy looks like the following:

     Root
        marble obj
        cube
          marble(T)
          cylinder
        shiny_sphere
          ellipsoid
        shiny(T)

Support example:
Examples/Marble&Shiny2

                             - TUTORIAL 3.4 -

You inserted a new cylinder under the marble_obj level, and because there
was already a marble mapping in that level, the cylinder automatically
becomes made of marble. Moving shiny(T) to Root level has such an effect
that shiny material affects all the objects in the hierarchy. The material
of the ellipsoid remains the same, but the cube and the cylinder become
made of a mixture of marble and shiny, which looks like a well polished
marble.

3.1.3 Optical Properties

Real world material appearances and properties can often be analyzed best
by considering the properties in suitable classes. The classification
can be for example:

- How is the color defined

- What happens when light hits the surface of the material

- What happens when light travels inside the material.

In REAL 3D, color is always included in the objects themselves, not in
the materials. This is quite natural, because in the real world, the
same material can appear in different colors (green glass and brown
glass, etc.). For maximum flexibility, in REAL 3D materials may also
contain various colouring methods which overrule the default object color
or modify it. These methods include bitmap texture maps and mathematical
texture maps, which are both described in detail later.

The second important property class are the properties which define what
happens when light hits the surface of the material. You can define these
properties from the sliders at the right side of the material editor of
REAL 3D.

When light hits the surface, part of it penetrates the surface, part of it
is absorbed, and part is reflected back.

Figure T3-1: Absorbed, Penetrating and Reflected Components of Light.
             (PICTURE: T3-1)

First of all, the object color itself defines the amount of absorbed
light: the darker the color, the more absorption. What happens to the
rest of the light is defined by Transparency property. The higher the
transparency, the more light penetrates the surface. The maximum amount
of penetration depends on the angle in which the light hits the surface.
If the light hits perpendicular to the surface, then all the light can
penetrate. When the angle gets smaller, more and more is reflected.
As we know from the laws of optics, if the light travels from optically
thicker material to thinner (e.g. from water to air), there is an angle
of total reflection after which all light is reflected back, no matter
how transparent the materials are.

So, the non-absorbed light is split into two components. The behavior of
both components is defined by Brilliance property. If Brilliance is zero,
the surface is a diffuse matt surface, and each reflected/refracted light
ray is directed randomly into the surrounding environment. This means,
that no reflections of other objects can be seen on the surface.
If Brilliance is maximum, 100%, the surface acts as a mirror, showing
clear images of surrounding objects. If the Transparency is also high,
then you get a clear glass appearance.

                             - TUTORIAL 3.5 -

Figure T3-2: Light Travelling in Different Materials  (PICTURE: T3-2)

When we combine the extreme values of Brilliance and Transparency, these
are the results:

     Transparency O%   |      100%
     ------------------+------------
     Brilliancy 0%     |
          Default matt |  Matt glass
     ------------------+------------
     Brilliancy 100%   |
            Mirror     | Clear glass

When you create transparent materials, you can also define the refraction
index using the Refraction slider. The higher the value, the less
refraction that happens.

Other "Surface class" properties are:

- Specularity: the sharpness of high-lights or "hot-spots" created by
               light sources.

- Specular brightness: the intensity of high-lights created by light
                       sources.

- Roughness: defines molecular level roughness of the surface.

The last class are the properties which define what happens inside the
materials while light travels in them. Both of the Turbidity adjustments
belong to this class. Turbidity defines the degree of turbidity
(fogginess) of the material. For example, you may use it when simulating
atmospheric phenomena such as: fog, mist, and clouds, also when simulating
water or not perfectly clear glass. Turbid saturation gives extra accuracy
in simulations, as it defines the relation between the turbidity effect
and the distance which the light travels inside the turbid material. The
higher the value, the more easily the turbidity effect reacts to distance
variations, whereas turbid saturation 0 produces "flat" turbidity.

As an example of these properties, lets create a fog cloud and a glass
ball:

1. Open the material editor. Name the first material as fog.

2. There are no highlights on a surface of a fog cloud, so leave
   specularity to zero.

3. There is no diffuse, clear boundary surface in a fog cloud. Therefore,
   set Brilliance to maximum level 100%.

4. There is no boundary resisting light penetration. Therefore, set
   Transparency to 100%.

5. It is best to avoid strong Refractions in this case, so adjust
   Refraction to 100%.

6. Set Turbidity to 10%. The default saturation level of 25% is suitable.

7. Activate the Smooth gadget; this allows the light to penetrate the
   cloud better.

8. Press APPLY

9. Next create glass material: change the name to glass.

                             - TUTORIAL 3.6 -

10. Glass always reflects light, so deactivate the Smooth gadget.

11. Adjust specularity to 75%, to get nice highlights.

12. Set refraction to 70%, to get "glass" refractions.

13. Reset turbidity back to zero to get clear glass.

14. Now glass is ready, so press APPLY.

15. To visualize the properties of these materials, we need something on
    the background, so we will create one more material: a checker
    texture. First press RESET to get rid of old definitions, and then
    type the name checker.

16. Define the texture name, r3d2:textures/bluewhite. After material
    RESET, Color map is automatically active.

17. Activate TileX and TileY

18. Press APPLY

19. Now the materials are ready, so you may close the material editor.

20. Create a level (Create/Structure/Level) and name it "wall".

21. Create a large rectangle (Create/Visibles/Rectangle) filling the view.

22. Select Create/Mapping/Parallel, select checker from the material list
    and click OK, shape a small parallel mapping rectangle.

23. Step back to the root level in the hierarchy, and create a new level
    "fog".

24. Create a white sphere (Create/Visibles/Sphere).

25. Select Create/Mapping/Default, select the fog-material and click OK.

26. Step back to the root level in the hierarchy and create a new level
    "glassball".

27. Create another white sphere beside the fog sphere.

28. Select Create/Mapping/Default, select glass from the material
    selector, and click OK.

29. Now the model is ready. Take a top view of the scene and make sure
    that the rectangle is behind the spheres. Then find a good viewing
    angle using the cursor keys, so that you see the rectangle through
    the spheres.

30. Open the render settings dialog (View/Render/Settings). Set mode to
    Lampless - in Environment mode, the renderer ignores transparency
    settings in order to produce a rendered image faster. Click OK, and
    render an image.

Support example:
Examples/Materials/gas&glass

                             - TUTORIAL 3.7 -

3.2 TEXTURE MAPPING

3.2.1 General Information

In REAL 3D, Image files can be used as parameters for materials. The
technique of using bitmap images for defining various material properties
is called texture mapping, and the images themselves are called textures.

A typical example of texture mapping is modelling a floppy disk with a
disk label. After creating a blue disk shape, it is necessary to "glue"
the white label with text on to it. This label can be drawn using a paint
program and then projected as a parallel texture map on to the disk.

To use texture mapping, you need:

- A texture- Any digitized/painted/scanned IFF image and also a 24/32-bit
  true color Targa image created by REAL 3D can be used.

- A material referring to the texture. The material contains the name of
  the texture and other desired properties.

- A mapping referring to the material. The mapping can be created by using
  Create/Mapping menu.

- An object to which the material is applied using the mapping. As
  described earlier in this section; the object and mapping should be
  placed under the same hierarchy level.

The tutorial chapter 3.1.2 has already demonstrated how to create a
texture mapped object. In the following chapters, we will consider
different aspects of texture mapping in more detail.

3.2.2 Textures

It is possible to use from 1 to 24-bit IFF files or true color Targa
files as textures. The image format, size, and depth that is the most
suitable, depends on the application. The following examples demonstrate
some basic rules of how to choose the correct texture type.

- 24-bit textures are usually only necessary when outputting 24-bit
  graphics. Using smaller image depths saves a lot of memory and are
  faster to render.

- Grade-function can be used to obtain 24-bit color resolution with lower
  texture depths. For example, to get a texture with a 24-bit color
  gradient from blue to white: you can use a two pixel, 1 bit deep image,
  (which contains only one white pixel and one blue pixel), and "grade"
  the texture. This saves memory, because this image occupies only a
  couple of bytes of memory , whereas the corresponding 24-bit texture
  may require several hundred kilobytes of memory or more. Nevertheless,
  the texture gradient function is a time-consuming one, and sometimes
  24-bit textures can be faster to render.

- Regular geometric patterns can often be represented with very low
  resolution textures. For example, for a checker pattern, you need only
  a 4 pixel, one bit deep tiled texture. The Tiling feature, repeating
  the same pattern, is handy in situations like this.

- If you are creating an animation where you zoom in very close to a
  texture mapped surface, you will probably need a quite high resolution
  texture in order to avoid clearly visible pixelization effects. Also,
  the "grade" function is useful for this purpose.

                             - TUTORIAL 3.8 -

3.2.3 Texture Mapped Materials

In REAL 3D, texture mapping is a material property. Each material of the
material library can contain a texture map. If you want to apply multiple
texture maps for an object, you can create several materials and link them
all with the object. This is demonstrated later in the chapter "Multiple
Materials".

A material can use a texture for defining various properties independently
from each other. For example, a texture can act as a bump map and as a
color map at the same time. There are seven different usages for texture
mapping:

- Color mapping: maps the color of the texture to the material.

- Bump mapping: uses the red component of the texture as a local height
  information when shading the surface of the material.

- Transparency mapping: uses the green component of the texture to define
  Transparency of the material.

- Brilliancy mapping: uses the blue component of the texture to define
  brilliance of the material.

- Shadow mapping: filters the original color of the object with the
  texture colors.

- Clip mapping: can be used to clip/cut surfaces.

- Scope masking: defines the spatial scope/visibility of the material
  using the texture shape as a mask.

Note :
Clip mapping is actually a material property. It does not reshape the
object - the Renderer just treats clip mapped areas as fully transparent
material. Clip mapping usually does not work properly in Environment
rendering mode where transparency in general cannot be simulated
convincingly.

3.2.4 Mapping

Mathematically, the term "mapping" means; a rule which defines how to
attach to every point of a space, exactly one counterpart in another
space. REAL 3D uses this kind of rule to define how a point in 3D
absolute space is mapped into the 3D material space, where the
properties of the materials are defined.

The data item which defines the rule is called mapping. You can create
mappings using the functions in the menu Create/Mapping. There are five
basic mappings available:

     - Default
     - Parallel
     - Cylinder
     - Sphere
     - Disk

Each mapping performs a 3D coordinate transformation in a natural way.
For example, Default mapping leaves the coordinates unchanged and sphere
mapping maps normal 3D coordinates to polar coordinates (horiz. angle,
vert. angle, radius).

Each mapping (except Default) includes a geometry (or shape), which
visualizes and defines how the coordinate transformation happens. You
define the geometry when creating the mapping, and because REAL 3D stores
the mappings in the hierarchy tree, you can easily modify (resize, move
etc.) or even animate them.

The mappings can be customized using the Mapping handler from the material
editor. For example, a cylinder mapping can be modified to a spiral style
mapping by activating the built-in Mapping/Tilt handler.

Note :
Although the geometric properties of mappings are mainly used with texture
mapping, REAL 3D uses mappings as a way of connecting a material to an
object. The coordinate transformation of a mapping may not be used at all.

                             - TUTORIAL 3.9 -

3.2.5 Sector Mappings

Sometimes when using cylinder, disk, or sphere texture mapping, it is
desirable to map the texture into a sector instead of full 360 degrees.
The following example demonstrates how to do this, and at the same time,
it shows how to use a lower level interface of REAL 3D for defining
mappings.

Let us assume that the task is to create a cylindrical can, which has a
label covering 1/3 of the side of the can. The following actions give the
desired result:

1. Create the can using Create/Visibles/Cylinder function.

2. Use Create/Sectors/Cylinder to create a cylinder sector, using the same
   axis as the "can" cylinder. Position the sector suitably so that the
   cylinder sector defines the correct area for the label on the surface
   of the can.

3. Make sure that the cylinder sector is selected and select Modify/
   Properties/Attributes function; REAL 3D opens the attributes requester.
   Activate Mapping gadget and select OK.

4. Now open the material editor and create a material with a suitable
   color texture. Activate Color map and define the image name. Name
   the material as "label", and press APPLY. Then close the material
   editor.

5. Make sure that the cylinder sector is still selected and select
   Modify/Properties/Tags menu. When requester opens, click the Add
   gadget. Then type the four capital letters SMAT , then click in the
   empty space and finally type the name of the material, "label". In
   other words, type the string "SMAT label". It is important that the
   string is exactly correct, including upper/lowercase characters,
   otherwise the material will not be found. Then click OK.

6. Now the scene is ready for rendering; select environment rendering
   mode and start the rendering.

Support example:
Examples/Materials/sector_mapping

3.2.6 Spline Mapping

In addition to the basic mappings and sector mappings presented earlier,
REAL 3D offers an advanced method for using cubic B-spline parameter
space mapping. This technique means that you can use a cubic B-spline
surface as a mapping for itself so that the mapping automatically follows
the shape of the B-spline surface. When using this mapping method, the
texture pattern follows the surface deformations in a natural way, no
matter how much the surface is bent or stretched. A good example is a
roll of chequered paper rolled open during an animation; if the paper
roll is modelled using a cubic B-spline surface, and the pattern is a
spline mapped color texture, then the desired result is achieved.

To use spline mapping:

1. Create an object using a cubic B-spline surface.

2. Open the material editor and create a material having the desired
   texture map. Select the desired texture mapping type, for example
   color mapping.

3. Activate the Spline map gadget, and press APPLY to create the material.

4. Use Create/Mapping/Default and create a mapping on a view. You can use
   Default or any other mapping, because spline mapping overrules the
   original mapping geometry.

                             - TUTORIAL 3.10 -

5. Link the object and the mapping together in the hierarchy unless you
   have done it already, for example by multi-selecting both and using
   Create/Boolean/OR.

6. Render the scene using Environment rendering mode. Make sure that
   B-Spline->Phong rendering setting is not active - spline mapping does
   not work with Phong shaded surfaces.

Note:
That you can use spline mapping to map: bumps, other properties as well as
colors, tiling, and other texture mapping options. When tiling, you may
use the two rightmost fields of S-map uvwh gadgets of the material editor
to scale the tile size: for example, a value 0.25 produces four tiles to
the surface.

Support example:
Examples/Materials/spline_mapping

3.2.7 Index Format String

REAL 3D supports automatic indexing of texture file names. This feature
can be used for creating animated textures. In this chapter, the indexing
system is described in detail.

There are several places in REAL where an index must be included in a
file name, e.g. a sequence of Backdrop Image files. When such an index is
needed, it is included in the name by using an Index Format String. The
inclusion of this string not only specifies that an index is to be used,
but also what format is to be used for the index, and where in the name
it is to be placed.

For those familiar with the "C" programming language this Index Format
String uses the same conventions as the "C" function "sprintf". For most
indexing, use of the following information should suffice:

     "%" Start of format string

This is then followed by either or none of:

"-" To specify that the index should be left-justified

"Field width specifier". if the index has less digits than the field
width, then it will be padded either to the left or right if "-" is used.
If this width is specified with a leading zero then the padding character
will be a zero, otherwise it will be a space. The format string is then
ended with the conversion character "d". This specifies the index to be
in decimal format.

Examples:

     If the index variable is 3

     File_Name_%d produces:       File_Name_3
     File_Name_%2d produces:      File_Name_3
     File_Name.%-2d.IFF produces: File_Name.3.IFF
     File_Name.%03d produces:     File_Name.003

3.2.8 Animated Textures

When creating animations, it is often desirable to also animate textures
instead of using static texture maps. For example, one can animate a walk
through a room where a television is displaying changing images; in this
case, the TV screen should contain an sequence of varying color textures.

REAL 3D offers flexible tools for creating such effects. In order to
create a animated texture, do the following:

1. Create the texture sequence. For example, draw ten images, and save
   them with the same name appended with a growing index. The indexing
   convention can be selected quite freely, you can find the exact rules
   from the previous chapter "Index Format String". The actual name must
   be the same for all the images. For example: "txr0",

                             - TUTORIAL 3.11 -

   "txr1", "txr2", etc.

2. Create a material, and type the name of the textures you created
   without index to the texture name field (e.g."txr"). Append the index
   format string after the name as presented in the previous chapter.

For example, the texture name definition can be "txr%d".

3. Select the desired Index handler for the material using the material
   editor. The default handler goes through the textures incrementing the
   index frame by frame. If you are going to use cyclic texture animation
   instead of having a new index for each new frame, you should set the
   parameter b to be the amount of textures, (e.g. 10).

4. Use the material in your animation.

Instead of using the cyclic handler , you can use the pingpong handler,
which goes back and forth in the texture sequence. You can also define the
rule which defines which texture to use in each frame/time value by using
RPL/Formula handlers, as presented in the chapter "Procedural Handlers" of
this section and in the reference section. When using those alternatives,
you can refer to the global/local animation time or to the frame counter.

The tutorial example file "Examples/Materials/Water" contains an example
of using an animated bump texture to simulate waves. It uses default
index handler with a 30 frame cycle, and therefore, if you want to produce
a loop animation, you should set the animation window resolution gadget to
a multiply of 30 frames: 30, 60 or 90 etc.

3.3 ADVANCED MATERIAL FEATURES

3.3.1 Multiple Materials

This chapter explains one very important part of the material handling of
REAL 3D, namely the usage of multiple materials per object. Actually, the
tutorial example presented earlier used this method when demonstrating the
connection between the hierarchy and materials ("shiny marble").

Using mutiple materials is quite easy. You just create the object and the
materials you want to apply to the object. Then you create a hierarchy
level, put the object under it and create as many mappings as necessary
under the same level. For example:

     multimatobj
        myobject
        colormat(T)
        bumpmat1(T)
        bumpmat2(T)
        topmat(T)

Different materials may be used to define different properties for the
object. For example: a material including a colour texture for defining
the color, a material with a dense bump texture to define surface
roughness, and a material with a large scale bump texture to define bigger
bumps.

Secondly, different materials may be used to define object properties in
different spatial locations. For example: a sphere can be textured so that
the north pole is made of wood and the south pole is made of marble.

Often, when multiple materials are applied, the material definitions do
not overlap, and it is easy to predict what the result is. For example:
if you map two non-tiled parallel colour textures, say, two labels, to a
box so that the labels do not overlap, you just get two separate coloured
areas on the box surface. A more interesting case occurs when the
materials overlap. By default, if

                             - TUTORIAL 3.12 -

two mappings define two different values for a material property in a
point in space, REAL 3D uses the average of the two at that point. In
other words, the materials get automatically blended.

Different bump definitions are:

- A bitmap bump texture: Image + Bump map

- A math. bump texture: Bump handler = built-in/RPL/formula.

The material editor includes some functions with which you can control
material blending more accurately. First of all, the Effect slider offers
global adjustment which determines how much the material affects the
objects to which it is applied. For example, if you apply marble to an
object and marble has 50% Effect setting, you get a marble-default material
mixture. When the materials are blended, the Effect values are used as
weights which define how big a proportion of each material is put to
the mixture.

Secondly, scope handlers can be used as spatial weight distributions.
This means that the effect of a material can vary in different points of
3D space. For example, you may create a spot of marble in a wooden object
so that the marble smoothly fades away and turns into wood.

One of the most useful scope handlers is the built-in Local scope handler.
It weights the material effect so that the effect is maximum in the middle
point of the mapping used (e.g. in the middle point of a sphere mapping or
in the top left corner of a parallel mapping). The maximum effect, defined
by the effect slider, fades smoothly away within a certain radius. By
default, this radius is the radius of the mapping, but it can be overruled
by defining a non-zero parameter in a.


Other built in scope handlers are described in the reference section.

As an example, we can create a bumpy sphere whose north pole is made of
wood and south pole is made of marble.

1. Create a new level.

2. Create a sphere under the level.

3. Open material editor.

4. First create the bumpy material: define name bumpy, define texture
   r3d2:bumpmaps/irregular, deactivate Colour map and activate Bump map,
   set bump height to 5% and adjust specularity to 50%. Hit APPLY.

5. Create wood: hit RESET, then define name wood, texture R3D2:textures/
   wood1, activate tile gadgets, and set specularity again to 50%. Then
   click Scope handler gadget until it displays "Local". Hit APPLY.

6. Create marble: do NOT reset the material editor, just change material
   name to marble and change texture name to R3D2:textures/marble1. Hit
   APPLY. Now the materials are ready, so you may close the material
   editor.

7. First create the global bumpy material mapping: select Create/Mapping/
   Sphere, select bumpy and click OK, click in the middle of the sphere
   and size the texture sphere.The size can be equal to the size of the
   original sphere. t does not matter in this case.

8. Select Create/Mapping/Sphere again, select wood, and shape the mapping
   so that the north pole is in the middle of the mapping sphere. The size
   should be almost twice the size of the original sphere.

9. Select Create/Mapping/Sphere, select marble, and shape an equally big
   mapping around the south pole.

10. Render the image in environment mode.

Support example:
Examples/Materials/Localscope.

                             - TUTORIAL 3.13 -

The Scope mask feature offers an easy way to define the scope
distribution. You can use an image to define which parts of the space are
affected by the material. The following example, writing "rough" letters
to a matt surface, demonstrates this.

1. Start the example by drawing white text on black background in a paint
   program. Save the image or suitable part of it as a brush.

2. Open the material editor of REAL 3D and type the name of a material,
   "rough".

3. Define the texture name to be the text brush name.

4. Deactivate Colour map gadget.

5. Activate Scope mask gadget.

6. Activate Transp. col gadget, and set transparent colour to black using
   Transp.R, Transp.G and Transp.B gadgets (all zero). This means that you
   will not map the black background colour of the text.

7. Adjust roughness to 30% and hit APPLY.

8. Create a rectangle on a view window.

9. Create a parallel mapping for the rectangle having equal size and
   position as the rectangle.

10.Render an image in environment mode.

Support example:
Examples/Materials/Scopemasking

3.3.2 Procedural Handlers

Each handler row of the material editor of REAL 3D includes four main
types of handlers: Default handler, additional built in handlers, RPL
handler and formula handler. The two last ones, RPL and formula, make it
possible for the user to easily and quickly define new custom handlers.
For example, it is possible to define an infinite number of different
mathematical colour textures. The Formula handler is based on the EVAL
word of RPL. When using the Formula handler, you can type in a formula
directly which defines the desired properties from a certain set of
parameters. These parameters could include for example: material space
coordinates x, y and z. It is possible to use all the usual mathematical
functions in these formulas; the exact list is given in RPL EVAL
documentation.

It is possible to create quite interesting bump map textures using
trigonometric functions. The following example of a bump mapped surface
where the bumps are also time dependent, demonstrates this:

1. Open the material editor and name the new material as wave.

2. Set Bump handler to Formula and type the following formula to the
   string gadget of the handler:

   bx = sin(3*sin(5*x)+y+T*3.14),by = sin((x+T)*3.14)*cos(5*x*y)

3. Add some specularity to the material and hit APPLY.

4. Create a blue rectangle and create a parallel mapping referring to the
   wave material.

5. Render an image or an animation.

Support example:
Examples/materials/mathbumps

                             - TUTORIAL 3.14 -

RPL handlers offer even more flexible way of expanding the material
features. In this case, the string gadget associated with the RPL
handler may contain any RPL expression, including the EVAL word. RPL
coded expressions are faster than Formula expressions, but require more
RPL knowledge. The RPL expression used may also be a full RPL procedure
defined in the master RPL environment. For more details, see RPL
documentation.

The following examples demonstrate the usage of formula handlers.

Example:  y = y + 10*sin(4*a*x/100)  where a = 6.28

When used with an image file 100 pixels wide to be mapped onto the
surface, this formula produces a series of vertical sine wave ripples.
The parameter a is being used to convert x into radians, so that using the
constant 4 produces four cycles of sine waves. The constant 10 in the
expression makes the sine deviation +/- 10 pixels.

Example: s = 25

This combines 25% of the properties of the material with the existing
properties.

Example: s = x

When used with a texture file 100 pixels wide will apply the image such
that its effect becomes stronger over the whole width of the image.

The scope handler is also the most appropriate place to assign procedural
values to the Material Variables controlling the basic physical material
properties.

Example: br = 100.0*x

When used with a parallel mapping texture and no image file causes
brilliance to increase linearly along the width of the mapping rectangle.

Example: bx = sin(5*a*x), by = sin(2*a*y)
         when a = 6.28

Applies sine wave ripples in x and y direction to the surface. The "a"
parameter is again being used as 2*pi to convert x & y to radians so that
the constants 5 & 2 produce five ripples along the x axis and 2 ripples
along the y. Since x & y are not normalized, these expressions only
produce the correct results when used without a texture file.

Example:  R = 255*x, G = 255*y, B = 255*z

The above expressions replace any existing colour components with a Red
value, which increases along the x axis of the texture, and a Green value
which increases along y. The Blue value is derived from the z coordinate.
Using these expressions would mean that the colour of the surface would
depend upon its position in the texture.

The size variable can be used to bind a formula to the size of a texture,
as in the following example:

Example:  R = if(z <= sz, 255, 0)

This replaces the red component of the surface with a full intensity
value, if the point on the surface is inside the texture size.

Example:  i = F/a when a = 3

The index increases at one third of the rate of the Global Animation
Index.

Example:  i = 10*t%5
          % - modulus function

As the local time "t" changes from 0.0 to 1.0 the index will change from
0 to 4 twice.

                             - TUTORIAL 3.15 -

3.3.3 Non-homogeneous Materials

The Scope feature can be used for defining non-homogeneous materials.
There are two ways to do this: by using Formula/RPL scope handler with an
RPL expression, which defines the desired property directly, or by using
multiple scope-weighted materials, in which case the blending process
produces different results in different parts of space.

An example of the formula method is a shiny material with a formula scope
handler and formula

     sb = 50*(sin(x)+1)

This formula modifies specular brightness; trigonometric sin function
produces a repeating horizontal brightness wave pattern. As an example of
the second method, blending two materials, let us consider modelling a
planet with atmosphere. The purpose is to make the atmosphere glow when
sun shines through it.

1. Open the material editor. First create a planet surface material:
   name it as planet, set texture map to r3d2:textures/planet, and press
   APPLY.

2. Create a star sky material: change the name of the material to space,
   and change the texture name to r3d2:textures/space. Activate TileX/
   TileY gadgets, and set Unshaded flags, because the image will be used
   as an unshaded back ground plate. Press APPLY.

3. Create gas material: hit RESET button to get a clean start, name the
   material as gas, activate the Smooth gadget to eliminate surface
   reflections, set Transparency, Brilliancy and Refraction to 100%,
   turbidity to 10%, turbid saturation to 50%, and specularity to 100%.
   Hit APPLY.

4. Create glowing gas by modifying the previous material: change the name
   to glow, and adjust specular brightness to 10%. Then select Local scope
   handler, and select APPLY to insert the new material into the material
   library.

5. Now you may close the material editor, and start building the objects.
   First create a level and name it star plane. Create a rectangle under
   the level, and create a parallel mapping, which refers to space
   material. The space textured rectangle will act as a background plate,
   so place it behind the rest of the scene and size it accordingly. It is
   probably necessary to use Modify/Properties/Attributes/Infinite gadget
   to make the plane infinite.

6. Go back to the root level of the hierarchy and create a level called
   planet. Create a sphere under the planet level. Then take a view from
   above to the planet and create a sphere mapping referring to the planet
   material.

7. Step back to root level and create a new level called atmosphere. Under
   that level, create another sphere, white or light blue, around the
   planet sphere, make it a little bigger than the planet. Then define two
   sphere mappings, one referring to gas and the second one referring to
   glow. Both mappings should match exactly the size and position of the
   atmosphere.

8. Create a light source between the star plane and the planet.

9. Adjust the camera so that you look towards the planet with the star
   plane behind it. Also, make sure that you see the light source through
   the atmosphere.

10. Open render settings requester. Select Normal rendering mode, set Mat.
    samples to one and hit OK. Then render an image.

                             - TUTORIAL 3.16 -

The hierarchical structure of the scene is:

     Root
        starplane
          rectangle
          space(T)
        planet
          ellipsoid
          planet(T)
        atmosphere
          ellipsoid
          gas(T)
          glow(T)
        lamp

It is important that the planet is above the atmosphere object in the
hierarchy, because the two overlap. The planet object should replace
atmosphere, not the other way around. The higher an item is in the
hierarchy, the higher priori it has.

In this example, the specular glow of gas fades away towards the outer
edge of the atmosphere because of the Local scope property. What is
left is the other non-glowing gas. The Mat. sampling value 1 was very
important: it instructs REAL 3D to study the material not only on the
surface of the atmosphere, but inside it too.

Therefore, the non-homogeneous nature of the gas is detected and the
proper effect is created.

Note:
That using a nonzero Mat.sampling value has meaning only if transparent
materials are used.

Support example:
Examples/Materials/Planet.

3.3.4. Mappings and Hierarchy

Hierarchical manipulation of mappings requires some consideration. When
creating certain animation effects (e.g. material metamorphosis), mappings
must be grouped using hierarchy, or referred to across the hierarchy. It
has already been pointed out that a mapping connects a material only to
those objects which are located in the same hierarchy level as the mapping
itself. How do you connect a hierarchical group of mappings into an
object?

This can be done by using the "Mapping flag" of the Modify/Properties/
Attributes function. Anywhere in the hierarchy you can replace a mapping
with a level or a symbolic link by setting the "mapping flag" of the level
or link. The level may contain the actual mappings or the link may refer
to the actual mapping. Anyway, REAL 3D looks at the whole hierarchy
regressively checking all the objects labelled with texture flags. If a
level or link without a Mapping flag is found, recursion does not proceed
under it. All the mappings found in this way will affect the result.

As an example, consider the following simple hierarchy of an animated
texture map group:

     Root
        candlestick
        motion_ mat(T)
          mappings(T)
            wood(T)
            marble(T)
        level(M)
            line

Support example:
Examples/Materials/moving_texture

                             - TUTORIAL 3.17 -

3.3.5. Some Material Morphing Examples

The following examples may help clarify how to morph materials.

Example 1:
Material morphing using built-in "Temporal Scope" handler

This material handler can be used for modifying the effect (scope) field
of the material from one value to another. These values are defined by
using Scope a & b fields. The field "a" defines how strongly the material
in question affects objects in the beginning of the time and "b" is used
for defining the effect for the end of the animation.

For example, if you would like to create a wooden sphere whose material is
morphed to marble during the animation, you could create two materials so
that the effect level of the first material starts from the zero and gets
stronger while the effect of the second material gets weaker and weaker.
In order to do this:

1. Create two materials named "wood" and "marble". Use colour mapping and
   appropriate textures so that you can see when the material changes from
   wood to marble. Set the Scope cycle gadget of both materials to
   "Temporal" and use the following values for "a" and "b" fields:

     Material   a b
     --------------
     wood       1 0
     marble     0 1

When the time is 0, marble has no effect at all while the material "wood"
is at its maximum level. When the time proceeds, the material "marble"
gets stronger and stronger, whereas the "wood" material is faded away.

2. Create a sphere.

      +------+
      | Root |
      +------+
         |
     +--------+
     | sphere |
     +--------+

3. Add both materials using Create/Mapping/Parallel.

                +------+
                | Root |
                +------+
                /   |  \
               /    |   \
              /     |    \
     +--------+ +------+ +--------+
     | sphere | | wood | | marble |
     +--------+ +------+ +--------+

Note:
You can use different mapping methods for the different materials, for
example: parallel projection for the wood and cylinder projection for the
marble. Not only can the texture be morphed, but also the projection type
can be morphed over the time.

4. Play the animation.

Support example:
Examples/Materials/temporal_scope

Example 2:
Mapping geometry morphing

Because mappings are really primitives defining the size, position and
orientation for the actual bitmap textures, you can animate the mappings
using all the animation methods available. For example, you could use
mappings as particles and animate them using the particle system oriented
animation techniques, such as wind and gravity, or perhaps you just want
to rotate the texture about your objects using ROTATE method. The
following example demonstrates how to move a texture over an object during
an animation by using PATH method.

                             - TUTORIAL 3.18 -

1. Create a "wood" material using an appropriate texture.

2. Create an object, say tube.

              +------+
              | Root |
              +------+
                 /
           +------+
           | tube |
           +------+
           /   |  \
          /    |   \
     +----+ +----+ +----+
     | p1 | | p2 | | p3 |
     +----+ +----+ +----+

3. Create a mapping using parallel projection (Create/Mapping/Parallel).
   This sets the material of your object "Tube" to wood (remember the
   philosophy: if your object consists of a car and a motion, the result
   is a moving car, if your object consists of a "Tube" and a "wood", the
   result is a wooden tube).

              +------+
              | Root |
              +------+
                 /   \
           +------+ +---------+
           | tube | | wood(T) |
           +------+ +---------+
           /   |  \
          /    |   \
     +----+ +----+ +----+
     | p1 | | p2 | | p3 |
     +----+ +----+ +----+

4. Now animate "wood" primitive by applying the function Animate/Create/
   path to it (i.e. define what kind of path the wood texture should
   follow). Now the hierarchical structure of your object is as follows:

                    +------+
                    | Root |
                    +------+
                    /      \
                   /        \
           +------+          +------+
           | tube |          | wood |
           +------+          +------+
           /  | \               /   \
          /   |  \             /     \
     +----++----++----+ +---------+ +--------------+
     | p1 || p2 || p3 | | wood(T) | | level (PATH) |
     +----++----++----+ +---------+ +--------------+
                                       /
                                    +------+
                                    | line |
                                    +------+

5. Set the texture flag of the level object/Root/wood. This tells the
   renderer to look inside the level to seek out actual mapping
   primitives.

6. Render the animation

Support example:
Examples/Materials/mapping_path

Example 3:
Material/Mapping geometry morphing using MORPHING animation method

You can use morphing to animate the shape of mapping primitives. This also
causes the properties of the corresponding materials to be morphed. In
this example, we will create three "key" materials which are used as key
frames for morphing the "result" material and mapping geometry.

1. Create four materials called "result", "key1", "key2" and "key3". Use,
   for this example, different specularity levels for the different key
   materials. Properties of the result material do not matter, because
   they will be determined by the key materials during the animation.

2. Create a sphere

      +------+
      | Root |
      +------+
         |
     +--------+
     | sphere |
     +--------+

3. Create a level object named as "level" and set the mapping flag of it,
   using Modify/Properties/Attributes.

            +------+
            | Root |
            +------+
              /  \
             /    \
     +--------+ +-----------+
     | sphere | | level (T) |
     +--------+ +-----------+

                             - TUTORIAL 3.19 -

4. Create the "result" mapping using parallel mapping.

            +------+
            | Root |
            +------+
              /  \
             /    \
     +--------+ +-----------+
     | sphere | | level (T) |
     +--------+ +-----------+
                  /
             +--------+
             | result |
             +--------+

5. Create a level object called "keys" with the animation method MORPHING
   CLOSED.

            +------+
            | Root |
            +------+
              /  \
             /    \
     +--------+ +-------+
     | sphere | | level |
     +--------+ +-------+
                  /    \
           +--------+ +----------+
           | result | | keys (M) |
           +--------+ +----------+

6. Create parallel mappings key1, key2 and key3 inside the morphing object
   "keys". Each mapping should have different shape, size and position.

            +------+
            | Root |
            +------+
              /  \
             /    \
     +--------+ +-------+
     | sphere | | level |
     +--------+ +-------+
                  /    \
           +--------+ +---------+
           | result | | keys(M) |
           +--------+ +---------+
                       /   |    \
                      /    |     \
                +------++------++------+
                | key1 || key1 || key1 |
                +------++------++------+

7. Set the Modify/properties/Attributes/WF-Invisible flag for "keys(M)"
   level if you don't want to see all mapping wireframes.

8. Now use one material window and two  view windows for rendering the
   animation. Load the material "result" into the material window so that
   you can see how the properties of it are morphed during the animation.
   Set the View/Drawing Set/Render_Wire flag of one view window so that
   you can see how the wire-frame representation of the result mapping is
   morphed. Use, for example, Lampless mode shading on the second view
   window so that it shows the animation using ray tracing.

Support example:
Examples/Materials/mat_morphing

Example 4:
Using an intelligent object to modify material properties

One possible way to morph material properties over the time is to use one
intelligent object for that purpose. Usually methods are used for defining
how objects with which they are associated behave, but nothing prevents us
from using them for defining how materials behave as well.

1. Create one material, "wood".

2. Create one sphere, one (parallel) mapping and one empty level.

               +------+
               | Root |
               +------+
               /   |  \
              /    |   \
     +--------++------++-------+
     | sphere || wood || level |
     +--------++------++-------+

3. Select the "level" and select the menu Animate/Create/RPL. This
   function opens a requester allowing you to define a short RPL program
   to be associated with the selected object. Type the following program:

   "attr(wood->bril)=Time*100"
   EVAL DROP

                             - TUTORIAL 3.20 -

4. Open the material window and load "wood" material into it. Play the
   animation and you will see how the object "level" modifies the
   brilliance of the material "wood".

Support example:
Examples/Materials/mat_RPL_anim

Hint:
It is pretty easy to think of more sophisticated ways to use this
technique to animate material properties. First of all, the procedure
itself could be much more complex. Furthermore, the object with which the
procedure is associated, could contain sub-objects, tags etc. For example,
the velocity tag (which defines the speed of the object for particle
system methods) could be used for defining the brilliancy of the object.
The higher the speed the more reflective the object becomes.

The techniques that have been presented here are not the only ones. There
are some even more fundamental ways of implementing material morphing.

For example:

- you can recreate the material for each frame instead of modifying the
  existing one. This makes it possible to define all the material
  properties without any limitations.

- you can define a set of materials, save them to a file and just load
  them in when the time reaches a certain value.

- you can write your own material handler formulas or RPL procedures
  which may depend on animation time.

- you can use SIZE method to resize spherical mappings with Local scope
  handlers about their center points with the effect of each material
  growing respectively.

The possibilities are many...

                             - TUTORIAL 3.21 -



Chapter 4 MODELLING
-------------------

4.1 FREE FORM MODELLING AND POINT EDITING

In this chapter we shall investigate the modelling techniques of REAL 3D
which are best suited for creating free form objects such as a human face.
The approach is based on curves and mesh surfaces whose points can be
freely edited to obtain a desired shape. The usual procedure for creating
a free form surface is the following:

1. Create some curves which contain enough information of the basic shape
   of the surface.

2. Manipulate and edit curves if needed.

3. Use a suitable tool to build a surface from the curves.

4. Use linear and nonlinear modifications to edit the overall shape.

5. Use point editing for details and fine tuning.

4.1.1 CUrves

A curve, which is a sequence of pints in space, is an important object in
free form modelling. The free form tools of REAL 3D create surfaces by
combining curves in different ways. Another context where curve data is
needed regularly is animations: motions in REAL 3D animations can be
defined using curves.

There are two classes of curves in REAL 3D: open curves and closed curves.
The result of many operations depend on this difference. For example, when
defining a path for an object, a closed curve gives a different result
than an open one, even if the start and the end point of the latter
coincide.

A curve can be "evaluated" in two ways:
- as a polygonal line, "polyline"
- as a Cubic B-Spline

The term "evaluate" in this context means that the points which define the
curve and which are used to control the curve are used as an input in a
calculation process which produces another curve. The result curve, which
may not pass through the original points, is the actual shape which is
used.

A "polyline" simply connects the points of the curve with straight lines.
The curve will have sharp edges.

To create a polyline:

1. Select Create/Controls/Open line.

2. Use the left mouse button to add new pints to the end of the curve.

3. When the curve is ready, use the right mouse button to end the
   definition.

The following special options are available during curve creation: - <DEL>
key removes the given points one by one. - <BACKSPACE> key closes/opens
the curve.

The B-Splines in R3D2 are controlled in a conventional way using control
polygons. The actual curve generated from control polygons can produce
somewhat surprising results until the properties of B-Splines are
understood. So called "knot-points" are the points that the curve actually
passes through.

To experiment with B-Splines, select a View window and use View/
Drawing_Set to open the Drawing Settings requester. Turn on "C. Polyg."
and "Knots" gadgets and make sure that "Curves" is also on.

Now try creating some B-Spline curves and observe the effects. With the
Drawing settings set as above, you will see the control polygon, a smooth
B-Spline curve (evaluated from the control polygon), and a series of
"knot points" on the curve.

                             - 4.1 TUTORIAL -

The first knot-point tends to be near the second control point, and there
are always two less knot-points than control points. This means there must
always be at least 4 control points. Don't become confused by closed
B-Splines, their first knot-point and last knot-point are the same point.

Open B-Spline:   knots = cpoints - 2
Closed B-Spline: knots = cpoints

When using Controls/B-Spline Ctrlp, you define the curve by defining the
control points. This usually produces the "smoothest" result, although it
requires some experience when it comes to shape control.

Controls/B-Spline Knot inputs the actual knot-points, and then constructs
a B-Spline which passes through these points. This method can be the
easiest to control.

Controls/B-Spline Curve shows the actual B-Spline curve while you define
new points.

The following simple test shows one new property of B-Spline curves:

1. Select View/Drawing Set menu, deactivate "C. Polyg." gadget and exit
   Drawing settings requester by clicking OK.

2. Draw a B-Spline curve.

3. Select Modify/Linear/Move and move the curve to a new position.

You can see that even though your drawing settings leave the control
polygons invisible, when you modify B-Splines REAL 3D automatically uses
the control polygon representation for speed reasons.

4.1.1.1 Special Curve Shapes 

There are several useful curve shapes available in the Create/Controls
menu. Some examples are presented below.

Circular curves can be created using the Circular Line or the B-Spline
Circle functions. Both work in a similar way:

1. Select e.g. Create/Controls/Circular Line.

2. Click the center point position.

3. Shape a circle.

4. Type a suitable point number for the curve when the program asks for
   "Subdivision" click OK. Usually the default value 8 is sufficient.

You can also easily create Helix curves:

1. Select Create/Controls/B-Spline Helix.

2. Define a suitable point number and an angle for the helix. For example,
   the default angle 6 gives about one revolution around the axis. Select
   OK.

3. Click the center point position.

4. Shape a cylinder, which defines the size of the helix.

4.1.1.2 Multiple Control Points

The term "mutiple control point" means defining several control points at
the same location. The corresponding curve points are called "multiple
knot points". The alternatives and their results are:

                             - TUTORIAL 4.2 -

- Single control point - normal "smoothing"
- Double control point - almost sharp angle, still somewhat rounded
- Triple control point - sharp angle, or "corner" curve goes through the
  control point.
- Higher number of control points do not produce further changes in shape

Figure T4-1: The Effect of Single, Double, and Triple Control Points.
             (PICTURE: T4-1)

Controls/B-Spline Curve function uses triple knot points at the beginning
of the curve automatically to pull the curve to the given start and end
positions.

Note:
Multiple control points not only alter shape but also the "evaluation
speed". This means that when using such curves as motion paths, the speed
slows down in those curve parts which correspond to multiple control
points and can even stop at the triple knot points.

4.1.2 Selecting Points

When free form modelling it is often necessary to make fine adjustments
to selected points on the surface of an object. Manipulation of the object
as a whole does not always allow for sufficient detail to get the desired
result. REAL 3D includes support for single and multiple point selection
enabling pointwise editing of freeforms. This kind of point editing is
only possible with free form curves and meshes. Point editing is not
possible with CSG objects such as cubes and spheres etc.

There are two ways to point edit freeforms:
- Direct B-Spline knot point editing one point at a time (using Move
  Knotpoint)
- Point editing using sub-groups.

The following examples demonstrates both:

1. Draw an "s" with a B-Spline curve. Use e.g. Create/Controls/B-Spline
   Ctrlp., and define the shape using 8 control points.

2. Select View/Drawing Set and activate "C.Polyg. , "Knots" and "Curve"
   gadgets, so that REAL 3D displays all the B-Spline information.

3. Select the B-Spline curve you created.

4. Select menu Modify/Freeform/Move Knot point and click near one of the
   "knots". Then move the mouse to a new position; you can see the curve
   follow the mouse. <LMB> click at the new position.

The second point editing method offers a more the abili to put selected
points in a "group" or "sub-group" relating to a free form. Example:

5. While having <SHIFT> key down, drag a box around top half of the curve.

6. Select Create/Structure/Group. A new object called "group" appears in
   myour Select window.

7. Select a modification function, for example Modify/Linear/Rotate, and
   modify the "group". Only the points in the "group" are affected by the
   modification action while the rest of the curve remains unchanged.

8. When the modifications are complete and you no longer need to reference
   the particular "group" that you have defined, use Modify/Hierarchy/
   Delete to delete the "group".

                             - TUTORIAL 4.3 -

This example demonstrated how to create a sub-group of a freeform, Groups
are "objects" in a hierarchy and they can be saved along with the freeform
object. Also, you can modify groups with all the modification functions,
Groups can even be animated: for example, the action of a mouth forming
words could be the metamorphic between "mouth" sub-group key shapes of a
"face" freeform!

4.1.3 Freeforms as Levels

In the previous example "Selecting Points", the technique of creating
groups consisting of points of a curve was explained. The usage of a group
in many cases can be temporary and its modification straight forward.
Attention to its position in hierarchy was not of great importance.

However all freeforms can contain hierarchical sub-structures in the same
way as levels. The main intention for this feature is for storing groups
related to the freeform. If groups are multi-selected along with their
parent freeform, and a modification is applied , then the points of the
group will be modified at least twice; once for the freeform and once for
the group itself. If the groups are placed within the parent freeform then
accidental multiple-modification can be controlled.

Secondly, it is natural to put sub-groups of a freeform under itself in
the hierarchy.

The following examples of freeform surfaces will demonstrate how to use
this feature.

4.1.4 Freeform Surfaces

REAL 3D includes a set of powerful functions which can create point
editable freeform meshes from curves. The program supports 3 mesh classes:
open meshes, cylindrical meshes, and tours meshes.
A mesh surface consists of a regular grid of curves which usually shows
the shape very clearly. The regular representation also allows some
special surface manipulation techniques such as "remapping" which is
described later.

Mesh objects are always hollow. This means that you can use the Boolean
operations to cut them, but you cannot use them as tools to cut with.

Freeform surfaces are similar to curves in the sense that the actual point
data defining the mesh can be "interpreted" or "evaluated" in several ways
such as:

- Polygonal surface
- Phong shaded surface
- Cubic B-Spline surface

The first two produce the same shape, although their shading is different.
B-Spline surface approximates the control polygon mesh in a similar way as
B-Spline curve approximates the control polygon: the result is a strongly
"smoothed", nicely curved surface. You can control the evaluation method
(the "type" of mesh; polygonal, phong, b-spline) using Modify/Freeform/
Type function.

4.1.4.1 Example: Creating a Simple Mesh

The easiest way to produce a freeform surface is to use Create/Freeform/
Mesh function. This function produces an open, rectangular mesh with the
desired control point resolution. To make the tutorial example more
interesting, we will experiment using a freeform as a level as described
earlier in chapter 4.1.3, "Freeforms as Levels".

                             - TUTORIAL 4.4 -

1. Hit <RAM>d to open Drawing settings requester, deselect "Knots" and
   "Curve", select "C, Polyg.", and exit the requester using the OK
   gadget.

2, Take a top view - <RAM>z - and select Create/Freeform/Mesh.

3. When REAL 3D asks the resolution of the mesh, suggesting 8*8, click OK.

4. Shape a square in the same way that you would create a rectangle
   (remember: two separate <LMB> clicks on opposite corners- do not "drag"
   it!)

5. REAL 3D creates a primitive "mesh". Double-click it on the Select
   window, and you notice that it becomes the current level even though
   it is a primitive.

6. Next create some subgroups, this time by using the quick keyboard
   method. Press the <Ctrl><SHIFT> keys and drag a box around every 3rd
   point of each of the four middle rows, as shown in the figure T4-2.
   Create 3 more similar four point groups. The four groups together
   should cover the middle square of the mesh.

Figure T4-2: Sub-grouping a Mesh  (PICTURE: T4-2)

Now you have created a mesh with a sub-structure consisting of 4 groups.
The groups are in the right place in hierarchy, under the mesh itself.

Now modify the mesh in the following way:

7. Hit <RAM>x to get front view.

8. Select 1st and 3rd group and Modify/Linear/Move them upwards.
   Then select 2nd and 4th group and Modify/Linear/Move them downwards
   (see the figure below). This will produce a zig-zag of ridges and
   valleys on the mesh.

Figure T4-3: Modified Mesh  (PICTURE: T4-3)

Support example:
Examples/Freeform/simple_mesh

Now the test mesh is ready for visualization experiments (or lets "see"
what we've got). So far the simple mesh looks quite simple indeed, but by
adjusting the drawing settings a beautiful B-Spline surface is revealed:

9. Hit <RAM>d, deactivate "C. Polyg", activate "Curves" and select OK.

A smooth surface is drawn. It is "smaller" than the original control
point mesh. Remember how B-Spline curves were influenced and controlled
by "control points" , B-Spline meshes are controlled in a similar way.
It will take 2 additional curves (in both u and v directions) to define a

                             - TUTORIAL 4.5 -

B-Spline mesh than for a similar polygon or Phong shaded mesh. You must be
careful when modelling to keep in mind that the mesh shape that you define
as a polygon will not yield the same shape if converted to a B-Spline.

To get a more detailed visualization of the B-Spline surface:

10. Hit <RAM>d, adjust both "Curve Subdiv." "and "Surface Subdiv" to 7,
    activate "Draw v" gadget and select OK.

Figure T4-4: Dense Wire-frame Representation  (PICTURE: T4-4)

Now the densely draw wireframe very clearly shows the shape of the mesh
These tests have shown some useful properties of B-Splines:

- A small amount of control points are sufficient for producing curved
  surfaces making point editing easy and memory consumption low.
- Visualization density is independent of the shape.

Next we will get a ray traced visualization of the mesh:

11. Use <RAM>s to open Render settings requester. Select Environment mode,
activate B-Spline->Phong gadget, adjust "Subdivision" to 1 and click OK.

12. Use <RAM>r to render an image in your view window.

The B-Spline mesh is rendered using Phong-shading. This produces a faster
preview of the surface and will properly represent the shape of the
B-Spline. This technique is an excellent way of getting a quick preview
of your B-Spline object. Rendering B-Splines will take more time than a
quick Phong shaded representation and this can be used when modelling as
a time saving feature. Rendering using Phong shading looks smooth but
there may be some visible artifacts, especially the profile of the mesh
may look a bit "edgy".

The Phong shading quality can be controlled using "Subdivision" gadget in
the Render settings: the higher the value, the better the quality, but
unfortunately more memory and time is required. The value 1 is usually
suitable.

                             - TUTORIAL 4.6 -

To get true high-quality B-Spline shading you can deactivate the
"B-Spline->Phong" function gadget and set the subdivision back to 2. The
advantage of this method is that it shades with extremely good quality
with no "edge stepping", and still does not require much memory. The
complexity of the calculations do however involve longer rendering times.

Finally, try rendering the mesh in Draft mode. You automatically get
shaded polygons in shortest possible time.

4.1.4.2 Coplanar Sweeping

Another easy way to define a surface is using a coplanar sweep. The
surface is obtained by sweeping a curve along another curve.
For example, to create "a roll of paper":

1. First define a "profile curve", which shows the intersection shape of
   the surface. Take a side view (<RAM>y) and use Create/Controls/B-Spline
   Knot to draw a straight horizontal line between two points.

2. Then Define a "sweeping curve": Use <RAM>x to get front view again and
   select Create/Controls/B-Spline Curve. Then draw a spiral, starting
   from the point where you see the "profile curve", drawing smaller and
   smaller circles (see the figure below).

3. Multi-select the two curves and select Create/Freeform/Coplanar sweep.

4. Delete the two curves (the mesh is created and you don't need the
   original two curves any longer).

Figure T4-5: Coplanar Sweep  (PICTURE: T4-5)

Support example:
Examples/Freeform/roll_mesh

Now lets bend "the paper roll". There is a problem: the profile curve was
a straight line, and there are no control points in the middle to bend.
You can verify this by activating Drawing Set/Control Polygon drawing
gadget and deactivating Curve gadget. Therefore:

5. Select Modify/Freeform/Reparametrize, select "w" gadget and OK. A new
   curve should appear in the middle of the roll. If not, select the
   function again and use "h" gadget this time.

6. Take a side view to the roll, select Modify/Bend Global/Move 2D, click
   at the top end and bottom end of the roll. Then grab the roll from the
   middle and bend it until the form is suitable.

                             - TUTORIAL 4.7 -

4.1.4.3 Orthogonal Sweeping

Othogonal sweep is quite similar to the coplanar sweep. But while moving
the profile curve along the sweeping curve, the profile curve is also
rotated according to the direction of the sweeping curve.

An example - creating a freeform tube:

1. Use <RAM>y to take a side view, Select Create/Controls/B-Spline
   Circular and create a 6 point B-Spline circle (the profile curve in
   this example); the size of it defines the radius of the tube.

2. Hit <RAM>x for front view, select e.g. Controls/B-Spline Knot and draw
   a sweeping curve, starting from the middle of the profile curve. For
   best results, draw/modify the sweeping curve so that the profile circle
   is perpendicular to it at the beginning (see the figure below).

3. Multi-select the profile curve and the sweeping curve, FOLLOW THIS
   SELECTION ORDER. Order is important Deselect all objects, press
   <shift>, click the profile curve on Select window, then click sweeping
   curve, then release <SHIFT>.

4. Select Create/Freeform/Orthogonal.

Figure T4-6: Orthogonal sweep  (PICTURE: T4-6)

Support example:
Examples/Freeform/orth_sweep

It is important that you place the profile curve at the beginning of the
sweeping curve, orthogonally to it (see the figure above) because the
profile is swept relative to the initial position.

If the radius of the tube seems to vary too much, delete the mesh and then
use Modify/Freeform/Reparametrize to increase the points on the sweeping
curve control polygon before applying the orthogonal sweeping again.

4.1.4.4 Rotate - Creating a Wine Glass

Rotation-function is a special case of orthogonal sweep: the sweeping
curve is circular. We use the classical example of creating a wine glass
for the demonstration:

1. Hit <RAM>e to get a good orientation.

2. Select Create/Controls/Axis and draw a vertical line on the window.
   The length of the line does not matter, except that a long line is
   helpful when drawing the glass profile.

3. Select Create/Controls/B-Spline curve and start drawing the profile
   curve from the middle of the inner surface of the glass (that point
   is on the vertical axis). Shape the glass profile upwards, then down
   along the outer surface of the glass, and finally pull the curve back
   to the axis (see the figure below).

4. Multi-select first the profile curve, then the axis, in this order.

5. Select Create/Freeform/Rotate. When REAL 3D asks "Subdivision", enter
   6 and hit OK.

                             - TUTORIAL 4.8 -

Figure T4-7: Wine Glass  (PICTURE: T4-7)

Support example:
Examples/Freeform/wineglass

The rotation produces somewhat thinner glass than the original profile
curve. You can compensate for this easily by taking a top view and using
Modify/Linear/Size 2D to increase the diameter of the glass until it is
suitable. Also, increasing the subdivisions has a similar effect, but is
not wise to use too many control points which will consume extra memory
for this simple shape.

4.1.4.5 Swinging

Swinging is a generalization of the previous rotation function. It inputs
a swinging curve, which scales the radius of the rotated profile curve or
moves it.

An example of applying swinging is the creation of a spiral shaped surface
as shown in the figure T4-8:

1. To make accurate modelling easier, select View/Grid/Snap to Grid;
   also, hit <RAM>e to reset the scale.

2. Use Create/Controls/Axis to draw a vertical line on the display.
   Modify/Properties/Name it "axis".

3. Select Create/Controls/B-Spline Closed and draw a low rectangle to the
   left side of the axis. Use double clicks in each corner, to get
   suitably rounded edges. Modify/Properties/Name the curve as "profile".

4. Take a top view by hitting <RAM>z. Then select Create/Controls/B-Spline
   Helix, set "Subdivision" to 24 and "Angle" to 24 (this will give about
   4 revolutions). Then shape the helix around the axis; the exact size of
   the radius does not matter. Modify/Properties/Name the helix as
   "swingcurve".

5. Use <LMB> to place the "cursor-hot-point" at the center of the helix.
   We need the "cursor-point" to define the center of the helix so that we
   can easily define the bending axis for a radial bending that we are
   going to perform next. It is easy to define the 'pint when looking at
   the helix from the top view, then, when we go to the side view the
   middle point is already defined. Now hit <RAM>x.

6. Make sure that the helix is still selected and choose menu Modify/Bend
   Linear/Size Radial. Then click in the middle of the bottom of the
   helix, and then in the middle of the top of the helix (so you draw a
   line along the original axis having the same height as the helix
   curve). Then "grab" the helix curve at its topmost outer edge point
   with a <LMB> click and move the point to the axis by clicking on the
   axis. The shape of the helix should then become conical.

                             - TUTORIAL 4.9 -

7. Take a top view again (<RAM>z) and verify that all the 3 curves are
   properly positioned. Modify/Linear/Rotate the helix curve so that the
   lowest point, furthest away from the axis, starts from the profile
   curve. See the figure below.

8. Then go back to the front view; select Modify/Linear/Extend, click in
   the middle of the bottom of the helix, then on the top, and extend the
   helix upwards, until the length is suitable. Also, move the profile
   curve in direction of the axis until the start point of the swinging
   curve is at the same height as the profile curve.

9. <SHIFT> Multi-select the profile curve, the axis, and the swinging
   curve, in this order.

10. Select Create/Freeform/Swing&Size. REAL 3D creates a freeform shape.
    You can then delete the three curves.

Figure T4-8: Example of Swinging  (PICTURE: T4-8)

Support example:
Examples/Freeform/swinging

4.1.4.6 Cross-sectional Surface Construction

Surfaces can be constructed by joining cross-section curves together. This
is demonstrated by the following example creating a smooth edged "L"
shaped logotype letter.

The logotype consists of two flat polygons which form the front and back
surfaces, and a cylindrical B-Spline mesh which bevels the edges and forms
the side surface of the logo.

1. Start the example by resetting the display: Activate the View, hit
   <RAM>e, select View/Type/Parallel, and activate View/Grid/Snap to Grid,
   and select View/Drawing Set/Curves & Knots & C. Polyg.

2. Select Create/Visibles/Polygon and draw a "L" shape (figure T4-9).

     +---+
     |   |
     |   |
     |   |
     |   |
     |   |
     |   |
     |   |
     |   |
     |   |
     |   |
     |   |
     |   |
     |   |
     |   |
     |   +----------+
     |              |
     |              |
     |              |
     +--------------+

Figure T4-9: Front Surface of the Logo is a Polygon

3. The first cross-section curve must match the polygon edge. Because we
   use B-Splines, we must use triple control points in every corner Select
   Create/Control/B-Spline Closed, start from top left corner of the
   polygon and draw the curve along polygon edge clockwise, carefully
   <LMB> clicking 3 times in each corner. After defining the points in the
   last (bottom left) corner, finish the curve by hitting <RMB>.

If you did everything correctly, the new curve travels exactly along the
edge of the polygon.

Just as we used triple control points to pull a curve to a point, we now
use the triple curves to pull a B-Spline surface to a curve!

                             - TUTORIAL 4.10 -

4. Select the curve and use Modify/Structure/Duplicate twice, so that the
   result is three identical curves.

This triple curve technique is important when modelling with B-Splines and
you will probably need it frequently. But now, lets create the next cross-
section; a slightly larger rounded B-Spline, around the polygon.

5. Select Create/Controls/B-Spline Closed and start drawing a new curve
   around the polygon. This time maintain a suitable constant distance
   from the polygon, say two grid units. Remember this distance: it will
   be used as a general "rounding" radius during the later steps of this
   example. To get the best result, use the same amount of control points
   as in previous curves, three points at each corner, but do not put them
   at the same positions.
   Distribute the three points symmetrically around each corner as shown
   in the figure T4-10: one point 2 grid units before the corner, one at
   the corner and one point two grid units after the corner (in the figure
   T4-10 it is assumed that the first three curves were drawn starting
   from the top left corner). Remember that you can undo points using
   <Del> key.

Figure T4-10: Fourth Cross-section  (PICTURE: T4-10)

The 4th curve was drawn to the same plane as the polygon. This will allow
the B-Spline surface to join the polygon smoothly and tangentially. The
next cross-section will make the surface bend backwards:

6. Use Modify/Structure/Duplicate to create a copy of the 4th curve.

7. Take a side view (<RAM>y) and move the copy two grid unit backwards.

8. Duplicate the 5th curve and move it again, say, 4 grid units backwards.

9. Duplicate the 6th curve and move it 2 grid units backwards.

After steps 5-9, you should have four identical B-Spline curves in a row,
as in the figure below. Continue working using the side view in the
following way.

10. Multi-select the first three curves (the ones matching the front
    polygon edge) and Modify/Structure/Duplicate them.

11. Move the three copies 2+4+2 = 8 grid unit backwards, to the same
    position as the backmost curve is located.

12. Select the front polygon, duplicate it, and move it to the back as
    well.

13. Use <RAM>x to go back to the front view and verify that all the items
    are correctly centered around the first polygon.

14. Now multi-select all the cross-section curves in their creation order
    (do not include polygons) and select Create/Freeform/Build from
    Curves.

15. If the result seems to be OK, delete the curves.

                             - 4.11 TUTORIAL -

Figure T4-11: Side View of the Section Curves and the Final Surface
              (PICTURE: T4-11)

Support example:
Examples/Freeform/Logo.

When using cross-sectional surface construction, for best results, each
curve should have the same number of pints and the curves should be
oriented in the same direction (not one clockwise and one in a counter
clockwise loop). Also the start points of the section curves should be
located along the same longitudinal direction.

4.1.4.7 Mesh-Pixel Tool

When using the second variation of the pixel tool, Mesh-Pixel Tool, the
bitmap is taken as a height map when creating a free form surface. The
brighter the pixel colour, the higher the peak there will be on the
correspnding place of the surface.
For example, you can create a free form ground surface for a landscape:

1. Start a paint program and draw a small (try 20*20 pixels) height map
   or edit a digitized map image (remember that the intensity of the
   colour red defines the height of the bump). Save this map as a brush
   to the ram disk.

2. Choose Create/Freeform/Mesh-Pixel Tool. Now the file selector is
   displayed, select the brush you saved to ram disk.

3. Next, you can define the size and location of the object mesh that
   will be created by defining a rectangle in a View Window.
   The object is then created.

4.1.5 Modifying Curves and Meshes

The functions of the menu Modify/Freeform can be used to manipulate free
form objects in many ways.

Remap function is a very powerful feature of REAL 3D. With it, you can
modify the number of the points with which a curve or a mesh is
represented. Increasing the point number makes it possible to add more
detail to the shape. The basic form can first be roughly defined then the
remap function can be used to add more points and thus obtain more control
over local details.

The ability to decrease the point number is useful if a shape must be
substantially altered, a small number of points is easier to control.
Remember of course that if you first decrease the point number and then
increase back to the original number, you do not always get the same exact
shape. A small number of points cannot contain the same amount of detail
as a larger number of points.

                             - TUTORIAL 4.12 -

To modify the pointnumber of a mesh:

1. Select the mesh.

2. Select Modify/Freeform/Remap.

3. REAL 3D displays the current counts and requests the new point counts.
   Define suitable numbers and click OK.

Another reason for decreasing the point count is related to memory: if you
cannot render a free-form surface because of lack of memory, you can
reduce the number of points in the scene until the rendering succeeds.

Modify/Freeform/Reparametrize is a special case of Remapping. It can only
increase the point count-it doubles the amount of control points in each
dimension, but it does this so that the shape does not change. Normal
remapping may cause minor changes.

The distribute-function re-distributes the control points of a curve
evenly along the curve length. This can be used to smoothen the shape of
a curve or a mesh. For example directly hand drawn or bitmap vectorized
curves tend to have unwanted irregularities; these can be eliminated with
this function. (Another way to do this kind of modification is to Remap
the point count down until the shape is smooth).

If the object to be re-distributed contains relatively few points, the
operation may change the shape quite radically. The results of
distributing a mesh which is densely populated with points are easier
to predict.

When creating a curve, the curve can be closed using the <Backspace> key
option. An open curve can be closed afterwards using the closing function:

1. Select the curve.

2. Select Modify/Freeform/Open/Close.

3. Select "u" gadget and hit OK.

Note that you can use the same function to open the curve; by deactivating
the "u" gadget.

In a similar way, you can use the function to change the mesh type between
open, cylindrical, and torus types.

It is possible to connect two curves together using the Concatenate
function:

1. Select the curves that you want to concatenate (join).

2. Select Modify/Freeform/Concatenate.

A new curve is created; original curves remain unaltered. If the result is
not what you wanted, just delete the new curve and check the following
things:

- If the second curve was concatenated (joined) to the beginning of the
  first, multi-select the curves in the opposite order before applying
  the concatenate function.

- If the concatenation (joining) occurs from the beginning of the first
  curve, not from the end, select the first curve and use Modify/Freeform/
  Swap Direction function to reverse the curve before concatenation.
  Similarly, if concatenation uses the wrong end of the second curve,
  swap the direction of that curve before joining.

In the same way, you can concatenate meshes. But with meshes there are
even more ways to do the concatenation. Each mesh has four sides instead
of two ends. The additional control is provided by "Exchange u&v"
function, which exchanges the two mesh dimensions internally.

In general, this u & v orientation and evaluation direction of freeforms
play quite a big role in freeform modelling. When you activate View/
Drawing Set/Knots gadget, REAL 3D displays u & v symbols and arrows on
curves to assist you.

                             - TUTORIAL 4.13 -

Many freeform surface manipulations are easier to perform by splitting
the surface back to curves.The curves can then be manipulated and then
surfaces can be rebuilt from curves. The menu Modify/Freeform/Surf. to
Curves performs this task. You can control the direction in which the
surface is split into curves by using Exchange u&v function.

For example, to break a mesh into two:

1. Select the mesh.

2. Select Modify/Freeform/Surf. to Curves; the curves are produced, and
   you can delete the original surface.

3. Multi-select the first half of the curves and use Create/Freeform/Build
   from Curves function. Then select the rest of the curves and apply
   "Build from Curves" again.

You may also include the "break-point curve" in both halves or even
duplicate it twice to get a triple curve before joining the curves.
This will help to close the gap between the surface halves when using
B-Splines.

Another example is removing a point from a mesh. To do this, you must
remove the whole curve containing the point:

1. Select the mesh and apply Freeform/Modify/Surf. to Curves.

2. Delete the curve that contains the desired point.

3. Join the curves back to form a surface.

4. If operation was successful, delete the original mesh.

4.1.6 Bending Functions

In addition to conventional modification functions such as move, rotate
or size, REAL 3D contains a large set of nonlinear functions for freeform
deformations.

The first group of such functions consists of "bending" functions. There
are 24 different bending variations available: four different bending
functions combined with six different bending mode combinations.

All the bending functions of the Modify menu first require an input line
(curve) called the "bending axis", which defines the bending interval.
The following picture illustrates the differences between the bending
functions:

Figure T4-12: Bending  (PICTURE: T4-12)

In the picture, the arrow on the left (1-2) is the bending axis, and the
straight cylinder is the original object. The small arrow (3-4) defines
the amount of bending. The lines 1-2, and 3-4 are defined by <LMB> clicks.

Local bending affects the object only inside the bending interval.

Global bending affects the object everywhere.

End point bending bends the object so that in the start point of the
bending axis the bending effect is zero and the effect grows to the
direction of the axis.

                             - TUTORIAL 4.14 -

Linear bending is the skew transformation. (a straight bend originating
from the end of the cylinder defined by the point "1".)

For example, to bend a small curve to a tube mesh:

1. Select the mesh.

2. Select Modify/Bend Local/Move 2D.

3. Draw a line in the middle of the tube and to the direction of the tube;
   the length and position of the line defines the interval (the interval
   is where the bending affects the object).

4. Grab the object by clicking with the left mouse button.

5. Move the mouse to the direction you want to bend the object.

6. When the result is OK, use the left mouse button again.

Each bending method includes two sets of bending options. If the "Move"
version is used, all the points of the object modified are moved as much
to the bending direction regardless of the distance from the point to the
bending axis. If the option "Size' is used, bending becomes
multiplicative: the further the point lies from the bending axis, the more
it is moved. The following picture demonstrates this:

Figure T4-13: Bend&Move vs Bend&Size in Local 2D Bending  (PICTURE: T4-13)

When using the Bend&Size mode, the distance from the bending axis to the
object is important. For example in Fig T4-13, the bending axis was
positioned precisely to the left edge of the cylinder half, therefore that
edge of the object remained the same in the modification. Also the
distance from the point which you "grab" to the bending axis is important:
the greater the distance, the more accurate control you have. If the point
lies on the axis, moving the pointer even a little bit produces a
dramatically change in the shape.

The second set of bending options (3D) defines how the coordinate
direction (the plane perpendicular to where the bending is defined - could
also be called the depth coordinate direction) is taken into account in
the modification. When the "2D" bend function is used, the bending affects
the object on a 2D plane and the depth coordinate is not considered.
The option "3D" affects the object in the depth direction precisely in the
same way as . in the direction of the bending axis; the cursor defines the
middle point of the bending interval in the depth direction. In other
words it affects the object in 3 planes with the "bending axis" defining
the center point.

The "Radial" option directs the modification radially away from the
bending axis.

Figure T4-14: Bending Examples  (PICTURE: T4-14)


                             - TUTORIAL 4.15 -


4.1.7 Example: Creating a B-Spline Head

Use one View window and one Select window for this example.

1. Take a side view (<RAM>y) and create a profile curve of your face
   using the function Create/Controls/B-Spline Curve; about 20 points
   is enough. This function automatically creates triple control points
   at both ends thus pulling the curve to them. Remember that by using
   triple control points you can produce sharp edges, double control
   points produce rounded edges while single control points only pull the
   curve slightly towards them producing a smooth curve. If the result
   is not what you expected, use <Del> key to delete misplaced points as
   you are forming the curve.

Figure T4-15: Face Profile  (PICTURE: T4-15)

2. Modify the created profile curve using Modify/Freeform/Move Knotpoint
   so that it really starts to look like your profile. This function finds
   the nearest knot point of the curve (or mesh) and allows you to move
   it.

3. Create six more cross-section curves each defining a new radial
   "slice" so that the left side of the head is fully represented.

Figure T4-16: Cross-sections.  (PICTURE: T4-16)

4. Take a view from above. Select all curves except the first, set
   "Project/Macro/Record", rotate the curves about 25 degrees, end macro
   recording and select Project/Macro/Spread Current. Hand-adjust the
   first curve and make minor hand adjustments to the other curves if
   necessary. The result should be similar to figure T4-17.

Figure T4-17: Cross-sections, Top View  (PICTURE: T4-17)

                             - TUTORIAL 4.16 -

5. Select all curves in reverse order, duplicate them, and "mirror" them
   in order to create curves for the right side of the head.

Figure T4-18: Cross-sections Doubled and Mirrored.  (PICTURE: T4-18)

6. Select all curves and execute Create/Freeform/Build From Curves.
   This creates a B-Spline mesh which interpolates through all selected
   cross-section curves. Delete the curves. (NOTE: you can save the
   project at any time to be able to start again from any point)

7. Now comes the trick! There are some advantages in creating the head
   using vertical cross-sections (for example, you only have to create 50%
   of the curves needed for the head, because the head is symmetrical).
   However, some details on the face can be defined more easily using
   horizontal cross-sections. So swap the surface parametrization using
   the function Modify/Freeform/Exchange_u_&_v and then execute the
   function Modify/Freeform/Surf.to_Curves. Delete the mesh and modify
   the horizontal cross-section curves (you may have to close them if they
   are open, using Modify/Freeform/Open/Close).


Figure T4-19: Horizontal Cross-sections  (PICTURE: T4-19)

8. Now create the head again with Create/Freeform/Build_From_Curves,
   Modify/Freeform/Exchange_u_&_v, Modify/Freeform/Surf.to_curves, edit
   vertical cross-sections and so on until your B-Spline head is perfect.

9. You can use more dense wire-frame representation to render the scene
   by setting the Surface Subdiv field in the View/Drawing_Set requester
   to 5.

Figure T4-20: Dense Wireframe of the Head  (PICTURE T4-20)

                             - TUTORIAL 4.17 -

10. Finally you can render an image: select the menu View/Render/Settings,
    set Mode to LAMPLESS, Subdivisions to 1 and render the head.

Figure T4-21: Ray Traced B-Spline Heads  (PICTURE: T4-21)

Support example:
Examples/Freeform/Head

                             - TUTORIAL 4.18 -

4.2 BOOLEAN OPERATIONS


Boolean operations offer one of the most powerful means of creating and
modifying objects.

Let's consider a situation where an engineer cuts an object made of pine
with a tool that has just been painted. Since the paint on the tool is
still wet, it sticks on the object and the cut surface is "painted" with
the wet paint. The engineer notices this and replaces the tool with
another clean tool, the new cut surface is clean showing the beautiful
texture of the pine. The Boolean operations of REAL 3D work in a similar
way. All Boolean operations are executed in the same way.

1. First select an object to be operated on. (Work piece or target)

2. Then select an object to operate with. (the Tool)

Note:
This is a multi-select process where the order of selection is important.
Target first, then with the <SHIFT> key down click on the tool.

3. Choose an operation.

Both "parameters" of the Boolean operation should be selected when you
execute the operation.

A simple example of a object created with a Boolean operation is a lens.
A lens can be thought of as the intersection of two partially intersecting
spheres.

1. Create a sphere and Modify/Properties/Name it as "lens".

2. Modify/Structure/Duplicate the sphere and move the copy to the right
   so that the spheres are partially intersecting (see the figure below).

3. Use modify/Structure/Name to rename the copy as "tool".

4. Select the first sphere (lens).

5. Press <SHIFT> down and select the second tool sphere so that the both
   spheres become selected.(multi-select)

6. Choose Create/Boolean/AND.

The resuming object will be the part of the work piece that is inside the
tool. It is a lens. In the View windows there are still two partially
intersecting wireframes of spheres visible. Therefore:

7. Select the menu Create/Boolean/Rethink.

This creates a new wireframe representation for the resume of the Boolean
operation.

If you look at the Select window, you can see that the two objects have
been replaced with a new level having the name "lens (A)". The symbol (A)
shows the object type, Boolean AND. If you render your creation, you will
notice that you really have created a lens shaped body. If you change the
material of the lens to glass, it can be used as a magnifying glass!

The results of different Boolean operations between the two spheres are:

Figure T4-22: Boolean Operations  (PICTURE: T4-22)

                             - TUTORIAL 4.19 -

OR is the default operation, which is executed if no other operation is
specified by the user. In other words, when you create objects, you add
matter from one to the other.

Note:
If you position two objects in OR operation so that they partially
intersect, their materials will not fuse. What happens is that REAL 3D
will automatically remove material from the second object to make room
for the first object.

Let's continue experimenting with the lens object. Select the new level
created with the Boolean operation and select Modify/Properties/
Attributes. The AND gadget on the top right corner of the requester is
set, and OR gadget is unset.

If you double-click the "lens" level on the Select window to make it the
current level, you will find the two original spheres under it.

These observations reveal the nature of Boolean operations in REAL 3D:
again, everything is based on hierarchy, and a Boolean operation is just
a hierarchy level. The objects used in these operations can be complex
ones with many levels of hierarchy, and they can contain objects that
resume from previous Boolean operations.

This means that instead of using the procedure described above you can
also make Booleans by adjusting the "attributes" of the level. When you
create a new level, its type is by default OR, but if you want to do
intersection instead of union you can change it to AND using Modify/
Properties/Attributes function. After that, just add the parameters (the
target and tool) under the level. To modify the lens further, we can cut
an oval hole through the lens:

8. Make the boolean AND level "lens" the current level.

9. Create a cylinder and stretch it to an oval form.

10. Locate the cylinder so that its axis goes through the focal points of
    the lens (see the figure below). Make sure that the cylinder is long
    enough to pass through the whole lens.

The hierarchy of the scene is now the following:

     Root
        lens(A)
          lens
          tool
          cylinder

Now render an image of the object. You will notice that there is no lens
with a hole but rather a hole without a lens! All right, actually one
thing was forgotten deliberately, namely inverting the volume of the
cylinder. The resume was the intersected volume inside all three
primitives. To get the correct result:

11. Select cylinder.

12. Select Modify/Properties/Attributes.

13. Activate "Inverted" gadget and click OK.

Now render the object again to see what was originally expected. If a
member of a Boolean operation is inverted, the exterior of it is used to
intersect other objects. In other words, inverted objects cut material in
the volume that they occupy leaving untouched the volume exterior to them.

                             - TUTORIAL 4.20 -

Figure T4-23: A Lens with an Oval Hole  (PICTURE: T4-23)

The object volume inversion is handled automatically when you use Boolean
AND NOT operation. Then all the objects except the first selected one will
automatically get the "Inverted" flag set.

Note:
As the example already shows, Boolean operations may contain any number of
objects. In previous REAL 3D versions, AND was a binary operation
accepting only two parameters.

In REAL 3D it is possible to execute the Boolean operations so that the
tool affects not only the volume but also the surface of the object that
is operating on. This is a very useful feature of REAL 3D. For example,
if you cut a notch in a pine board using a "shiny reflecting" (material
attributes) tool and use AND NOT "with paint operation, you get a "shiny
reflecting" notch on the board.

Likewise, if you use a red lathe you get a red notch. And if you use a
chimney to cut a notch, you get a piece of wood with a notch of brick
coating. On the other hand, if you use any of the non painting operations,
you get a clean notch of pine on your pine board (the wood texture of the
pine board "x-rays" right through the object so that you get a continuity
of the texture). In this case the surface of the tool does not affect
the object that is operated on.

To test this feature:

14. Open palette window (<RAM>p) and change the current colour to black.
    Verify the colour selection by pressing OK gadget and close the
    palette window.

15. Select the cylinder and use Modify/Properties/Colour.

16. Open the Modify/Properties/Attributes requester and activate the
    "Paints" gadget.

17. Render an image.

This time you got a real black hole!

You can obtain the same results by using Create/Boolean/AND with Paint or
AND NOT with Paint functions directly, instead of changing the attributes
afterwards.

Finally, we can make a section diagram of the lens by spItting the lens in
two, using a plane surface. You are already familiar with the two
dimensional plane primitives; circles, rectangles, and triangles. When
used in Boolean operations, these plane primitives are not extremely thin
two dimensional surfaces, but, on the contrary, infinitely thick halves of
space. In other words, a plane divides the space into two halves and
involves one of these halves. The wireframe representations of plane
primitives have a small peak that tells you which side of the plane is
defined by the primitive.

If you set a plane so that it goes through the focal points of a lens,
and then execute AND NOT operation, the half of the lens that is on the
same side of the plane as the spike is removed. The AND operation would
preserve the half that is on the spike's side of the plane.

                             - TUTORIAL 4.21 -

To remove half of a lens:

18. Make "lens (A)" the current object.

19. Create some plane primitive e.g. a rectangle and place it so that it
    goes through the focal points of the lens.

20. Render.

Support example:
Examples/Objects/split_lens

Figure T4-24: A Split, Drilled Lens.  (PICTURE: T4-24)

Now you have made half a lens with an oval hole through it. To REAL 3D it
is a very simple object. You can, for instance, stretch it if you want.
In a similar way you can create more and more complex objects which can be
saved to disk, and used to create new objects, As you complete useful new
objects and tools, using the program becomes easier and faster.
When you execute a Boolean operation, the hierarchical structure of the
object is modified to reflect the resuming object. If you move "lens (A)"
object, you notice that the "hole" faithfully follows the cube when you
relocate the cube. On the other hand, you can select the hole and make it
bigger by re-sizing the cylinder and immediately get another result.
Or you can even create animations where the hole moves, or where the
progression of the hole being drilled is animated, or an object being
turned in a lathe etc. can be demonstrated. Hierarchical implementation of
Boolean operations makes all this very easy in REAL 3D.

4.2.1 Wireframes of Booleans

Wireframe representation of Boolean operations do not necessarily
correspond to the true shape of the object. The easiest way to modify the
wireframe of a boolean operation is to use Modify/Boolean/Rethink
functions:

1. Select the object to be modified

2. Select Create/Boolean/Rethink All.

3. If the resume is not good enough, use the Undo function.

This operation makes all wireframe line segments outside the volume of the
selected Boolean object invisible, usually giving a better representation.
The result of this automatic wireframe modification can then be further
improved by hand. Drawing curves and placing them under the Boolean
operation level can be helpful, and possibly by making some wireframes
invisible.

Rethink functions may sometimes leave not enough wireframe. REAL 3D will
try to represent the objects with a minimum number of lines.

                             - TUTORIAL 4.22 -

The difference between Rethink and Rethink All is that Rethink All
regressively goes through the hierarchy under the selected objects,
whereas Rethink considers only the highest hierarchy level of the
selected objects.

4.3 OBJECT AT TRIBUTES

You can use the Modify/Properties/Attributes operation to get some
information about the objects and to modify this information when
necessary. For example:

- An object can be made invisible in the editor.
- An object can be protected from modifications.
- An object can be made infinite by removing so walled standard limits
  from it.
- An object can be made hollow.
- The bounding planes, i.e. the surfaces at its ends, can be removed
  from a hollow object.
- An object's ray tracing attributes can be changed: it can be made
  invisible, non-existent, shadowless, motion blurred or matt shaded in
  ray trace rendering.
- Object volume and Boolean operation properties can be modified (AND/OR
  type, volume inversion, "Paints" property).

To make a cone invisible in the wireframe mode:

1. Select the cone.

2. Choose Modify/Properties/Attributes.

3. Set the WF-Invisible field on.

4. Choose OK.

After this the cone is invisible in wireframe rendering, but you can still
notice its existence in the Select window and in ray trace rendering.

To make a cylinder into a thin walled tube:

1. Select the cylinder.

2. Choose Modify/Properties/Attributes.

3. Set the Hollow, No 1 st BP and No 2nd BP fields on.

4. Choose OK.

Note:
If the object is not hollow, you cannot remove its bounding planes.

Note:
When the bounding planes are removed from a cube, the planes are removed
so that you can look through the cube in the direction from which the cube
was created.

The following fields:

- No 1st BP
- No 2nd BP
- Infinite

of the Attributes requester affect only primitives: those properties are
not inherited in the hierarchy. Conversely, you can make any complex
object e.g. "Hollow or WF-Invisible".

The "WF-Invisible" function is needed when, for example, the outcome of a
Boolean operation needs editing. All unwanted details, like slight
roundings of the edges of a cube, should be made invisible to make the
wireframe rendering faster.

The "Protected" flag locks the object so that any modification does not
affect it. This can be useful in animations for example.

                             - TUTORIAL 4.23 -

4.3.1 Infinite Primitives

REAL 3D includes many primitives which can be expanded to infinite shapes
in a natural way. For example, a cylinder is a body bounded by a cylindric
surface and two plane surfaces.

Such primitives can be made "Infinite" using Modify/Properties/
Attributes/Infinite gadget. Applying this function makes three dimensional
primitives infinitely long and plane primitives infinitely wide.

To create an infinitely long cylinder:

1. Create a cylinder.

2. Choose menu Modify/Properties/Attributes.

3. Set the Infinite field on and choose OK.

The wireframe of the cylinder is not changed, but if you render an image
of the object you will notice that it is infinitely long.

Plane primitives (polygons, disks, and ellipsoids) are automatically made
infinite when they are used in Boolean operations, unless their "Hollow"
attribute is set; then they act as two dimensional thin surfaces.

4.4 SPECIAL FUNCTIONS

4.4.1 Use of Animation Methods for Creation

Read this Chapter 4.4.1 after getting acquainted with the basic features
of the REAL 3D animation system.

The flexible animation system of REAL 3D can be used as a modelling tool
in many different ways. The following example, creating a chain of
objects demonstrates this:

1. Create an object, for example a cube.

2. Select the cube, then select menu Animate/Create/Direction, and draw
   a path starting from the cube.

3. Select Modify/Properties/Animation, choose "CREATION" method from
   the method list and click OK.

4. Find the original cube from the hierarchy (it is under the level whose
   animation type you just changed to CREATION) and select it.

5. Select Modify/Properties/Tags, click ADD, type "SCRE I=1", hit <return>
   and select OK. This adds the creation condition tag to the cube.

6. Open Animation window, set "Resolution" field to the number of cube
   copies you want to create along the path and play the animation.

7. Delete the creation method level.

Support example:
Examples/Objects/cubesource.

                             - TUTORIAL 4.24 -

4.4.2 COG Modifications

In addition to ordInary "linear" modifications found in the menu Modify/
Linear , REAL 3D includes two sets of "component" modifications: "COG"
modifications and "About COG" modifications.

For example:

1. Use a macro to create a row of cubes.

2. Multi-select the cubes, select Modify/About_COGs/Size 3D, click in the
   middle of one of the cubes and resize it. The rest of the cubes are
   resized similarly around their middle (COG) points.

3. Select Modify/COGs/Rotate, click in the middle of the cube row and
   rotate it. The cube row is rotated, but each cube maintains its local
   orientation.

Figure T4-25: COG modifications  (PICTURE: T4-25)

For example, you can use About - COGs/Size 3D to resize the objects you
have used in Object_Pixel Tool, or leaves of a fractal tree (it is a good
idea to use Modify/Properties/COG function to set the COG to a suitable
position before using the object with the above mentioned tools; this
makes after-processing easier and more controlled).

                             - TUTORIAL 4.25 -

Chapter 5 RENDERING
-------------------

In this chapter we will learn about the rendering engine which is a very
flexible and sophisticated part of REAL 3D. This part of the software
renders images of your scenes using the so called ray tracing principle.
The surfaces of the objects that you have created in the editor are
coloured by creating a mathematical model of reality around them. In this
model light rays are emitted from light sources and then reflected from
object to object until they hit a place which causes vision: your eye
(the camera).

You will find that rendering in REAL 3D is very flexible and quite easy
to learn. From simple draft mode to full ray tracing, you are able to
employ the most suitable modes for your rendering needs. The first
tutorial chapters mainly used draft rendering mode without colours, now
we will explore more exciting rendering modes:

To render a ray traced image of a group of different coloured spheres:

1. Create the spheres.

2. Find a suitable viewing point using the cursor keys.

3. Select View/Render/HAM. REAL 3D opens the render setting requester with
   which you can select: rendering accuracy, picture size, etc. Now change
   the "Mode" field to "Lampless" and select OK.

4. If you want to save the picture after it has rendered in the HAM
   window, use Project/Environment/Save Screen function.

5. Use Project/Environment/Close_Current to get back to the original
   screen, or you could leave the HAM screen open and edit the scene
   there. You can use <LAM>m to jump between the screens.

Note:
If you have started rendering and for some reason you want to stop,
select Extras/Cancel All or hit the space bar.

5.1 LIGHTING SETTINGS

The following gadgets of the render setting requester affect the light
balance and brightness of the image:

Ambient: These gadgets define the amount of diffused reflected light that
is present in the scene. A good real world example of a diffuse reflecting
surface is a white wall in an unlit room on a cloudy day. In the world of
REAL 3D this light is called ambient light. The greater you set the
ambient light intensity , the less contrast there is between lit and the
shadowed surfaces of the objects.

Brightness: The intensities of the light sources can be set to a proper
level with the brightness gadget. When you create light sources in
REAL 3D, you don't have to pay attention to their brightness since the
differences in intensities will be automatically scaled to the appropriate
levels. The scaling is based on the amount of light these light sources
cast on the scene, the brightness ratios of the light sources are
preserved. The outcome of the scaling depends on the value of the
brightness control.

Overlight: This gadget defines what happens in the bright parts of the
picture. If overlight is zero, even the colour of the brightest objects
does not turn to white. On the other hand, if you start to increase the
overlight value, you get more and more overexposed pictures.

Autoexposure: This field sets on the automatic scaling of light sources.
Then the brightness of the picture is determined on the overall brightness
of the scene. This option can be compared with a automatic exposure
function of a camera. This feature is active by default.

                             - TUTORIAL 5.1 -

5.2 COLOR/IMAGE SETTINGS

Background: These 3 gadgets specify the background colour for the picture.
You can set the RGB values by typing them into the numeric gadgets or by
using the Colours/Background local menu.

Backgr. grad: Selects the second background colour which is used for
gradients.

Backgr. gradient: When you activate the Backgr. gradient gadget, REAL 3D
will automatically render the image using the specified colour gradient
as a background.

Environment: The environment colour defines the colour of the surrounding
"space". Reflected light rays, which do not hit any visible objects, will
have this colour.

Envir. grad: The second environment colour used in environment gradients.

Envir. gradient: When you activate the Envir. gradient gadget, REAL 3D
will use a gradient to specify the colour of the surrounding space instead
of a fixed colour. The gradient starts from the Environment colour above
(at the "north pole") and ends to the Environment gradient colour below
(at the "south pole").

The background colours specify an artificial background for the image.
The colours do not interfere with the true objects in the scene. The
environment colours are the colours which are used in the actual ray
tracing calculations. The possibility of specifying these two colour
definitions separately gives extra flexibility, but also means that
incorrect settings can produce a clearly unrealistic or undesirable
results. Therefore, remember the following recommendations:

- If the scene contains transparent objects (especially when clip mapping
  is applied), the environment colour and the background colour should be
  equal, and neither gradient function should be used. If gradients are
  required, use e.g. a hollow 3D sphere around the scene with a suitable
  texture map.

- If the scene contains mirror-like objects but no transparent objects,
  the environment colours and the back ground colours should be equal.
  You can use the gradient functions if you use them both simultaneously.

Other combinations are sometimes useful for effect purposes (e.g. a shiny
golden logo type on a black background).

Note:
The Environment colours have importance only when the scene contains
reflecting/refracting objects.

Background colour can also be provided from an image file. This happens by
specifying the name of the image file to the Backdrop image string field
and by activating the corresponding gadget on the bottom right coiner of
the requester. This overrides the colour and gradient settings. The
backdrop image always fills the background completely and its size and
aspect ratio are adjusted accordingly.

Similarly , the "mathematical" environment colour map (a solid colour or
a gradient) can be replaced with an image file based environment map.
To do this, enter the name of the environment image file to the
"Environment map" string field and activate the corresponding "Environment
mapping" gadget. The image is mapped using spherical mapping to the
surrounding space: the top edge of the image will be mapped to a single
point at the "north pole" above, and the bottom edge of the image is
squeezed to the "south pole" below.

                             - TUTORIAL 5.2 -

If you have to contrOl the mapping type more accurately, create true 3D
objects around the scene (e.g. rectangular walls or a hollow sphere) and
texture map them appropriately.

Both the Environment map and the Backdrop image can be animated by simply
adding an index format string to the name. For example, if the backdrop
image name is "images/backpic%d", REAL 3D uses the name "images/backpic0"
in the first frame, and increments the index in each frame by one.

5.3 RENDERING QUALITY SETTINGS

The following gadgets of the render settings requester affect image output
quality.

Anti-aliasing: You can select a suitable level of anti-aliasing using the
Anti-aliasing gadget. The effect of this function is that jaggies caused
by insufficient picture resolution are smoothed using colour gradients.
If the value is 0, no anti-aliasing is done, but if the value is 2 or 3,
you get quite nice smooth pictures. The only disadvantage is that
rendering gets slower as the anti-aliasing factor increases. If the
rendering is done in 24 bit, increasing the factor may give a visible
improvement in the picture quality. Normally, there is no need to use a
higher anti-aliasing value than 4. The Draft and Outline rendering modes
do not support anti-aliasing.

Resolution: The resolution gadgets specify the resolution of the rendered
picture, that is, how many picture elements are rendered with a single
calculated point. This function is useful for previewing. Using lower than
1 by 1 resolution, for instance 2 x 2, speeds up the rendering and gives
you a quick visual representation of the scene.

Width and Height: It is possible to define the size of the image to be
rendered using Width and Height fields.

When the rendering output target is a View window, the gadgets only
display the current dimensions. When the rendering target is an external
screen, the dimensions are truncated to fit the external screen size;
smaller sizes can be specified. When the target is a disk file (in IFF/
Targa/BMP formats), the picture size is limited only by the operating
system of the Amiga: under Workbench 2.0 or greater the theoretical
maximum is 32768 * 32768 pixels.

5.4 RAY TRACING QUALITY SETTINGS

The render settings requester includes some adjustments which control the
accuracy which the rendering engine uses in ray tracing calculations.

Recursion depth: The recursion depth field defines how far light rays are
traced when they reflect from surface to surface. i this field has a
value of three for example, then only the first three reflections of any
light ray can have any effect on the environment. When an object does
not contain any reflecting or transparent bodies this field does not have
any meaning. If your object contains transparent and reflective materials,
the bigger the value of this field the better and the more realistic the
result. Unfortunately , the rendering time may increase dramatically, so
it is best to keep it as small as possible. For example, if your target
includes one glass sphere, recursion depth of 3 is probably enough. If
your model represents two glass balls and you are looking through both of
them at the same time, recursion depth must be at least five.

Mat. samples: when using non-homogeneous transparent materials, this value
defines how densely the material properties are sampled. Usually the value
can be zero. Some effects will improve with a value 1.

                             - TUTORIAL 5.3 -

Only some special simulations (e.g. gas clouds) may require higher values.

Subdivision: B-Spline shading quality. The default value 2 is suitable for
most purposes. The higher the value, the "smoother" and better quality
shading, but rendering time will increase. The Subdivision value also
defines the subdivision density when converting B-Spline meshes to Phong
or polygon shaded surfaces. This happens when the Draft and Outline
rendering modes are used or when the B-Spline->Phong gadget is activated.
Usually the 0 or 1 level subdivision is sufficient; higher values consume
significant amounts of RAM.

5.5 RENDERING MODES

Mode/Draft: When Draft mode is used, rendering is executed using the so
called draft mode. Here all the objects are converted to a white basic
material which is neither mirror-like nor transparent. It also does not
have any texture. The rendering is done using a single light source that
is in the same place as the observer. The output is always in grey scale.

Draft mode is the fastest ray tracing mode in REAL 3D. Although the speed
is partly obtained by simplifying the model, the mode is adequate for many
purposes such as; previewing before final rendering, or the representation
of technical objects. In the latter example, shadows and reflections may
cause unwanted visual confusion. Fast mode, in combination with a high
resolution, offers an excellent alternative for producing clear and
detailed graphics. Mode/Normal: When the Normal mode is set, a complete
model is used. The rendered picture will have shadows, reflections, etc.

Mode/Shadowless: In this mode rendering is done as in the previous mode
with one exception: the shadows of objects are not calculated. This makes
rendering considerablely faster. The mode is especially suitable for
animation production.

Mode/Lampless: This mode is even faster than shadowless mode. One
automatically inserted light source placed at the view point is used.
Textures, properties of materials, etc. are all taken into account.

Mode/Environment: This mode is almost as fast as the Draft mode. It is
equal to the Lampless mode except that the reflection calculations take
only the Environment colour/gradient or Environment map into account.
The result is that the rendering time is quite constant regardless of
the complexity of the scene, typically from 1 to 1 5 minutes per image.
Nevertheless, some realism is lost, especially when the scene contains
transparent objects.

Mode/Outline: the Outline mode renders a contour picture of the object
which is a hidden line wire frame image.

Note:
If you use Normal or Shadowless mode, remember to create a light source
to illuminate your object. Otherwise all the objects in your picture
would have only ambient light.

                             - TUTORIAL 5.4 -

5.6 DITHERING

Dithering is a method to increase the number of colours available by
mixing existing colours. Dithering works best in high resolution
pictures. You can choose between different dithering methods using the
Dithering cycle gadget. The first dithering method, None, switches
dithering off. The second dithering type, Rnd RGB (Rnd = Random), uses a
separate random deviation for each of the R, G, and B components.

The third dithering type, Rnd intensity, adds the same random deviation
to each colour component.

The next dithering method, Fixed rnd int, also adds the same random
deviation to each colour component, but the dithering pattern is kept
the same in each rendered image. This means that when rendering
animations, the dithering pattern does not "move", and delta compression
methods work better. This is the default method.

Row dithering mixes the colours linewise, not pointwise, thus giving
slightly faster rendering and better image compression.

Raster dithering mixes the colours using regular geometric patterns.

The best one for you depends on the application. Usually, random dithering
gives a good impression of "rough" surfaces, whereas no dithering or
raster dithering produce "sharper and clearer" images. Line dithering is
usually not suitable for interlaced video applications, but it can be used
as a "style" effect for printed images.

The Dither scale slider can be used to define the maximum amount of colour
deviation in dithering. The default value is 64 and the maximum is 256.
The higher the value, the more mixed colours you get.

Note:
That 24 bit rendering output does not use dithering.

5.7 SPECIAL SETTINGS

HL-Shade: This option offers an alternative shading mode. The default
shading mode maintains the proportions of the RGB colour signals when
calculating different shades for the colour of an object. This principle,
which is theoretically correct, does not always produce good looking
pictures when using a limited number of colours and outputting the image.
This happens especially when colours are not pure, that is, when there are
not significant differences between R-, G-, and B- components. HL-Shade
uses additive method instead of proportional method: all the RGB-
components are changed as many units between consecutive shades of a
colour. The original colour may distort, but the result is fine.

Pixel h/w: This gadget allows the user to define the pixel aspect ratio
pixel height/pixel width for rendering. If a value 0 is given, then the
program uses default ratios (for example in LORES-HAM-INTERLACE this
default aspect ratio for PAL is 0.5). If a nonzero value is given, then
it replaces the default pixel aspect ratios.

DOF scale and DOF Strength: These values define the depth of field of the
image. If either is zero, the picture will be sharp everywhere (a pinhole
camera). The higher the values, the more "blurred" the image you get.
DOF scale is a distance-related adjustment: it specifies how quickly the
image goes

                             - TUTORIAL 5.5 -

out-of-focus in front of and behind the sharp zone in the scene. 1.0 is a
good default value. DOF strength specifies the maximum amount of DOF blur
in the image. Typically, the value 2 is quite suitable.

Note:
Draft and Outline modes do not use the DOF feature.

No bgr. antial.: When this gadget is set, REAL 3D does not anti-aliase
object colours with the background colour. This is necessary when the
computer generated image will be combined with video backgrounds. See also
the example "Using Alpha Channel" later in this chapter.

Alpha output: Activates alpha channel output. The alpha information can be
written to the external screen or to a disk file. See the example "Using
Alpha Channel".

Field rendering: When this gadget is set, the renderer calculates every
odd frame half a pixel lower. This feature is designed for producing the
interlaced fields of e.g. the PAL video standard. See the example
"Rendering Fields" in this chapter.

5.8 HIERARCHY AND RENDERING

If two objects overlap, then their materials are not blended, but one
object replaces the other in the space occupied by both. During rendering,
this is significant only when it is possible to see inside the overlapping
space, that is, when transparent materials are used (or when a boolean
cuts the overlapping spice). For example: if a metal sphere is inside a
fog cloud, and the fog cloud has a higher priority, then the metal sphere
is not visible. If the priority is reversed, the metal sphere can be seen
through the fog.

5.9 RENDERING A WIREFRAME PREVIEW OF AN ANIMATION

As a first example of rendering animations, we will consider the fast
wireframe preview. To verify the quality of the motions, you need 25 fps
(PAL) or 30 fps (NTSC) playback speed, which is not possible
interactively. Therefore, you have to save the wireframe images to disk
and then create a delta file which can be played at the desired speed.

Do the following:

1. Create/Load the animation.

2. Use Project/Environment/Open screen to open a screen with suitable
   properties. As this is going to be only a motion preview, we recommend
   that you use for example 1 or 2 deep HIRES screen.

3. Select Project/Windows/View Borderless; this opens a full screen
   window.

4. Close other REAL 3D screens and windows.

Note:
that you can perform the steps 2-4 by replacing the environment
(Project/Environment/Replace) with a ready-made wireframe preview
interface.

                             - TUTORIAL 5.6 -

5. Open the animation window and set its gadgets as specified in the
   following steps.

6. Set Time to zero by: moving the Time slider or by entering the time
   value to the Time gadget.

7. Select the screen to be saved by clicking the name of the screen you
   opened in the screen name list gadget (REAL 3D may already proposed
   the correct screen name on the "Saved" string gadget below the list).

8. Set the Wireframe/Ray trace cycle gadget to "Wireframe".

9. Specify a Screen file name with a full path (e.g. "R3d2:images/
   wireimage"). Verify also that the Format string is suitable.
   The default "%d" is suitable for the REAL 3D deltaconverter.

10. Enter the amount of frames you want to render to the Resolution field.
    Use the same amount of frames as you plan to use with the final
    production, for example 200 frames.

11. Activate the Save gadget.

12. Press the play animation gadget "..>|" and wait until the animation is
    played and saved to the end (you can see it from the time value).

13. Use the Deltaconvert program to create a delta animation as specified
    in the Appendix "Utility Software". Then delete the original frames
    and use Delta Play to play the delta-animation.

It is strongly recommended that you always create a wireframe preview of
your production before final rendering.

5.10 RENDERING AN ANIMATION

When you want to render an animation using ray traced shading, follow the
steps of the previous example 5.9, except that in the step 8, select "Ray
trace" instead of wireframe. Otherwise the procedure is the same.

You can specify the image format to be used by opening a suitable screen.
For example, you may open a LORES-HAM-Overscan screen, or a 16 colour
HIRES-Interlace greyscale screen.

Usually it is best to use one screen with a borderless window as in the
previous wireframe example. REAL 3D always saves the whole screen, the
contents of individual windows cannot be saved separately. If you want to
render small images, open a screen with small dimensions and use a
borderless window. For example, to render a shaded miniature-size HAM
preview of an animation:

1. Use Project/Environment/Open Screen to open a HAM screen. Set the Width
   e.g.to 160 and the Height to 128 (or to 100 NTSC) before opening the
   screen. Then use Project/Windows/View Borderless to open a full screen
   window.

2. Close other REAL 3D screens and windows.

3. Open the animation window, define the HAM screen to be the saved one,
   reset the time, specify the screen file name, select Ray trace shading
   and activate the Save gadget. You may use lower frame resolution this
   time because the wireframe animation preview has already shown the
   motions. The purpose of this preview is to check the shading.
   Rendering one fourth of the final frames is a suitable sample for shade
   checking. Enter e.g. 50 frames to the Resolution field.

                             - TUTORIAL 5.7 -

4. Render the animation and Delta convert and then Deltaplay.

It is strongly recommend that you always create shaded previews of your
productions before final rendering. Using 1/4 of the final frames and
1/20th of the full video resolution, this preview rendering time may be
only 1% of the final rendering time.

5.11 RENDERING TO A FILE

It is possible to render an image directly to a disk file. This may be
necessary if the image resolution is very high (for example more than
normal video resolution). Secondly, this makes it possible to create 24
or 32 bit graphics without having a special frame buffer or other such
display device.

File rendering is selected by setting the Output cycle gadget to one of
the "file" targets. This selects 24 bit rendering and the image is
constructed using over 16 million colours. The renderer writes the image
directly to disk with the file name defined in the "File" string field
and appended by the index specified in the index format string of the
animation window. As usual, remember to add a suitable directory path at
the beginning of the file name, otherwise the images are saved to the
current directory.

Note:
24 bit rendering can create large files, for example, a picture with
1024*1024 pixels may require three megabytes. The file format alternatives
currently available are:

Output/IFF file: The IFF-24 field selects compressed 24-bit IFF ILBM
format output in rendering.

Output/Targa file: The file format REAL 3D uses is the true colour Targa
format which is a popular standard on IBM PC compatible systems.

Output/BMP-file: This gadget selects BMP format output which is also a
popular format on the IBM PC compatible platform.

The following example describes how to render an animation in 24-bit
directly to a disk file.

1. Create/Load the animation.

2. Modify the environment for rendering: leave only one View window open
   and open the animation window.

3. Activate the View and hit <RAM>s to open the render settings requester.

4. Set "Output" to IFF file.

5. Enter the name for the images to the "File" field.

6. Define the size of the image in the Width and Height gadgets, for
   example: 736*564 (PAL) or 736*482 (NTSC) pixels.

7. If the default aspect ratio 1.0 is not suitable, enter the exact value
   to the "Pixel h/w" gadget.

8. Modify other settings to suit and select OK to close the requester.

                             - TUTORIAL 5.8 -

9. Adjust the camera position and the scale of the View window. The disk
   file will include exactly the same view of the scene as you see in the
   window. If you have created a camera object (possibly an animate one),
   activate the View/Observer/Camera view feature to make sure that the
   camera settings will be used.

10. Next define the animation window settings: reset the time to zero,
    enter a suitable amount of frames to the Resolution field, and check
    the index format string. Select "Ray trace" shading. You do NOT have
    to specify a screen to be saved, nor a screen file. DON'T activate the
    Save gadget, unless you really want to save BOTH wireframe images from
    the screen AND the 24 bit images.

11. Press the "..>|" gadget to render the animation.

The essential steps of the file rendering are the steps 4, 5 and 6.
Especially remember to check the image size because the Output cycle
gadget automatically adjusts. The second important, to avoid double
saving, is to not activate the Save gadget of the animation window.

Note:
The View window displays the contents of the disk file image always in
horizontal direction; if the window shape is different from the image
file shape, the vertical contents may be different. For example, if your
View window has the shape of the monitor display and its width is greater
than its height, and you define an image file of 800*800 pixels with the
aspect ratio 1, then the file image is a square, and therefore a wider
vertical area of the scene is included in the rendered file image.

5.12 CONTINUING A CANCEELLED RENDERING PROCESS

When you start rendering an animation it is a good idea to save the whole
project just before pressing the play gadget of the animation window.
If you have to cancel the rendering, it is then easy to continue again by
reloading the project if necessary.

If you have cancelled rendering an animation, but you want to continue
rendering:

1. Load the animation (Project/Project/Replace)

2. Open the animation window.

3. If you are using particle animation methods, set the "Play to/Jump to"
   cycle gadget to "Play to". This is necessary because particle
   animations must be regenerated frame by frame in order to get a certain
   state back; you cannot jump directly in time. In other types of
   animations you can select "Jump to" to go to the desired point in time.

4. Select "Wireframe" shading instead of "Ray trace".

5. Make sure that the "Save" gadget is not selected.

6. Check the index of the last frame that has already been rendered; enter
   the next index value to the "Frame" field and hit <RETURN>. The
   animation is played to that frame. Using the wireframe shading, it will
   get to the desired point quickly.

                             - TUTORIAL 5.9 -

7. Change "Wireframe" to "Ray trace", activate the Save gadget (unless
   you are rendering to file, see the example 5.11) and press the play
   button.

You can also save the project at the time the rendering was cancelled,
and then reload the project back later and just press the play button to
continue rendering. It is usually best to keep a copy of the project in
its initial state (particle animations cannot be "rewound" back to the
beginning).

5.13 RENDERING TO AN EXTERNAL SCREEN

REAL 3D contains a well designed interface for easy access to frame buffers
and other custom display devices directly from REAL 3D.

To use custom display devices, you need a special interface library for
the particular device. REAL 3D software package contains a collection of
such libraries included in the "Accessories" directory. There are more
available in Public Domain and from hardware manufacturers.

Note:
That REAL 3D interface libraries are not the libraries which are written
for the display devices themselves: for example, there exist a
"harlequin.library", but the correct REAL 3D interface library is called
"hr_r3d. library".

In the REAL 3D user interface, display devices are accessed using a so
called "External screen". When using the external screen, the first step
is to install the correct library:

1. Copy the desired REAL 3D interface library from "r3d2:Accessories"
   drawer to your libs: directory.

Of course, the display device itself must first be installed properly.
For example, when using Harlequin, install the board into the machine
according to the manufacturers directions and copy "harlequin.library"
to "libs: directory". Then copy "accessories/hr_r3d.library" to "libs:".

2. Select Project/External Screen/Settings menu in REAL 3D.

3. Type the name of the interface library, e.g. "hr_r3d.library".

Note:
The library name may be case sensitive! Therefore, use capital letters
only if the original name was written in capital letters.

4. Select a suitable saving format. This format is used when you select
   Project/External Screen/Save or when you render animations with the
   save option. The default format, IFF 24, is a good choice. Then select
   OK.

5. Select Projects/External Screen/Open. Something visible may or may
   not happen, depending on how the display device works.

6. You may try to use Project/External Screen/Set Modes function. If the
   device supports multiple modes, you should get some kind of mode
   selector. If something has gone wrong and the external display opening
   was not successful, you will get an error message telling you that the
   external screen is not opened.

                             - TUTORIAL 5.10 -

If the opening failed, check the following:
- Is the device hardware properly installed
- Are all the necessary libraries copied to libs:
- Read the readme file of the interface library (check "Accessories"
  drawer)
- Check that you typed the library name correctly, try typing in lowercase
  letters only.

If the opening was successful, you can render to the external screen in
the following way:

7. Choose one of the view windows to be used as a handle to the external
   screen. Open the render settings requester of the view.

8. Set Output cycle gadget to External. Width and Height Gadgets should
   automatically change to the new dimensions which correspond to the
   full external screen size. You may change them to smaller numbers if
   you do not want to get a full screen rendering.

9. Select other rendering settings and select OK.

10. Find a good viewing angle (or camera position) in the view and start
    rendering by hitting <RAM>r.

The shaded image in eternal screen will contain the same image as the
wireframe representation shows in the handle view. If the width to height
proportion of the view is different from that of the external screen, both
images will show the same horizontal width but the vertical height will
differ. To get an exact representation in the View window of the image to
be rendered to the external screen, you must have the same width to height
ratio.

After rendering, you can save the image using Project/External Screen/Save
function; this displays the file requester with which you can define a
suitable file name for saving. Before saving, you can also choose the
image format to be used using External Screen/Settings menu; currently
IFF 24, True colour Targa 24, and 32 (alpha included) are supported.
The fourth format, Custom, is device dependent. Check the interface
library specific docs for more information.

Note:
That the Save function always saves the full external screen regardless
of its contents (partial screen rendering, box rendering, etc.).

You can use External Screen/Close function to close the screen when other
programs need to access the display device. REAL 3D closes the screen
automatically when you exit the program.

The Eternal screen library name and other settings can be saved as a part
of your real-startup environment.

5.13.1 Rendering an Animation Using External Screen

When you want to render an animation to hard-disk using an eternal screen,
do the following:

1. Create/load the animation project.

2. Open the external screen as presented in the previous example.

                             - TUTORIAL 5.11 -

3. To maximize the rendering speed, leave only one view window open and
   use View/Render/Settings to choose suitable rendering options. Set the
   Output cycle gadget to External screen.

4. Use External Screen/Settings to select the desired saving format
   (default IFF 24 is probably OK).

5. Open the animation window. Set the time to 0.0 (default).

6. "Screens" selector of the animation window should contain "External".
   Click "External" or type the name to the "Saved" string gadget below
   the screen name list.

7. Activate the Save gadget (unless you are going to single frame record
   the images directly using a frame command).

8. Verify that the drawing method is Ray trace, not wire frame.

9. Type the full name for file saving (including path) to "Screen file"
   gadget.

10. Adjust other animation settings (e.g. frame resolution).

11. Press the play animation gadget "..>|".

Each frame is rendered first to the external screen, then it is saved to
a disk file. The advantage is that you can monitor how the rendering
proceeds and cancel the rendering if the result is not expected (we
recommend a low resolution HAM preview before final rendering) The
disadvantage is that the data transfer to and from the external screen may
require extra time where as direct-to-disk file rendering will be a little
faster.

5.13.2 External Screen Aspect Ratio

The latest interface library versions (v.40) includes automatic aspect
ratio support. When you render to the external screen, the pixel aspect
is automatically set to the correct value if the render settings aspect
ratio field is set to zero. You can overrule this auto-configured value
by typing any non-zero value to the aspect ratio field "Pixel h/w".

In older libraries (v.36), the default aspect was 1.0.

5.13.3 Other Information

The external screen interface is quite general and different interface
libraries can work in various ways. Some devices require another monitor,
some use the same as the Amiga OS. Usually, one monitor systems work so
that when you start rendering the external screen pops up and disappears
again when you click it or cancel the rendering.

For example, the implementation of a mode query (Set Modes function) and
custom format saving can vary; both can be no-operation-at-all functions.
These details are usually specified in the interface library documents.
At the time of the initial release of REAL 3D V2 there are libraries
planned for the following devices:

                             - TUTORIAL 5.12 -

Devices:

     - Harlequin
     - VD2001
     - DCTV
     - Impact Vision
     - EGS
     - Visiona
     - Domino
     - Merlin
     - SAGE boards
     - Opal Vision
     - A-Video
     - Horizon

Note:
Most libraries are developed by other programmers.

The external screen can be used to also implement the standard Amiga based
rendering facilities. For example, it may be a disk file rendering
interface with multiple file format support, or just an Amiga screen with
desired properties (for example: EXTRA HALFBRITE screen or 5 bit colour
LORES screen with custom dithering algorithms).

A nice setup using two monitors and an external screen:

1. Change the output target of one of your view windows to External,
   using Render settings requester. The rendering mode can be Environment.

2. Select View/Drawing Set and set "Ray trc." gadget to activate automatic
   ray traced shading for the view.

Now you can continue using your interface as before and REAL 3D keeps on
rendering a new shaded image on the second monitor display, using idle
processor time available to do something useful.

5.14 BOXES

With the box functions you can define a specific part of the display to
be rendered. The purpose is to allow you to quickly test render only
critical parts of the image without having to perform a full page render.

It is also possible to first quickly render the picture using a lower
resolution, define the boxes, and then render only the boxes using a
higher resolution.

For example:

1. Create an object.

2. Select View/Render/Settings and set X-Resolution = 4, Y-Resolution = 4,
   Anti-aliasing = 0, then select OK.

3. Hit <RAM>r to get a quick render in the view window.

4. Select View/Boxes/Define and shape a rectangle defining a "critical"
   part of the scene.

5. Select View/Render/Settings, set X-Resolution = 1 , Y-Resolution = 1,
   Anti-aliasing = 2 and select OK.

6. Select View/Render/Boxes. Only the box area is re-rendered and it is
   rendered with the higher resolution and anti-aliasing.

It is possible to have multiple boxes at the same time. You can modify and
delete the boxes individually; REAL 3D automatically names the boxes using
their creation order. Boxes/Delete All removes all the box definitions.

                             - TUTORIAL 5.13 -

Box definitions are window-specific: each View may has its own box list.

You can also use box function to divide the rendering of an image into
smaller sub-images which can be assembled later. This is useful for long
rendering times where the process must be cancelled. For example, to
render 4 sub-images of a 1024*1024 pixel 24-bit image to disk files:

1. Create the scene and define the render settings for the View window to
   be used (Output = IFF file, file name etc.) Set image Width and Height
   to the full 1024*1024 size. Then save the project.

2. Use View/Boxes/Define to define a box on the View. The size and
   location of the box do not matter.

3. Select View/Boxes/Modify, select the box (there should be only one box)
   and enter Left edge = 0, Top edge = 0, Width = 512, Height = 512.
   Then select OK.

4. Render the first quarter of the image using the View/Render/Boxes
   function.

5. When the image is rendered, select View/Render/Settings and change the
   file name (for example, add "tr" postfix to it), so that the new image
   is not written over the first one.

6. Select View/Boxes/Modify, select the box and enter Left edge = 512,
   Top edge = 0, Width = 512, Height = 512. Then select OK.

7. Render the second quarter (use View/Render/Boxes).

8. Repeat the previous steps for the two last quarters.


			    End Of Part 2





