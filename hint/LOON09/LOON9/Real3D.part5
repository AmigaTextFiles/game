

                               PART 5



                            - REFERENCE 1.20 -

Figure R1-11: Regular Polygon-based Visibles  (PICTURE: R1-11)

Reg.polygon

PRIMITIVE: polygon
Create regular polygonal plane.
NUMERIC: number of sides of a regular polygon
DEFINE: center and radial size.

Reg.polyhedr.

PRIMITIVE: polyhedron
Create regular polygonal cross-section prism.
NUMERIC: number of sides of a regular polygon
DEFINE: center and radial size of polygonal cross-section, The polygonal
cross-section is extruded to the defined depth.

Reg.polymid

PRIMITIVE: polymid
Create regular polygonal based pyramid.
NUMERIC: number of sides of a regular polygon
DEFINE: center and radial size of regular polygon base and then apex.

Reg.cut.plmd

PRIMITIVE: cut-polymid
Create regular polygonal cross-section prism.
NUMERIC: number of sides of a regular polygon
DEFINE: center and radial size of regular polygon base and then center and
radial size of truncating surface.

                            - REFERENCE 1.21 -

Circle

PRIMITIVE: ellipse
Create circular plane.
DEFINE: center and radius.

3P Circle

PRIMITIVE: ellipse
Create circular plane.
DEFINE: three points on the circumference of a circle to create a circular
plane.

Cylinder

PRIMITIVE: cylinder
Create cylindrical prism.
DEFINE: circular cross-section to be extruded to defined depth.

Cone

PRIMITIVE: cone
Create conical surface.
DEFINE: circular base and apex.

Cutcone.

PRIMITIVE: cut-cone
Create conical surface with truncated apex.
DEFINE: circular base and center of truncating surface.

Figure R1-12: Circle-based Visibles  (PICTURE: R1-12)

                            - REFERENCE 1.22 -

Figure R1-13: Ellipsoid Visibles  (PICTURE: R1-13)

Sphere

PRIMITIVE: ellipsoid
Create regular spherical surface.
DEFINE: center and radius.

Ellipsoid

PRIMITIVE: ellipsoid
Create ellipsoid surface with elliptical axes in two directions.
DEFINE: center and then the size of the two axis of an ellipse. This
ellipse defines the major circumference of the ellipsoid parallel to the
input plane. The depth is pre-defined.

Ellipsegment

PRIMITIVE: ellipse-segment
Create ellipsoid with two cutting planes equidistant from the defined
circular circumference.

DEFINE:
center and size of a circle about the major axis of the ellipsoid parallel
to the input plane. Then define center and size of the cutting planes.
The depth is pre-defined.

Cut ellipseg

PRIMITIVE:
ellipse-segment Create ellipsoid with two cutting planes, one positioned
on the defined circumference.

DEFINE:
center and size of two circular planes. The larger one becomes the major
circumference of the ellipsoid parallel to the input plane.

                            - REFERENCE 1.23 -


Figure R1-14: Hyperboloid Visibles  (PICTURE: R1-14)

Hyperbol

PRIMITIVE: hyperboloid
Create hyperbolic surface with two cutting planes equidistant from a
"waist".
DEFINE:
center and radius of two circular cross-sections. The larger of the two
circular sections defines the 1 st & 2nd cutting planes and the smaller
defines the waist.

Cut hyperb.

PRIMITIVE: hyperboloid
Create hyperbolic surface with two cutting planes, one positioned at the
"waist" of the surface.
DEFINE:
center and size of two circular cross-sections. The smaller one defines
the circumference of the waist.

Sectors/

The creation functions in this sub-menu enable various visibles to be
constructed with cross-sections which are a sector of a circle. The first
coordinate describes the center of the circular cross-section, then the
start-point of the segment is defined by the next coordinate, finally the
third coordinate defines the angle of the segment and the radius of the
cross-section.

Figure R1-15: Sector Visibles  (PICTURE: R1-15)

                            - REFERENCE 1.24 -

Circle

PRIMITIVE: ellipse SECTOR
Create sectored circular plane.
DEFINE:
sector cross-section only.

Cylinder

PRIMITIVE: cylinder SECTOR
Create sectored cylinder.
DEFINE:
sector cross-section only.

Cone

PRIMITIVE: cone SECTOR
Create sectored cone.
DEFINE:
cross-section and apex.

Cut cone

PRIMITIVE: cut-cone SECTOR
Create sectored cone with truncated apex.
DEFINE:
cross-section then center and radial size of cross-section at the apex.

Ellipsegment

PRIMITIVE: ellipse-segment SECTOR
Create sectored ellipsoid with equidistant cutting planes.
DEFINE:
cross-section then center and size of second cross-section. Larger will
be circumference.

Cut ellipseg.

PRIMITIVE: ellipse-segment SECTOR
Create sectored ellipsoid with cutting planes at circumference and end.
DEFINE:
cross-section then center and size of second cross-section. Larger cross-
section will be the circumference.

Hyperbol

PRIMITIVE: hyperboloid SECTOR
Create sectored hyperbolic surface with waist.
DEFINE:
cross-section then center and size of second cross-section. Smaller cross-
section will be the waist.

Cut hyperbol

PRIMITIVE: hyperboloid SECTOR
Create sectored hyperbolic surface truncated at waist.
DEFINE:
cross-section then center and size of second cross-section. Smaller cross-
section will be the waist.

Structure/

Level

PRIMITIVE: level OR
Create a structure which can be used to contain objects at a new level of
the hierarchy. The arrangement of objects in levels is key feature used by
many of the functions and systems of REAL 3D.
Levels are used for defining a logical structure of the object and they
can be compared to directories (Drawers) of Disk Operating Systems.

                            - REFERENCE 1.25 -

                                     +-------+
                                    /| brace |
                                   / +-------+
                          +------+/  +--------+
                          | base |---| stand2 |
                         /+------+\  +--------+
               +-------+/          \ +--------+
     +------+ /| table |\ +-------+ \| stand1 |
     | Root |/ +-------+ \| Cover |  +--------+
     +------+             +-------+

Figure R1-16: Hierarchy Levels  (PICTURE: R1-16)

Link

PRIMITIVE: link
This creates structures each of which references the selected objects.
This "symbolic-link" can then be cut and pasted to another part of the
hierarchy to provide access to the original object. A link can only be
used to read the data from a target object. Modifications are not passed
to the object through a link. The most common situation which requires the
use of links is for using one object to define the parameters for several
methods. They are also necessary sometimes when defining texture morphing
using the MORPH methods.

Links can also be used for jumping from one level to another by double
clicking the desired link on Select window. If link points to a level
object, that level becomes the current level. If it points to a primitive,
probably nothing happens, because most primitives cannot be the current
level, in other words, they cannot have sub-structure.

Group

PRIMITIVE: group
Create a structure called a "group" which refers to the points on a
freeform. Unlike links, groups can pass data in both directions. Hence
modifying a group modifies the points on the original freeform. The points
to form the group are taken from the vector-stack, so they must be
selected from the freeform first by using <DRAG><SHIFT> or Lasso selector.
If several objects are selected, then a new level will be created
containing all the new groups. Groups are usually created inside the
freeform they refer to, so unexpected cumulative modification results are
avoided (same points are modified first through freeform itself and again
through groups referring to freeform).

HOT-KEYS:
There are also two hot-key combinations:
<CTRL> <SHIFT><DRAG> and
<CTRL><SHIFT><ALT><DRAG> which will automatically create a group with the
name "group tmp", or a level with the name "level tmp". When <ALT> is
used, then only points from the selected freeforms are used.

Method

PRIMITIVE: level OR SMTH
Creates a new level and opens the animation-properties requester to allow
a method typed to be selected. This will then be assigned to the new
level, which becomes the current-level to allow the parameters for the
method to be defined easily.

Note:
That the same result can be achieved by creating a level object using the
function Create/Structure/Level, and changing the method type using the
function Modify/Properties/Animation.

Methods are "intelligent objects used for creating animations. In other
words, method objects cause target objects to be animated according to
parameter objects placed under them.

                            - REFERENCE 1.26 -

Light-sources/

Point

PRIMITIVE: offset LIGHT-SOURCE
Create point light source.
DEFINE: single coordinate.

This is rendered as a single infinite point of light. Because the point
light has no dimension, it can produce only sharp edged shadows. In real
world the intensity is inversely proportional to square of distance, but
in REAL 3D, a formula which produces less radical result is used and
intensity drops only inversely proportionally to distance.

DIFFUSE LIGHT SOURCES

These use Render-Settings/"Lightsamples" to determine the quality of the
soft-shadow they cast. The higher the Render settings/Lightsamples, the
better the quality of shadows generated. If Lightsamples is zero, the
light source is treated as a point light. Intensity is dropped the same
way as the Point light.

Line

PRIMITIVE: line LIGHT-SOURCE
Creates a diffuse linear light source.
DEFINE: two points of a line.

This casts soft-shadows from a linear source the length of the line
created.

Wall

PRIMITIVE: rectangle LIGHT-SOURCE
Creates a diffuse rectangular light-source.
DEFINE: rectangular plane. The soft-shadows are cast from an area light-
source the size of the rectangle created.

Controls/

The objects created in this menu do not appear when a scene is rendered.
They are used to create other objects or control various aspects of
functions and methods.

The wire-frames for all controls are drawn with a broken line of long
dashes by default.

Attribute

PRIMITIVE: attribute
This creates an attribute primitive. It does not require any spatial
coordinates, so no pointer input is required. This primitive can, for
example, be used as a parameter for methods when object attributes, such
as motion blur must be animated.

Offset

PRIMITIVE: offset
Create a primitive for the specified coordinate. Offsets are most commonly
used with animation Methods to define centers of rotations etc.
DEFINE: coordinate.

Axis

PRIMITIVE: line
Create a line with two points.
DEFINE: start and end coordinates of axis. Axes can be used, for example,
as parameters for animation methods for defining rotations and straight
motions.

                            - REFERENCE 1.27 -

Coordsys

PRIMITIVE: coordsys
Create a set of x,y,z axes.
DEFINE: origin and size. Coordsys primitive is used as a parameter to
animation Methods. It is also very handy for defining the orientation of
input plane of View windows.

Figure R1-17: Lines and Curves  (PICTURE: R1-17)

Open Line

PRIMITIVE: line "polygon"
Create one or more linked lines.
DEFINE: start coordinate and at least one other coordinate. Multiple
points on the line are defined by supplying multiple coordinates. The
function is terminated with <RMB>.

The line can be closed/opened with <BACKSPACE> key. In animations,
polygonal lines can be used for producing "sharp edged" motions. For
example, mechanical devices often require motions which are not smoothly
curved. When used as a parameter for freeform surface construction tools,
polygonal lines produce polygonal surfaces.

Closed Line

PRIMITIVE: line "polygon"
Create three or more lines linked as a polygonal loop.
DEFINE: start coordinate and at least two other coordinates. The function
is terminated with <RMB>. The curve can be opened/closed using <BACKSPACE>
key.

Circular Line

PRIMITIVE: line "polygon"
Create three or more lines linked as a regular polygonal loop.
NUMERIC: Number of sides to regular polygon.
DEFINE: center and radial size.

                            - REFERENCE 1.28 -

B-Spline Ctrlp

PRIMITIVE: line "B-spline"
Create B-spline by defining control-polygon.
DEFINE: at least 4 coordinates of points on open ended control-polygon of
B-spline.

This is one of the basic tools when creating B-spline curves. It allows
the user to define a control polygon which defines the actual smooth
B-spline curve of third degree. The curve tends to automatically be very
smooth when using this curve definition method, but the fact that the
curve itself is dislocated from the control points makes it tricky to use
for the novice user. B-spline curves can be used for defining smooth
motions for animation methods, and as parameters for B-spline freeform
surface construction tools.

B-Spline Knot

PRIMITIVE: line "B-spline"
Create B-spline by defining knot-points.
DEFINE: 2 or more coordinates of knot-points on B-spline.

Figure R1-18: A B-spline Curve Produced from Knot Points  (PICTURE: R1-18)

This tool allows the user to define a B-spline curve by defining the
curve's knot points. Because the curve passes through knot points, the
user has more accurate control over the curve. However , the curve may
not always interpolate knot points in expected way.

B-Spline Curve

PRIMITIVE: line "B-spline"
Create B-spline by defining control-polygon. End points are fixed with
triple-points and curve is drawn interactively.
DEFINE: start-point coordinate, then consecutive points on the control-
polygon. As the cursor is moved, the resultant B-spline curve is drawn.
When terminated, the last coordinate supplied becomes a fixed end-point.
The start and end points of the B-spline polygon are fixed by defining
three points on the control-polygon at the same coordinates (triple-
point).

B-Spline Closed

PRIMITIVE: line "B-spline"
Create B-spline by defining closed control-polygon.
DEFINE: four or more points of a polygon with closed ends.

B-Spline Cir.

PRIMITIVE:
line "B-spline" Create circular B-spline by defining closed regular
polygon.
NUMERIC: sides of regular polygon. Entry must be 4 or greater.
DEFINE: center and radial size.

                            - REFERENCE 1.29 -

B-Spline Helix

PRIMITIVE: line "B-spline"
Create helical B-spline.
NUMERIC: number of points on control-polygon and total angular distance of
helix in radians.
DEFINE: center and radial size.

Mappings/

All the objects created in this sub-menu have a material definition
attached to them when created. They define the type of mapping used to
apply the material properties to the physical objects in the hierarchy.

The type of the mapping primitive defines how the absolute space, where
objects are defined, is mapped to material space where material properties
are defined. For example, when using rectangle primitive, the absolute
space is mapped to material space using parallel projection which is fully
defined by the size and the orientation of the rectangle used.

See also Material window/Mapping handler description.

The material to be mapped to absolute space is referred by a tag "SMAT".

The wire-frames for all mapping objects are drawn with a broken line of
short dashes.

Default

PRIMITIVE: attribute MAPPING
Creates attribute with attached material properties.

This enables material properties not requiring any special mapping to be
placed in the hierarchy. This saves on memory and avoids cluttering the
screen with unnecessary wire-frames.
No transformations are applied between  material/absolute spaces (in other
words, the space where materials and objects are defined is the same).
When using textures with this mapping, parallel projection along z-axis
is used.

Parallel

PRIMITIVE: rectangle MAPPING
Create rectangular mapping.

The basic mapping type of the attached material properties will be
parallel. The size and position of the rectangle determines how material
space is moved, rotated and stretched to absolute space where objects are
defined.

Cylinder

PRIMITIVE: cylinder MAPPING
Create cylindrical mapping.
DEFINE: center and radial size of circular cross-section. Depth is pre-
defined.

This mapping method can be used for wrapping textures cylindrically around
objects. The axis of the cylinder corresponds the vertical direction of
the texture. The horizontal direction is bent along the cross-section
circle.

Sphere

PRIMITIVE:
ellipsoid MAPPING
Creates spherical texture.
DEFINE: center and radial size.

Disk

PRIMITIVE: ellipse MAPPING
Creates circular texture.
DEFINE: center and radial size.

                            - REFERENCE 1.30 -

Observers/

Viewpoint

PRIMITIVE: viewpoint
Create a viewpoint.
DEFINE: two coordinates defining the centers of stereo viewpoint pair.

Viewpoint can be used for defining orientation for View windows. If the
menu View/Camera/Camera_View is checked, the orientation for the
corresponding View window is fetched from the viewpoint object, if found.
If the object contains more than one viewpoint, the first one found is
used, unless the viewpoint contains a tag SWND, in which case it is used
only if the contents of the tag matches the name of the View window in
question. This makes it possible to associate different viewpoints with
different View windows. Because viewpoint is just a primitive, it can be
animated like any other object. It is possible to create animations where
the screen contains more than one View window and where each View window
shows the animation from different point of view. The viewpoint primitive
can be used with the aimpoint primitive for fully define the orientation
for the camera. In other words, camera consists of a viewpoint and an
aimpoint.

Aimpoint

PRIMITIVE: aimpoint
Create an aimpoint.
DEFINE: center.

The aimpoint primitive can be used for defining camera direction. The
reason why the camera is divided into two different part is that it makes
it possible to insert aimpoint to any object, and if the object is
animated, the camera always tracks it. This is true for viewpoint too.
Of course, it is possible to place both primitives inside one level
object, in which case, it can be treated just like a single camera. The
tag SWND can be associated with aimpoints as well.

Compound Tools/

The functions in this section all create multiple visibles all placed
within a new level. All the necessary boolean-operations and other
modifications are carried out on the original visibles to create the
expected composite visible shape.

Lathe

Create compound-object from various visibles by defining an axis and a
profile.
DEFINE: two end points of axis. Then define a sequence of "curve"
directions and shapes to create the profile.

A new direction for the profile curve is started by cancelling the curve
shaping with the <RMB> . This makes it possible to create sharp joints
between object segments. The function is terminated by using the <RMB>
twice.

Circular Subdivided

Create compound-object from cylinders along subdivided line. The polygonal
line is subdivided using quadric Bezier curves.
NUMERIC: subdivisions per line segment.
DEFINE: circular cross-section, open polygonal line.

Rounded Circ. Subd.

Create compound-object from cylinders along subdivided line with spheres
at junctions.
NUMERIC: subdivisions per line segment.
DEFINE: circular cross-section, open polygonal line.

                            - REFERENCE 1.31 -

Sharp Circular

Create compound-object from cylinders along line.
DEFINE: circular cross-section, open polygonal line.

Rounded Circular

Create compound-object from cylinders along line, with spheres at
junctions.
DEFINE: circular cross-section, open polygonal line.

Conical

Create compound-object by joining defined spheres with cones.
DEFINE: two or more spheres.

Conical Subdivided

Create compound-object by joining defined spheres with cones, subdividing
between sphere centers. Position and radius for intermediate spheres is
interpolated using quadric Bezier curves.
NUMERIC: subdivisions between centers of spheres.
DEFINE: two or more spheres.

Rectangular

Create compound-object from rectangular prisms along line, with cylinders
at junctions.
DEFINE: circular cross-section, open polygonal line.

Rectangular Subdiv.

Create compound-object from rectangular prisms along subdivided line, with
cylinders at junctions.
NUMERIC: subdivisions per line segment.
DEFINE: circular cross-section, open polygonal line.

Rectangular Conical

Create compound-object by joining defined cylinders with rectangular based
pyramids.
DEFINE: two or more cylinders.

Rect.Conical Subd.

Create compound-object by joining defined cylinders with pyramids,
subdividing between cylinder centers.
NUMERIC: subdivisions between centers of cylinders.
DEFINE: two or more cylinders.

Rounded Polygon

Creates a compound plane from a polygon and circle segments.
DEFINE: polygon. The created compound plane is bounded by this polygon.

A polygon is created which forms the outer controlling boundary polygonal
plane whose "corners" are rounded with segments from circular planes.
While this bounding polygon is being defined, the resultant polygon and
circle segments which will compose the final plane are shown.

                            - REFERENCE 1.32 -

The following key bindings are defined during creation:

TICK      - define new radius for the current corner.
BACKSPACE - define new radius for arbitrary corner.
<SHIFT>
<TICK>    - new radius for all corners.

Rounded Polyhedron

Create a compound solid from polyhedron and cylinder segments.
DEFINE: bounding polygon.

The bounding polygon defines the rounded polygonal cross-section which is
extruded to a defined depth to form a solid. The level created contains a
polyhedron and the cylindrical segments of the compound solid.

Hot keys are similar to Rounded polygon tool.

Ellipsed Polygon

Create a round edged compound plane from a polygon and ellipse segments.
DEFINE: bounding polygon. The level created contains a polygon visible and
several ellipse segments which boarder all the edges of the polygon.
This forms a compound plane with continuous curved edges.

Ellipsed Polyhedron

Create a round edged compound solid from a polyhedron and cylinder
segments.
DEFINE: bounding polygon. A polyhedron and the cylindrical segments which
border its edges are created. This is the extruded solid of the ellipsed
polygon defined by the bounding polygon.

Join Primitives

This creates a set of cut-cones or cut-pyramids to join multi-selected
spheres or cylinders together. Only the new visibles form the compound-
object; the original visibles remain at their original level. If non-
spherical ellipsoids or cylinders of dissimilar depth are used, then the
cut-cones or cutpyramids will use the minimum dimensions of the operands
as a default. Using any visible other than ellipsoids or cylinders will
be ignored by this function.

Object-Pixel Tool

Create multiple copies of selected objects using pixels from image file.
SELECT: image file
DEFINE: rectangle. The compound-object is created from multiple copies of
the selected objects. The offsets for each of these new objects is taken
by mapping the image file onto the rectangle and taking the coordinates of
each active pixel. Their color is taken from the pixel color. For register
color IFF files pixels of register color 0 do not create objects. With
24-bit image files all pixels create objects.

Freeform/

The free-form construction functions take two or more lines selected as
operands by multi-selection. These operands are used to produce a mesh.
If all operands are of one type, then the resultant mesh will be of the
same type. With mixed types of operands, then the mesh will be polygonal
by default. If B-spline operands are used, then there must be four or more
to produce a B-spline mesh.

                            - REFERENCE 1.33 -

Note that when creating B-Spline surfaces, a large amount of points are
not needed for making objects "smooth", which is the case when creating
objects using polygonal models. Instead, points are needed for
representing details.

Mesh

PRIMITIVE: mesh
Create rectangular mesh of B-spline curves.
NUMERIC: the number subdivisions of each axis of the mesh.
DEFINE: size of the mesh as a rectangle.

Coplanar

PRIMITIVE: mesh
Create a mesh from a profile displaced along a sweeping curve.
OPERANDS:
1st - profile
2nd - sweeping-curve
The profile is displaced along the sweeping curve and replicated at each
point of the sweeping curve. The resultant profiles are joined
consecutively into a mesh. The profile curves of the mesh remain parallel
to the original profile operand. The displacement is relative, in other
words the profile curve is not pulled to the beginning of the sweeping
curve.

Figure R1-19: Coplanar Sweeping  (PICTURE: R1-19)

Orthogonal

PRIMITIVE: mesh
Create a mesh from a profile displaced along a sweeping curve.
OPERANDS:
1st - profile
2nd - sweeping-curve
The profile is rotated to follow the direction of the sweeping-curve while
being displaced. At each point of the sweeping curve, the profile is
replicated. These profiles are joined to form the mesh.

Figure R1-20: Orthogonal Sweeping  (PICTURE: R1-20)

Rotate

PRIMITIVE: mesh
Create a mesh by rotating a profile about an axis.
OPERANDS:
1st - profile
2nd - axis of rotation
NUMERIC: number of subdivisions during rotation. The new mesh is created
by rotating the profile about the axis and creating a new profile for each
subdivision specified. The profiles are linked into a mesh.

                            - REFERENCE 1.34 -

Swing/Move

PRIMITIVE: mesh
Create a mesh by rotating a profile about an axis and displacing it using
a third curve.

OPERANDS:
1st - profile
2nd - axis of rotation
3rd - displacement-curve

The profile is copied once for each point on the displacement-curve. Each
copy is rotated about the axis by the angle between the original profile
and a line through the axis, and the corresponding point on the
displacement-curve. Each copy is also displaced by the relative distance
between the axis and original profile, and the axis and the corresponding
point.

Swing/Size

PRIMITIVE: mesh
Create a mesh from a profile, an axis and a sizing curve.

OPERANDS:
1st - profile
2nd - axis of rotation
3rd - sizing-curve

The profile is copied once for each point on the sizing-curve. Each copy
is rotated about the axis by the angle between the original profile and a
line through the axis, and the corresponding point on the sizing-curve.
Each copy is also scaled by the relative distance between the axis and the
original profile, and the axis and the corresponding point.

Figure R1-21: Swing/Size  (PICTURE: R1-21)

                            - REFERENCE 1.35 -

Build from Curves

PRIMITIVE: mesh
Multi-select a number of curves to be built into a mesh. The order of
selecting the curves determines the order in which the curves are
assembled. By default, the surface is not closed in "joining" direction,
The function Modify/Freeform/Open&Close can be used for closing the
surface in the ("v") direction.

Figure R1-22: Build_From_Curves  (PICTURE: T1-22)

Mesh-Pixel Tool

PRIMITIVE: mesh
create a mesh using image file.
FILE: name of image file.
DEFINE: rectangle. The image file will be scaled to the rectangle. A mesh
will be constructed with a point for each pixel of the image file. The
height of each point above the base level is relative to the intensity of
the corresponding pixel.

Fractals/

Landscape

Figure R1-23: Fractal Landscape Generator  (PICTURE: R1-23)

Create a mesh representing a fractal "landscape".

REQUESTER: fractal generator information
DEFINE: rectangle.

Gadgets :

u Direction, v Direction

These fields define the resolution for the final landscape mesh. In order
to get the best possible result, the value of these fields should be
2^n+1, where "n" is integer.

Depth
This defines the relative depth of the landscape to be created. The higher
the value, the higher the profile.

Random
Defines how random the result is. The higher the value, the greater the
randomness.

                            - REFERENCE 1.36 -

Figure R1-24: Fractal Tree Generator  (PICTURE: R1-24)

Power

Defines the shape. If the value is large, mountain peaks are sharp and
valleys are flat. If small, then mountain peaks are flat and valleys deep.

Seed

Seed value for random factor. Using identical seeds allows identical
landscapes to be created.

Tree

Create a fractal "tree" from spheres and cut-cones and optionally a
selected object.

REQUESTER: fractal generator information
DEFINE: sphere for position and size of first "node", then two coordinates
to define direction of growth and length of the first branches.

If an object is selected, then this will be used as the "leaves" at the
ends of the last branches.

The basic idea for controlling all the properties of a tree is relatively
simple. There are some initial settings, like depth and branch count which
have several modifiers applied, like random and depth modifier, in order
to get the final value for a particular property of the tree.

                            - REFERENCE 1.37 -

For example, the following diagram shows how the number of sub-branches is
defined for each node:

Initial      - This is an initial value defined by "Branch Init"
   |           field in the Fractal tree requester.
   |
  \/

Random       - Initial value is passed to random modifier, which uses the
   |           value of the gadget "Branches_Rand" to define how much to
   |           randomize the initial value.
   |
  \/

Depth        - Depth modifier changes the value according to the value of
   |           "Branch Depth" The lower the level of the node, the higher
   |           the number of sub-branches.
   |
  \/

Branch       - Branch modifier modifies the passed value according to the
   |           branch in question. This makes it possible to define fewer
   |           sub branches for outer parts of the tree.
   |
  \/

Actual       - The actual number of sub branches for the node in question.

             level 2
   \/\/\/\/  level 1
    \/  \/
     \  /    level 0
      \/

The depth of this tree is 3 and branch count is 2.

Depth Fields:

There are three fields used for defining the depth of each branch. The
depth of a branch dictates how many times it can branch again.

Init

This value defines an initial depth for all branch instances in a tree.

Rand

Defines a random scale used for modifying initial depth value. If a value
of this gadget is 0, the depth is not affected randomly. If 100, the depth
of a tree can vary +/- 0.5 *depth.

Branch

Defines how the branch in question affects the depth, i.e. how the tree to
be created is balanced. If zero, then either the central or first branch
of each node has the greatest depth. If 50, all branches are treated
equally and if 100, the outer or last branches of each node has the
greatest depth.

Branch Fields:

These fields define how the number of branches is defined. This
information is evaluated individually for each branch of a tree.

Init

This field defines the initial number of branches per node.

Rand

This defines how randomness affects the initial number of branches. The
new branch count can vary up to +/- 0.5*initial_count.

                            - REFERENCE 1.38 -

Depth

This field defines how the level of the node in question determines the
number of sub-branches to be created. If 0, it has no affect at all. If
100, the number of branches is reduced from level to level using the
following formula:

     level/(level + 1)^2*f/100*count,

Where: f is the value of this gadget.

Thus, if level is 0, or the factor "f" is zero, the level of the node has
no effect over the number of sub-branches. In other words, the higher the
level, the fewer the number of branches.

     O   O
      \ /   Level 1: 2 sub branches
       O
       |
     O | O
      \|/   Level 0: 3 sub branches
       O

Branch

Define how the branch in question determines the number of sub-branches to
be created. If 50, the tree is balanced (each branch will contain equal
number of sub-branches). If 0, the central or first branch of each node
has the highest number of sub-branches.

Size fields:

These fields define how the size of the node is defined.

Depth

Initial sizing factor. Defines how the size of each node is reduced for
each new level. A value of 10 means the size for new nodes in the next
level will be 10% of the size of the nodes in the current level.

Rand

Random factor. If zero, then there is no randomness. If 100, size can vary
+/- size/2.

Branch

Define how the branch in question modifies the size of the node to be
created. This field can be used for creating trees with inner or first
nodes thicker than outer or last nodes.

Length Fields:

Depth Defines how the length of branches is reduced from level to level.

Rand

Random factor for length.


Branch

How the branch in question affects the length of the branch.

Direction Fields:

Direct Hor, Vert, Norm

These fields define the directions for branches to be created. The
direction for a new branch is calculated by using vector addition, where
the three vectors are Norm, Hor and Vert. Norm is the direction of the
current branch and Hor and Vert are perpendicular to this. The
mathematical formula for this vector addition is:

     newdir = norm*current_dir+hor*sin(x)+vert*cos(x),

Where: Norm, Hor and Vert are the values of the corresponding gadgets on
the requester, and x is value representing the direction of the current
branch.

                            - REFERENCE 1.39 -

Rand

Define random factor for the length of the H or, Vert and Norm vectors.

Gravity

Define how much "gravity" pulls down the branches for each new level. If
0, gravity is zero too. If 1 00, gravity pulls down the branches by the
length of the first branch.

Rotate Fields:

These fields define how much branches are rotated for each new level.

Level

The maximum rotation is half a revolution.

Random

Random factor for rotation.

Other Gadgets:

Subdivision

This field defines how many spheres and cut-cones are used for creating
branches. If 1, all nodes are connected using one cut-cone. The higher the
value, the smoother the the result. Branches are smoothed using a cubical
B-spline curve.

Branch Color

Define the color for all visibles forming the body of the tree created.
The contents of this string are passed to EVAL to define the color for the
spheres and cut-cones of the tree. The following variables are defined
during evaluation:

R, G, B - Color for the object to be created.

x, y, z - COG of the object to be created

I       - Hierarchy level (the level of the root is 0)

b       - Number of the branch in question. The range is 0.0 to 1.0, where
          the first branch in a node is 0.0 and the last is 1.0. If used,
          then the central branch will be -1.0

s       - Subdivision index for branches. If subdivision is 1, all
          branches consists of only one cut-cone and the value of "s" is
          constant (1 ). If subdivision is 1 0, each cut-cone has a
          separate index, where the index for last cut-cone created for
          the branch in question is 10.

If this gadget is empty, current color is used.

Leaf Color

This string is passed to EVAL in order to define a color for the leaves.
If this gadget is empty, the original colors of leaf objects are used
instead.

R, G, B - Color for the leaf to be created.

x, y, z - COG of the object to be created

I       - Hierarchy level (the level of the root is 0)

b       - Number of branch to which the leaf is attached.

If this string is empty, the color of the selected objects is used.
Example Formula:

     R=127+128*sin(b), G=127+128*cos(b), B=127+128*cos(b)

                            - REFERENCE 1.40 -

Note:
For both these color evaluations, the only variables which affect the
visibles in question are R, G, & B. Although the other variables can be
assigned new values, this only affects their use in the expressions. It
does not modify the visibles.

Central

If set, then the various "Branch" gadgets work with the "central" branch
of a node e.g. 3rd branch of a group of 5. Otherwise, they work with the
first branch.

Trunk

If set, then a main trunk will be created and the first node will be at
the top to form a "tree", otherwise it will be a "bush".

Boolean/

OR
AND
AND NOT
AND with PAINT
AND NOT with PAINT

Figure R1-25: Boolean Operations  (PICTURE: R1-25)

These all work by creating a new object from the selected objects. At
least one object must be selected using multi-selection. The first object
selected is used as the target, and the rest of the selection are used as
the operands. The target and operands are copied to a new level which has
its AND attribute set.

For AND NOT, the operands each have their INVERTED attribute set. The
operands of AND with PAINT have PAINTS set, and AND NOT with PAINT sets
both these attributes for the operand objects.

                            - REFERENCE 1.41 -

Rethink

When applied to selected booleans, this function re-calculates the wire-
frame to more closely resemble the surface of the objects produced as a
result of the boolean-operator.

Rethink All

This function also produces new wire-frame for booleans. It also scans
through sub-objects of the selected-objects, and re-calculates the wire-
frames for all booleans.

Figure R1-26: Rethinking Boolean Wire-frame  (PICTURE: R1-26)

                            - REFERENCE 1.42 -

1.3 MODIFY

Linear/

All these functions are started and completed with <LMB> or terminated
with <RMB>.

Move

DEFINE:
handle coordinate, then new position A reference coordinate is defined,
then the selected objects can be moved by this "handle" to a new position.

Move COG

DEFINE:
new position for COGs When all the selected objects have their Center-off-
Gravity (COG) moved to the cursor position after the first <LMB> click, a
new position for the COGs is then selected. If objects are multi-selected,
then all their COGs are moved to the same coordinate and this causes them
to overlap. If a level containing sub-objects is selected, then their
COG's are averaged to find the COG of the whole group.

Size 2D

DEFINE:
sizing-center, sizing handle then new size A center about which the sizing
of the selected objects will take place is first specified, and then a
reference coordinate or "handle". As the cursor is moved relative to the
sizing center, the objects are re-scaled in proportion to the distance
between the center and the handle, and the current cursor position and the
center. The re-scaling only  takes place about the coordinates axes of the
Input-plane.

Size 3D

DEFINE:
sizing-center, sizing handle then new size

This works in an identical way to Size-2D, only the re-scaling is applied
to all three coordinate axes of the objects.

Stretch

DEFINE:
sizing-center, sizing handle then new sizes

This works in a similar way to Size _2D, only the re-scaling parameters
are evaluated independently for each of the two Inputplane axes before
being applied to the objects.

Extend

DEFINE:
extension-center and direction, then extension amount

The fixed center of the extension is defined first, then the direction in
which the extension of the objects is to take place. Moving the cursor
relative to the fixed point determines the degree of extension.

Rotate

DEFINE:
rotation-center and handle, then amount of rotation

The center about which the objects are to be rotated is first specified,
then a reference point. Moving the cursor about the rotation-center
controls the amount of rotation applied to the target objects.

                            - REFERENCE 1.43 -

Mirror

DEFINE:
fixed-point and end-point on mirroring axis, then final position of axis
end point.

The axis about which the objects is to be mirrored is defined in two
stages. First define the fixedpoint and endpoint of the axis. The axis can
then be rotated about the fixed-point until the final position is
selected.

Shear

DEFINE:
two points on shearing-axis, handle, and then degree and direction of
shear.

The shearing-axis determines the direction along which the shearing
modification will be applied. Then select a handle coordinate. Moving the
cursor relative to this coordinate defines the direction and amount of
shearing to be applied to the selected objects.

Rot&Ext

DEFINE:
rotation-center with extension fixed-point, rotation handle with
extension-direction and then amount of rotation and extension to be
applied.

This is a combination of the rotation and extension modification
functions. The first coordinate defined is used as both the center for the
rotation function and the fixedpoint for the extension. The second
coordinate defines the rotation handle and the direction for the
extension. Moving the cursor allows the amount of each modification to be
applied to the objects to be determined.

Deform

DEFINE:
fixed-point, deformation-direction and then degree of deformation.

This function works in a similar way to extend. The extension of the
objects dimensions along the deformation-direction is matched by the
inverse amount of extension to the objects dimensions perpendicular to
this.

Structure/

Cut

Remove selected objects from hierarchy and place in clip-buffer.

Copy

Copy selected objects to clip-buffer.

Paste

The contents of the clip-buffer are pasted to the bottom of the current
level.

Delete

Delete selected objects from hierarchy. This does not alter the clip-
buffer.

Duplicate

Copy selected objects and paste to hierarchy. The copy is left in the
clip-buffer.

                            - REFERENCE 1.44 -

Swap

Cut currently selected objects, reverse the order in which they were
selected, and paste them back to the corresponding locations in the
hierarchy. This function does not use nor affect the clip buffer in any
way.

PrOperties/

Color

The color of the selected objects becomes the RGB values of the current-
color. If the <SHIFT> key is held down when this function is activated,
the modal color requester is opened and the color of the first selected
object is shown.

Name

A text requester carrying the name of the first selected object is opened.
The name can then be edited. The maximum length for an object name is 16
characters. All multi-selected objects are renamed to the specified name.

Attributes

Open Attributes requester to modify the attributes of selected objects.
Multi-selecting objects displays the attribute settings for the first
object; confirming changes with OK changes the attributes of ALL multi-
selected objects to the chosen settings.

Gadgets of Attributes Requester:

AND/OR

These control whether a boolean AND or a boolean OR operation is to be
used for this object. This means that all objects inside a level have
this boolean operator applied.

Inverted

If set, then everything outside of the volume of the objects is used for
boolean operations.

Paints

The surface properties of the objects are applied to intersecting surfaces
in boolean operations when this attribute is set.

WF-Invisible

Objects wire-frames are invisible if set.

RT-Invisible

If set, then the object will not visible when rendered.

Mapping

Setting this allows any primitive to be used as a texture. This means that
sector-visibles can be used as textures, but only rectangles, ellipsoids,
cylinders and circles will have their geometry projected appropriately.
If this flag is set for a level or a link, then the Rendering Engine will
scan the object for mappings.

                            - REFERENCE 1.45 -


Protected

When set, the object is not affected by ANY modifications other than
direct hierarchy modifications such as Cut and Delete.

Motion-Blur

Setting this attribute means that Motion Blur will be evaluated for this
object during rendering, provided that Animation Settings/"Samples" is
set greater than 0.

Light-source

When set, an object is a light. An offset becomes a light-point, an axis
(two point line) becomes a light-line and a rectangle a light-wall). All
other primitives are treated as lightpoints with their COG as the source.

Hollow

Objects will be hollow if set.

No 1st BP

Visible surface of 1 st bounding-plane is removed if set.

No 2nd BP

Visible surface of 2nd bounding-plane is removed if set.

Infinite

Actual bounding planes are removed if set.

Scene

If set, then objects only visible via reflection or refraction.

Not Reflected

The objects will reflect but not be reflected if this attribute set.

Matte

The objects will always return the background color. This effectively
means they mask any objects behind them as though they were behind part
of the background.

Cast Shadows

This attribute allows specific visibles and lights to be removed from
shadow calculations. It is set by default, but if un-set, then affected
lights will not cast shadows from any visibles, and any visibles affected
by this attribute will not cast shadows from any lights.

Alpha Channel

Open a modal requester allowing user to define new value for Alpha channel
property for selected objects. The Alpha channel of the first selected
object is shown when the requester is opened.

Tags

This enables tags to be added or modified for selected objects in sequence
using the Tag-requester.

In REAL 3D, tags are used for expanding object and material data
structures which may be necessary e.g. when creating user defined methods
or procedural materials.

Tag requester shows a list of the tags defined for the current object.
Selecting from this list makes the Tag available in the edit box. Either
the Tag-ID or its Tag-Values can be edited. Pressing <ENTER> updates the
list.

                            - REFERENCE 1.46 -

Gadgets of the Tag Requester:

DEL
Deletes the current tag from the list.

ADD
If the edit box is shaded, then this gadget makes it possible to enter
text for a new gadget. When text has been entered, using this gadget adds
the text to the list.

The Tag ID will be checked to see if its first character is a valid type.

Valid Tag Types:

     C, D, F, I, M, S & V

Any Tag-Values follow the Tag ID and are separated from it and each other
by <SPACE>. The length of a Tag ID is restricted to four characters, the
first of which must be a valid type.

Animation

The animation properties of the selected objects can be changed with the
Animation Properties Requester.

Figure R1-27: Animation Properties Requester  (PICTURE: R1-27)

This has five numeric gadgets to define Start Time, End Time, Phase,
Frequency and Method Time. For a method to function correctly, Start Time
cannot be after End Time, but Phase can be any Time value and Frequency
any positive value. "Time" defines the local Method Time for a method in
its current state. Confirming new settings updates the VTIS, VTIE, VPHS
and VFRQ tags.

Start Time

This defines the time before which the method will be inactive.

End Time

This defines the time after which the method will be inactive.

The method will carry out the whole of its evaluation during the period
from Start Time to End Time.

Method Action

      ^
1.0 I |         ____>
      |        /
      |       /
      |      /
      |     /
      |____/
      |
0.0 + +-------------->
      Time ^   ^
           |   |
         VTIS  |
              VTIE

Phase

This controls the "phase relationship" between the method and parent time.
In effect, it is an offset, so instead of starting from Method-Time = 0.0,
it will start from the value specified by "Phase".

                            - REFERENCE 1.47 -

Frequency

This acts as a multiplier applied to the time passed to the method via the
animation message. Increasing or decreasing Frequency increases or
decreases the rate at which method carries out its actions. If it is
decreased. so the resulting method time is less than 1.0, then the method
will only carry out the specified fraction of its actions.

Method Time

The current local method time. This requester also contains a list
selector to allow the method type to be attached to the selected objects.
Internally, this defines the SMTH tag.

If the method type is "NONE", then although the tags for the Time
properties will be created or modified, this will not affect how the
Animation System evaluates the objects.

Animation Method Types:

     NONE
     COLLISION
     CONTROL CURVES
     CREATION
     DIRECTED FORCE
     DIRECTION
     FRICTION
     INT COLLISION
     INV KINEMATIC
     MORPHING CLOSED
     MORPHING OPEN
     MOVE & DIR
     PATH
     PROCESSOR
     RADIAL FORCE
     ROTATION
     RPL
     SIMPLE SKELETON
     SIZE
     SKELETON
     STRETCH
     SWEEP
     TANGENT FORCE
     TRANSFORM
     WAVE

The method type is used to specify how an object is evaluated by the
Animation system. Each method requires a certain hierarchical syntax in
order for it to be valid. The syntax for each method is described in
detail in the reference chapter 2.

Replace Tags

Allows the tags of selected objects to be modified collectively. The tag
to be modified is selected using the requester. The Tag ID and Tag values
can then be edited. All tags with identical Tag ID and Tag Value are
replaced with the edited values.

e.g. Material references "SMAT wood" can be changed to "SMAT marble"

The following properties are evaluated by certain methods for particle
animation. Some of them define new tags which override default object
properties.

COG

DEFINE: coordinate for new COG
TAG: MCOG

The COGs of the selected objects are changed to the the defined
coordinate. The COG is the reference point used by the Modify/Linear/Move
COG function. Also Skeletonal control, particle system, Modify/About_COGs/
xxx and Modify/COGs/xxx functions use this attribute.

Direction

DEFINE: coordsys
TAG: DDIR DDIV

                            - REFERENCE 1.48 -

This changes the direction for the selected objects to those of the
defined coordsys. Direction is needed for:

- skeleton methods

- spin becomes fully defined only when associated with direction

- when using the function Obj. Space to View

Velocity

DEFINE: axis
TAG: VVEL

The new velocity of the objects are defined by the direction and length of
the defined axis. Velocity means how much object is moved in one second.
Velocity is used by particle system oriented methods.

Spin

NUMERIC: three values in radians
TAG: VSPI

The spin (angular velocity) of the objects are given the values specified
by the user. Spin defines how fast the object is rotating. The first value
defines how fast the object is rotating around VHOR axis, second around
VVER and third defines the spin around the vector perpendicular to VHOR
and VVER.

Size

NUMERIC: scalar value in Absolute-Spatial-Coordinates
TAG: FSIZ

The default size for the objects is redefined. This is the size value used
by COLLISION, INT COLLISION and FRICTION methods. For example, the
collision detection system uses the size for detecting if the collision
between objects is possible or not.

Bend Local/

     Move_2D
     Move_3D
     Move_Radial
     Size_2D
     Size_3D
     Size_Radial

Bend Global/

     Move_2D
     Move_3D
     Move_Radial
     Size_2D
     Size_3D
     Size_Radial

Bend Endp./

     Move_2D
     Move_3D
     Move_Radial
     Size_2D
     Size_3D
     Size_Radial

Bend Linear/

     Move_2D
     Move_3D
     Move_Radial
     Size_2D
     Size_3D
     Size_Radial

All the free form bending functions work in similar ways. They are
normally used for modifying free forms. If other than free forms are
modified, only COGs are affected. A bending axis is defined with two
points, then a handle coordinate is defined. After the degree of effect
has been decided, the function is completed. The bending function effect,

                            - REFERENCE 1.49 -

defined below, determines how the bending axis is used to determine the
effect interval. This selects which points of the freeforms will be
affected. The effect interval is the volume bounded by two planes at each
end of the bending axis and orthogonal to the axis.

Bending Function Effects:

Local

Only those points within the interval are affected.

Global

All points are affected. Those within the interval are affected with the
direction of transformation, those outside in the opposite direction.

End_Point

All the points from the plane through the first end point and beyond are
affected. The degree of effect increases progressively away from this
first plane.

Linear

All points are affected with linear shear-like functions. The bending axis
determines the direction perpendicular to the effect.

The actual function type determines how the selected points are
transformed.

Move_2D

The displacement of the points is independent of the distance from the
point to the bending axis and its position in the bending interval.

Move_3D

Although the displacement is independent of the distance from the point to
the bending axis, the depth of the point within the bending interval is
treated in the same way as its distance along the bending axis.

Move_Radial

The displacement is independent of the distance to the bending axis but
increases radially away from the axis.

Size_2D

The displacement increases the further the point is from the bending axis
but is not affected by its depth within the interval.

Size_3D

The displacement is affected equally by the distance of the point from the
axis and its depth within the interval.

Size_Radial

The effect increases with the distance of the point radially from the
bending axis

Non-linear/

There are four different types of Non-linear spatial transformations. All
of them have a radial interval of effect.

Move

DEFINE: end point and center point Size
DEFINE: center point and end point

                            - REFERENCE 1.50 -

Stretch

DEFINE: center point and end point

Rotate

DEFINE: center-point and end-point

Each of these types can use one of the following control forms:

     * Parabola
     * Linear
     * Circle
     * Sine
     * Curve

The Non-linear transformation functions take freeforms as their operands.

The function type is applied to the points in the operands non-linearly
over the interval of effect. The degree of effect of the function type
depends upon the distance of the target point from the center point and a
scaling factor derived from a control curve. The scaling factor is
calculated by taking the distance of the target point from the center
point and using this to evaluate a point along the control curve from its
start. This control point is then projected perpendicularly onto an axis
and the scaling factor is this distance.

Pre-defined Control Forms

For the Linear, Circle, Sine & Parabola forms the control curve is defined
internally.

For example, using the Circle form of Modify/Non-linear/Move, the scaling
factor for each point in the operand is the perpendicular distance from
the axis to the point around the circumference of the circle which
corresponds to the distance of the target point to the defined center
point. The distance of the point is normalized, so that the full radius of
the effect of the function is the circumference of the control circle.

Curve Form

The Curve form uses a TRANSFORM method defined by the user, and selected
with /Set_Tool.

Because the scaling factor is derived by evaluating ALONG the control-
curve, the profile of the points being modified does NOT match the curve.

Set Tool

Select the object to be used as a tool by the Non-Linear functions Curve
form. This object must be a TRANSFORM method.

Special/

Project To Object

DEFINE: Two points, which define the projection direction and the
projection distance.

This function projects the operands onto a defined object.

The function takes two or more operands. The first operand is used as a
target, onto which the rest of the operands are projected. The operands
to be projected can be:

1. primitives; the function moves their COGs the distance defined by the
   given two points, unless the COGs collide to the target object (The
   first operand) earlier.

2. freeforms, including groups from a larger mesh. The control points of
   freeforms are moved independently the amount specified by the given two
   points, unless they collide to the target object (the first operand)
   earlier.

                            - REFERENCE 1.51 -

Inverse Kinematic

DEFINE: coordinate

This function can take one or more lines as its operands and moves the end
points with the pointer while applying Inverse Kinematic Evaluation. This
means the line segments will behave like mechanical linkages with rotary
joints at each point. The start point is fixed and never moves.

COGs/

     Size_2D
     Size_3D
     Stretch
     Extend
     Rotate
     Mirror
     Shear
     Rot&Ext

The above functions work in the same way as their linear counterparts,
except the COG's of the selected objects are used as the operands.

About COGs/

     Size_2D
     Size_3D
     Stretch
     Extend
     Rotate
     Mirror
     Shear
     Rot&Ext

The About_COG's functions also work in a similar way to their linear
equivalents, but the modification is applied to each multi-selected
object individually, with their COG's being used as ether the center or
fixed point for the function.

For example:
Using About_COGs/Size_3D causes each object to be individually sized on
all three axes using their COGs as the sizing center and in proportion to
the amount the cursor is moved away from the defined center relative to
the defined handle coordinate.

Freeform/

Reparametrize

This doubles the number of knot-points on a B-spline along the directions
selected, without affecting the shape of the curve.

Move Knotpoint <RAM>K

This allows a single knotpoint on a freeform to be selected and moved.
The <LMB> selects the nearest knotpoint on the freeform.

Concatenate

This takes multi-selected freeforms as its operands and creates a new
freeform by joining them together. The endpoints of each freeform are
joined to the startpoint of the next in the selection. When the operands
are meshes, then the start & end-points of the v direction lines are
joined. The number of points in the u direction of the result mesh will be
the same number of points as in the u direction of the first mesh in the
selection. The functions /Swap Direction and /Exchange_u_&_v can be used
to control how the freeforms are concatenated.

Swap Direction

Reverse the direction in which a freeform is evaluated.

                            - REFERENCE 1.52 -

Open/Close

The Open/Close Freeform requester has two gadgets indicating if a freeform
is currently open or closed in each of the u & v directions. Selecting
either of these gadgets will reverse the state. Selecting OK applies the
change to the targets.

Type

Change how the data of a freeform is to be interpreted. Both curves and
surfaces can be one of the following types:

     Polygon
     Phong
     B-spline

Invert

Treat current freeform data as knot points and convert freeforms to new
control polygon.

Remap

Modify number of points along each dimension of a mesh.

Surf. to curves

Create a set of lines from the lines defining the u dimension of a mesh.
To obtain the line s defining the v dimension, then use /Exchange_u_&_v
first

Distribute

Figure R1-28: Distribute.  (PICTURE: R1-28)

This function redistributes the knot points along a B-spline line or over
a B-spline mesh so they are spaced equidistant.

Assign

Figure R1-29: Modifying a Mesh with the Assign Function.  (PICTURE: R1-29)

Points from a mesh pushed onto the Vector stack using <DRAG><SHIFT> are
assigned new coordinates. The new coordinates are taken from a selected
line operand. The selected points are assigned their new coordinates
consecutively i.e. first selected point from the first point on the line.
If the number of selected points and points on the curve are un-equal,
then extra points are ignored or un-used.

Exchange u & v

This exchanges the interpretation of the u and v dimensions of selected
mesh(es).

                            - REFERENCE 1.53 -

Snap to

This function takes two or more freeforms as parameters and "snaps" the
points of the rest of the operands to the first "target" operand. The
"Snap" operation is based on the shortest distance from each point to the
target.

Usually, the operands are groups, because snapping e.g. a whole surface
to another one seldom makes sense. For example, the three leftmost curves
of a B-spline control polygon mesh can be snapped to another mesh, thus
joining the both.

Delete

DEFINE:
Select a freeform, <SHIFT><DRAG> a point on it, then select the function.

The function deletes the selected points on a freeform. If the operand is
a mesh, the "u"-direction curve on which the point lies, is deleted. To
delete a "v"-direction curve, apply Exchange_u_&_v first. If the curve/
mesh contains less than 4 points in a parameter direction after applying
the function, the type of the freeform is automatically converted to
"Polygon".

Insert

DEFINE: Select a freeform, <SHIFT><DRAG> a point on it, then select the
function.

This function adds a new point after the first selected point of each
operand curve. If the operand is a mesh, a new "u"-direction curve is
inserted. The position of the new point or the shape of the new curve is
obtained by interpolating linearly the selected point/curve and the next
point/curve. If the selected point/curve is the last one, it is
duplicated.

Break

DEFINE: Select a freeform, <SHIFT><DRAG> a point on it, then select the
function.

This function splits the target freeform. The point where a curve is
broken is copied to both halves. If the target is a freeform, it is broken
in "u" direction along a curve on which the selected point lies.

Draw Mode/

     * Accurate
     * Bounding_box

These two complementary toggles select whether the full wire-frame or a
rectangular prism enclosing the selected objects is to be used while a
modify function is being executed.

1.4 VIEW

Each view window has its own settings to define how and when it is
refreshed. These are defined with the functions under this menu heading.
The View to which these settings apply will be the currently selected
window.

Type/

* Parallel

View shows the objects using parallel-projection. No account is taken of
distance to the viewpoint when calculating the 2D positions of 3D
coordinates. The viewing coordinate system can be altered using the
keyboard controls.

* Perspective

                            - REFERENCE 1.54 -

The 2D positions of 3D coordinates are evaluated taking into account the
perspective caused by their distance from the viewpoint. The viewing
coordinate system can be altered using the keyboard controls. This form of
projection is slower than parallel.

* Separate IO

When this is enabled the input and output planes are separated. This means
that rotating the view coordinates allows object creation to be viewed
from any angle. Disabling this function means the input and output planes
remain connected during rotation, so the actual creation orientation is
changed.

Input Crd./

Set XY <RAM>X

Set I/O planes of view window to be x, y plane.

Set YZ <RAM>Y

Set I/O planes to be y, z plane.

Set ZX<RAM>Z

Set I/O planes to be z, x plane.

Set Custom <RAM>C

Set I/O planes to last defined custom direction maintained by all other
functions except Set_XY/YZ/ZX. This makes it possible to swap quickly
between all four main projections.

Define X

Define x axis of input plane to be the same as vector defined using two
coordinates.

Define Y

Define y axis of input plane to be the same as vector defined using two
coordinates.

Obj. Space to View

Use a selected object to define the orientation for the view window. In
other words, the direction of the selected object becomes the direction of
the active View window.

Camera/

Forward <RAM>F

Backward <RAM>B

These functions allow you to move forwards in the direction of the
aimpoint, or backwards away from the direction of the aimpoint. Both the
viewpoint and the aimpoint are moved. SETTINGS/View Resolutions/Position
defines how much they are moved each time.

Orientation

Opens a requester which is used for defining the current viewing angle.
Three values defines how much the viewing angle is rotated about x, y and
z axes in degrees. If the menu View/Separate IO is not set, this function
also rotates the input plane.

View->Camera <RAM> V

This allows the current View-orientation to be saved by storing it to the
selected objects. The objects must contain at least one camera, and the
orientation will be copied to the first viewpoint and/or aimpoint found.

                            - REFERENCE 1.55 -

Camera-> View

Selected objects are searched and the first viewpoint and/or aimpoint
found will be used to define the new orientation for the View. This allows
a new View orientation to be selected using previously defined viewpoint
and/or aimpoint. If no cameras are found, then an error will be raised.

Create Camera

This records the current view-orientation by creating a level at the
current hierarchy level containing a viewpoint and aimpoint. The aimpoint
and viewpoint data reflect the current orientation and zoom settings of
the View.

* Camera View

When this function is enabled, then viewpoint and aimpoint primitives are
used for defining the orientation for the View window when an animation is
played. This means that if these primitives are modified by the user, or
by a method during the animation, then the viewing position and zoom level
will also change. If there are more than one viewpoint or aimpoint, the
first found is used, unless the tag SWND is used for defining a particular
name of a View window to be exclusively related to aim/viewpoint in
question.

Display/

Zoom In <RAM>+

Increases magnification of View using zoom setting.

Zoom Out <RAM>-

Decrease viewing magnification using zoom setting.

Custom Scale

Enter zoom scale with numeric requester.

Position

Move view position in plane of View. A point in Absolute Coordinate Space
is defined first, and this is moved to the coordinate of the View defined
with the second <LMB> action.

Pos&Zoom In <RAM>I

DEFINE: center point and size of new view.

The center point of the new viewing coordinates is created, then a
rectangle the same proportions as the view is sized. If confirmed, then
the view will be expanded so the rectangle fills the view window.

Pos&Zoom Out <RAM>O

DEFINE: center point and size of the current view.

The defined rectangle becomes the size of the current view in the view
window.

Reset <RAM>E

Reset View Orientation to the last saved settings for the View.

Grid/

Select

Open the grid select requester to select name of grid to use as current
grid for View.

                            - REFERENCE 1.56 -

Figure R1-30: The Grid Requester  (PICTURE: R1-30)

Create

Create a new grid using the grid requester, with the following gadgets:

Name

Enter name of the new grid. Grids are selected using the name.

Grid

Enter X,Y, Z dimensions of grid.

Origin

Enter X,Y, Z coordinates of origin of grid.

Position & Size

The grid plane position and size definitions.

Pattern

A 16 bit value, which defines the drawing pattern for the grid. The
default value 65535 defines a solid line, whereas the value 255 defines a
broken line. The value 1 produces only discrete dots.

Color

The color of the grid.

If confirmed, then the new grid will become the current grid for the
window.

Modify

Allows a grid to be selected using the Grid select requester. Then the
Grid requester is opened to allow the selected grid to be modified. If the
changes are confirmed, the grid is modified and it becomes the current
grid

Reposition

The center of the grid is redefined to the coordinate defined with the
pointer.

Delete

Select name of grid to be removed from list of defined grids.

* Visible

If set, then grid is visible

* Snap to Grid

Entered coordinates will be rounded to nearest grid dimension.

                            - REFERENCE 1.57 -

Render/

Window <RAM>R

Render currently selected view window.

Boxes

Only render defined boxes in selected view window.

Grayscale

The highest resolution screen with maximum bitplanes will be opened with
a borderless window for rendering. The initial settings will be taken from
the current View, and the render settings requester will be opened to
allow the user to make changes before commencing rendering.

HAM

Open HAM screen with borderless view window and render to this. Initial
settings are taken from the current View, and the render settings
requester is opened to allow changes to be made before finally rendering.

* Selected

When set, only selected objects are rendered .

Settings <RAM>S

Open Render settings requester for current View.

Local Menu:

IMAGES/

Backdrop image/

Define

Produce file requester to select Backdrop image.

Show

Display Backdrop image. If the image is 24-bit, then a requester will be
produced asking for confirmation, as displaying the image may overwrite
the contents of the External Screen.

Environment map/

Define

Produce file requester to select Environment map image file.

Show

Display the Environment map image. As with Backdrop_image/Show, this will
ask for confirmation before displaying a 24-bit file.

COLOR/

     Ambient
     Background
     Background_gradient
     Environment
     Environment_gradient

Each of these menu selections assigns the current color to the RGB values
for the corresponding numeric gadget. The current color can be changed
using the Palette window.

                            - REFERENCE 1.58 -

SET/

File Name

Open a file requester to define the name of the output file, which is used
when IFF file/Targa file/Bmp file output is selected.

Memory_Usage

This opens a requester to control the maximum memory the View window can
use when rendering. The more memory the Rendering Engine has available,
then the faster it is capable of going, and if it does not have enough,
then it cannot render at all.

Figure R1-31: The Memory Usage Requester  (PICTURE: R1-31)

Gadgets:

Fixed

The maximum amount of memory the View can use when rendering is calculated
from the amount of free memory when the View is created.

Relative

The memory for rendering is determined as a percentage of the total
available memory when rendering is commenced. The default for this is 20%.

* Color Shading

When set the Rendering Engine will use color shading. For this setting to
produce the correct results, the screen palette must be set to "COLOR
SCALE" using the main menu function PROJECT/Environment/Screen Palette to
open the screen palette requester. Color shading works properly only if
screen depth is 6 or higher.

Figure R1-32: The Render Settings  (PICTURE: R1-32)

                            - REFERENCE 1.59 -

Gadgets:

Output

Select output target for rendered image:

Window     - Real-3D View window

IFF File   - File in IFF24 format

Targa File - File as Targa format

BMP File   - File in Windows(TM) BMP format

External   - External Screen e.g. 24-bit frame-store

Note:
If a View which is a handle to an External-screen is saved, it does not
automatically open the External screen when the file is re-loaded. This
will produce a warning requester, and if the External-screen is not
opened, then the View will default to rendering to it's window"

File

When one of the "File" output targets is selected, then the name of the
destination file is entered here, or it can be selected with SET/File_
Name. The file name will have the current Frame number appended to it,
and formatted using the Format string from the Animation system.

Mode = Draft

The rendering engine uses a grey-scale evaluation of the object color and
ignores all material properties to render the image. This is the fastest
rendering mode available.

Mode = Environment

All objects are treated as Not Reflected with reflections being taken from
Environment color and/or map. Only a single light-source from the
viewpoint is used. This is the fastest rendering mode which shows object
colors and a representation of material properties.

Mode = Lampless 

The scene is rendered using full object and material properties, but only
the single viewpoint light-source is used.

Mode = Shadowless

All user-defined light-sources are evaluated, but no shadows are
calculated.

Mode = Normal

Full rendering evaluation.

Mode = Outline

The scene is rendered as a hidden-line wire-frame image by rendering the
edges of all objects. These outlines are colored according to each
object's color properties and will be dithered if dithering is enabled.

Dithering = Rnd RGB

Separate random deviation for each color component:

     R = R + rnd1,
     G = G + rnd2,
     B = B + rnd3

Dithering = Rnd intensity

The same random deviation is used for each component:

     R = R + rnd,
     G = G + rnd,
     B = B + rnd

Dithering = Fixed rnd int

The same random deviation for each color component and a fixed dithering
pattern is used for every frame.

                            - REFERENCE 1.60 -

Dithering = Row

Colors dithered line by line.

Dithering = Raster

Use a checkered pattern for dithering.

Dithering = None

No dithering applied.

Ambient (0,0,0)

Color and level of ambient light. This affects the overall color of
highlights and shadows.

Background (128 128, 128)

Color of image background. This does not interact with the rendering of
objects and materials.

Backgr. grad (RGB settings & gadget) (0, 0, 0)

Using Background Gradient enables a non-uniform background to be produced.
When the Background gradient gadget is enabled, then the image will have a
uniform gradient from the Background color at the top of the image to the
Background Gradient color at the bottom.

Environment (128, 128, 128)

This specifies the color which is evaluated as if an infinite sphere of
this color surrounds the objects in the scene. This sphere is treated as a
Scene object and only appears in reflections and via refraction.

Envir. grad (RGB settings & gadget) (0, 0, 0)

When the Environment Gradient gadget is enabled, then the "Environment
Sphere" will have a gradient from the Environment color at the top, to the
Environment Gradient color at the bottom of the image.

Brightness (0 - 255)

This controls the scaling of all the light sources in the scene. The ratio
between the intensities of all the light sources is maintained, but re-
scaled by the Brightness setting. The default setting is 50.

Overlight (0 - 255)

The level of this setting controls how rapidly the color intensity turns
the color to pure white. While the color of each pixel is being evaluated,
the internal color components can exceed 255. The excess for each
component is multiplied by the Overlight factor and then added to the
other two components. The default setting of 1 means that only the
brightest parts of the scene become "over-exposed", and only gradually.

Recursions (0 - 16)

This defines to what depth light rays are evaluated as they reflect from
surface to surface. At the default setting of 3, only the first three
reflections of a light ray can have any effect on the current pixel.

Dither scale

This defines the maximal deviation of the color signals when using
dithering. The default value of 64 determines that only two consecutive
colors are mixed at a time. 24-bit rendering output is not affected by
this setting.

                            - REFERENCE 1.61 -

Backdrop image (file name & gadget)

When the Backdrop image gadget is enabled, then the named file is used as
a background to the rendered scene. This does not interact with the 3D
objects in any way and fills the background display area completely. If a
backdrop image is being used, this replaces any Background color settings.

Environment map (file name & gadget)

Setting the Environment map gadget maps the file specified onto the
"environment sphere". If an environment map is being used, this replaces
any Environment Color/Gradient settings.

Width & Height

These gadgets control the width & height of the rendered image in pixels
when rendering to a file or an Eternal Screen. They are ghosted when a
Window output target is selected, and they only display the window
dimensions.

Pixel h/w

Controls the aspect ratio used for individual pixels when rendering. The
default setting of 0. 0 means that the target Rendering Screen's automatic
aspect ratio is used.

DOF Scale

Controls how the Absolute Spatial Distance of an object from the Aim-point
affects the focus. "DOF Scale" does not relate directly to Absolute
Spatial Coordinates, but the higher it's value, the more rapidly distance
from the Aim-point increases blurring. If set to 0.0, then Depth of Field
is infinite and all objects are sharp.

DOF Strength (0.0 - 5.0) 

This numeric controls how much blurring occurs at a given distance. Like
"DOF Scale", the effect increases with an increase in value, and if set to
0.0, then Depth of Field is infinite. Default setting is 2.0.

X-resolution (1 - 8)
Y-resolution (1 - 8)

These two gadgets control the size of patches evaluated when rendering.
Default is 1 for X & Y.

Antialiasing (0---8)

This controls when the color signal difference triggers the Adaptive
Over-sampling of the Anti-aliasing routines.

     trigger level = 256/(2^aa)

     So: 256/(2^8) = 1 -> always over-sampled
     256/(2^1) = 128 -> if csd > 128

     where: csd = color signal difference
     aa = anti-aliasing setting

It also affects motion blur quality by triggering additional temporal
sampling.

Lightsamples (0 - 32)

This controls the amount of sampling used for diffuse light-sources. A
setting of 1 will produce satisfactory results unless the diffuse-light-
source is very large in relationship to the other objects in the screen.
A "Lightsamples" level of 32 converts a lightwall into over 1000 internal
light-sources, which will have a significant impact on rendering time.

Mat. samples (0 - 32)

Amount of sampling for Non-homogeneous Material Properties.

                            - REFERENCE 1.62 -

Subdivisions (0 - 4)

Controls how finely B-spline surfaces are evaluated when rendering, and if
B-spline->Phong is set, how much each face is subdivided. A setting of 0
will be faster, but may produce some visual errors. If set to 4, B-splines
are very finely subdivided during rendering. This will slow evaluation
considerably, but will allow even very convoluted surfaces to render
correctly. The default setting is 2, which is adequate most of the time.

B-spline->Phong

B-spline surfaces are converted internally to phong type freeforms before
rendering. This obviously produces all the artifacts of "Phong" shading,
but as it accelerates calculations considerably, it is useful for
evaluating a scene before final rendering. The quality of the result is
controlled by the Subdivisions setting. The conversion process consumes a
significant amount of memory.

Autogxp (set by default)

This rescales the output from the Rendering Engine, so only the brightest
parts of the scene will reach maximum display brightness when rendered.
The effect of this is the same as that of automatic exposure by a camera,
which is to produce the most balanced image possible under the available
lighting conditions.

Field rendering

Every odd frame is rendered half a pixel lower. This provides the odd and
even fields for 50fps PAL.

No bgr. antial.

Prevents anti-aliasing between the edges of objects and the background.
This is useful when the image will be genlocked with video source.

Alpha output

Rendering calculations will be carried out using Alpha Information from
visibles. This Alpha Channel information can go directly to an External
Screen if the device supports this, or can be rendered to a Targa Alpha
file.

HL-shading

Uses additive instead of proportional method to calculate consecutive
shades of a color. This produces significantly better results for 6-bit
HAM rendering. It can be also used for producing more "colorful" images
in general.

Export RPL

This function outputs all the material data-structure, object data
structure, animation settings data structure and the Render settings for
the View in ASCII RPL format to a file specified by the user through the
file requester.

Drawing Set <RAM>D

Opens Refresh settings requester. This requester controls how each View is
refreshed and what features are displayed when refreshed as wireframe.

                            - REFERENCE 1.63 -

Figure R1-33: Drawing Settings  (PICTURE: R1-33)

Gadgets:

Curve Subdiv. (2 - 9)

The number of subdivisions used when drawing curves. The default is 5.

Surface Subdiv (2 - 9)

The number of subdivisions used when evaluating the curves of a B-spline
surface. The default setting is 2.

Draw v

When set, the v direction of a B-spline is drawn using Surface
Subdivision. If un-set, then only u direction is subdivided.

Render Wire

Window is always refreshed as wire-frame when refreshed by the Animation
System.

Morphing Routes

Key-frame morphing paths are drawn when set.

No Refresh

The window will not be refreshed by normal refresh commands.

Coordinates

When enabled, the View will display the position of the pointer in
absolute spatial coordinates and the "Current and "Next" items on the
action list will be displayed in the active view window's title bar.

                            - REFERENCE 1.64 -

Aspect R.

Control the aspect ratio of the view window.

C.Polyg.

Draw control polygons of B-splines when set.

Curve

When set, the curve of a B-spline is drawn. This is the default setting.

Knots

If set, the knot-points of B-splines lines will be marked with a "oo" and
the end-point of the curve will be marked with an arrow. The end-points of
the curves for a B-spline mesh are marked with "u" or "v", depending on
which dimension. This is set by default.

Mappings

Mapping primitives are visible if this gadget is set. This is the default.

Names

The names of objects will appear on or near them if this is set.

Ray Trc.

If this is enabled, then the default refresh mode for the window will use
the rendering engine with the current Render settings.

Controls

When set, Controls objects are visible. This is the default.

Busy Req.

When set, a requester will be produced when the window is being rendered,
or when a Fractal tree is being generated, to show the percentage of the
task completed.

Abs Grid

This produces a fixed grid in the Z-X plane to make visualization of the
current view orientation easier.

Boxes/

Define

Create rectangle to confine rendering area. An unlimited number of these
rectangles can be defined, and they may overlap.

Modify

Select name of box to modify, then a numeric requester will allow the
position and dimensions of the box to be changed.

Delete

Select name of box to be deleted.

Delete All

Remove all box definitions for selected window.

Show All

Shows all defined boxes with broken outline.

                            - REFERENCE 1.65 -

1.5 ANIMATE

The Animation System refreshes all Views during play, ignoring the System
Refresh Settings and any "No Refresh" gadgets for individual Views.

Create/

These functions all build the necessary hierarchical structure to
implement the method for selected objects. The selected objects each
become the target for the method and the defined controls become the
parameters for the method.

For further details of the methods, see the reference chapter 2.

Coplanar Path

Create a PATH method using selected objects and defined B-spline.
DEFINE: points on the control polygon of a B-spline.

Orthogonal Path

Create a DIRECTION method using selected objects and defined B-spline.
DEFINE: points on the control polygon of a B-spline.

Rotation

Put the targets into counter clockwise rotation in the current input
plane.
DEFINE: coordsys

Sweep

Create a SWEEP method using selected objects and defined offset and
B-spline.
DEFINE: first offset, then points on the control polygon of a B-spline.

Stretch

Create a PATH method using selected objects and defined coordsys and
B-spline.
DEFINE: coordsys then points on the control polygon of a B-spline.

Size

Create a SIZE method using selected objects and defined coordsys and
B-spline.
DEFINE: coordsys then points on the control polygon of a B-spline.

RPL

Create a RPL method using targets and specified text. The text can be any
valid RPL. The method is attached directly to the target(s). No
additional structure is created.

Control/

Play Forwards

Evaluate animation for from current time to Time = 1.0 and refresh Views
every 1/Resolution time intervals.

Play Backwards

Play Animation from current time to Time = 0.0.

Go to Beginning

Change Time to 0.0 and evaluate animation at Root level.

Go to End

Change Time to 1 .0 and evaluate Root.

                            - REFERENCE 1.66 -

Step Forwards

Increase Time by 1/Resolution and evaluate Root. If Samples is greater
than zero, then the evaluation will be subdivided, but the Views will only
be refreshed at the end of the interval.

Step Backwards

Decrease Time by 1/Resolution and evaluate Root with subdivision, if
Samples > 0.

Refresh

Refresh the animation system. Some methods automatically add tags to
objects when refreshed first time, "matching" the parameters and the
target objects.

1.6 EXTRAS

Vectors /

The Vector stack is a place for storing and modifying Absolute Spatial
Coordinates or points from freeforms. It works on a "Last In First Out
(LIFO) basis. Whenever a <DRAG> box is formed, the points inside the box
are stored or "pushed" onto the Vector stack. If no keys are used as
modifiers, it performs a default action, which is to return the average
of all the points inside the box.

Points or coordinates can also be pushed onto the Vector-stack without any
automatic action being taken. They can then be retrieved or "pulled" from
the Vector stack to replace <LMB> coordinate entries while using Create or
Modify functions.

HOT-KEYS:

<DRAG>  - Push points from all objects and return average.

<DRAG>
<ALT>   - Push points from selected objects and average.

<DRAG>
<SHIFT> - Push points from all objects inside <DRAG> box onto Vector-
          stack.

<DRAG>
<SHIFT>
<ALT>   - Push points from selected objects onto stack.

<LMB>
<ALT>   - Push ASC onto Vector stack.

<RAM>   - Pull point to replace <LMB> click in a View.

Before the pints are used, it is possible to carry out various vector-
arithmetic operations with them to obtain averages of different groups of
points; or create new construction points relative to existing ones.

Push

This waits for a <LMB> click or <DRAG> in a View, and the coordinate
defined or points selected are pushed onto the stack.

Pull <RAM>.

Pull coordinate from stack to define a coordinate instead of using a <LMB>
click or a <DRAG> action.

Enter

Enter value for ASC using a requester. This coordinate is then pushed onto
the stack.

                            - REFERENCE 1.67 -

Clear

Clear Vector stack. The stack can also be cleared by using <DRAG> over
empty space.

Add

Add two vectors on the top of Vector stack. The result remains on the
stack.

Subtract

Subtract top vector from next vector, leaving the result on the stack.

Average

Average first two vectors on the top of the stack.

Average All

Find the average of all the vectors on the stack. This is the same as
using <DRAG>, only the average point is left on the stack.

Cross Product

Calculate the cross-product of the top two vectors of the stack. The
cross-product of two vectors is one which is perpendicular to both.

The following Evaluation System functions take multi-selected objects as
their operands, and if they are a valid evaluable parameter, then they
will be evaluated, otherwise they will be ignored. If the selected object
is a level, then the first sub-object will be used as the operand. For
each evaluated parameter, a point will be entered onto the Vector stack.

Eval. Current

This function evaluates a pint along parameters corresponding to the
current value of Time.

Define & Eval.

Three values between 0.0 and 1 .0 are entered. These are used as the
coordinates of the Parameter Space for the evaluable parameters.

Length evaluate

Evaluates a point a given distance in ASCs along each parameter which is
a line.

Undo

Recall previous hierarchy definition from undo buffer.

Statistics

Produces requester stating:

- Number of objects in hierarchy
- Memory used for hierarchy

Refresh All/

Wire-frame

Refresh all Views using their individual Refresh Settings.

Ray Trace

Renders all View windows. Each View uses its own Render Settings.

                            - REFERENCE 1.68 -

Cancel All

Terminates execution of all REAL 3D functions currently being executed.

Evaluate/

Curve Length

Display the lengths of the currency selected lines.

Parameter

Find the nearest point on selected parameters to the pointer when <LMB>
clicked. This point is entered onto the Vector-stack.

Select Objects <RAM><SPACE>

This function selects the objects in the hierarchy which currenCy have
points on the Vector stack selected with <DRAG><SHIFT> .

1.7 SET TINGS

Clip Boxes/

Figure R1-34: The Effect of a Clip Box  (PICTURE: R1-34)

Cubes can be selected as volumes to define which portion of the scene is
to be visible as a wire-frame. This does not affect rendering.

* Active

If set, then only those parts of the scene enclosed by the cubes currently
selected a s clip boxes will be drawn as wire-frame. The wire-frames are
only drawn to the nearest line endpoint inside the clip boxes.

Select

Enable currency selected cubes as clip boxes.

Deselect

Disable all current clip box definitions.

General

Produce requester for general system settings:

Vector Format

The numeric format for displaying coordinates.

Float Format

Numeric format to be used for general floating point number display.

Macro File

Where to save the current-macro definition.

                            - REFERENCE 1.69 -

Aspect Ratio

Default system aspect ratio. This is combined with the Refresh Settings/"
Aspect-R" or Render Settings/"Pixel-h/w" of each View to produce the
aspect ratio finally used for refreshing each View.

Drag Delay

This controls the delay before dragging produces the default average all
result from the Vector stack.

Confirm Save

When this gadget is activated, REAL 3D gives a warning before overwriting
any existing file.

Refresh/

These complementary toggles define the System refresh settings which
control which view windows will be refreshed when REAL 3D issues an
automatic refresh command.

* None    - None of the Views will be refreshed.

* Current - Only the currently active View.

* All     - All the view windows.

Oper.Level/

These functions control what levels of the hierarchy to re-draw.
Everything from the current level and below is re-drawn, with the depth
controlling how many levels above are to be considered.

* Active

Enable redraw depth when set

Depth

Enter number of hierarchy levels above current level to redraw.

Creation/

The following toggles determine various system actions during object
creation.

* Qry. Level Name

When a compound-object creation function is used, a requester is produced
to allow the user to change the name of the level created.

* Qry. Prim. Name

The creation of any new primitive queries its name.

* Auto current

Make newly created level the current level of hierarchy.

* Auto active

New object will be active after creation.

*Auto index

As new objects are created, a "." and an index number is appended to their
names. This auto-indexing may slow down the creation procedure in some
cases (F or example, when importing DXF files, where all primitives are
created at the same level).

                            - REFERENCE 1.70 -

Paths

Enter the default file paths for loading and saving. The path can either
be entered in the text gadget, or by clicking the gadgets on the left, a
file requester is produced which enables the path to be selected. These
can be separately defined for the following data sections:

     Objects
     Macros
     Materials
     Environments
     Projects
     Textures
     Images

Alpha Channel

This requester allows the current alpha information value to be set. This
is stored as an object property in an the same way as the RGB color
components; it acts just like a fourth color component for rendering.
Alpha information is used only when the combination of non-Draft mode
Render Settings with "Alpha-Channel" enabled is used. The background Alpha
level is automatically set to maximum value 255. One byte of alpha
information per pixel is written to the output target.

Attributes

Allows default attributes and names used at creation to be set for each
primitive. For example, if you want all the cubes you create to be
automatically hollow:

1. Choose Settings/Attributes.

2. Find the primitive "cube" from the list and select it, then press OK.

3. The REAL 3D will now create a requester which shows the current object
   attributes. Set the Hollow field and choose OK.

From now on all new cubes you create are hollow. You can verify this using
the Modify/Properties/Attributes function.

RPL

Produces requester to enter the depth settings for the various RPL stacks

Parameter Stack

This stack holds the parameters for RPL words as well as the results after
execution.

Returncode Stack

Hold the addresses of RPL words calling another word, so execution can
return to the original location.

Control Stack

Used internally by RPL while compiling new words. It is also used for "IF"
and 'LOOP" nesting, and recursion.

Vocabulary Stack

Stack used for storing the references to the compiled code for RPL word
definitions. The amount of memory required for each reference is not
exactly quantifiable, but is approximately 12 bytes on an Amiga System.

Strings

Maximum number of string variables which can be used in RPL at any one
time. The maximum length of a string is 255 bytes.

                            - REFERENCE 1.71 -

View Resolutions/

     Rotation (0.125664)

     Position (0.100000)

     Zoom     (10.00000)

These functions enable the increments used for view window rotation,
position and zoom to be set. Rotation is specified in radians, Position
in ASCs and Zoom as scaling units. The default settings are shown in
parentheses.

Undo/

* Active

Enable operation of Undo buffer. If memory runs out, it is possible to
recover the memory used for the buffer by de-activating it.

Set Depth

Define the depth of the Undo buffer. This defines how many previous
versions of the hierarchy are stored. If the scene is complex, then a deep
buffer will consume memory very quickly. The default depth is 3.

Clear

Clears current contents of Undo buffer This also recovers the memory used
by the buffer.

File Icons

This function calls up a requester , enabling the user to select which
REAL 3D file data sections should have an icon created for them when they
are saved.

1.8TOOLS

This menu is only active if a Tool window is the active window.

Icons/

     * Visibles
     * Sectors
     * Structures
     * Lights
     * Controls
     * Compounds
     * Freef.Tools
     * Mod/Linear
     * Mod/Structure

The menu toggles, listed above, select which sets of pre-defined tool
icons are to be loaded into the selected tool window. It is possible to
have several tool windows each containing different, or even duplicate
sets of tool icons.

Create Icon

The user is requested to enter the text for a tool gadget. This will be
created in the currently active Tool window. When this gadget is selected,
an RPL file or word with the same name as the gadget text will be looked
for in the MACRO directory or Master RPL environment. If found, it will be
executed. The maximum length for the gadget text is 11 characters.

Delete Icon

This opens a requester displaying the text contents of all the user
defined tool gadgets. One can then be selected for deletion.

                            - REFERENCE 1.72 -

Chapter 2 ANIMATION SYSTEM
--------------------------

2.1 Principles

2.1.1 General Information

The basic concept of the Real 3D Animation system is that it is possible
to create an object which consists of a shape, and a motion. These
animation actions are created by adding an animation method to the same
level of hierarchy as the object defining the shape. For example, a moving
car consists of a shape and a motion object.

      +-----------+
      | MovingCar |
      +-----------+
         /     \
     +-----+ +-----------+
     | Car | | Motion(M) |
     +-----+ +-----------+
               /
           +------+
           | Road |
           +------+

Figure R2-1: A moving car consists of a shape and a motion.

Technically a method consists of an object to which some kind of procedure
has been attached. The Animation system informs each method when time has
changed and each procedure then determines what actions it should carry
out to the targets. For brevity the term "method" is used interchangeably
with method procedure unless it is necessary to make the distinction
clear.

There are two possible kinds of method procedures: built-in method
procedures and procedures defined via RPL by the user.

2.1.2 Built-in Methods

The built-in methods, with the exception of TRANSFORM, each use the
objects at the same level of hierarchy as themselves as targets
(excluding other methods). Built-in methods all carry out their actions
on their chosen targets depending on the difference between their current
time and the new time value. The actions of the built-in methods are
determined by three factors: their method type, their parameters (if
specified in their syntax), and the outcome of their evaluation of time.

Most of the built-in methods require additional information in order to
carry out their actions. This information takes the form of either one
or more parameters contained within the sub-structure of the method
object, or one or more tags attached to the method object. It is also
sometimes necessary to attach tags to the targets and the parameters.
Since most methods require at least one parameter it is usual to use a
level as the method object. It is possible, and often necessary, to
arrange methods hierarchically so that one method affects the parameters
of another.

2.1.3 User Defined Methods

User defined methods can take whatever action they choose when informed
by the Animation system that Time has changed. They do not even have to
affect any target or take any account of their method time. It is quite
legitimate for a method procedure to take some arbitrary action such as
a call to a system function for every new frame. Since the syntax of the
method procedure is decided by the user, it is possible to choose an
appropriate method object to attach to the procedure; and any required
parameters or tags can be specified in any way.

The user can create new methods either using the RPL word MTH_CREATE, or
by using the build-in method named just RPL. It is also possible to
customize existing methods by associating SRPL and SFOR tags with them.

                             - REFERENCE 2.1 -

Note:
A method procedure is executed for every time interval. The number of time
intervals during an animation is dependent on Resolution and Samples.

2.1. 4 Evaluating Parameters

Most methods require that certain parameters be of a type that can return
certain information when processed using the Evaluation System.

Evaluation System takes three floating values and one object as parameters
and returns either a point or direction corresponding to the given
parameter values.

Currently the following primitives can be used as evaluable parameters:

     offset
     axis
     coordsys
     ellipse
     line
     mesh

Other primitives can be made evaluable by attaching SFOR or SRPL tags to
them and by defining relevant RPL variables. In order to make the object
fully evaluable (ie. all methods can use it) proper values must be
assigned to the following variables by user defined formula/procedure:

x,y,z - position corresponding given parameter value

i,j,k- direction corresponding given parameter

Variables t, u, and v are used for parameter space and are read only. All
built-in evaluable primitives are sensitive only to the first dimension
(t) except for the mesh which uses the first two dimension (t and u).
Tags SFOR and SRPL can be attached to evaluable primitives in order to
customize them, in which case the built-in evaluation is processed first.

The user has access to the Evaluation System via the RPL words "O_EVAL"
and 0 DERIV which allows an evaluable parameter to be used to provide the
same kind of control for a user defined method procedure as the built-in
methods use.

2.1.5 Animation Oriented Tags

There are five vector tags which are evaluated by the Animation-System and
used to control the operation of all methods. The interaction of these
tags and their affect on the operation of the methods is as follows:

VTIS - This tag defines when the method becomes "active". The current time
       of the method in is automatically shied to start from zero. In
       other words, when the current time reaches the value defined by the
       tag VTIS, the method begins to work and its time starts from the
       zero.

VTIE - When the current time reaches this value, the method in question
       becomes inactive. The local time of the method is stretched so that
       when the current time runs from the VTIS up to VTIE, the time of
       the method in question runs from 0 up to 1.

VPHS - The time is shifted by this value for the method in question.

VFRQ - The time of the method is multiplied by this value.

                             - REFERENCE 2.2 -

be used for accessing SFOR - This tag can the RPL interface of the
Animation System. The tag can be associated with methods, targets and
parameters and can affect the RPL variables defined during animation. The
contents of this tag is usually a formula which modifies certain variables
in order to customize the object it is associated with.

SRPL - The purpose of this tag is to provide the user with total control
over the RPL interface of the Animation system. The tag value can be any
RPL program providing the user with a more powerful way to customize the
method, target, and/or parameter objects.

The RPL Interface to the Animation system consists of the following
variables:

T - The current time. This time can be modified by the Animation Window
    and is always between 0 and 1.

Res     - Frame resolution

Frm     - Current frame

a, b,c  - Velocity

i, j, k - Spin

x, y, z - Center of Gravity

t, u, v - Local time of the method in question or parameter value for
          object evaluation

m1, m2  - Mass

d       - Diameter of the object (size of the bounding sphere)

f       - Strength of the Force

rnd     - Random value, always between 0 and 1

o       - Address of the object

I       - General usage 32 bit integer value

fx, fy,
fz      - General usage variables. Purpose depends on the context

s       - Distance

dt      - Time interval between subsequent animation samples

e       - Kinetic energy of the object

2.1.6 Particle System Principles

The particle system of Real 3D is implemented through methods.

These methods treat all targets as "particles" with velocity, spin, mass,
and other physical particle properties. Particles then behave according to
Newtons Laws of Motion when acted upon by forces. With the exception of
PROCESSOR, each particle method modifies the velocity and spin by applying
a force that depends upon the method type and the properties of the
particles. The motion properties are stored in the tags VVEL and VSPI
which describe the linear and rotational velocity along or about each axis
respectively.

2.1.6.1 Converting Motion Properties into Real Motion

The PROCESSOR method converts the motion properties into actual Move and
Rotate modifications for each particle. If this method is not present on
the level of the targets of other particle methods then VVEL and VSPI will
be changed but the particles will not move or rotate.

                             - REFERENCE 2.3 -

2.1.6.2 Forces in the Particle System

The other methods each apply some force to particles. The default formula
for this force can be over-ridden by the user with the tags SFOR and SRPL.
These can contain expressions which are evaluated by RPL and assigned to
the force variable.

If the strength of the default force is not strong enough then SFOR f*100,
for example, would increase this by a factor of 100. It can also be set to
a constant simply with SFOR 100, which can be desirable for certain
effects.

Individual methods then have certain other variables that relate to their
effect.

2.1.6.3 Real Time and Particle Motion

The particle methods simulate the effect of physical motions. This means
they require an absolute time scale on which to operate. This time scale
is called Real-Time, and is expressed in terms of seconds.

A particle with a velocity of 1.0 will travel the distance of one Absolute
Spatial Coordinate in one Real Time second. Spin is evaluated in the same
way with one revolution (expressed as 2 * PI radians) occurring per Real
Time second. The amount of Real Time evaluated during an animation is
controlled by the "Seconds" field of the Animation Window, and is not
related to "Resolution" or rendered frames.

2.1.6.4 Side-effects of Particle Animations

The Particle System simply evaluates the velocity and spin of each
particle for each time interval and then the PROCESSOR method updates the
position and direction accordingly. It is often not possible to calculate
what the previous motion properties of a particle were given only the
current values. Imagine looking at a pool table after the player has
played his shot and all the balls have come to rest. It is clearly not
possible to work out how the balls came to be in their current position.
They have no velocity or spin and they could have just stopped moving from
some unknown direction, or been placed there by hand. This means that a
particle animation CANNOT be evaluated in reverse in the same way as other
methods.

The only possible way that Real 3D could play particle animations
backwards would be to record every frame in a buffer, and this would eat
away all available memory too quickly to be of any use.

The Undo buffer is the only way to recover the starting position of a
particle animation to replay it.

Another side effect is that the motion produced by other methods is not
taken into account by the Particle System. It can only evaluate the
movement and rotation described by the tags VVEL and VSPI.

Often particle animation is the fastest way to produce animations where
moving and colliding objects have to behave as realistically as possible.
To "hand-animate" the collision between hundreds of irregular objects
would be prohibitively time consuming, and would be unlikely to yield
believable results. With the particle animation system all the
calculational details are taken care of leaving the user free to design
the actual animation.

2.1.7 Creating New Methods

If it is not possible to create a desired animation effect using one of
the built-in methods it is possible for the user to create their own via
the Real Programming Language-RPL. There are two ways in which this can be
accomplished:

                             - REFERENCE 2.4 -

1. Create some RPL text, possibly via Project/Macros/Record Macro, then
   create the RPL method with the text attached.

2. Define an RPL word to carry out the desired animation action; then use
   the MTH_CREATE word to add this new method to the "Method Type" list of
   the Animation Properties requester. The word must be defined in the RPL
   "Master" environment, or "INHERIT" must be used in the RPL Shell window
   where the word was defined. The new method can then be used exactly
   like any of the built-in methods. The method procedure attached to the
   method object, when this method type is selected, is the user defined
   RPL word; and it can be as simple or as complex as necessary.

2.2 Animation methods

The structure of each syntax description is as follows:

SYNTAX

The necessary hierarchical structure is described under this heading. The
syntax is generalized to show the minimum structure necessary for the
method to function as a stand alone animation object.

PARAMETERS

Parameters required by the method in question are described under this
heading. Parameter names refer to the SYNTAX.

TAGS

Tags which have some specific application to the method in question are
included here.

VARIABLES

All RPL variables affected by the method in question are described here.

DESCRIPTION

A full explanation is given of how the method evaluates any parameters or
tags to carry out its actions on the targets.

EXAMPLE

Simple example clarifying the usage of the method.

2.2.1 Path

SYNTAX

Figure R2-2: PARAMETERS  (PICTURE: R2-2)

path - evaluable parameter object defining how to move the objects.

TAGS:

VPHS - Automatically created for each target if the ISKE tag is not
       present or the value is not equal to 2.

ISKE - Created and set to 2 when VPHS tags are created.

                             - REFERENCE 2.5 -

VARIABLES

a, b, c - relative movement during "dt"
dt      - time interval
t, u, v - current time

DESCRIPTION:

Moves all targets along the given "path". The movement of the targets for
each time interval is evaluated from the parameter.

When the animation is played for the first time, the VPHS tag is
automatically created for each target object by snapping their COGs to the
parameter curve.

If automatic phase definition is not desired, the user can create an ISKE
tag with the value of 2 before playing the animation.

RPL variables a, b and c reflect how much the target object in question
will be moved during the time interval.

2.2.2 Rotation

PURPOSE

Rotate about another object

SYNTAX

Figure R2-3: (PICTURE: R2-3)

PARAMETERS

coordsys---Any geometric

TAGS

None

VARIABLES

i,j, k - Defines how fast the target object in question rotates about the
         object space of the parameter object.

I      - Modify flags. Can be used for defining what kind of rotation
         should be applied to the target objects.

The following values are valid:

0      - target objects are rotated about the parameter object (same as
         Modify/Linear/Rotate).

4      - target objects are rotated about COGs of their own (same as
         Modify/About COGs/Rotate).

8      - target objects are not rotated, their COGs are (same as Modify/
         COGs/Rotate).

DESCRIPTION

Rotates targets around parameter object. Each geometric has a well defined
axis as part of its geometry. The ROTATION method rotates the targets
about this axis.

The angular step per time interval is derived from "Resolution"; but is
calculated so that the method does not rotate the targets completely
during its evaluation. It rotates by one angular step less than that
derived, producing continuous motion for a cyclic animation.

 


                             - REFERENCE 2.6 -

Note:

The Right Hand Rule is used for defining the direction of rotation about
the parameter; so the direction of rotation can be changed by mirroring
the parameter object.

2.2.3 Sweep

PURPOSE

General rotation with accelerations

SYNTAX

Figure R2-4: (PICTURE: R2-4)

PARAMETERS

center-  parameter for the center-point for general rotation.

control- evaluable parameter defining how to rotate the target around
         the center-point.

TAGS

VPHS -   Phase used for defining rotations for the target

VARIABLES

I -      Modify Flags, see ROTATE method.

DESCRIPTION

General rotation with accelerations and decelerations. This rotates the
targets around "center". The rotation is controlled by the evaluation of
the "control" parameter.

Character animations, walking robots etc. applications where arbitrary
accelerations are needed can be easily created using this method.

The tag VPHS can be associated with any target object but it is not
defined automatically.

2.2.4 Size

PURPOSE

Size objects during an animation

SYNTAX

Figure R2-5: (PICTURE: R2-5)

PARAMETERS

center - parameter defining center-point for sizing.

                             - REFERENCE 2.7 -

control - evaluable parameter defining how object is sized.

TAGS

None

VARIABLES

I -      Modify flags, See ROTATE method.

DESCRIPTION

Changes the targets size according to the distance between the "center"
parameter and the evaluated point from the "control".

The variable "I" can be used for defining whether to use Modify/Linear/
Size, Modify/COGs/Size or Modify/About_COGs/Size.

2.2.5 Stretch

PURPOSE

Stretch objects in given directions

SYNTAX

Figure R2-6: (PICTURE: R2-6)

PARAMETERS

coord - coordsys defining axis for the stretch.

control- evaluable parameter defining how the target dimensions are
         stretched.

TAGS

None

VARIABLES

I -      Modify flags, see ROTATE method.

DESCRIPTION

The targets dimensions in relationship to the axis of the "coordsys" are
changed according to the point evaluated from the "control" and projected
onto the corresponding axis of the "coord".

This method can be used for creating deformations needed in bouncing
spheres, collision detection animations etc.

2.2.6 Direction

PURPOSE

Move along a path with automatic direction control.

SYNTAX:

Figure R2-7: (PICTURE: R2-7)

                             - REFERENCE 2.8 -

PARAMETERS

path - evaluable parameter defining move and rotate transformations.

TAGS

VPHS, ISKE

VARIABLES

None

DESCRIPTION

Moves targets along a given "path" rotating it to follow the curvature of
the parameter.

VPHS tags are automatically created by snapping the COG of each target
object to the parameter curve "path".

This method can be used for creating animations where objects move along
a path like a car follows a road. Swimming fishes, sneaks etc. can be
created by subdividing freeform meshes into subgroups and using groups as
targets for this method.

2.2.7 Move & Dir

PURPOSE

Move along a path with separate direction control

SYNTAX

Figure R2-8: (PICTURE: R2-8)

PARAMETERS

move -   evaluable parameter defining movement for the targets.

direct - evaluable parameter defining rotation for the targets.

TAGS

VPHS, ISKE

VARIABLES

None

DESCRIPTION

This is a combination of methods MOVE and DIRECTION. The first parameter
defines how the targets are moved. The second parameter defines how the
targets are rotated using the same evaluation as DIRECTION. Thus, two
identical curves produce a result the same as the DIRECTION method. If the
second parameter is a straight line (axis) the method works as a MOVE
method.

The VPHS tag is automatically defined for each target by snapping the COG
of the target in question to the parameter curve "move".

2.2.8 Control curves

SYNTAX

Figure R2-9: (PICTURE: R2-9)

                             - REFERENCE 2.9 -

PARAMETERS

curve1,
curve2-  two evaluable parameters defining how to control the stretch,
         rotation, and movement of the targets.

TAGS

VPHS, ISKE

VARIABLES

I -      Modify flags. The first bit is used to define whether or not the
         method should stretch the target. If set, targets are not
         stretched.

DESCRIPTION

Two points are evaluated from each of the parameters of this method and
the relationship between these points are used to control the
transformations of the targets. The distance between the points controls
the size, the angle between them controls the rotation, and the relative
displacement since the previous evaluation controls the movement.

The VPHS tag is automatically defined for each target by snapping the
target to the first parameter curve.

2.2.9 Simple skeleton

SYNTAX

Figure R2-10: (PICTURE: R2-10)

PARAMETERS:

skel - skeleton

TAGS:

VOFF -   Defines the offset between the skeleton and target COGs.

If not present, each target COG is snapped on to the skeleton.

VPHS -   Parameter value defining the position on the skeleton.

SFOR,
SRPL -   when associated with targets, can be used for redefining the
         position on the skeleton.

ISKE -   the value 2 indicates that the VPHS and MCOG tags defined for
         each target.

VARIABLES

x, y, z - Parameter space defining the position of the target object on
          the skeleton.

DESCRIPTION

This method moves the COGs of the targets to the skeleton. The position on
the skeleton is defined by the tag VPHS associated with the target object
in question. However, SRPL and SPHS tags allows a more powerful way to
define the same thing: the position can be defined using whatever formula
to define proper values for x,y and z variables. If the value changes
during the animation, the position of the target object on the skeleton
changes correspondingly.

The VOFF tag defines the offset between the skeleton and target COGs. If
not present, each target COG is snapped over the skeleton.

                            - REFERENCE 2.10 -

By default the tag VPHS is automatically defined by snapping the COG of
the target onto the skeleton and detecting which parameter value of the
skeleton corresponds to that position. The difference between these two
points are then used for defining the value for the tag MCOG.

2.2.10 Skeleton

PURPOSE

Skeletonal control

SYNTAX

Figure R2-11: (PICTURE: R2-11)

PARAMETERS:

primary - primary skeleton object defining the direction for the target
          objects

secondary - secondary skeleton object defines how the target objects are
            oriented about the primary skeleton.

TAGS

VOFF -   displacement between target COG and skeleton objects

VPHS -   parameter value defining the position on the skeleton.

SFOR,
SRPL -   when these tags are associated with the targets, variables x, y
         and z can be used for redefining the position of the target
         object.

ISKE -   Indicates that the VPHS, VDIR, and VDIV tag definitions are
         executed.

VARIABLES

x, y, z - position of the target object.

DESCRIPTION:

Skeleton parameter "primary" is connected to the targets using move &
rotate transformations. By modifying the skeleton objects, the targets
are modified accordingly. Skeletons are typically modified using Inverse
Kinematics. The second parameter is needed to fully define the direction
for the target objects. By rotating this object about the skeleton, all
the target objects will also rotate about the skeleton.

The VOFF tag defines the offset between the skeleton and the target COGs.
If not present, each target COG is snapped over the skeleton.

By default the MCOG, VDIR, VDIV and VPHS tags are defined automatically
for each target.

Note:
The hierarchical combination of SIMPLE SKELETON/SKELETON with the INV
KINEMATIC method is a common way to create "Character Animations".

                            - REFERENCE 2.11 -

2.2.11 Inv kinematic

PURPOSE

Modify skeletons by re-defining or manipulating the end point only.

SYNTAX:

Figure R2-12: (PICTURE: R2-12)

PARAMETERS:

path-    evaluable parameter that defines the end point for the skeletonal
         object

TAGS

VOFF -   Offset vector.

SRPL,
SFOR -   Formula/procedure for defining the end point

VPHS -   Phase for end point evaluation

VARIABLES

a, b, c - endpoint

DESCRIPTION:

Applies Inverse Kinematic evaluation to the targets while moving their
end-points along "path". Inverse Kinematics attempts to move the end point
of the skeleton to a defined point without changing the distance of points
used for defining the skeleton.

Variables a, b and c reflect the endpoint defined by the evaluation
process and can be changed by user defined SRPL and SFOR tags.

2.2.12 Morphing open & closed

PURPOSE

Morphing based on key-frames

SYNTAX

Figure R2-13: (PICTURE: R2-13)

PARAMETERS:

key1,
key2, ... two or more key-frame objects

TAGS

VOFF -   displacement for the target object

                            - REFERENCE 2.12 -

VARIABLES

None

DESCRIPTION:

This Method can be used to apply morphing to the targets. The hierarchical
structure of the target should correspond to the structure of "key"
objects. At least two key objects are needed. Cubical B-Spline
interpolation is used for defining intermediate situations.

The targets object data structure is just used as the space in the
hierarchy to store the results of the morphing. Modifying it does not
affect the actual result of the animation.

If the targets contain material references, morphing is also applied them
too. Different materials must be created and used for the target and the
"keys" as their material data structures is/are again used to store the
morphing results.

The following material properties are morphed:

- S-map u, v, w & h
- X-Freq & Y-Freq
- Transparent Color
- Specularity
- Specular Brightness
- Brilliance
- Transparency
- Turbidity
- Turbidity Saturation
- Refraction
- Effect Level
- Roughness
- Bump height
- Dither
- a & b variables for each Procedural expression

2.2.13 Transform

PURPOSE

Time transformations

SYNTAX

Figure R2-14: (PICTURE: R2-14)

PARAMETERS

coord -  axis or coordsys primitive to which the evaluated point from
         "trans" is projected.

trans -  time is mapped to the parameter space of this evaluable
         parameter.

TAGS

None

VARIABLES

None

DESCRIPTION:

Local time transformation. This differs from other methods in that its
"target" is actually the local time being passed by the Animation System
to each method. After the time has passed through the TRANSFORM method
then the local time will have been changed to a new value according to
the parameters.

                            - REFERENCE 2.13 -

The method re-maps the parameter space of the "trans" parameter by
projecting it onto the "coord" parameter. If the "coord" parameter is
an axis, then the transformation affects only the first component of the
time (t). If it is a a coordsys, then other dimensions can also be defined
(u, v).

2.2.14 Wave

SYNTAX

Figure R2-15: (PICTURE: R2-15)

PARAMETERS

coordsys - coordsys or axis primitive defining wave direction

wave -   any evaluable object defining a shape of the wave

TAGS

None

VARIABLES

x, y, z - position of the target in the object space of "coordsys"

fx, fy, fz - position corresponding x, y and z variables

t, u, v - current time

DESCRIPTION

This method applies "wave" effect over all the target objects. If the
target object is a freeform, then the wave is applied separately to each
individual point. If the target object is non-freeform (hierarchical
"level" object, quadric etc.) then it is treated as a whole.

If the first parameter object is "coordsys", the targets are moved
parallel to the "z" axis of it and the targets projections to "x" and "y"
axis are used as parameters for evaluating pints from the second parameter
object. These evaluated pints are projected to the "z" axis and the
difference between the projected points are used for defining how much the
target in question should be moved. If the second parameter object is a
mesh (or any evaluable object sensitive to the first two component of the
parameter space) the wave shape can be defined separately in both the "x"
and "y" directions.

If the first parameter object is "axis", then radial waves are created and
the distance between the target and the axis is used as a parameter for
evaluating the shape of the wave from the second parameter object.

The user can define whatever control curve for wave generation by
attaching a formula or procedure to the method object with the tags SRPL
and SFOR and by defining the variables "fx", "fy" and "fz". The variables
"x", "y" and "z" represent the current position of the target object in
question in the object space of the first parameter object. If the first
parameter object is "axis" then the "x" variable reflects the distance
between the target and the axis and the "y" reflects the targets
projection to the axis.

                            - REFERENCE 2.14 -

EXAMPLE

Symmetrical sin waves

1. Create a mesh

       +------+
       | Root |
       +------+
          /
     +------+
     | mesh |
     +------+

2. Create the method WAVE

         +------+
         | Root |
         +------+
           /  \
     +------++----------+
     | mesh || Level(M) |
     +------++----------+

3. Create axis inside the method so that
it is perpendicular to the mesh

         +------+
         | Root |
         +------+
           /  \
     +------++----------+
     | mesh || Level(M) |
     +------++----------+
                /
           +------+
           | axis |
           +------+

4. Create a circle beside the axis.

         +------+
         | Root |
         +------+
           /  \
     +------++----------+
     | mesh || Level(M) |
     +------++----------+
                /     \
           +------++--------+
           | axis || circle |
           +------++--------+

2.2.15 Radial force

SYNTAX

                              / FMAS 10
     +--------+  +----------+/
     | Object |--| particle |-- VVEL 0 0 0
     +--------+\ +----------+\
                \+----------+ \ VSPI 0 0 0
                 | Level(M) |
                 +----------+\
                              \
                               \+--------+
                                | center |
                                +--------+

Figure R2-16:

PARAMETERS

center - evaluable primitive defining a "center" of the force.

TAGS

FMAS -   mass

VVEL -   velocity

VARIABLES

x, y, z - COG of target object

a, b, c - velocity of target object

i, j, k - spin of target object

d -      size (diameter) of target

m1 -     mass of target object

m2 -     mass of parameter object

dt -     time interval between subsequent animation samples

e -      kinetic energy of target

f -      strength of the force

t, u , v - current time

fx, fy, fz - direction of the force (unit vector)

s -      distance between parameter target objects

                            - REFERENCE 2.15 -

DESCRIPTION

Modifies velocity of the objects by applying a force radiating from the
"center".

The default formula used for defining force field is f = m1*m2/d<, which
makes RADIAL FORCE act like gravity on a planetary scale. A small offset
(0.05) is added to d< to prevent extreme behavior of particles.

The method can be customized by associating SFOR and SRPL tags with it.
The direction of the force (fx, fy, fz) and the strength of the force (f)
can be freely modified/redefined. All other variables are "read only".

The velocity of the object is modified according to Newtons laws of motion
F = ma, where "F" is the strength of the force, "m" is a mass of the
object and the "a" is the acceleration.

For example, if the strength of the force field is "F", the mass of the
target object is "m", the time interval between subsequent frames is "dt"
then the velocity of the object is changed by "dv".

                dv     F * dt
     F=m*a=>F=m*--=>dv=------
                dt       m

SEE ALSO

PROCESSOR method

2.2.16 Directed force

SYNTAX

                              / FMAS 10
     +--------+  +----------+/
     | Object |--| particle |-- VVEL 0 0 0
     +--------+\ +----------+\
                \+----------+ \ VSPI 0 0 0
                 | Level(M) |
                 +----------+\
                              \
                               \+--------+
                                | direct |
                                +--------+

Figure R2-17

PARAMETERS

direct - evaluable parameter defining the direction and center of the
         force field

TAGS

FMAS -   mass (kg)

VVEL -   velocity (m/s)

VSPI -   spin (rad/s)

VARIABLES

x, y, z - COG

a, b, c - Velocity

i, j, k - Spin

d -      size (diameter)

m1 -     mass

dt -     duration

e -      kinetic energy

f -      strength of the force

t, u, v - current time

fx, fy, fz - direction of the force field (unit vector)

s -      distance between center of force field and the object in question

DESCRIPTION

Modifies the velocity of particles by applying an external force. The
direction and strength are defined by evaluating the parameter object. The
direction of the force field is the evaluated direction of the parameter
object and the strength is defined by the distance between the object in
question and the evaluated position (center of the force field) of the
parameter object.

                            - REFERENCE 2.16 -

Default force is defined using the formula f = 1000.0/(1+s), where "s" is
the distance from the center of the force field.

User defined formulas and procedures can change the variables "f" and "fx,
fy, fz". All other variables are read only.

The velocity of the object is modified according to the Newtons laws of
motion: F = m * a. In other words, if the force affects the object for the
time of "dt", then the velocity is changed by the value "dv" according to
the following equation:

        F * dt
     dv=------
          m

2.2.17 Tangent force

SYNTAX:

                              / FMAS 10
     +--------+  +----------+/
     | Object |--| particle |-- VVEL 0 0 0
     +--------+\ +----------+\
                \+----------+ \ VSPI 0 0 0
                 | Level(M) |
                 +----------+\
                              \
                               \+------+
                                | axis |
                                +------+

Figure R2-18:

PARAMETERS:

axis -   valuable parameter defining the axis of the rotating cylindrical
         field of force.

TAGS

FMAS -   mass

VVEL -   velocity

VSPI -   spin

VARIABLES

x, y, z - COG

a, b, c - velocity

i, j, k - spin

d -      size

m1 -     mass

dt -     duration

e -      kinetic energy

f -      strength of the force

t, u, v - current time

fx, fy, fz - direction of the force field

s -      distance between center of the force and the object in question

DESCRIPTION:

Modifies velocity and spin of objects by applying a force that is
perpendicular to the vector between the COG of the particle and the axis
of the force field. The direction and strength of this rotating force is
derived by evaluating the "axis" parameter for the current time.

The default force is defined using the equation f = 1000/s where "s" is
the distance between center of the force field and the object in question.

The force affects the object according to the Newtons laws of motion. The
direction of it is defined using the "right hand rule".

                            - REFERENCE 2.17 -

2.2. 18 Collision

SYNTAX
                               / FFRI 0.7
                               | ICSM 2
     +--------+  +----------+  | FREB 0.5
     | Object |--| target1  |--< FMAS 10.5    / FFRI 0.7
     +--------+\ +----------+  | VVEL 0 0 0   | ICSM 2
                \+----------+  | VSPI 0 1 0   | FREB 0.5
                 | Level(M) |  \ FSIZ 1.5     | FMAS 10.5
                 +----------+\               /| VVEL 0 0 0
                              \             / | VSPI 0 1 0
                               \+--------+ /  \ FSIZ 1.5
                                | param1 |/
                                +--------+

Figure R2-19:

PARAMETERS

Objects with which the target objects can collide.

TAGS

FREB -   Rebound Energy

FFRI -   Surface Friction

ICSM -   Collision Surface Sampling

FMAS -   Mass

VSPI -   Spin

VVEL -   Velocity

FSIZ -   Size of the bounding sphere

VARIABLES

m1 -     mass of the collided parameter object

m2-      mass of the collided target object

s -      distance between COGs

a, b, c - relative velocity vector (v2 - v1 )

i, j, k - relative spin

e -      relative kinetic energy

t, u, v - current time

o1, o2 - addresses of collided objects 

I -      1 = process collision,
         2 = do not process collision,
         3 = fatal error

p1, p2 - addresses of internal collision data structures

DESCRIPTION

Non-interactive collision detection. Collisions are detected only between
targets and parameter objects.

The COLLISION method affects the motion of the particles using principles
related to natural physical laws. Each collision transfers kinetic energy
between the particles involved. The velocity of each particle after a
collision is dependent on their initial velocities. In addition, velocity
is converted to spin and vice versa depending on the shape of the objects
and where they collide.

The tag FREB defines a floating-point value which describes how the energy
of motion is changed by the collision. The new velocity of the objects is
the product of its/their current velocity and the average of the Rebound
Energy. If both tags equal 1.0, the collision is totally elastic and no
motion energy is lost. If both values are 0.0, collision is totally non-
elastic and the particles "stick" together. Values greater than 1.0 means
that the velocity of the particles increases for each collision.

The tag which affects how the spin and velocity interact as particle
surfaces "rub" against each other is FFRI. This is the "surface-friction"
of each particle. The higher the value of this tag the more the velocity
alters spin for each collision and vice versa.

Both these properties can have any positive value. If they are absent then
the default value for FREB is 1.0 and for FFRI is 0.0. Values between 0.0
and 2.0 for FFRI produce results resembling normal physical friction
effects, with a value of 0.5 being typical. Values greater than 2.0 will
produce un-natural or extreme surface-friction behavior.

                            - REFERENCE 2.18 -

The final tag for controlling collision behavior is ICSM (Integer
Collision Sampling). When two particles come within initial collision
range their ICSM tags are checked. If present the tag determines how
finely to spatially-sample the surfaces used for the surface-collision
detection. The lowest sampling value of the particle pair is used.

ICSM can have the following value:

0 - Default (same as ICSM absent)
1 - Increased sampling
2 - Maximal sampling

For basic collisions where the particles collide and immediately rebound
the default is adequate, but if particles "slide" or "roll" over each
other, or if surface-friction effects are involved, then one of the higher
values may be required to produce realistic results. If the spatial-
sampling is not high enough then some surface penetration can result in
incorrect collision effects.

The user defined SFOR and SRPL formula/procedure can be used for
customizing collision processing. The variable "I" is used for defining
whether the collision should be processed. If the value of this variable
is 1, collision is detected and will affect the velocities/spins of the
collided objects. The value 2 indicates that no collision was detected. By
having the value of this variable always at 2, the user defined formula
can disable all collisions. The value of 0 indicates a fatal error and
animation playing is cancelled.

When using an RPL word as a collision hook function, the variables o1, o2
and p1, p2 provides the user with total control over collision processing.
The variables o1 and o2 contain the addresses of objects between whom the
collision detection should be applied.

The variables p1 and p2 points to internal data structures described below
where all data used for processing collisions can be found. This interface
can be used for modifying velocities and spins of objects directly.

Offset  Field  Size  Description
--------------------------------
  0      aObj   4     Address of the object

  4      aCOG   4     Address of the COG of the object

  8      aVel   4     Address of the VVEL tag value the object.

 12      aSpi   4     Address of the VSPI tag value.

 16      fSiz   8     Size of the bounding sphere of the object

 24      fMas   8     Mass of the object

--------------------------------

2.2.19 Int collision

SYNTAX

                               / FFRI 0.7
                               | ICSM 2
     +--------+  +----------+  | FREB 0.5
     | Object |--| target1  |--< FMAS 10.5
     +--------+\ +----------+  | VVEL 0 0 0
                \+----------+  | VSPI 0 1 0
                 | Level(M) |  \ FSIZ 1.5  
                 +----------+

Figure R2-20

PARAMETERS

None

TAGS

FREB -   Rebound Energy

FFRI -   Surface Friction

ICSM -   Collision Surface Sampling

                            - REFERENCE 2.19 -

FMAS -   Mass

VSPI -   Spin

VVEL -   Velocity

FSIZ -   Size of the bounding sphere


VARIABLES

m1 -     mass of the collided parameter object

m2 -     mass of the collided target object

s -      distance between COGs

a, b, c - relative velocity vector (v2 - v1)

i, j, k - relative spin

e -      relative kinetic energy

t, u, v - current time

o1, o2 - addresses of collided objects

I -      1 = process collision,
         2 = do not process collision,
         3 = fatal error

p1 , p2 - addresses of internal collision data structures

DESCRIPTION

Interactive collision detection. Like the non-interactive collision
detection this only modifies the velocity and spin of the particles
involved. However, collisions are detected between all particles at the
same level as the INT COLLISION method, and the motion of all colliding
particles interact.

SEE ALSO

COLLISION

2.2.20 Friction

SYNTAX

                              / VVEL 0 0 0
     +--------+  +----------+/
     | Object |--| particle |-- VSPI 0 0 0
     +--------+\ +----------+\  FSIZ 0.5
                \+----------+ \ FMAS 100
                 | Level(M) |
                 +----------+

Figure R2-21

PARAMETERS

None

TAGS

FMAS -   mass

FSIZ -   size

VVEL -   velocity

VSPI -   spin

VARIABLES

x, y, z - COG (position) of the object

a, b, c - velocity .

i, j, k - spin 

d -      size (diameter)

m1 -     mass

dt -     time interval (duration)

e -      kinetic energy

f -      coefficient of friction

t, u, v - current time

                            - REFERENCE 2.20 -

DESCRIPTION

Frictional force evaluation. This method slows down the velocity and spin
of objects at the same level. The SFOR tag can be used to define custom
friction formulas.

The variable f contains the default "coefficient of friction", the default
value for this is evaluated using the following formula:

       d * e
     f=------
       d*e+m

This coefficient is used for modifying the velocity and the spin of
objects according to the following formulas:

     vel(new) = vel(old) * (1 - f)

     spi(new) = spi(old) * (1 - f)


In other words, the bigger the object, the higher the coefficient and the
more the friction force slows it down. If the size of the object is 0,
force would'nt affect it at all.

The bigger the mass, the less the friction can affect the velocity of the
object.

The user defined formula/procedure can change the following variables:

f -      coefficient

a, b, c - velocity

i, j, k - spin

All other variables are read only.

2.2.21 CREATION

SYNTAX

                              / SDEL I=t>0.5
     +--------+  +----------+/
     | Object |--| target   |-- VCRE 0 0 0
     +--------+\ +----------+
                \+----------+
                 | Level(M) |\ +--------+ / SCRE I=t>0
                 +----------+ \| sample |/
                               +--------+

Figure R2-22

PARAMETERS

sample - Sample objects for procedural creation

TAGS

VCRE -   creation time

SCRE -   formula used for procedural creation

SDEL -   formula used for procedural deletion

VARIABLES

x, y, z - position of the object

a, b, c - velocity

i, j, k - spin

d -      size

m1 -     mass

dt -     time interval

e -      kinetic energy

t, u, v - current time

fx, fy, fz - birdth day

I -      boolean value for deletion/creation

                            - REFERENCE 2.21 -

DESCRIPTION

This method is one of the most unusual of the built in methods. It
actually creates and deletes objects during animations. Objects are
created and deleted depending on how the SCRE String CREation formula tag
evaluates for each parameter and how the SDEL (String DELetion formula)
tag evaluates for each target.

For each parameter object that the SCRE formula evaluates to a non-zero
value then the object is created at the same level as the CREATION method;
effectively becoming a target for possible deletion.

For each target that the SDEL formula evaluates to a non-zero value then
the object is deleted.

If the parameters do not contain a SDEL formula or the formula never
evaluates to non-zero, then this method will continue to create without
deletion until the animation ends or the available memory is exhausted.

If there isn't a SCRE tag associated with the parameter object, method
never creates it. This makes it possible to use other methods for
animating sample objects of creation method. For example, boiling water,
fireworks etc. phenomena can be easily created this way.

The tag VCRE is automatically created for all created targets for saving
the birthday of the object in question. This information can be used for
deleting objects according to their ages.

The possibIe values for the variable "I" are:

1 -      Object is either created or deleted depending on the tag in
         question (SCRE, SDEL)

0 -      Object is not created or deleted

All other variables are "read only".

If there are SFOR or SRPL tags associated with the method object, they are
processed after the SCRE and SDEL tags.

2.2.22 Processor

SYNTAX

                              / VVEL 0.64-0
     +--------+  +----------+/
     | Object |--| particle |-- VSPI 0 0 0
     +--------+\ +----------+
                \+----------+
                 | Level(M) |
                 +----------+

Figure R2-23

PARAMETERS

None

TAGS

None

VARIABLES

a, b, c - velocity

i, j, k - spin

DESCRIPTION

This method processes the motion properties of each target object into
Move and Rotate transformations according to the Newtons laws of motion.

If a velocity tag is associated with the target object, it is read and the
object is moved according to the following formula:

      s
     v- => s=v*t
      t

where "v" is the velocity of the object (VVEL), and "t" is a time interval
between subsequent frames (animation samples).

If a spin tag is associated with the target object, the object is rotated
according to the following formula:

                            - REFERENCE 2.22 -

       2*PI Rad      w * t
     w=--------=>RAD=------
           t         2 * PI

where w is a spin defined by VSPI tag, "t" is the time interval, PI is
3.14 and "Rad" is the angle in radians.

2.2.23 RPL

SYNTAX

     +--------+
     | Object |\
     +--------+ \+------------+
                 | Object (M) |--- SRPL Proc
                 +------------+

Figure R2-24

PARAMETERS

The number and type of parameters required for this method are entirely
dependent upon the implementation of the method procedure attached to it
via the SRPL tag.

VARIABLES

Any

DESCRlPTION

A method whose method procedure is defined with a single line of RPL text.

This method executes the user specified RPL "text" every time the object
animation time is changed. This "text" acts as the method procedure. The
"text" is just passed to RPL interpreter. It can contain a short
interactive program, the name of a user defined RPL word or it can contain
the "LOAD" word with a file-name; which loads and executes the actual
program from the named file. The RPL interpreter for executing this "text"
resides in the "Master" environment so it is necessary to use "INHERIT"
if the word definition was created in an RPL window.

The program should not contain any variable or word definitions because
they will be redefined every time the method procedure is executed (which
happens at least once per frame).

                            - REFERENCE 2.23 -

Chapter3 RPL SYNTAX
-------------------

Following prefixes are used for variables and constans to indicate the
type of the variable.

a -      generic address

b -      byte (8 bits)

e -      either integer or floating-point value

f -      floating-point value

i -      long integer value (32 bits)

I -      boolean flag. 0 deNote:s FALSE, any other value deNote:s TRUE.

s -      address of a sting

v -      vector (consist of three floating-point values)

w -      short integer value (16 bits)

CFA -    Code Field Address. The address of a defined word on the
         Vocabulary Stack.

name -   The text for an RPL token (word or variable).

NULL -   The integer value zero.

3.1 KERNEL WORDS

This sub-chapter contains the syntax and descriptions for all the general
usage words built-in to RPL's vocabulary when a RPL window is initially
opened.

WORD

     (

TEMPLATE

     (

DESCRIPTION

This defines the start of an RPL comment. All the text after it until
either ")" or EOL is ignored.

Note:
The two comment control words "(" and ")" are defined internally and do
not appear as part of the vocabulary.

EXAMPLE

     ( this is a comment )
     VLIST ( list vocabulary

WORD

     )

TEMPLATE

     )

DESCRIPTION

Terminates a comment before EOL reached. Other words can then follow.

EXAMPLE

     0 1 . ( top stack item, then second item ).

WORD

     .

TEMPLATE

     i.

DESCRIPTION

Takes a parameter off the stack and prints it as an integer value.

EXAMPLE

     10 .
     15.5 .
     10 20 30 1.2 ....

                             - REFERENCE 3.1 -

SEE ALSO

     F.H.O.B.

WORD

     .S

TEMPLATE

     .S

DESCRIPTION

Prints the whole contents of the Parameter Stack without removing any
values.

WORD

     !

TEMPLATE

     iValue aVariable !

DESCRIPTION

Assigns an integer value iValue to an integer variable aVariable.

Integer and floating point variables must be referenced only with words
that are for the variable type in question. For example, an integer
variable MUST NOT be referenced using F! or F@, but only with ! and @.
This is because the internal representations for similar integer and
floating-point values are different.

EXAMPLE

     VARIABLE MyVar ( define an integer variable )

SEE ALSO

     @ VARIABLE

WORD

     &

TEMPLATE

     & Word aWordAddr

DESCRIPTION

Retrieves the address of the specified word and places it on the stack.
The word can then be stored in a variable and executed by EXECUTE.

EXAMPLE

     : MyWord
      "Hello!" PUTS
     ;

     & MyWord EXECUTE

SEE ALSO

     ?& EXECUTE

WORD

     +

TEMPLATE

     i2 i1 + iResult

DESCRIPTION

Takes two integers off the stack, adds them, and puts the sum on the
stack.

                             - REFERENCE 3.2 -

EXAMPLE

     VARIABLE MyVar

     10 20 + MyVar ! ( MyVar = 10 + 20 )

WORD

     -

TEMPLATE

     i2 i1 - iResult

DESCRIPTION

Takes two integers off the stack, subtracts the stack top value from the
second one, and puts the difference on the stack.

EXAMPLE

     20 10-.

WORD

     *

TEMPLATE

     i2 i1 * iResult

DESCRIPTION

Takes two integers off the stack, multiplies them, and puts the product on
the stack.

EXAMPLE

     3 4 * .

WORD

     /

TEMPLATE

     i2 i1 / iResult

DESCRIPTION

Takes two integers off the stack, divides the second value on the stack by
the stack top item, and puts the integer part of the quotient on the
stack.

EXAMPLE

     10 5 / .

WORD

     :

TEMPLATE

     :

DESCRIPTION

Begins a word definition. . The ":" is followed by a space and the name,
which can be up to 15 characters, of the RPL word to be defined.

The definition ends with a ";".

EXAMPLE

     ( define RPL word )
     : MyFunction
        "this is RPL word" PUTS
     ;

     ( call it )
     MyFunction

SEE ALSO

     ;

WORD

     ;

TEMPLATE

     ;

                             - REFERENCE 3.3 -

DESCRIPTION

Ends a word definition.

SEE ALSO

     :

WORD

     <

TEMPLATE

     i2 i1 <lResult

DESCRIPTION

Takes two integer values off the stack and compares them. If the second
value is less than the first value, < puts TRUE on the stack, otherwise
FALSE is put on the stack.

WORD

     <=

TEMPLATE

     i2 i1 <= lResult

DESCRIPTION

Takes two integer values off the stack and compares them. If the second
value is less than or equal to the first value, <= puts TRUE on the stack,
otherwise FALSE is put on the stack.

WORD

     <>

TEMPLATE

     i2 i1 <> IResult

DESCRIPTION

Takes two integer values off the stack and compares them. If the second
value is not equal to the first value, <> puts TRUE on the stack,
otherwise FALSE is put on the stack.

EXAMPLE

     : MyTest ( i1 i2 )
      <>
      IF
        "not equal" PUTS
      ELSE
        "equal values" PUTS
      ENDlF
      ;




     10 20 MyTest ( not equal
     5 5 MyTest ( equal values

WORD

     =

TEMPLATE

     i2 i1 = IResult

DESCRIPTION

Takes two integer values off the stack and compares them. If the values
are equal, = puts TRUE on the stack, otherwise FALSE is put on the stack.

EXAMPLE

     : IsEqual ( i1 i2 )
      =
      IF
        "Yes" PUTS
      ELSE
        "No" PUTS
      ENDIF
     ;

     10 20 IsEqual ( no
     10 10 IsEqual ( yes




			     END OF PART 5





