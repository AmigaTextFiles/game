Part 3



 and generates relocation records for relocations that span hunks. The
 linker also combines any hunks in the object module that have the
 same name. For example, the linker merges all near BSS hunks and
 appends them to the __MERGED data hunk.
[] generates overlay nodes, if required.
[] copies segments of the library files that are referenced by the program
 to the executable module. If those segments reference any symbols,
 then the library segments that define those symbols are also copied to
 the executable module. This process is repeated until all symbols are
 resolved.
[] produces data for the overlay supervisor, if required.
[] produces a map file and cross-reference tables, if requested.

 If you are not using overlays, all of the hunks in the executable module
are contained in one primary node (also called the root node). If you are
using overlays, the executable module also contains a node for each
overlay.



Running Your Program

When you run your program, the AmigaDOS system loader copies the
executable module into memory. As it copies the executable module, the
loader:

[] resolves the remaining relocations.
[] allocates and zeroes the memory required for uninitialized far data (the
far BSS hunks).

 There are two other program components, the stack and the heap, that
are not part of the executable file but that form an important part of the
final executing program.


Stack Area  The stack is a writeable memory area whose size is set by the AmigaDOS
stack command or by the external long integer __stack. The default
stack size is four kilobytes. This stack is used during function calls for
saving registers and passing arguments. Within a function, automatic
variables are allocated from the stack.
 For many C programs, a four-kilobyte stack is adequate. If your
program requires more stack space, see Chapter 11, "Using Amiga
Specific Features of the SAS/C Language," for information on allocating
additional stack space.

How Does the Compiler Work? 175




Heap Area  The heap is a writeable memory area whose size is determined by the
 following:

 [] the dynamic memory needs of the program
 [] the amount of memory installed on the system
 [] the amount of memory that is currently being used.

All memory allocation routines such as malloc return memory from
  the heap. If the heap is not large enough to handle a request, the library
  function calls on the AmigaDOS system to provide more memory.



 Changing Hunk Names

 If you change the names of any of the hunks produced by the compiler,
 keep in mind the following:

 [] All hunks with the same name are merged by the linker.
 [] Hunks with different names are loaded separately by the system loader.
 [] The system loader may have trouble finding enough contiguous
memory to load very large hunks.

The following hunk section names are reserved:

 NTRYHUNK
Your load file may contain only one NTRYHUNK hunk. The linker
places this hunk first in the executable module. Usually, this name is
used only as the name of overlay manager's code hunk.

 __MERGED
This name is used for the near data section. All hunks with this name
are merged and moved into the root node. The startup code initializes
register A4 to point to this hunk.

 _NOMERGE
Hunks with this name are never merged with other hunks, including
other hunks named _ NOMERGE. They occupy a single, separate hunk
in the load file.

176 Chapter 12




Addressing Data

If you compile with the default options, your program code and data are
referenced with one of three different types of addresses:

[] 16-bit address relative to the program counter.
  Items in the code section are referenced with 16-bit PC-relative
addresses.
  The 16-bit offset is a signed value that is added to the current 32-bit
address in the program counter. Therefore, if a function is more than
32 kilobytes above or below the point at which it was called, the linker
constructs an absolute branch instruction within the 32-kilobyte range
and routes the call through that branch.
[] 16-bit address relative to register A4.
When you link your program, all data in the near data and near BSS
hunks are merged into one near data section. When you run your
program, the startup module loads the address of the near data section
into register A4, and this section is referenced with 16-bit A4-relative
addresses.
  Using 16-bit addresses produces code that is smaller and faster
because each load or store instruction requires only four bytes.
However, because near data are referenced with 16-bit addresses, you
are limited to 64 kilobytes of near data. If you have a very large data
structure or array, consider placing it into the far section.
[] 32-bit absolute address.
Items referenced with 32-bit addresses can be located anywhere in
 memory. Items in the far data and far BSS sections are referenced with
 32-bit absolute addresses.
Using 32-bit addresses produces code that requires more space and
 takes longer to run because each load or store instruction requires six
 bytes. However, because far data are referenced with 32-bit addresses,
 there is no limit on the amount of far data that you can declare in your
 program.

  chip data are always referenced with a 32-bit pointer and are
therefore considered non-reentrant. However, most chip items are picture
image structures that are referenced in a read-only mode. If your
program uses chip data as read-only, your program is still re-entrant.
Chip data can be accessed by the Amiga custom chips such as graphics
chips and sound chips. Chip data are loaded into chip memory, which is
the lowest 512K to 2M of system memory, depending on the version of
the hardware that you are running.
  You can modify how your program code and data are accessed by:

[] declaring individual data items with the appropriate keyword:
__chip,__near, or__far

How Does the Compiler Work? 177




[] compiling with the stringmerge option
[] compiling with the abs funcpointer option
[] compiling or linking with the smallcode and/or smalldata options
[] compiling with the code and/or data options
[] compiling with the datamem, codemem, and/or bssmem options
[] linking with the chip or fast option.

For more information on the __chip, __near, or __far keywords,
see Chapter 11, "Using Amiga Specific Features of the SAS/C Language."
For more information on the compiler and linker options, see Chapter 8,
"Compiling and Linking Your Program."



Understanding Data Types and Sizes

The following sections describe how various data types are represented
on Amiga hardware.
  By default, all arithmetic objects are signed, and therefore, they can
take on values less than zero. However, if you specify the
unsignedchar option, the compiler treats all char objects as
unsigned.
  You can specify that an integral object (char, int, short or long)
be signed or unsigned by declaring the object with the signed or
unsigned keyword, as in the following example:


  unsigned long x;


  The following table lists the sizes, minimum values, and maximum
values of each of the signed and unsigned data types.



TypeBytes Minimum  Maximum
signed char1 -128+127
unsigned char 1 0 255
signed short  2 -32,768  +32,767
unsigned short2 0 65,535
signed int4 -2,147,483,648  +2,147,483,647
unsigned int  4 0 4,294,967,295

 (continued)

178 Chapter 12




TypeBytes Minimum  Maximum
signed long4 -2,147,483,648  +2,147,483,647
unsigned long 4 0 4,294,967,295
float (IEEE)  4 3.402E-373.402E+38
double (IEEE) 8 2.222E-308  1.797E+308
float (FFP)4 5.421E-209.223E+18
double (FFP)  4 5.421E-209.223E+18




  Note: In the AmigaDOS environment, pointers are always 4 bytes in
length. Also, the values for signed int and unsigned int in this
table are the values if you do not specify the shortint option.
  The default size of an int on Amiga hardware is four bytes. However,
you can set the size of an int to two bytes by compiling your program
with the shortint option.
When the compiler is calculating the value of an expression using
variables of different data types, the compiler performs some automatic
type promotions and then does the calculation using the data type of the
widest operand. The widest operand is the operand that can contain the
largest positive number. For example, suppose you may have a
calculation involving a variable of type char and a variable of type
unsigned long. The char is automatically promoted to int, so the
calculation now involves an int and an unsigned long. The int is
then promoted to unsigned long under the wider type rule.
  These rules can dramatically affect your code. In the example
calculation, the char is signed. If it holds a -1, for example, the -1 is
promoted to int, yielding -1. The int is then promoted to unsigned
long, yielding a very large positive number.
These implicit conversions follow the conversions described in the
ANSI Standard in Section 3.2.1.5, "Usual Arithmetic Conversions." The
following table lists the type to which the various data types are
converted.

How Does the Compiler Work? 179




Operand Type  Conversion Type
charint
unsigned char int
short  int
unsigned shortint
intint
unsigned int  unsigned int
longlong
unsigned long unsigned long
float  float
double double




  Note: As previously stated, if you compile your program with the
shortint option, integers are two bytes long. Then, if you cast the
result of an expression involving two integers to another type, you do not
get the results you might expect. For example, you could have the
following code in your program:


long l;
int i=32000;
int j=32000;


l = (long)(i * j);


If you compile this code with shortint, i and j are not promoted to
long before the expression is evaluated. The result of the expression is
too long to fit into a short integer. The overflow is cast to a long, which
gives the wrong result. To correct the problem, explicitly cast i or j to a
long, as in the following example:


l = (long)i * j;



Storing Data
In the C Language, each data object is associated with a storage class that
is either declared with a keyword (auto, extern, static, or

180 Chapter 12




register) or determined by the context in which the declaration
occurs.
  An object's storage class determines the location where the object is
stored and the scope of the object. Therefore, the storage class of the
objects in your program can affect your program's size and performance.
  The following list describes where objects are stored, based on their
storage class:

External
  External objects are stored in a global data area (one of the near, near
  BSS, far, far BSS, or chip sections).

Static
  Static objects are stored in a global data area (one of the near, near
  BSS, far, far BSS, or chip sections) unless you specify the
  stringmerge option. If you specify stringmerge, data declared
  static const are placed in the code section.

Automatic
  Storage for automatic objects is allocated on the stack during the
  execution of the function in which the object is defined.

Formal
  An object has the storage class formal if it is a parameter (or
  argument) to a function. Storage for formal objects is allocated on the
  stack during the execution of the function in which the object is
  defined.

Register
  Register variables may be stored in registers, or they may be stored on
  the stack. If you run the global optimizer, the optimizer allocates all
  register variables and ignores the register keyword. If you do not
  run the optimizer and you specify the noautoreg option, only those
  variables you declare with the register keyword are stored in
  registers. If you compile with autoreg, the code generator decides
  which additional variables are stored in registers.

181





  13 Writing Portable Code

181 Introduction
181 Compiling Your Program
182 Writing Your Program
  183 Dealing with Data Type Sizes
  183 Determining Structure Size and Padding
  184 Writing Structures to a Disk File
  187 Using Narrow Types in Pre-ANSI Function Declarations
  188 Using Incomplete Structure Tags




Introduction

The C language has many characteristics of a portable language, but some
features of the C language are dependent on the type of machine on
which the program is running. However, you can write programs that
run on many different machines if you follow some guidelines when
compiling and writing your program.
  The following sections describe actions you can take to improve the
portability of your programs.



Compiling Your Program

You can compile your program with the strict and/or ansi options.
These options enable many warnings that identify possible problems in
your code that may cause errors if you port your code to systems other
than the Amiga system. For example, the following code generates
message number 120:
void func1(long);
void func2(void)

{
short s=0;
func1(s);
}

182 Chapter 13




If you compile this code with the strict option, the compiler displays
the following message:


Warning 120: Integral type mismatch: possible portability problem
Expecting "long", found "short"



Writing Your Program

If you use only library functions and language features that are defined in
the ANSI Standard (American National Standard for Information
Systems--Programming Language C), your program should compile
without modification on any system that has an ANSI-compliant C
compiler. However, there are many features of the C language that are
implementation-defined. Even if your program compiles without
generating errors, it may not run as you expect. See Appendix 3,
"Implementation-Defined Behavior," for more information.
  To help you identify non-portable functions and macros in your
program, you can define the _STRICT_ANSI preprocessor symbol. You
can define this symbol by entering define _STRICT_ANSI= 1 in the
sc command or by entering the following statement in your C source file
before any header files are included:


#define _STRICT_ANSI 1


If you define _STRICT_ANSI, the header files that are defined by the
ANSI Standard (such as errno.h and stdio.h) do not define any
prototypes or macros for functions not permitted by the ANSI Standard.
If your program calls a non-ANSI function, the compiler issues a warning
message because the function has no prototype. For more information on
the _STRICT_ANSI symbol, refer to SAS/C Development System Library
Reference, Version 6.0.
  In addition, if you follow a few additional guidelines, you can avoid
most portability problems. The following list contains some guidelines
that can help improve the portability of your program.

[] Do not assume data type sizes are standard.
[] Do not assume structure padding or size is standard.
[] Be careful when writing structures to disk.
[] Do not use narrow types in old-style definitions.
[] Be careful about using incomplete structure tags.
[] Do not write pointers to files. Pointers are useless outside of the
invocation of the program that generates them.

Writing Portable Code 183




[] Do not assume that you know whether char variables are signed.
[] Do not assume that you know the placement of bitfields within
structures.

The following sections discuss these guidelines in more detail.


Dealing with  Do not assume that the int data type is always a particular length. The
Data Type Sizes  ANSI Standard specifies that the int type must be at least as long as the
short type and that the short data type must be able to hold numbers
in the range 32767 to -32768. Therefore, portable code should never
store numbers larger than 32767 or smaller than -32768 in an int. Use
long for larger numbers.
  The default size of an int on the Amiga system is four bytes. On other
systems (such as the IBM PC), the size of an int is two bytes. The
SAS/C Compiler treats the data types int and long as the same data
type. However, you can set the size of an int to two bytes by compiling
your program with the shortint option. If you compile with
shortint, the compiler treats the data types int and short as the
same data type.
  If you port your program to a system that uses two-byte integers and
you do not compile with the shortint option, you may receive
unexpected results. For example, when passing parameters on the Amiga
system, short and char variables are silently promoted to ints.
Therefore, any function declared as receiving a long does not produce a
warning if you pass a short or char to the function. To receive an
appropriate warning message, you can enable warning 120 by compiling
with the warn= 120 or strict compiler options.
  Declaring an object as signed is usually redundant, because integral
objects are signed by default. However, judicious use of the signed
keyword can enhance your program's portability, because some compilers
may make char declarations and bitfields unsigned by default.


DeterminingEven though the Motorola 68000 processor uses byte addresses, it
Structure Sizerequires that 16-bit and 32-bit data items be aligned on even addresses.
and PaddingThat is, the lowest bit of the address must be zero. Because of this
requirement, the SAS/C Compiler inserts dummy bytes (called padding) as
necessary to align integers, floats, doubles, and pointers.
  For example, in the following structure, the SAS/C Compiler adds one
byte between the structure members a and 1.


struct misc
{
char a[3];

184 Chapter 13




long l;
  };


If the dummy byte was not added, the long structure member would
end up on an odd boundary and an addressing exception would result.
  On other systems, an ANSI compliant C compiler may add more or less
padding as required. Many computers require that long integers fall on
four-byte boundaries, so the compiler would add three bytes of padding
instead of one.
  Because of these alignment requirements, data structures may be
different sizes on different machines. Do not assume that you know the
size of a structure based on the fields declared in it. Use the s i z eo f
operator to determine the size, and do not depend on sizeof to return
the same result on different machines. Using the previous example, the
expression sizeof ( struct misc ) has a value of 8, and the following
expression has a value of 7:


 sizeof(misc.a) + sizeof(misc.l)


 Writing  If you try to write structures to a disk file on one system and read the file
Structures to a  on another system, you may get different values. This problem may be
Disk File  caused by differences in structure padding (as described under
"Determining Structure Size and Padding") or by differences in the
representations for characters, floating-point numbers, or integers. For
example, the following program writes a structure to a file:


 linclude <stdio.h>
 main()
 {

 FILE *fp;
 struct
{
char x;
short y;
} record;


 fp = fopen("testfile","wb");
 record.x = 3;
 record.y = 4;
 fwrite(&record,sizeof(record),1,fp);
 fclose(fp);
 }

Writing Portable Code 185




If you compile and run this program using the default compiler options,
the file testfile contains four bytes in the following order: 03 00 00
04. However, if you compile and run this program under MS-DOS,
which uses the Intel 8086 processor, the file contains 03 04 00. The
reasons for the different values are as follows:

[] The SAS/C Compiler inserts a padding byte so that integer y is
correctly aligned. The Intel processor does not require this padding.
[] The Motorola processor writes integers from the high byte to the low
byte, and the Intel processor writes integers from the low byte to the
high byte.

  The following paragraphs describe some simple rules that you can use
to make your structures more portable between the Amiga computer and
most other computers. These guidelines help you produce a structure that
your program can write to disk and then read in a single operation.
These guidelines are not guaranteed to work in all cases, but they do gain
you limited ability to interchange files between various computers.
The computer to which you are porting your program must do the
following:

[] Use the same floating-point format for doubles that you are using on
the Amiga system (FFP if the math= ffp option is specified, IEEE for
all other formats).
[] Use the ASCII character set.
[] Use the same sizes for data types:
char  1
short 2
long  4
[] Store integers using the same bit pattern that the Amiga system does.

  The structure to be written must follow these rules:

[] The structure can contain only the following data types:
  TypeLength
  char1
  short  2
  float  4
  long4
  double 8 (or 4 if you compile with math=ffp)
  Do not use ints or any pointer types in the structure.
[] Structures or unions may contain other structures or unions that
follow these rules.
[] Each field must be placed at an offset relative to the start of the
structure that is an exact multiple of the field's size.

186 Chapter 13




[] A nested structure or union must be placed at an offset that is an exact
multiple of the largest simple arithmetic type occurring in any of its
fields, including the fields of any substructures or subunions.
[] If the structure or any of its substructures contains a double, the
structure must contain extra fields as needed to ensure that its total
size is an exact multiple of the size of a double. If it does not contain
a double, it must contain extra fields to ensure that its total size is an
exact multiple of four.

For example, you cannot port the following structure between systems:


  struct NOTDISKABLE  /* Non-diskable structure */
  {
char a;
double d;
short s;
long l;
char name[27];
struct XXX
{
  char a, b;
} foo[11];

  };
To make the previous structure portable between systems, you must
declare the structure as follows:


 struct DISKABLE  /* Diskable version of same structure */
 {
char a;
char dummyl[7];  /* following double needs 8-byte offset */
double d;
short s;
short dummy2; /* following long needs 4-byte offset */
long l;
char name[27];
char dummy2[5];  /* following structure needs 4-byte offset */
struct XXX
{

 char a, b;
 char dummy3[2];  /* Pad to multiple of 4 bytes */
} foo[11];
char dummy4[4];  /* Pad to multiple of 8 bytes */
 };

 Writing Portable Code 187




Using Narrow  The ANSI Standard states that function definitions should specify the data
 Types in  type of each parameter, as in the following example:
 Pre-ANSI
 Function /* ANSI Standard prototype-style definition */
Declarationsvoid newfunc(short s, float f)
  {
.
.
.
  }





Pre-ANSI C accepted function definitions in the following form:


/* Pre-ANSI old-style definition */
void oldfunc(s, f)
short s;
float f;
{
.
.
.
}


  The ANSI Standard default argument promotion rules (described in
Section 3.3.2.2 of the ANSI Standard) differ for functions defined with
prototype style definitions and functions defined with old-style definitions.
You may get incorrect results on ANSI conforming compilers if you use
ANSI standard prototypes and old-style function definitions for the same
function. You can avoid this problem by not using narrow data types
(char, short, and f loat) in function prototypes and definitions.
  The ANSI Standard says that functions defined with old-style definitions
and no prototypes must receive all char and short parameters as if
they were type int and receive all float parameters as type double.
The incoming parameters are then converted to the appropriate shorter
type. Functions defined with new-style definitions are free to receive
narrow types as declared. Unfortunately, the caller of the function does
not know whether the function is defined with a prototype-style definition
or with an old-style definition.
  The ANSI Standard does not define what happens if you declare a
function using an old-style definition but also include an ANSI standard
prototype for the function. To make more programs work as expected, the
SAS/C Compiler treats such definitions as if they were new-style
definitions.

188 Chapter 13




If you do not port your program to a system other than the Amiga
 system, you should not encounter any problems with narrow types unless
 the following situation occurs:
The caller has a prototype for a function that says float. The
called function does not include the prototype and has an old-
style definition that says f loat.

 The data types char and short do not cause problems on the Amiga
 system because they are passed as if they were type int for both old-
 style and prototype-style function definitions.
To help identify problem situations, you can enable the following
warnings:



 WarningDescription

 165 This message identifies narrow types that have been used
 in function prototypes. You can enable this warning with
 the warn=165 option.

 176 This message identifies arguments that have been
 promoted using the default argument promotion rules
 and, as a result, conflict with the prototype given for the
 function. You can enable this warning with the strict,
 ansi, or warn=176 option.

 179 This message identifies narrow types that have been used
 in an old-style function definition. You can enable this
 warning with the strict or warn=179 option.




Using Incomplete  An incomplete structure tag is a structure tag (or name) that has not yet
  Structure Tags  been defined. The ANSI Standard allows you to refer to structures by
 name before they have been defined, as long as you only declare pointers
 to the structure and do not attempt to dereference these pointers.
Incomplete structure tags can cause problems if they occur in a
 function prototype. The ANSI Standard allows incomplete structure tags
 in function prototypes but states that the incomplete tag goes out of scope
 at the closing parenthesis of the prototype. Any declaration of the
 structure later in the program is not associated with the incomplete tag
 used in the prototype and is considered to be a completely different
 structure.
If you define the function later in the program, an ANSI-conforming
 compiler may issue an error message, and your program may not
 compile.

Writing Portable Code 189




  For example, many ANSI-compliant compilers generate an error
message for the following code, claiming that the type of the parameter
does not match the type declared in the prototype.


void func(struct FOO *);  /* Incomplete tag FOO */
struct FOO
{
int x, y, z;
};


void func(struct FOO *parm)  /* Error here! */
{
}



If you move the definition of struct FOO before the prototype, this
code compiles without problems.
  To help you identify incomplete tags, you can enable the following
warnings:



WarningOptions

148 This warning identifies any use of incomplete tags. You
can enable this warning with the warn= 148 option.

149 This warning identifies incomplete tags that are used in
function prototypes. You can enable this warning with
the strict or warn=149 option.

  191

190 Chapter 13


[] Part 4
Appendices





Appendices1 Solving Common Problems
2 Error and Warning Messages
3 Implementation-Defined Behavior
4 Converting From Aztec C Options to SAS/C Options
5 Converting from Version 5 to Version 6

192

 193




Appendix 1
Solving Common Problems


193 Introduction
193 Resolving Undefined Symbols
195 Fixing Compilation Errors
197 Using CodeProbe
197 Using Formatted Print Functions
198 Using getchar
199 Getting Incorrect Results from Function Calls
200 Crashing the Machine
200 Using The asctime Function
201 Managing the Standard I/O Window
201 Linking Resident Programs or Creating Resident Libraries
202 Writing Replacement Functions for SAS/C Library Functions
202 Eliminating Informational Messages




Introduction

This appendix describes the solutions to some of the most common
problems for which users call the Technical Support Division. This
appendix also includes questions that the Technical Support Division
anticipates will be generated by the conversion to Version 6.
  Before calling the Technical Support Division, read the read.me file
on disk 1 carefully. (The read.me file is also copied to the directory into
which you install the product if you installed the SAS/C Development
System on a hard drive.) This file contains errata for the documentation
and information about any feature that may have been added after the
documentation went to press.



Resolving Undefined Symbols

When I compile and link, I get messages reporting Undef ined
Symbol: _CXnnn and saying that the proper math library has not
been included.
In your program, you have accessed floating-point math routines, but
you have not linked with the appropriate math library. Specify the
appropriate math option for the library with which you want to link,
such as math=standard. If you are using the link option to link
your program, the compiler links with the correct math library. If you

194 Appendix 1




call the linker separately from the compiler, you must specify the
correct math library in the slink command after the libs keyword.
Refer to SAS/C Development System Library Reference, Version 6.0 for
more information about math libraries.

I am getting BLTN and/or CXERR errors, and I am using math libraries
and header files.
You may be including the math header files for one type of floating-
point format and linking with libraries for another type of floating-
point format. For example, you may be including m68881.h and
linking with scmffp.lib. Different floating-point formats are
incompatible and should not be mixed. Make sure that your included
header files match the math library with which you are linking.
  If you find no problem with the compatibility between your header
files and your math library, contact the Technical Support Division.

When I link my project, I get undefined symbols. This code worked in
Release 5.10.
Some of the library symbol names have been changed to comply with
the ANSI Standard for symbol names. The ANSI Standard states that
any symbols that are not mandated by the Standard must begin with
an underscore and a capital letter or two underscores.
  When you compile your program, the compiler adds an additional
underscore to the beginning of any symbols defined in C code.
Therefore, a C symbol with two underscores has three underscores
when the linker finally sees the symbol.
  If your code refers to a symbol that has changed names from
Version 5 to Version 6, the linker may produce an undef ined
symbol message when you link your program. If you receive this
message, first check the SAS/C Development System Library Reference
for different versions of the symbols with different numbers of
underscores. Remember, the linker reports one more underscore on
the symbol than the SAS/C Development System Library Reference
shows.
  Change your C code to refer to the new name for the symbol as
described in the SAS/C Development System Library Reference. If this
solution is not practical because of the number of references to the
symbol, you can solve this problem in one of two other ways:

[] Use the define option on the sc command or a #define
statement in a header file to define the old name to the new name.
[] Use the define option on the slink command to force all
references to one of the names to refer to the other. If you define
the item in your code (in other words, you declare it without the
extern keyword), you should use the def ine option to defife the

Solving Common Problems 195




  new name (used by the library) to the old name (used by your
  code). If you declare the item with the extern keyword and,
  therefore, use the library definition for the item, use the define
  option to define the old name (used by your code) to the new name
  (used by the library).

  One very common technique used in Version 5 was to declare the
main routine of your program as _main instead of main to bypass
the overhead required to set up stdio and argument parsing. You
should change this name to __main and add the keyword
__stdargs to be compatible with Version 6. If you do not change
this name, the linker issues a message saying that the symbol _ main
is undefined. (Remember, the linker puts in an extra underscore, so
the symbol it is really looking for is main).


Fixing Compilation Errors

I have installed my compiler correctly, but I keep getting the message
se not found or sc not found whenever I try to do anything.
Your s:user-startup may not be set up correctly. The installation
program places three assign statements and the path statement at
the end of your s:user-startup file. If you are invoking any
programs that create a new Shell (such as PopCLI) in your
s: user-startup file before the path sc: c add statement, sc: c
may not be in new shells created by the program. To correct the
problem, move the three assign statements and the path statement
above any calls to programs that create a new Shell.
  If you are running under AmigaDOS Version 1.3, you may have a
different problem. The installation program places the necessary
assigns in a file named s :user-startup, which is called from
s: startup-sequence. You may have to edit
s: startup-sequence and make some changes. See Chapter 1,
"Installing Your SAS/C Development System," for information on
modifying your startup file.

After switching to Version 6, my old programs will not compile, or
they compile with a lot of warning messages. Why is this happening
and how can I fix it?
There are two solutions:

[] In Version 6, the compiler assumes that your code will provide
prototypes for all functions. (In Version 5, you had to specify the
-cf option for the compiler to identify missing prototypes.) If your
code does not define prototypes for all functions, the compiler may
produce several warning 100, 154, and 161 messages. Specify

196 Appendix 1




ignore= 100+154+161 to suppress these warnings, or use the
genprotos option to generate prototypes for your functions and
#include the resulting header file.
[] Unlike previous versions, the header files and libraries for
Version 6 of the SAS/C Compiler are ANSI-compliant. The ANSI
specifications affect both ANSI and non-ANSI functions and data
names, so some non-ANSI functions and data names have also
changed.
 Convert your program to use the new ANSI-compliant libraries
and headers. For any functions mentioned in error messages, read
the description of the function in the SAS/C Development System
Library Reference. This reference manual describes the parameter
list, return value, and necessary header files required by each
function. Make sure that you are including the correct header for
each of the SAS/C or AmigaDOS functions that you are calling.

When I compile, the options I requested do not act as expected.
When you compile your program, whether you compile from the Shell
or the Workbench screen, the compiler looks for an scoptions file
in your current directory. If it does not find one, it looks for the file
ENV: sc/scoptions. If it finds either of these files, it uses any
additional options specified in the file. You can run the scopts utility
or edit the scoptions file to review the options specified in these
files. If you want to prevent the compiler from reading the options
specified in any scoptions file, specify the resetoptions option
as the first option in the sc command. If your program then runs as
expected, you have a problem with the options that you have specified.
If you specify the verbose option, the compiler tells you the location
of the scoptions file used.

During compilation, I get the message semi-colon expected in a
header file.
Check for extra characters at the beginning of your file in front of
your #include statements or in one of your header files. You may
have accidentally pressed a key while starting the editor.

I keep getting the message Error 25: Modifiable lvalue
required, but I am declaring all my variables for a function just like
it says in the library reference manual.
Do not include the const keyword in your declarations. The SAS/C
Development System Library Reference contains many variables defined
with the const keyword, especially pointers to strings. This keyword
is required by the ANSI Standard and indicates that these variables
will not be modified in the library function to which they are passed.
The const keyword is present in the parameter list of the prototype

Solving Common Problems 197




that is found in the associated header file. This prototype, not the
declaration you should include in your program, is what is described
in the synopsis for each function in the SAS/C Development System
Library Reference. Use the synopsis as a guideline for your
declarations, but do not include the const keyword.



Using CodeProbe

I do not get all of the information I expect out of CodeProbe, or
CodeProbe does not know about variables and functions it should
know about.
You may not be compiling with the correct debug option. If you are
compiling with nodebug or debug=line, try compiling with
debug=sf. For a complete description of each debug option, see
Chapter 8, "Compiling and Linking Your Program."

CodeProbe does not work if I double-click on the Debug icon from the
WorkBench screen.
To invoke CodeProbe from the WorkBench screen, click on the Debug
icon. Then, hold down the Shift key and double-click on the icon for
your program's executable module.



Using Formatted Print Functions

printf (or sprintf, fprintf, and so on) does not print the correct
values.
This problem can happen for the following reasons:

[] You are asking printf to print a variable, but the variable
conversion characters are incorrect. For example, you are trying to
print a long integer using %d as the conversion character. A
long variable requires a %ld if the shortint compiler option is
active. Often, if you have one conversion character wrong, the rest
of the line you are printing is also incorrect. Check your entire
printf (or fprintf, etc.) format string carefully.
[] You are trying to print a float or a double, but you have not
linked with the proper math library. You must link with a floating
point math library to perform any floating point operations. If you
are linking with a floating point library, make sure that it is
positioned in your slink command line before sc . lib so that the
linker can find the correct version of printf. If you specify the
link option in the sc command, the compiler links the libraries in
the correct order.

198 Appendix 1




[] You are linking with amiga.lib before the math library and
sc.lib. You should specify amiga.lib as the last library in the
slink command.



Using getchar

getchar does not work as expected.
Input and output on the Amiga system are buffered. On most other
systems, getchar immediately gets a character from stdin (usually
the keyboard). However, the CON: device on the Amiga system buffers
its input, so your program does not actually read any characters until
you do one of the following:

[] fill up the console input buffer
[] press Return
[] enter the Amiga End-of-File character, Ctrl-\.

The SAS/C Development System libraries include two functions that
you can use to deal with this problem:

getch  gets a character from the console in RAW mode. The
character is returned as soon as the user types it.

rawcon turns RAW mode on and off. rawcon(1) sets the console
into RAW mode. rawcon (0) restores the console to non-
RAW mode.

When the console is in RAW mode, any characters typed by the user
are passed immediately to the application.
getch returns a single character from stdin just like getchar,
but getch gets the character in RAW mode. If your console is not in
RAW mode, using getch is equivalent to the following sequence:


rawcon(1);
c = getchar();
rawcon(0);


If your console is in RAW mode, getch is equivalent to getchar.
  For more information about getchar, refer to SAS/C Development
System Library Reference.

Solving Common Problems 199




Getting Incorrect Results from Function
Calls

My program compiles and links without errors, but I am getting the
wrong results from some of my SAS/C function calls.
You can get incorrect results from a function if you do not include the
correct header files for the function you are calling. The header files
contain prototypes for each of the SAS/C functions, as well as
definitions for many common data structures required by these
functions. By including the correct header file, you are providing the
compiler with a prototype for the SAS/C functions you call.
  The ANSI Standard requires that the compiler assume that functions
that are called without the previous inclusion of a prototype return an
int. For example, this means that if you call atof, which returns a
double, without including math . h, the compiler assumes that atof
returns an int and allocates only 4 bytes for the return value. When
atof is called and the correct 8-byte double value is returned in the
4-byte space allocated for it, the value appears to be incorrect.
  You may be including the incorrect header file for one of these
reasons:

[] In Version 6, the prototype is contained in a different header file
than in Version 5. For example, in Release 5.10, the function atof
was included in math.h. In Version 6, the atof prototype was
moved to stdlib.h as required by the ANSI Standard. Check the
SAS/C Development System Library Reference for the correct header
file for the functions that you are using.
[] You may be including the right header file from the wrong
directory. For example, the include:dos directory contains many
header files with the same names as those in the root level
include: directory. However, these header files are AmigaDOS
header files and not ANSI header files. The AmigaDOS header files
do not contain the necessary prototypes and data declarations. For
example, you may be including dos /stdio.h instead of
stdio.h. Do not substitute header files from the include:dos
directory for standard headers.
[] You may be including header files from the proto directory instead
of those in the root level include: directory. Although the files in
the proto directory do contain prototypes for many of the SAS/C
functions, these files are intended to be included in addition to the
standard header files, not in place of them. Do not use header files
in include: subdirectories as substitutes for the root level header
files.

200 Appendix 1




Crashing the Machine

My program compiled and linked without any errors, but when I run
it, my machine crashes. What am I doing wrong?
The following list contains some of the more common errors that
crash programs. Most of these errors are caused when your program
accesses memory that it is not supposed to access.

[] You have declared a pointer to an array or structure for which you
have not allocated memory. This mistake is especially easy to make
when calling functions that fill the array or structure with
information, such as the fstat, lstat, and stat functions.
 To correct this problem, call malloc or calloc to allocate the
appropriate amount of memory for the array or structure.
[] You have assigned an inappropriate value to a pointer, so the
pointer no longer points to a valid memory space. This type of error
can be quite difficult to track down. You may want to run the
CodeProbe, the Enforcer, or the Mungwall program if you think
these types of errors may occur. Enforcer and Mungwall are
programs that detect memory errors. They are available from
Commodore Applications and Technical Support (CATS) and are
shipped with Version 6.
[] You have specified the nostackcheck option and are overwriting
your stack. Do not specify nostackcheck until your program is
completely debugged. The stackcheck option is the default unless
you are creating a shared library using the libcode option.



Using The asctime Function

I am using the asctime function to convert the time to Greenwich
Mean Time (GMT) correctly, but the result is exactly an hour (or two
or three...) off.
Your machine is probably in the default time zone, Central Standard
Time (CST), and has not been reset to your actual time zone. To
correct the problem, reset your machine's time zone environment
variable to your actual time zone with the following AmigaDOS
command:


  setenv TZ=your-time-zone

Solving Common Problems 201




For your-time-zone, enter your zone's standard three letter
abbreviation followed by the number of hours difference between your
time zone and Greenwich Mean Time. For example, for Eastern
Standard Time, the command would be as follows:


setenv TZ=EST5


You can also initialize the _ TZ variable as described in the SAS/C
Development System Libra~y Reference. Initialize the _ TZ variable with
the same time zone data as you would enter with the AmigaDOS
command described above (for example, EST5).
  Note: The AmigaDOS environment variable does not have a
leading underscore that the SAS/C data name has.



Managing the Standard 1/0 Window

An annoying window opens when I run my program from the
Workbench screen. How do I get rid of this window?
The SAS/C startup code opens the window to allow programs that are
run from the Workbench screen to access stdin, stdout, and
stderr. You can eliminate this window or change its attributes. For
information on managing this window, see Chapter 9, "Running Your
Program from the Workbench Screen."



Linking Resident Programs or Creating
Resident Libraries

I get the message absolute reference to name from the linker.
You are linking a resident program with the cres . o startup module,
or you are creating a resident library, but the linker detected a
reference to an absolute symbol. Make sure that the symbol being
referenced is not being modified. If the item is not being modified,
then you can ignore the warning message.

202 Appendix 1




Writing Replacement Functions for SAS/C
Library Functions

I wrote a replacement function for one of the SAS/C library routines,
but the library routines don't seem to be using my replacement
function.
If you write a function that has the same name as a library function,
you need to add the __regargs keyword to your function or
compile with the parms=both or parms=register option. For
example, you may want to replace the SAS/C library function malloc
with your own version of malloc. If you compile with the
parms=stack option or define your version of malloc with the
__stdargs keyword, then two versions of malloc are linked into
your executable. If you use other SAS/C library functions that call
malloc, these functions use the version of malloc in the SAS/C
libraries. However, your functions that call malloc use your version
of malloc. To make sure that all calls to malloc are using your
version of malloc, define your version with __regargs or compile
with the parms=both or parms=register option.



Eliminating Informational Messages

How can I turn off all of the informational messages the compiler and
linker produce every time I compile and link?
You can specify the following options on the sc command line:

sc nover link filename.c

203




Appendix 2
Error and Warning
Messages


203 Introduction
203 Using Error and Warning Messages
204 Explanations of Unnumbered Compiler Messages
206 Explanations of Numbered Compiler Messages
258 Explanations of Linker Messages
265 Enabling Suppressed Messages




Introduction
This appendix explains each of the error and warning messages that may
be produced by the compiler and linker.



Using Error and Warning Messages

You should treat warnings as seriously as errors. If you do not know why
a given warning is being produced, find out why. If you can safely ignore
the warning in the future, use the ignore option on the compiler or the
#pragma msg statement to suppress the warning.
  In general, the compiler attempts to prevent long cascades of error and
warning messages that result from a single mistake, but this action is not
always possible. As a result, you may see several messages generated by
the same error, especially if the error is in a control statement such as an
if, for, do, or switch statement. If you receive some messages that
seem to be incorrect or confusing, fix as many errors or warnings as
possible, and then recompile your program. The confusing messages may
disappear.
  Sometimes the compiler may generate an error message for code that
you believe is correct. In many cases, such errors are the result of
incorrectly using the preprocessor. A typographical error in a
preprocessor macro or accidental collision of a #def ined macro name
with another name in your program can cause very confusing problems.
If you think you are having problems with preprocessor macros, compile
your program with the pponly option to generate preprocessed output,
and check that to see exactly what the compiler is receiving.
Alternatively, compile with the list option to generate a listing file. The

204 Appendix 2




listing file allows you to see exactly what symbols are being defined by
the header files included by your program.
  Some error or warning messages are produced at the first non-
preprocessor statement after the actual condition that caused the error or
warning. For example, if your program is missing a semicolon, you do
not get a message at the end of the line that is missing the semicolon; you
get a message at the beginning of the next line of code. If you cannot find
an error exactly where the message occurred, look at several previous
lines in your source code . Remember, the compiler treats #include
files as if they are part of your source file. For example, a missing close
curly brace at the end of your last #include file may result in an error
message at the first line of your C source file. You can compile with the
pponly option to help diagnose this type of error.
  By default, many warning messages are suppressed but can be enabled
with the strict, ansi, or warn options. The descriptions of each
message indicate whether the message is suppressed and, if so, which
options enable the message. You can enable any suppressed warning with
the warn or error options. You can disable any warning with the
ignore option. You cannot use the ignore option to disable error
messages. See Chapter 8, "Compiling and Linking Your Program," for
more information about the strict, ansi, error, warn, and ignore
options. See also "Enabling Suppressed Messages" later in this appendix
for a complete list of the suppressed messages and the options you can
use to enable them.
  Some messages listed as warnings can also be produced as errors in
some cases. If a message is produced as an error instead of a warning, it
cannot be ignored (just as errors cannot be ignored).
  You can display help information on a specific message from the
message browser utility (scmsg) by clicking on the message and pressing
the Help key or by invoking the AmigaGuide utility on the file
sc:help/scmsg.guide.



Explanations of Unnumbered Compiler
Messages

Freeing Resources
If you compile your program and your machine runs low on memory,
the compiler displays this message and frees memory to enable it to
continue the compilation. You can force the compiler to free memory
at any time by pressing Control-F in the window to which the
compiler is sending output.

 Error and Warning Messages 205




Floating point overflow optimizing constants
The global optimizer was attempting to perform compile-time constant
calculations, but the calculations caused a floating-point error. Your
code is causing floating-point numbers to overflow.

Can't open type file "name" for mode
The compiler could not open the specified file. The mode is either
read or write.

Combined output filename too long
The filename produced by the compiler, with the path, overflowed the
compiler's internal buffer (255 bytes).

Can't open sc:libs/lib-name.library
The specified shared library could not be found. Make sure the library
is available in sc:libs.

CXWRN: text
An internal error occurred. With CXWRN errors, the compiler attempts
to continue the compilation, but may not be able to do so. Please
contact the Technical Support Division.

CXERR: num
An internal error prevented the compiler from continuing. Please
contact the Technical Support Division.

Can't delete old GST: object is in use
Continuing with no GST file
You specified the makegst option, but an existing copy of the same
GST was in use by another program. Check for other compilations that
are using the GST. You may also be browsing the GST with the
hypergst utility.

Can't open GST file: gst-filename
The specified GST file could not be loaded. Either the file is an invalid
GST file, or the file does not exist.

Invalid symbol definition: symbol-name
You attempted to define the specified symbol on the command line
with the define compiler option, but the symbol did not adhere to
the normal rules for C preprocessor symbol syntax.

Seek error on object file
The compiler attempted to perform a seek operation on the output
object file but encountered an I/O error.

I/O error code on file "name"
The compiler received the specified I/O error code from the operating
system while attempting to read the named file. Refer to The
AmigaDOS Manual, 3rd Edition (Commodore-Amiga, Inc. 1991) or see
the header file dos/dos.h for details on the numeric error codes.

206 Appendix 2





Explanations of Numbered Compiler
Messages

Warning 1:  invalid preprocessor command

  This warning is generated by invalid use of preprocessor commands.
  For example, you could specify an unrecognized command, fail to
  include a space between command elements, or use an illegal
  preprocessor symbol. The command is ignored and compilation
  continues.

  Error 2:  unexpected end of file

  This error is generated when the compiler expects more data, but it
  encounters the end of an input file. This error may occur in a
  #include file or in the original source file. A missing #endif or
  unbalanced curly brace or parentheses in the source file or in one of
  the previously included files may produce this message. In many cases,
  correcting a previous error eliminates this error.

  Error 3:  file not found "filename"

  The filename specified in a #include command was not found or
  could not be opened.

  Error 4:  invalid lexical token

  A character was found in the file that is not a standard character in the
  C character set or is in an inappropriate place. For example, entering a
  pound sign (#) in the middle of non-preprocessor C code or entering
  nonprintable control characters anywhere except in a comment
  produces this error.

  Error 5:  invalid macro usage

  Your code invoked a macro incorrectly. Check for unbalanced
  parentheses and other syntax errors. The problem may be in a macro
  used by the macro that you invoked in your program.

  Error 6:  line buffer overflow

  A line of preprocessed input was longer than the line buffer size. The
  size of the line buffer is controlled by the ppbuf and memsize
  options. If you do not specify ppbuf or memsize, the size of the line
  buffer is 8192 bytes.

Error and Warning Messages 207




 Error 8:  invalid conversion

You attempted to cast a type to an incompatible type. This error usually
occurs when you attempt to convert something into an array, a
structure, or a function. Check for missing indirection (*) and/or
address (&) operators. For example, the following program tries to
assign a whole structure to a pointer.


  void main ( void )
  {
 struct FOO
 {
int a, b;
 } f;
 struct FOO *p;
 p = f;  /* Error 8 */
 p = &f; /* Correct */
  }



 Error 9: undefined identifier "name"

The specified identifier has not been declared. You may not have
included the proper header files to declare an extern, or you may
have misspelled the name of a variable. This message is produced only
once for each undeclared identifier. Subsequent uses of the identifier do
not produce a message. Subsequent declarations of the identifier may
produce messages about redeclaring the variable. Fix the error that is
causing the first error 9 message and recompile your program before
trying to fix additional messages involving the same variable.

Error 10:  invalid subscript expression

An error was detected in an expression used inside square brackets ([]).
This error may occur if:

[] the expression is missing
[] the expression is a preprocessor macro that evaluates to nothing
[] the result of the expression is void
[] the result of the expression is a pointer, a structure, or a union.



Error 11: string not terminated

The closing double quote (") was not provided when defining a string.

208 Appendix 2




Error 12: invalid structure reference

The operand preceding the structure member ( . ) or structure pointer
(->) operator is not a structure or a pointer to a structure, respectively.
Make sure you are not trying to reference a structure member with the
structure pointer operator or a structure pointer with the structure
member operator. In many cases, correcting a previous error eliminates
this message.

Error 13: member name missing

The name of the desired structure or union member did not follow the
structure member operator ( . ) or the structure pointer operator (->).
Check for preprocessor macros that may be defined to the same name
as the member.

Error 14: undefined member "name"

The indicated identifier is not a member of the structure or union to
which the structure member operator ( . ) or the structure pointer
operator (->) referred.

Error 15: invalid function call

An identifier or constant is used where a function or function pointer
identifier is required. This message can occur if you attempt to use a
variable not declared as a function or function pointer but give the
variable a parameter list. The compiler sees the parenthesized
expression and thinks you are calling a function. Check for
typographical errors such as leaving out an operator in an expression,
which produces a variable and a parenthesized expression. Such
typographical errors may also occur in preprocessor macros. For
example:


 /* The incorrect expression below generates an */
 /* "invalid function call" error.*/


 int i, j;
 void function(void)
 {

i = i + (j*2); /* Intended expression */
i = i(j*2); /* INCORRECT - deleted "+" operator */

Error and Warning Messages 209




  Error 16:  invalid function argument

  A function argument expression following the left parenthesis of a
  function call is invalid. You may see this message if you omit:

  [] an argument expression
  [] a right parenthesis from a function call
  [] a comma separator between two function arguments.


  For example:


func(.);
func(;
func(,1);


  Error 17: too many operands

  During expression evaluation, the end of an expression was
  encountered, but more than one operand was still awaiting evaluation.
  This message may occur if an expression contained an incorrectly
  specified operation.

Warning 18: non-ANSI use of operator in preprocessor condition

  This message is suppressed by default, but you can enable it with the
  strict, ansi, or warn=18 options. The ANSI Standard states that
  the sizeof and comma (, ) operators should not be used in
  preprocessor conditions. The SAS/C Compiler supports their use in
  preprocessor conditions, but programs that require strict adherence to
  the ANSI Standard should not use them.

  Error 19: unbalanced parentheses

  The number of opening parentheses in an expression did not equal the
  number of closing parentheses. If the expression appears correct in the
  C source file, check any preprocessor macros to make sure they
  generate balanced parentheses.

  Error 20:  invalid constant expression

  An expression that did not evaluate to a constant was encountered in a
  context that required a constant result. The compiler must be able to
  evaluate any constant expression (for example, expressions used to
  initialize static or external data) when the program is compiled.
  The expression in question did not meet this criterion. You may have
  used an illegal operator for a constant expression (such as ++, +=,
  function calls, and so on), or you may have used a variable whose value
  is available only at run time.

210 Appendix 2




  Error 21: illegal use of struct, union, or array type

  An identifier declared as a structure, union, or array was encountered
  in an expression where such types are not permitted. For example, you
  cannot use the ++ postincrement operator with a structure:
  
  struct FOO
  {
int a, b, c;
  } f;
  f++;/* Error 21 */
Warning 22: structure used as function argument

  This message is suppressed by default, but you can enable it with the
  warn=22 option. A structure or union was passed as an argument to a
  function. Although passing structures and unions is legal according to
  the ANSI Standard, some compilers do not allow you to pass structures
  or unions. Other compilers pass a pointer to the structure instead of the
  entire structure. Turn on this warning if your code comes from or must
  be ported to such a compiler.

  Error 23: invalid use of conditional operator

  The conditional expression operator (?: ) was used incorrectly. You may
  have included the question mark (?) but left out the colon (:). Also,
  check for an invalid expression after the operator.
  
  Error 24: pointer operand required

  An expression required a pointer at a specific place, but a non-pointer
  operand was provided. The compiler may generate this message if an
  expression after the indirection operator (*) was not a pointer or array
  expression or if the expression before the array indexing operators ( [ l )
  was not a pointer or array expression.

  Error 25: modifiable lvalue required

  You have attempted to assign a value to an expression that cannot be
  modified. An Ivalue is any expression that can appear on the left side of
  an assignment operation. For example, the ANSI Standard states that
  the result of a cast is not an lvalue; therefore, the following statement is
  invalid:


  long x;
  (short)x = 2;  /* Error 25 */

Error and Warning Messages 211




The following examples also generate this error message:


#define ADDONE(x) (x)++
ADDONE(12);  /* Error 25: Cannot increment a constant */
ADDONE(&g);  /* Error 25: Cannot assign to an address */
if(func(10)=j-2);  /* Error 25: "==" was intended, not "=" */
&x = &y; /* Error 25: Cannot assign to an address */


You may have defined a variable with the const keyword and then
tried to modify the value of that variable. The SAS/C Development
System Library Reference, Version 6.0 contains many variables defined
with the const keyword, especially pointers to strings. This keyword is
required by the ANSI Standard and indicates that these variables will
not be modified in the library function to which they are passed. The
const keyword is present in the parameter list of the prototype that is
found in the associated header file. This prototype, not the declaration
you should include in your program, is what is described in the
synopsis for each function in the SAS/C Development System Library
Reference. Use the synopsis as a guideline for your declarations, but do
not include the const keyword.

Error 26: arithmetic operand required

An expression required an arithmetic operand but the provided operand
was not arithmetic. An operand is arithmetic if it declared as char,
short, int, long, float, or double or the signed and unsigned
variants of these types.

Pointers, structures, unions, and functions are not arithmetic operands.

Error 27: arithmetic or pointer operand required

An expression required an arithmetic or pointer operand, but a
structure or union was provided. An operand is arithmetic if it declared
as char, short, int, long, float, or double or the signed and
unsigned variants of these types.

A pointer operand can be a pointer to any other data type, or it can be
the address of a variable or function.

212 Appendix 2




  Error 28: missing operand

  During expression evaluation, the end of an expression was encountered
  but not enough operands were available for evaluation. The compiler
  may generate this message if you specified a binary operator (such as
  the addition, subtraction, multiplication, or division operator) with only
  one operand. Also, check for invalid preprocessor macro expansions.
  For example:


 int i;
 int ary[10];


 i = i + ;  /* Error 28 */
 i = ary[i*]4; /* Error 28 (Among others) */

  Error 29: operation cannot be performed on a pointer

  An operation was specified that was invalid for pointer operands, such
  as one of the arithmetic operations other than addition or subtraction.

Warning 30: pointers do not point to same type of object

  In an assignment statement defining a value for a pointer variable, the
  expression on the right side of the assignment (=) operator did not
  evaluate to NULL or to a pointer of the same type as the pointer
  variable on the left side of the assignment operator. The warning is also
  produced when a pointer of any type is assigned to an arithmetic object.

  Error 31: integral operand required

  An expression required a given operand to be an integral type, but the
  actual operand was not an integral type. An operand is integral if it is
  declared as char, short, int, or long or the signed and unsigned
  variants of these types.

  For example, the following code generates error 31:


 double d;
 int ary[10];

 ary[d] = 10;  /* Error 31 */

Error and Warning Messages 213




  Error 32: cannot convert to required type

  The compiler was unable to convert a data item from its base type to
  the type required by the operation. The compiler may generate this
  message if you attempt to cast any data type to a structure, instead of
  casting the type to a pointer to a structure, or if you attempt to cast a
  structure to any other type. This message can also be produced for
  implied conversions, such as passing a structure as a parameter to a
  function expecting some other type. For example, the following code
  generates error 32:


 struct FOO f;
 int j;
 j = (int)f;  /* Error 32 */

Warning 33: non-portable operation on structure or union

  Your code has attempted to use an operator on a structure or union
  that is illegal for that type. For example, you may have used the
  equality == operator on two structures. The ANSI Standard does not
  permit the use of relational operators on structures or unions.

The SAS/C Compiler generates the equivalent of a memcmp call for
  this construct, but it may not perform as expected. Because structures
  may contain padding bytes, two structures of the same type with all
  identical members may compare false. If you intend to use direct
  structure comparison, make sure you declare the structure static or
  extern, or initialize the structure to zeroes using a call to memset.

  For example, the following code generates warning 33:


 #include <proto/dos.h>
 struct FileInfoBlock fib1, fib2;

 if(fib1 == fib2)  /* Warning 33 */


  Error 34:  invalid initializer expression

The expression used to initialize an object was invalid. The compiler
may generate this message if you fail to separate elements in an
initializer list with commas or if you attempt to initialize an array to a
single object, as shown in the following examples:


 int a[3] = 0;/* Error 34 */
 int b[3] = { 1 2 3 };  /* Error 34 */

214 Appendix 2




  Error 35: closing brace expected

  The compiler expected a closing brace (}) to terminate the definition of
  a function, structure, or nested block scope, but the brace is missing.
  The compiler may generate this message if:

  [] too many elements occur in an initializer expression list
  [] a structure member was improperly declared
  [] the end of the source file is reached before a definition is complete
  [] a previous error occurred in a control statement.


Warning 36: control cannot reach this statement

  A statement with no label followed a goto, return, break, or
  continue statement. The statement is therefore unreachable. This
  warning can sometimes be produced incorrectly if the compiler reported
  a previous error while in a control flow statement. Fix all previous
  errors and recompile your program before trying to fix the error that is
  generating this message.

  Error 37: duplicate statement label "name"
  See line number in file "filename"

  The specified statement label has already been defined in the current
  function. You cannot define the same label more than once in the same
  function.

  Error 38: unbalanced braces

  In a set of compound statements, the number of opening left braces ({)
  did not equal the number of closing right braces (}). This warning may
  be produced incorrectly if the compiler reported a previous error in a
  control flow statement. Fix any previous errors and recompile your
  program before trying to fix the error that is generating this message.

  Error 39: invalid use of keyword "keyword"

  One of the C language reserved words appeared in an invalid context
  (for example, as a variable name).

  Error 40: break not inside loop or switch

  A break statement was detected that was not within the scope of a
  while, do, for, or switch statement. This error may be produced
  incorrectly because of errors in previous statements.

  Error 41: case not inside switch

  A case prefix was encountered outside the scope of a switch
  statement. This error may be produced incorrectly because of errors in
  previous statements.

Error and Warning Messages 215




Warning 42: case expression not integral

The expression defining a case value did not evaluate to an integral
constant. This message is generated as an error message if the
expression could not be converted into an integral constant and as a
warning if the expression could be converted into an integral constant.
For example, if you use a variable as a case value, the compiler
generates an error message. If you use a floating-point constant as a
case value, the compiler converts the constant to an integer
(thereby truncating its value) and generates a warning message. For
example, in the following code, the case value 1.6 is truncated to 1,
and the value -1.6 is truncated to -1.

switch(i)
{
  case 1.6:  /* Warning 42 */
break;

  case -1.6:  /* Warning 42 */
break;
}



  Error 43: duplicate of case value See line number in file
  "filename"

You have used the same case value more than once within the same
switch statement. Check for possible preprocessor macro definitions
that expand to the same value. For example, both of the following case
statements evaluate to zero:


#define FOO 0
#define BAR 2


switch(i)
{
  case FOO:
break;
  case (FOO*BAR):  /* Error 43 */
break;
 }

216 Appendix 2




Error 44: continue not inside loop

A continue statement was detected that was not within the scope of a
while, do, or for loop. This error may be produced incorrectly
because of errors in previous statements.

Error 45: default not inside switch

A default label was encountered outside the scope of a switch
statement. This message may be produced incorrectly because of errors
in previous statements.

Error 46: duplicate default See line number in file
"filename"

A default label was encountered within the scope of a switch
statement in which a default label had already been encountered.

Error 47: while missing from do statement

A while clause did not follow the body of a do statement. This
message may be produced incorrectly because of errors in previous
statements.

Error 48: invalid while expression

The expression defining the looping condition in a while or do loop
was void or was missing. If you intend for a loop to be infinite, you
must supply a constant (such as 1) for the while condition. The error
may be produced because of a preprocessor macro that expands to
invalid code. In many cases, fixing a previous error eliminates this
message.

Error 49: else not associated with if

An else keyword was detected that was not in the scope of a
preceding if statement. This message may be caused by an error in a
preceding statement, especially if the previous error occurred while
processing the if statement with which the else statement is
associated.

Error 50: label missing from goto

The compiler expected a statement label to follow the goto keyword
but the label was missing. This message may be produced incorrectly
because of errors in previous statements.

 Error and Warning Messages 217




Warning 51: C++ comment detected

  This message is suppressed by default, but you can enable it with the
  strict, ansi, or warn=51 options. In C++, comments begin with
  two slashes (//) and terminate at the end of the line on which they
  begin. The SAS/C Compiler accepts comments entered in this way for
  convenience and for compatibility with other implementations, but they
  are not part of the ANSI Standard for the C language.

  Error 52:  invalid if expression

  The expression following the if keyword on an if statement was
  void, invalid, or missing. This error may be caused by a preprocessor
  macro expanding to inappropriate values or may be the result of an
  expression with an invalid return type (such as a structure type). In
  many cases, fixing a previous error eliminates this message.

  Error 53: invalid return expression

  The expression following the return keyword was void, invalid, or
  missing. The compiler may generate this message if a preprocessor
  macro expands to inappropriate values. In many cases, fixing a previous
  error eliminates this message.

Warning 54: switch expression not integral

  The expression defining the test value for a switch statement did not
  define an integral value as required by the ANSI Standard. The value
  supplied is converted to int before any attempt is made to use it. If the
  switch value is a floating-point value, this conversion may truncate
  the value. This warning can also be generated as an error if the value
  could not be converted to int.

Warning 55: no case values for switch statement

  The statement defining the body of a switch statement did not define
  any case statements. This warning may be produced incorrectly
  because of previous errors.

  Error 56: colon expected

  The compiler expected but did not find a colon (:). This message may be
  generated if a case expression was improperly specified or if the colon
  was omitted following a label to a statement. Because the compiler scans
  through newlines, blanks, and comments looking for the colon, this
  message is usually produced at the beginning of the line following the
  actual error.

218 Appendix 2




  Error 57:  semi-colon expected

The compiler expected but did not find a semi-colon (;). This error can
be generated if you use too many right parentheses or right curly braces
(}). Because the compiler scans through spaces and tabs looking for the
semicolon, this message is usually produced at the beginning of the line
following the actual error.

  Error 58:  missing parenthesis

A required parenthesis is missing. This error is often caused by
previous errors.

  Error 59:  invalid storage class

Possible storage classes are denoted by the keywords __near, __far,
__chip, register, auto, extern, and static. Some of these
keywords are invalid for certain types of data. For example, you cannot
declare an external variable with the register keyword, and you
cannot declare an automatic (local) variable with the __chip,
__near, or __far keywords. Your code attempted to use a storage
class keyword incorrectly. This error often occurs because of previous
errors.

  Error 60:  incompatible struct, union or array types

Incompatible structure, union, or array types were used in an
expression.


struct A {int x;}a;
struct B {double d;} b;
a = b;  /* Error 60 */


  Error 61: undefined struct/union tag "tag-name"

  Your code has used a structure or union tag that has not been declared.
  Check for misspelled structure names. You may want to compile your
  program with the pponly option or the list option and look at the
  output produced.

Warning 62: constant number out of range for type "type"
  Valid range is low to high

  Error and Warning Messages 219




The constant value indicated is not in the range of possible values for
the type to which the value is being assigned. This message may occur if
you are assigning a hexadecimal constant with the uppermost bit set to
a signed variable. By definition, a hexadecimal constant is a positive
value; therefore, the assignment to the variable reinterprets the constant
as a negative number. For example, the following lines generate
warning 62:


 signed char c = 0x80; /* Warning 62 */
 short s = 100000; /* Warning 62 */
 unsigned short uc = -1/* Warning 62 */


Unless you use the unschar compiler option, variables of type char
are signed and produce this warning if you assign any constant to them
with the high bit set (that is, any value between 128 and 255.) You can
suppress this warning for a specific case by casting the constant to the
appropriate type.

  Out-of-range constants can cause problems in your code that are hard
to debug. For example, the following code does not behave as intended:


 int i = 1xff;
 signed char c = 1xff;  /* Warning 62 */
 if(i == c)
 {
/* Not executed */
 }


The constant initializer Oxf f is the decimal number 255. When
assigned to the integer variable i, this value is preserved, and i gets
the value 255. When assigned to the signed character variable c, the
value of c becomes -1 because a signed character cannot represent
numbers higher than 127, and the constant Oxf f overflows. Therefore,
the comparison in the if statement results in the value false.

Warning 63:  item "name" already declared
  See line number file "filename"

The named item was previously declared at the cited location. This
warning is produced when two different members of the same
structure, union, or enum are given the same name.

220 Appendix 2




  Error 64: structure contains no members

  A structure declaration did not contain any members. This error can be
  produced by errors encountered during the structure's declaration.
  Fixing a previous error may eliminate this message.

  Error 65: invalid function definition

  Your code tried to define a function body inside another function body,
  inside a structure declaration, or inside a list of static initializers. This
  message may be produced incorrectly because of errors in previous
  statements.

Warning 66: invalid array limit expression

  The expression defining the size of the subscript in an array declaration
  did not evaluate to a positive integral constant. For example:


 int x[10.7];


  Error 67: illegal object

  Your code attempted to define an illegal item. For example, you may be
  declaring an array of functions (instead of an array of function pointers)
  or a function that returns an array (instead of a function that returns a
  pointer). This message can also be produced if you attempt to define a
  variable with the same name as a keyword. For example, the following
  code generates error 67:


 int break;  /* Error 67 */
 long while; /* Error 67 */
  Error 68: illegal object for structure

  A structure (or union) included a function as a member. You cannot
  include a function as a member of a structure or union, although you
  can include a function pointer.

  Error 69: struct name includes instance of self

  The named structure or union contains an instance of itself. Although it
  is legal for a structure or union to include a pointer to its own type, the
  structure or union cannot contain an instance of itself. If the structure
  
 Error and Warning Messages 221




  or union does not have a name, the name field is not printed in the
  message. For example, the following code generates error 69:


  struct FOO
  {
int a, b, c;
struct FOO x;  /* Error 69 */
  };

Warning 70: unrecognized escape sequence

  By default, this message is suppressed, but you can enable it with the
  strict, ansi, or warn=70 options. Escape sequences in string and
  character constants begin with a backslash (\) and contain one or more
  characters after the backslash. The ANSI Standard defines some escape
  sequences and reserves others for future expansion and for
  implementation-defined extensions. The SAS/C Compiler ignores the
  backslash on any such undefined escape sequences. Other compilers
  may take different action. For example, the following line prints the
  character q followed by a newline (\n) to stdout:
 
  printf("\q\n");  /* Warning 70 */


  Other ANSI-conforming compilers may substitute any other character for
  the \q escape sequence.

  Error 71: formal declaration error "name"

  A variable was declared before the left curly brace of in an old-style
  function definition, but the variable did not appear in the list of
  identifiers in parentheses following the function name. For example, the
  declaration of j in the following code generates error 71:


  int func(i)
  int i;
  int j;  /* Error 71 */
  {
  }



  You may have misspelled one of your formal parameters or forgotten to
  add the parameter to the parameter list.

222 Appendix 2




  Error 72: conflict with previous declaration
  See line number file "filename"

  A variable or function was declared that conflicts with a previous
  declaration for the variable or function in the same scope. The message
  indicates the filename and line number of the original declaration. If no
  prototype exists for a function, the first use of that function implicitly
  declares the function as returning an int. If the actual definition of the
  function follows the first use of the function and declares a different
  return type, the compiler produces this message. This message may be
  produced incorrectly if you forget to declare a variable in an earlier
  location and, therefore, received a previous error message about an
  undefined identifier with the same name. Fixing the previous error may
  eliminate this message.

Warning 73: declaration expected

  The compiler expected to find the declaration of a data object or
  function but did not. This message can also occur if you enter too many
  or too few curly braces. This message may be produced incorrectly
  because of errors in previous statements. Fixing the previous errors
  may eliminate this message.

Warning 74: initializer data truncated

  A static initializer expression contained more elements than the data
  item being initialized, as in the following example:


char b[3] = "abcd"; /* Warning 74 */


  String constants always have an implied NULL byte at the end. This byte
  is not counted when producing this warning. If you have a character
  array with three elements, you may initialize it as follows:


  char b[3] = "abc";

Error and Warning Messages 223




 The three elements receive the values a, b, and c. If there is room, the
 NULL terminator byte is also copied:


char c[4] = "abc";


 The elements of the above array are assigned the values a, b, c, and \0.
 Error 75: invalid sizeof expression

 The expression passed to the sizeof operator was invalid. This
 message may be produced if an attempt is made to take the size of a
 function, bitfield, or incomplete type, or if the result of the expression
 used is of type void. For example, in the following code, a is an
 incomplete type because its size is not specified when it is declared:


extern int a[];
int i;

i = sizeof(a);  /* Error 75 */
Error 76: left brace expected

 The compiler expected but did not find an opening left brace. For
 example, you may have omitted the opening brace on a list of initializer
 expressions for an aggregate.

Error 77: identifier expected

 The compiler expected to find the name of an identifier to be declared.
 The compiler may generate this message if the prefixes to an identifier
 in a declaration (parentheses and asterisks) are incorrectly specified or
 if a sequence of declarations is listed incorrectly, as in the following
 example:


int ;  /* Error 77 */


Error 78: undefined statement label "name"

 A goto statement referred to the named label, but the label does not
 exist in the function that referred to it. Check the spelling of your label
 and the goto reference. Make sure the label is in the same function as
 the goto statement.

224 Appendix 2




Warning 79: duplicate of enumeration value
  See line line file "file"

  When declaring an enumeration type, more than one enumeration
  constant was assigned the same value, as in the following example:


  enum COLORS
  (RED=1, BLUE=2, GREEN=1);  /* RED and GREEN are identical */


  Any enumeration constants that are not assigned an explicit value are
  assigned values one higher than the previous constant in that
  enumeration. If the constant is the first constant in that enumeration, it is
  assigned the value zero. Therefore, the following enum generates
  warning 79:


  enum COLORS (RED, BLUE, GREEN=1);  /* Warning 79 */


  RED is the first constant, so it is assigned a value of 0. BLUE is assigned
  a value of 1. GREEN is explicitly assigned a value of 1, which conflicts
  with BLUE.

Error and Warning Messages 225




Warning 80: invalid bit field or misplaced ':'

  This warning is commonly produced if you type a colon (:) when a
  semicolon (;) was expected. This warning can also be produced if you
  are actually declaring a bitfield and give an improper expression for the
  number of bits in the bitfield.

  Error 81: preprocessor symbol loop; macro expansion too long
  or circular

  When using the oldpp compiler option, a preprocessor symbol
  expanded to a value that contains a circular reference back to the
  symbol itself, thereby creating an infinite loop in the preprocessor.
  Check the definition of the macro being expanded on the line in
  question. This message cannot occur if the oldpp compiler option is
  not used because the ANSI Standard prohibits the expansion of
  preprocessor macros that occur as a result of expanding a previous
  instance of the same macro.

  Error 82: maximum object/storage size exceeded

  Your code attempted to declare a data item that exceeded the maximum
  size of objects in its storage class, or the last object declared caused the
  total size of declared objects in that storage class to exceed the
  maximum, as in the following example:


  char __near a[30000];
  char __near b[30000];
  char __near c[30000];


  Because there is a limit of 32767 bytes on the amount of near data
  allowed, the above request for 90000 bytes of near data will not work. If
  you are compiling with data=near (the default), the __near keyword
  is implied on all data items. Fix this warning by declaring some large
  data items with the __far keyword or by compiling with the data=far
  option.

226 Appendix 2




Warning 83: reference beyond object size

  Your code used an address beyond the size of the object used as the
  base for the address calculation. This warning usually occurs when you
  refer to an element beyond the end of an array, as follows:


char c[10];
void myfunc(void)
{
  c[11] = 0;  /* Warning 83 ~/
}

  This message can be produced only when the compiler can determine the
  value of the subscript at compile time, that is, the subscript is a constant.

Warning 84: redefinition of pragma or preprocessor symbol
  "name"
  See line number file "filename"

  Your code is redefining the preprocessor symbol or #pragma originally
  defined at the indicated file and line number.

Warning 85: return value mismatch for function "name"
  Expecting "typel", found "type2"

  The expression specifying the value to be returned from a function was
  not the same type as the function itself. If possible, the value specified is
  converted to the appropriate type. You can suppress this warning by
  casting the return expression to the appropriate type.

Some pre-ANSI C code produces many of these warnings when
  functions declared as int (either explicitly or implicitly) do not return
  a value. Before the ANSI committee approved the void keyword,
  declaring functions as returning an int was the correct way to handle
  functions that returned nothing. You can compile with the
  nowarnvoidreturn option to suppress these warnings when a
  function that is declared as returning an int actually returns nothing.

For example, the following two functions generate warning 85:


  functionl (x)
  int x;
  {
  }  /~ Warning 85 ~/


  int function2(x)
  int x;

Error and Warning Messages 227





  {  
char *p = NULL;
return(p);  /* Warning 85 */
  }


You can suppress the warning 85 for functionl by compiling with the
nowvret option. The nowvret option does not affect function2,
which is attempting to return a pointer from a function declared as
returning int.
Warning 86: formal parameters conflict with prototype
  See line number file "filename"

The types of the parameters to the function do not match the types
given in the prototype for the function. Check the prototype at the file
and line indicated against your definition.

Warning 87: argument count incorrect, expecting number
  arguments
  See line number file "filename"

Your code invoked a function with an incorrect number of arguments,
according to that function's prototype. Check the prototype at the
indicated file and line number against your usage of the function and
the actual function definition.

Warning 88: argument type incorrect
  Expecting "type 1", found "type2"

Your code invoked a function with an argument whose type conflicts
with the corresponding parameter as declared in the function's
prototype. The type of the argument expected is given as type 1, and
the type of the argument actually provided is type2. If possible, the
argument is converted to the appropriate type as if it were cast to that
type. If the argument cannot be converted, an error message is
produced.

228 Appendix 2




Warning 89: constant converted from "type1" to "type2"

  Your code supplied a constant that conflicted with the expected type.
  The constant was converted, but the conversion may have caused a loss
  of precision or lost values. For example, in the following code, the
  prototype for the function f oo specifies an int, but the function is
  passed a double constant:
  
void foo(int);

void myfunc(void)
{
foo(l0.67);  /* Warning 89 */
}

  The double constant is converted to an integer, resulting in an integer
  argument of 10, and the compiler generates warning 89 to inform you of
  the conversion.
  Error 90: invalid argument type specifier

  An error was made in declaring an argument in a function or prototype
  declaration. For example, the following declaration does not specify a
  type for the parameter y. For example:


void foo(int x, y)  /* Error 90 */
{
}

  Error 91: illegal void operand

  One of the operands in an expression was of type void. The void type
  represents no value and is, therefore, illegal in most expressions.

Warning 92: statement has no effect

  An expression statement did not produce an assignment, function call,
  or other action. Such a statement serves no useful purpose and can be
  eliminated. This warning is often generated when a typographical error
  has been made in coding the statement. For example, you might enter

Error and Warning Messages 229




  the equality (==) operator when you intended to enter the assignment (=)
  operator:


 int i;
 i == 5;  /* Warning 92 */


 In this example, the user intended to assign the value 5 to the integer
  variable i, but because of the extra equals sign, the statement does
  nothing.
Warning 93: no reference to identifier "name"

  Your code declared an automatic (local) variable but never used the
  variable. However, the variable might be used by code that has been
  excluded from the object module with #if or #ifdef statements.

Warning 94: uninitialized auto variable "name"

  An automatic (local) variable was used in an expression before it was
  given a value. Automatic variables are not guaranteed to have any
  specific value when a function is entered, so an uninitialized automatic
  variable can create seemingly random bugs. It is possible for this
  warning to not be produced when appropriate or to be produced
  incorrectly because the compiler does not check all possible execution
  paths. In rare cases, the message is produced incorrectly if the variable
  is used in a loop construct and initialized later in the same loop
  construct, as shown:


  void myfunc(void)
  {

int i, j;
for(i=0; i<10; i++)

{
 if(i > 0) printf("%d\n", j);  /* Warning 94 */
 j = i;
}
  }

  Without doing detailed loop analysis, the compiler cannot tell that j is
  not referenced by the call to printf until after it is initialized.

230 Appendix 2




Some cases that use uninitialized variables may not produce the
  warning. For example, no warning is produced for the following code
  even though j is not initialized if x is greater than S:


  void myfUnc(int x)
  {
 int j;
 if(Y < 5) j = X;
 if(j < 5)  /* j might be uninitialized */
 {
...
 }
  }

warning 95: unrecognized #pragma operand

  The keyword following a #pragma statement was not recognized as a
  SAS/C pragma keyword. Version 6 of the SAS/C Compiler supports the
  libcall, flibcall, syscall, tagcall, andmsg #pragmas.

  Error 96: missing name for #pragma

  In a libcall, flibcall, syscall, or tagcall #pragma
  statement, the name of the routine to be called was omitted or
  incorrect.

  Error 97: bad library base for #pragma

  In a libcall, flibcall, or tagcall #pragma statement, the
  library base was omitted or incorrect.

  Error 98: invalid data for #pragma

  In a libcall, flibcall, syscall, or tagcall #pragma
  statement, the offset or magic number fields were invalid. In a #pragma
  msg statement, a syntax error was made specifying the message number
  or the action to be taken.

  Error 99: attempt to change a const lvalue

  Your code attempted to modify a variable declared with the const
  keyword. Variables declared with the const keyword are read-only and
  cannot be modified.

 Error and Warning Messages 231




Warning 100: no prototype declared for function "name"

Your code called the named function, but the compiler did not find a
prototype for that function. Without a prototype, the compiler cannot
perform parameter type checking. Remember, a function that takes no
parameters still needs a prototype with void as its parameter list:


  int func(void);  /* "func" returns "int" and takes no parms */


If the function is a SAS/C function, the SAS/C Development System
Librar,v Reference tells you which header file to #include to get the
correct definition for the function. If the function is an AmigaDOS
function, its prototype is in the include: clib directory in the file for
its library. For more information, you can refer to the Amiga ROM Kernel
Reference Manual: Libraries, 3rd Edition (Commodore-Amiga, Inc. 1992)
or use the grep command to search the header file in the
include: clib directory for the prototype.
  Error 101: redundant keywords in declaration

The same storage class keyword was specified multiple times when
declaring a variable, function, or prototype. For example, you may have
specified the const or __chip keyword twice.

However, you can specify a typedef with a storage class keyword.
Any variables declared with this typedef are automatically assigned to
that specified storage class. Therefore, you may get an error 101 for
specifying the keyword explicitly on a variable declared with the
typedef, as in the following example:


  typedef int __far farint;
  farint x;  /* Declares a far integer called "x" */
  farint __far y;  /* Error 101 */
  Error 102: conflicting keywords in declaration

You have specified two mutually incompatible storage class keywords
when declaring a variable, function, or prototype. For example, you
may have specified the __near and __far keywords on a variable
definition.

However, you can specify a typedef with a storage class keyword.
Any variables declared with this typedef are automatically assigned to
that specified storage class. Therefore, you may get an error 102 for

232 Appendix 2




specifying a keyword explicitly on a variable which conflicts with the
keyword declared with the typedef, as in the following example:


  typedef int __far farint;
  farint x;  /* Declares a far integer called "x" */
  farint __near y;  /* Error 102 */


Warning 103: uninitialized constant "[name]"

The named variable was declared const, indicating that the variable is
read-only, but you have not initialized the variable. If the variable is
declared static or extern, it is initialized to zero for you but is
probably not useful unless explicitly initialized.

Warning 104: conversion from pointer to const/volatile to
pointer to non-const/volatile

A pointer to a const or volatile object is being converted to a
pointer to a normal object. For example, you may be passing the
address of a const variable to a function that takes a normal pointer.
After the pointer has been converted, the const or volatile
attribute is lost. Therefore, your const data might get modified, or
your volatile data might be kept in a register.

 Error and Warning Messages 233




  In the following example, warning 104 is produced when the function
foo is called with the const array data as an argument.

void foo(char *);

void myfunc(void)
{
const char data [] = "Hello, World!\n";
foo(data);  /* Warning 104 */
printf("%s\n", data);

}

void foo(char *p)
{
P[1] = 'a';
}


The function foo actually modifies its data by writing to it. Therefore,
printf prints the value Hallo, World! instead of Hello, World !
because the constant array has been modified.

234 Appendix 2




Warning 105: module does not define any externally-known symbols

The C source file and all of its included headers were compiled, but no
externally-visible functions or data items were defined. In this case, a
valid object file is produced, but it contains nothing that can be
accessed, and the file can removed from your link step if you desire.

  Error 106: postfix expression not allowed on a constant

Your code attempted to apply a postfix ++ or--operator to a constant.
This message may be generated because of an incorrect macro
expansion. You can use the pponly option to generate a preprocessed
file and check the macro expansion.

  Error 107: too many initializers

A data item was being initialized, but too many initializer elements were
provided, as in the following example:

struct FOO
{
int i, j;
};


struct FOO foo = {10, 20, 30};  /* Error 107 */

Warning 108: zero-length arrays are not an ANSI feature

This message is suppressed by default, but you can enable it with the
strict, ansi, or warn= 108 options. You have declared an array of
size zero, probably as a member of a structure to allow variable-sized
structures. While using zero-length arrays is a common extension to the
ANSI Standard and is supported by the SAS/C Compiler, the ANSI
Standard does not allow the use of zero-length arrays.

  Error 109: invalid use of type name or keyword

A type name (possibly a typedef) has been encountered where it was
not expected. You may have attempted to declare a variable with the
same name as a keyword.

 Error and Warning Messages 235




Warning 110: enum constant expression is wrong type
Expecting "type1", found "type2"

An enumeration constant value was explicitly assigned that did not
match the type of the enum being declared. For example, specifying a
double constant when defining an enum or specifying a long constant
when the shortint option is active will generate this message.
Example:


 enum COLORS { RED=1.0 }; /* Warning 110 */


Warning 111: non-portable enum type specified

This message is suppressed by default, but you can enable it with the
strict, ansi, or warn= 111 options. As an extension to the ANSI
Standard, the SAS/C Compiler supports short, char, and long
enum types with the syntax short enum, char enum, and long
enum. To improve the portability of your code, enable this warning.

Warning 114: negative shift or shift too big for type
shifts for type "type" must be between O and nUmber
bits

Your code attempted to shift an integral value by a constant number of
bits, but the constant was either negative or higher than the number of
bits in the value being shifted, as shown in the following examples:


int i = l;
i = i >> 33;  /* Warning 114 */
i = i << -l;  /* Warning 114 */


In the first example, i is 32 bits (an int) but is being shifted 33 bits.
Shifting a value by a number of bits higher than the number of bits in
the value generates a zero for the result. In the second example, i is
being shifted by a negative number of bits. Attempting to shift a value
by a negative number of bits usually generates a zero for the result
(although this result is undefined by the ANSI Standard).

Error 115: enum constant value "number~ out of range for enum
type

Your code specified a value for an enum constant while defining an
enumerated type which is out of range for the type of enum being
declared. Remember that enum constants that are not explicitly assigned
a numerical value are given the value of the previous constant defined

236 Appendix 2




in the same enum incremented by one. This increment might place the
constant's value out of the acceptable range, as in the following example:


  char enum COLORS
  {
RED=254,/* Numeric value is 254  */
GREEN,  /* Numeric value is 255 (254+1) */
BLUE/* Numeric value is 256 - too big for char */
  };/* Error 115 is issued */


The enum constant RED is assigned a value of 254. GREEN does not
have an explicit value, so it is assigned 254+1, or 255. BLUE does not
have an explicit value, so its value would normally be 255+1, or 256.
However, the enum is declared as being a char enum, so 256 is too
big and error 115 is issued.

Warning 116: undefined enum tag "name"

A reference was made to an enum that has not yet been declared. The
compiler may generate this message as a warning if only a pointer to
the enum is used, but the compiler generates this message as an error if
any other use is made of the enum.

  Error 117: enum contains no members

An attempt was made to define an enumerated type, but no member
names were specified. Use the pponly option to generate a
preprocessed file if you have problems eliminating this message.

  Error 118: conflicting use of enum/struct/union tag "name"

An attempt was made to define an enum, struct, or union that has
the same name as a previously defined enum, struct, or union in
the same scope. You cannot define an enum with the same name as a
struct, union, or another enum.

 Error and Warning Messages 237




  Error 119:  identifiers missing from definition of function
"name"

A prototype-style function definition was encountered, but the names of
the parameters were missing. You can omit the parameter names from a
prototype, but the names must be present in the actual function
definition. For example the following code generates error 119:


  void func(int, int, double);  /* Legal prototype */


  void func(int, int, double)/* Illegal function definition */
  {/* Error 119 */
  }



Warning 120: Integral type mismatch: possible portability
problem
Expecting "type1", found "type2"

This message is suppressed by default, but you can enable it with the
strict or warn=120 options. The wrong integral type was passed as
a parameter. This error may be a problem on another compiler or
another type of computer if the size of an int is different from the size
of an int on the Amiga computer. This warning is not a problem if
your code needs to run with the SAS/C Compiler only.

  In the following example, the SAS/C Compiler promotes the short
integer to a long integer even if you compile with the shortint
option:


  #pragma msg 120 warn
  void func(long);
  
  void main(void)
  {
short s = 10;
func(s);/* Warning 120 */
  }

However, pre-ANSI compilers on machines that define the int type to
be the same as short may not perform the conversion or may perform
the conversion and issue a warning message. In addition, if you remove
the prototype, this code will not work on any machine where int is the
same as short.

238 Appendix 2




Warning 121: hex/octal constant "constant" too large for char
High bits may be lost

Warning 121 is generated if a hexadecimal or octal constant specifies
more digits than will fit into a single char.

According to the ANSI Standard, hexadecimal bytes may be specified
in a quoted string using the \xhh escape sequence. The ANSI Standard
also states that the escape sequence consumes all valid hexadecimal
characters in the string following the \x, even if all the characters
consumed will not fit into a single byte, which may not be what you
want. For example, in the case of \xabcdefgh, you may want the
character 0xab first, followed by the string cdefgh. According to the
ANSI Standard, this escape sequence evaluates to the character Oxef
followed by the string gh, because the \x consumes all valid
hexadecimal characters. A single byte cannot hold the hexadecimal
number 0xabcdef, so the top bits are lost and 0xef is the result. The
best way to get the character 0xab followed by the string cdefgh is to
use ANSI string concatenation to terminate the escape sequence:
\xab cdefgh. The two strings are concatenated to form the desired
sequence.

Warning 122: missing ellipsis

A function or function prototype was encountered that attempted to
specify variable arguments with a trailing comma in the argument list.
According to the ANSI Standard, variable arguments must be specified
by a trailing comma followed by an ellipsis (...). The SAS/C Compiler
accepts the form without the ellipsis as if the ellipsis had been specified,
but other ANSI conforming compilers may require the ellipsis, as in the
following example:


void foo(int x, ... );  /* Right */
void bar(int x, );/* Wrong */


Warning 123: no tag defined for enumeration
Cannot construct prototype

The genproto option was active, but a prototype could not be
generated for a function because an enum was used as a parameter to
the function and that enum had no tag, as shown in the following
example.


void myfunc(colors)
enum (RED, GREEN, BLUE) colors;
{
}

 Error and Warning Messages 239




  The tag is the name normally appearing immediately after the keyword
  enum in the enum declaration. This message is produced only if the
  genproto compiler option is used to produce prototypes.
Error 125:  invalid number

  The numerical constant specified cannot be represented on the Amiga
  computer. The constant is probably an integer that is too large or too
  small (negative) to be represented in four bytes. This error can also be
  produced if a floating-point number is specified incorrectly or if invalid
  digits are provided to an octal constant.

  The following lines all produce error 125:


  double d = 10.3.2;/* Error 125 */
  int i = 123456789123456789; /* Error 125 */
  int j = 099;  /* Error 125 */


  In the first line, the value assigned to the floating-point variable has been
  incorrectly specified. In the second line, the value contains too many
  digits to fit into an int. In the third line, the value begins with a zero,
  which makes the value an octal constant, but it contains the digit 9,
  which is invalid for octal constants.
Warning 126:  #endif, #else, or #elif out of order

  A #endif, #else, or #elif was encountered but no #if or #ifdef
  was active.

  Error 127: operand to # operator must be a macro argument

  If a preprocessor macro parameter is preceded with the # operator, that
  parameter is replaced with the literal string consisting of the
  corresponding argument to the macro. For example, if you pass the
  argument FOO to a macro, and that argument in the macro definition is
  preceded by the # operator, that argument expands to the string
  "FOO". The # operator can be applied only to macro arguments.

  Error 128:  text-from-#error

  This message is the result of a #error preprocessor directive in the
  source code being compiled. The text of the message is taken from the
  #error line.

  Error 129: ambiguous struct or union member "name"

  Your code referred to a structure or union member that did not exist.
  In an attempt to resolve the name, the compiler examined the names of
  all members of substructures or subunions. Two or more members of
  subaggregates matched the name you provided, so the compiler was
  unable to determine which member you intended to specify.

240 Appendix 2




  Suppose you have the following code:
  
  void main(void)
  {
struct FOO
{
  int x, y, z;
};

struct BAR
{
  int a, b, x;
};

struct COMBO
{
  struct FOO foo;
  struct BAR bar;
}
combo.a = 10; /*Warning 193*/
combo.x = 10; /*Error 129*/
  }

  The reference to combo.a succeeds, although it generates a warning
  193 (implicit reference to structure member), because the
  full reference should be combo.bar.a. The reference to combo.x
  generates error 129, because both substructures of combo contain a
  member called x. The compiler cannot tell whether you mean
  combo.foo.x or combo.bar.x, so it issues the error message 129.

See Chapter 11, "Using Amiga Specific Features of the SAS/C
  Language," for more information on implicit structure references.

  Error l31: maximum temporary or formal storage exceeded

  The compiler must allocate stack storage to allow you to pass and
  receive structures or other parameters to and from functions.
  Parameters are copied onto the stack for each function call, so if you
  are passing large structures, your code will run very slowly. Consider
  passing a pointer to your structure instead of the entire structure.

 Error and Warning Messages 241




Warning 132: extra tokens after valid preprocessor directive

The ANSI Standard does not allow extra text on a preprocessor line,
but this extra text may be allowed by some C compilers. For example,
many programmers put a descriptive word after a #endif directive
indicating the #if to which the #endif belongs. To make your code
ANSI-compatible, you should place such descriptive words in comments,
as shown in the following example:


#ifdef SOMETHING
#endif SOMETHING /* Warning 132 */


#ifdef SOMETHING
#endif /* SOMETHING */  /* No warning */

  Error 133: cannot redefine macro "name"

An attempt was made to redefine a built-in preprocessor macro, like
__FILE__ or __LINE__ You cannot redefine built-in preprocessor
macros.

Warning 134: too many arguments

A macro definition was encountered with more than the allowable
number of arguments. The current ANSI limit for macro arguments is
31, and the SAS/C Compiler does not allow more than 31 arguments. If
message 134 is issued, the macro is not successfully defined. Any use of
the macro in your code produces a warning for a function with no
prototype and possibly a linker error when the name of the macro
cannot be resolved by the linker.

  Error 135: argument count incorrect for macro "name",
expecting number arguments
See line number file "filename"

Your code invoked a macro with too few or too many arguments. The
macro is defined at the specified file and line number.

  Error 136: invalid use of register keyword

Your code used one of the register keywords inappropriately. The
register keywords are register, __a0, __d0, __a1, __d1, and so
on.

242 Appendix 2




Warning 137: ANSI limits #line numbers to between 1 and 32767

This message is suppressed by default, but you can enable it with the
strict, ansi, or warn=137 options. The ANSI Standard states that
line numbers specified with a #line directive should be between 1 and
32767. However, the SAS/C Compiler accepts any number that will fit
into a signed four-byte integer.

  Error 138: operation invalid for pointer to void

Your code attempted to perform an operation on a void * pointer that
is not valid for void *. Such operations include addition, subtraction,
array indexing, and dereferencing (unary * operator). For example, the
following code attempts to perform addition on a void * pointer:

void *p = NULL;
p = p + 1;  /* Error 138 */


Warning 139: missing #endif
See line number file "filename"

The compiler encountered an #if, #ifdef, or #elif statement for
which there is no matching #endif. The file and line number of the
unmatched directive is specified in the message. This message occurs
only at the end of the source file, so large portions of your program
may have been ignored because of a stray #if or #ifndef with no
matching #endif.

Warning 140: sizeof operator used on array that has been
converted to pointer

Use of the sizeof operator on an array name gives the size of the
array. However, if the array name has been converted (cast) to a
pointer, the resulting size is the size of the pointer (4 bytes), not the
size of the array. Almost any use of an array name in an expression
implicitly casts the array name to pointer. To determine the actual size
of the array, pass only the array name to the sizeof operator.

 Error and Warning Messages 243




In the following example, in the first assignment statement, i gets the
value 4 (the size of a pointer to a character). In the second assignment
statement, i gets the value 10.


  char ary[10];
  int i;


  i = sizeof(ary+1);  /* Warning 140 */
  i = sizeof(ary);
  Error 142: array size never given for "name"

You can declare an array as extern and not specify the first subscript.
However, when you define the array, you must specify the subscript.
Storage is allocated when you define an array, not when you declare an
array as extern. For example:

extern char ary1[][10];  /* Legal */
char ary2[][10];  /* Error 142 */

  Error 143: object has no address

An attempt was made to take the address of something that has no
address. You may be attempting to take the address of a register
variable or an expression.

Warning 146: case value out of range for switch type

A case value was specified in a switch statement that can never be
taken. For example, if you compile with the shortint option and a
switch statement is switching on a short or int value, case values
too big to be stored in 16 bits will generate this warning:


/* The SHORTINT compiler option is on. */
  int i = 10;
  switch(i)  /* i is a 16-bit integer */
  {
case 0x08000000:/* Warning 146 */
 break;

case 65000: /* Warning 146 */
 break;
  }

244 Appendix 2




Warning 147: conversion between function and data pointers

Your code has cast or otherwise converted a pointer that points to a
function to a pointer that points to data. The ANSI Standard states that
this conversion is not legal. This conversion works with the SAS/C
Compiler in most circumstances, but you should use the
absfuncpointer compiler option if your code is larger than 32K.

Warning 148: use of incomplete struct/union/enum tag "name"
See line number file filename

This message is suppressed by default, but you can enable it with the
warn= 148 option. An incomplete tag is one for which no definition has
been seen. The ANSI Standard allows use of an incomplete tag (for
declaring pointers, for example). If you want to know when an
incomplete tag is being used, enable this warning. You may also want to
enable warning 149.

Warning 149: incomplete struct/union/enum tag in prototype scope
"name"

This message is suppressed by default, but you can enable it with the
strict or warn= 149 options. An incomplete tag was discovered in a
prototype. An incomplete tag is one for which no definition has been
seen. The ANSI Standard requires the incomplete tag's scope to end at
the end of the prototype. Therefore, any definition of the function later,
even if the tag in question has been defined, may generate an error
message and terminate the compilation. You may want to turn on
warning 148 for the most information about incomplete tags. If you do
not want to see all the incomplete tag information, you identify most
problem cases by enabling only warning 149.

The following function definition produces an error on many ANSI-
conforming compilers because the structure FOO referred to in the
definition is considered to be a different structure FOO than the one
referred to in the prototype.

 Error and Warning Messages 245




  void func(struct FOO *);  /* Warning 149 */

  struct FOO
  {
int x, y, z;
  };


/* Many compilers issue an error here. */
void func(struct FOO *foo)
{
}


This error could be fixed by moving the definition for the structure FOO
before the prototype.
Warning 150: the keyword "name" is meaningless for itemtype

When declaring a function or data item, you have used a keyword that
is meaningless for that type of item. For example, you cannot specify
the following:


void __chip foo(int);  /* Warning 150 */


It is meaningless to say that a function is to be allocated in _ _ chip
memory.
The __near and __far storage class keywords are valid on both
functions and data items, but have slightly different meanings. See the
descriptions of the data=near and code=near options in Chapter 8,
"Compiling and Linking Your Program," for more information.

Some keywords that are valid on functions are also valid on data
items because the data items may be pointers to functions of the
designated type. For example, you may have a function that returns a
pointer to a __regargs function. Keywords in this category include
__stdargs, __regargs, __asm, and __interrupt.

Other keywords need to be present only on the function definition.
You do not need to add them to function pointers and function
prototypes. Keywords in this category include __stackext and
__saveds. If these keywords appear on a data item, warning 150 is
generated and the extra keyword is ignored.

For more information on specifying keywords, see Chapter 11, "Using
Amiga Specific Features of the SAS/C Language."

246 Appendix 2




  Error 152: cannot define function via typedef name

Your code attempted to define a function using a typedef, as shown
below:


 typedef int foo(int);

 foo bar  /* Error 152 */
 {
 }



According to the ANSI Standard, you cannot define a function using a
typedef. The SAS/C Compiler does not accept such a definition.
Warning 154: no prototype declared for function pointer

Function pointers require prototypes just like functions. To declare a
prototype for a function pointer, enter the parameter list instead of the
empty parentheses in the definition, as shown in the following example:


void (*func1)();  /* Warning 154 */

void (*func2)(int, double, long);  /* No warning */


Remember that a pointer to a function that takes no parameters still
requires a prototype:

void (*func3)(void);  /* Function pointer takes no parms */

 Error and Warning Messages 247




Warning 155: no statement after label

The C language does not allow a label immediately before the curly
brace ending a block (}). If you enter a label in this position, the SAS/C
Compiler generates this warning. Enter a semicolon (representing a
NULL statement) after the label to suppress the warning, as shown in
the following example:

void funcl(void)
{
  goto foobar;
 /* more code */
  foobar: /* Warning 155 */
}

void func2(void)
{
  goto foobar;
 /* more code */
  foobar: ;/* No warning */
}



Warning 156: operation/comparison of pointer to "int" and
pointer to "type"

This message is suppressed by default, but you can enable it with the
warn= 156 options. If you compiled with the short int option, your
program has used a pointer to int and a pointer to short in an
operation. If you did not compile with the shortint option, your
program has used a pointer to int and a pointer to long in an
operation.

248 Appendix 2




For example, the following code will work if int and long are the
same length, but the same code will not compile if ints and longs are
different lengths:


/* Assume SHORTINT is not active */
  int *ip = NULL;
  long *lp = NULL;
  int diff;
  diff = ip - lp;

  Error 158: invalid type name

The compiler expected a type name for a cast or of f setof operation,
but the provided name was not recognized as a valid type name. Check
the preprocessed output to make sure you are providing the correct
information.

Warning 159: use of unary minus on unsigned value

This message is suppressed by default, but you can enable it with the
strict or warn= 159 options. Your code has used the unary minus
operator (-) on an unsigned variable. Using this operator on an
unsigned variable may not produce the expected result because the
result is still a non-negative number.

Warning 161: no prototype declared at definition for function
"name"

An old-style function definition was encountered, and no prototype was
in scope. The prototype must appear in the C file or a header file before
the definition of the function, or the function definition itself must be a
prototype-style definition.

Warning 162: non-ANSI use of ellipsis punctuator

This message is suppressed by default, but you can enable it with the
strict, ansi, or warn=162 options. You have declared a function
with the ellipsis punctuator (...) but the function has no arguments. The
ANSI Standard requires functions that take a variable number of
arguments to take at least one fixed argument.

Warning 163: initialization of auto struct, union, or array

This message is suppressed by default, but you can enable it with the
strict or warn=163 options. Your code has initialized an automatic
structure, union, or array. The ANSI Standard allows you to initialize
automatic structures, union, and arrays, but many pre-ANSI compilers
do not.

 Error and Warning Messages 249




Warning 164: & applied to array

This message is suppressed by default, but you can enable it with the
strict or warn= 164 options. Your code has used the address (&)
operator on an array name. You should instead take the address of the
first element in the array, or use the array name without the address
operator. For example:


  int ary[10];
  int *iptr;


  iptr = &ary;/* warning 165 */
  iptr = ary; /* OK */
  iptr = &ary[0]; /* OK */

Warning 165: use of narrow type in prototype

This message is suppressed by default, but you can enable it with the
warn = 165 option. This warning is provided for detecting situations
that may cause problems on other compilers if your code mixes function
prototypes and old-style function definitions. See Chapter 13, "Writing
Portable Code," for information on using narrow types in function
declarations. See also the descriptions of messages 176 and 179.

  Error 166: unrecoverable error or too many errors
Terminating compilation

Your program has exceeded the default or specified maxerr or
maxwarn values, or an error has occurred that prevents the compiler
from producing meaningful results.

  The default maximum number of errors is 50. By default, any
number of warnings may be generated.

Warning 169: ineompatible operands of conditional operator (?:)
"type1" conflicts with "type2"

The operands of the ?: conditional operator must be of compatible
types. Your code supplied types to the ?: operator that were not
compatible. For example, the following code generates warning 169:


int func(void)
{
int i = 0;
struct FOO *foo = NULL;
return (int)(i > O ? foo : i);  /* Warning 169 */
}

250 Appendix 2




The expression following the question mark (?) is of type
struct FOO *. The expression following the colon (:) is of type int.

This message can be an error if it is not possible to convert the types
in question. This can occur if one of the types is a structure or union.

Warning 170: overflow during operation on constants

A constant expression overflowed the limits of the type in which it was
being calculated. Perhaps you have added or multiplied two large
integers, thereby resulting in a number too large to represent in a four-
byte integer.

Warning 176: implicitly promoted formal "name" conflicts with
prototype
See line number file "filename"

This message is suppressed by default, but you can enable it with the
strict, ansi, or warn= 176 options. You are defining a function
using an old-style definition, which means that any narrow types (char,
short, and float) in your definition are implicitly widened to their
non-narrow equivalents (int, int, and double, respectively).
However, a prototype is in scope that gives the narrow version of the
type.

Functions that call your function will not know that your function is
using an old-style definition and, with some compilers, may pass an
incorrect value. An incorrect value is never passed using the SAS/C
Compiler on the Amiga hardware. See Chapter 13, "Writing Portable
Code," for information on using narrow types in function declarations.
See also the descriptions of messages 165 and 179.

Warning 178: indirect call without indirection operator

This message is suppressed by default, but you can enable it with the
strict or warn= 178 options. You called a function using a function
pointer, but did not use the indirection (*) operator to dereference the
pointer first. The SAS/C Compiler generated correct code, but on
pre-ANSI compilers this code may not work. Example:

void (*funcptr)(int);


funcptr(10);  /* Warning 178 */
(*funcptr)(10);  /* No warning */

 Error and Warning Messages 251




Warning 179: narrow type used in old-style definition

This message is suppressed by default, but you can enable it with the
strict or warn=179 options. Your code has used a narrow type
(char, short, or float) in an old-style definition. See Chapter 13,
"Writing Portable Code," for information on using narrow types in
function declarations. See also the descriptions of messages 165 and
176.

Warning 180: no space between macro name and its replacement
list

This message is suppressed by default, but you can enable it with the
strict, ansi, or warn=180 options. Your code is defining a
preprocessor macro that takes arguments but does not have at least one
blank after the closing parentheses of the argument list. The ANSI
Standard requires white space after the closing parentheses. For
example:


  #pragma msg 180 warn
  #define ADD(a,b)(a+b)  /* Warning 180 */


Warning 181: "name" was declared both static and external
See line number file "filename"

Your code has declared a function as both static and external at
different places. Both the function and its prototype must agree on
whether the function is static.

Warning 182: static function "name" declared but not defined
See line number file "filename"

Your code had a prototype for a function declared static but never
defined the function. The function definition may be hidden with # i f or
#ifdef statements.

Warning 183: inline function declared but not defined
See line number file "filename"

Your code had a prototype for a function declared __inline but
never defined the function. The function definition may be hidden with
#if or #ifdef statements.

Warning 184: invalid multi-byte character constant

Your code has specified a multibyte character constant (such as ~ ab ' ),
and you did not compile your code with the mccons option; or, if you
compiled your code with the mccons option, the multibyte character is
larger than the permitted four bytes.

252 Appendix 2




  Error 185: comma expected

The compiler expected a comma but did not find one. This error may be
produced because of errors in previous statements. Fix all previous
errors before fixing this one.

Warning 186:  implicit conversion between pointer and scalar

Your code has converted a pointer to an integer while doing static
initialization. You can suppress this warning by casting the pointer to
the appropriate type.

Warning 187: negative value assigned to unsigned type

This message is suppressed by default, but you can enable it with the
strict or warn=187 options. Your code has assigned a negative
constant to an unsigned variable. In doing so, your code is in effect
assigning a very large positive number to the variable, which may or
may not be the action you intended.

Warning 190:  #include ignored because header already included
See line number file "filename"

This message is suppressed by default, but you can enable it with the
warn=190 option. The nomultipleincludes compiler option is
active, and your code included the same header file more than once.
The compiler ignores the additional #include statement. You can use
this message to locate all such multiple includes if you want to modify
your header files to not include the same file more than once.

You can get even more information about which header files were
included by using the listincludes compiler option.

Warning 192: wrong size for enum

An enum variable was declared to be of a different type than the base
enum was when it was defined. Suppose you have the following code:


char enum COLORS = (RED, GREEN, BLUE);
enum COLORS color;  /* Warning 192 */
char enum COLORS color2;/* correct */


  The enum variable color should be declared the same size as the base
  enum type, which is char enum. The base enum type overrides the
  enum variable's type definition.

 Error and Warning Messages 253




Warning 193: implicit reference to struct/union member
Reference assumed to be "reference"

Your code has referred to a struct or union member name that is
actually a member of a substructure or subunion of the original. The
compiler has searched all substructures and subunions and determined
that exactly one member matches the name you specified, so it is using
that member. The reference printed in the message text is the fully
expanded name of the member that it is using. If you intend to take
advantage of this feature of the SAS/C Compiler, you may disable this
warning with the ignore= 193 option. If you choose to disable this
warning, your code may not work on other compilers.

For more information on using implicit structure references, see
Chapter 11, "Using Amiga Specific Features of the SAS/C Language."

Warning 194: too much local data for NEAR reference,
some changed to FAR

You have declared more than 32K of static data. The compiler can
address up to this amount using 16-bit offsets. Amounts greater than
32K must be addressed using 32-bit offsets. You may have compiled
with the data=f aronly option and declared some data with the
__near keyword. If your entire project is in one source file or is
compiled with data=faronly, you can ignore this warning unless you
get an error later in the compilation or link. Otherwise, you must
eliminate some near data in one of three ways:

[] Compile your program with the strmerge compiler option. This
option moves all string constants to the code section, thereby moving
them out of the near data section.
[] Declare read-only data as static const. When you compile with
  the stringmerge option, this data will also be moved to the code
section.
[] Add the __far keyword to some of your larger external or static data
items to move those items from the near section to the far section.
Specify the data=far compiler option to move all data items except
those declared with the _ _ near keyword to the far section.

Note: The second line of message 194 is not printed unless you
compiled with the data=auto option, or you compiled with the
data = faronly option and declared data with the __near keyword.

254 Appendix 2




Warning 195: nested comment detected

This message is suppressed by default, but you can enable it with the
warn= 195 option. The compiler found the start of a comment (/*)
inside of a comment. Some compilers allow comment nesting and others
ignore the start of the second comment. The ANSI Standard does not
allow nested comments. If you choose to use nested comments, you
should specify the comnest compiler option. However, using the
comnest option prevents your code from running on most ANSI-
compliant compilers.

Warning 196: specified include directory not found: "name"

The named directory does not exist or could not be accessed.

Warning 198: __regargs invalid for a varargs function

Functions that take variable numbers of parameters always pass their
parameters on the stack. The __regargs keyword is invalid for these
functions.

  Error 199: unbalanced comment
See line number file filename

Your code has a comment open (/*) with no corresponding comment
close (*/). This condition is not detected until the end of the C source
file.

Warning 204: macro invocation not terminated

Your code invoked a macro but did not supply enough closing
parentheses to terminate the invocation. Also, check any of the macros
that are invoked by the macro that you invoked directly in your code.

Warning 209: macro invocction may have multiple side effects

You have passed an expression with a side effect as an argument to a
macro, and that macro has evaluated the argument more than once.
Operators with side effects are ++,--, +=, /=, *=, -=, >>=, <<=, |=,
&=, and =.

For example, the max and min macros evaluate each argument twice.
If you invoke the max macro as MAX ( i ++, j ), the first argument is
evaluated twice, and two post-increments take place. You could define
the max macro as follows:


#define MAX(x,y) ((x) > (y) ? x : y)

int i = 0;
i = MAX(i++, 0);/* Warning 209 */

 Error and Warning Messages 255




  The macro expands to:


  i = ((i++) > (0) ? i++ : 0);


  The expansion contains the expression i++ twice, so if that branch of
  the ?: operator is executed, the variable i is incremented twice.

 This warning may sometimes be produced incorrectly, but you should
  examine each case to determine whether there is an error.

 Function calls are also considered side effects, but function calls
  produce warning 217 instead of warning 209.

Warning 212:  item "name" already declared
See line number file "filename"

  This message is suppressed by default, but you can enable it with the
  warn=212 option. You have declared an item twice. For example, you
  may have specified the prototype for a function twice, or you may have
  declared an extern twice. The declarations do not conflict, or the
  compiler would generate error 72, but code is harder to maintain if it
  defines the same item in more than one place. You may want to use the
  nomultipleincludes option to suppress multiple #includes of
  the same file if you enable warning 212.

Warning 213: empty argument to preprocessor macro

  This message is suppressed by default, but you can enable it with the
  strict, ansi, or warn=213 options. Your code calls a preprocessor
  macro with no argument text. This action is accepted by the SAS/C
  Compiler but is not permitted by the ANSI Standard. For example:
  #define FOO(a,b)  a
  FOO(lO,)
Warning 216: symbol "name" found

  You have compiled with the fsym compiler option, and the compiler
  has found a definition of one of the symbols that you specified as the
  parameter to the fsym option.

Warning 217: macro invocation may call function multiple times

  You have passed a function call as an argument to a macro that
  evaluates its arguments more than once. This action may cause
  incorrect results. See also the description of message 209.

256 Appendix 2




  Error 218: declaration found in statement block

The compiler found a declaration where it expected a statement. You
may have a statement in the middle of your declaration block, or vice-
versa. Any declarations found after this error are added as external
variables, which suppresses warnings about undefined variables but
may create additional errors later if your code declares a variable of the
same name. In the following example, the variable y is declared after
the first statement of the function:

void func(void)
{
int x;
x = 10;
int y;/* Error 218 */
}

Warning 220: old-fashioned assignment operator
taken as "operators"

This message is suppressed by default, but you can enable it with the
strict or warn=220 options. Older compilers allowed the operators
=-, =+, and so on. In ANSI C, these operators are specified as -=, +=,
and so on. The older specification is ambiguous when assigning certain
expressions (for example, x=-5; and x= - 5; ). To resolve this
ambiguity, newer compilers use =-, and some pre-ANSI compilers use
-=. Therefore, you should enter at least one space between the equals
(=) sign and whatever operator follows it to ensure portability.

  Error 223: "filename" is not a valid GST file

The specified filename was supplied using the gst compiler option as a
Global Symbol Table file, but it is not a valid GST file. Delete the bad
file and try re-creating it.

Warning 224: item "name" already defined
See line number file "filename"

This message indicates that a variable, function, or typedef is being
defined for the second time in a given scope. This message is normally
an error, but if the redefinition is harmless, the compiler allows it and
issues the message as a warning instead. As shown in the following
example, the compiler allows redefinition of typedef names in the
same scope if the new type is identical to the old type. The compiler
does not allow redefinition of functions or variables in the same scope.

 Error and Warning Messages 257




  typedef int foo;
  typedef int foo;  /* Warning 224 */


  void func(void)
  {
  }

  void func(void)/* Error 224  */
  {
  }





Warning 225: pointer type mismatch
"type1" does not match "type2"

Your code has performed an assignment or some other operation on
two incompatible different pointer types or on a pointer type and an
arithmetic type. For example:


struct FOO
{
int x, y, z;
} foo;
int *ip;


ip = &foo;  /* Warning 225 */


  Error 226: cannot convert "type1" to "type2"

The compiler was unable to perform a requested or implicit conversion.
For example, if one of the types is an instance of a structure, the
structure cannot be cast to another structure type or to an arithmetic
type. For example:


  struct FOO
  {
int x, y, z;
  } foo;
  int i;


  i = (int) foo;  /* Error 226 */

258 Appendix 2




  Explanations of Linker Messages

 Error 103: Out of memory!!
Error 103:  Out of memory!!
slink has run out of memory. By default, slink attempts to cache
  slink has run out of memory. By default, slink attempts to cache
  the object modules in memory between pass 1 and pass 2. If slink
  runs out of memory, it attempts to free the cached object modules. In
  some cases, slink cannot find enough continuous memory. Try adding
  bufsize 4096 to the slink command. This option turns off object
  module caching.

Error 425:  Cannot find library library-name

  The linker cannot find the specified library. Usually, SAS/C libraries are
  located in the LIB: directory. You may have misspelled to library 
  name in your slink command.

Error 426:  Cannot find object name

  The linker cannot find the specified object.

Error 443:  filename is an invalid file name

  The linker found an invalid character in a filename.

Error 444:  Hunk_Symbol has bad symbol-type symbol symbol-name

  The object module is corrupt. Try recompiling the object module.

Error 445:  Invalid HUNK_SYMBOL symbol-name

  The object module is corrupt. Try recompiling the object module.

Error 446:  Invalid symbol type symbol-type for symbol-name

  Either the object module is corrupt, or slink has found a symbol type
  that it does not recognize. Try recompiling the object module. For a list
  of valid symbol types, refer to the description of object file structure in
  The AmigaDOS Manual, 3rd Edition.

Error 447:  filename is a load file

  The file specified is an executable module instead of an object module.

Error 448:  filename is not a valid object file

  The file specified is not an object module. The file may be a C source
  file or a corrupt object module.

Error 449:  No hunk_end seen for filename

  The object module is corrupt. Try recompiling the object module.

Error 450:  Object file filename is an extended library

  A library file was specified as an object module. Add the library
  keyword in front of the library name.

 Error and Warning Messages 2S9




Error 501: Invalid Reloc 8 or 16 reference

  An 8- or 16-bit relocation address cannot reach its destination. The
  SAS/C Compiler does not generate 8-bit relocation records, but third
  party products may use them. The object module is probably corrupt.
  Try recompiling your source file. If recompiling the file does not correct
  the error, contact the Technical Support Division.

Error 502: function-name symbol - Distance for Reloc16 greater
 than 32768

  The distance from the point where the function is called to the function
  itself is greater than 32767 bytes. The function cannot be referenced
  with a 16-bit address field. Normally, slink tries to insert an ALV
  (Automatic Link Vector) at the end of the calling module, but if the
  module has more than 32K of code, the relocation may not reach the
  ALV. An ALV is the instruction used to reach functions that would
  otherwise be too far away. Compile the file with -code=far, or
  declare the function with the __far keyword.

Error 503: function-name symbol - Distance for Reloc8 greater
 than 128

  The distance from the point where the function is called to the function
  itself is more than 128 and so the function cannot be referenced with
  an 8-bit address field. The SAS/C Compiler does not generate 8-bit
  relocation records, but third party products may use them.

Error 504:  variable-name symbol - Distance for Data Reloc 16
 greater than 32768

  The distance for the 16-bit relocation is too far. You may see this
  message if a data item (such as a structure or an array) is larger than
  64K or if the total amount of data in your program is greater than 64K.
  To correct the problem, you can either break the data item down and
  make it smaller than 64K, or you can place the __far keyword on the
  definitions of one or more data items to force all references to those
  items to be 32-bits. Using the __far keyword reduces the amount of
  data in the near data section to less than 64K. You can also compile
  your program with the data = far option. However, using data=far
  increases code size and execution time.

Error 505:  variable-name symbol - Distance for Data Reloc8
 greater than 128

  The distance for the 8-bit relocation is too far. The SAS/C Compiler
  does not generate 8-bit relocation, but third party products may use
  them.

260 Appendix 2




Error 506: Can't locate resolved symbol symbol-name

 If this message appears, please contact the Technical Support Division.
 See Chapter 3, "Getting Help," for a complete list of items that you
 need to provide to the Technical Support staff.

Error 507: Unknown Symbol type symbol-type , for symbol
 symbol-name

 Either the object module is corrupt, or a slink has found a symbol
 type that it does not recognize. Try recompiling your source file. For a
 list of valid symbol types, see the description of object file structure in
 The AmigaDOS Manual, 3rd Edition.

Error 508: Symbol type symbol-type unimplemented

 Either the object module is corrupt, or a slink has found a symbol
 type that it does not recognize. Try recompiling your source file. For a
 list of valid symbol types, see the description of object file structure in
 The AmigaDOS Manual, 3rd Edition.

Error 509: Unknown hunk type symbol-type in Pass2

 If this message appears, please contact the Technical Support Division.
 See Chapter 3, "Getting Help," for a complete list of items that you
 need to provide to the Technical Support staff.

Error 510: symbol-name symbol - Near reference to a data item
 not in near data section

 The linker expected the specified symbol to be in the near data section,
 but the symbol is located in either the far data section, chip memory, or
 the code section.

You may have defined a variable as __far with the __far
 keyword in one module and externally declared the same variable in
 another module without the __far keyword. If so, the module with
 the external declaration attempted to reference the data as near. To
 correct the problem, the definition and all declarations of the data item
 must be specified with the same keywords.

If you compiled your file with the data=auto option, the compiler
 can place variables into the far data section if necessary. The compiler
 may have placed a variable in one module in the far section and a
 variable in another module in the near section. To correct this situation,
 either stop using the data=auto option, and use the __far keyword
 (if necessary) on the definition and all declarations of the variable that
 causes the error.

 Error and Warning Messages 261




Error 512: Invalid branch to function-name in overlay node
 module-name

  The linker detected a branch in an overlay node that calls another
  overlay node at the same level. This type of branch is not supported by
  the overlay manager.

Error 513: Multiple NTRYHUNK segments not permitted

  The NTRYHUNK is the root overlay node. No other hunks should have
  this name.

Error 514: Overlay manager _ovlyMgr is undefined

  This _ovlyMgr function is located in SAS/C libraries. To use the
  SAS/C overlay manager, link with sc.lib or scs.lib. You can also
  write your own overlay manager. See Chapter 8, "Compiling and
  Linking Your Program," for information on creating your own overlay
  manager.

Error 515: An ALV was generated pointing to data variable-name
 symbol

  A 16-bit relocation could not reach its destination, so slink inserted
  an ALV (Automatic Link Vector) instruction, and then determined that
  the destination is not in a code hunk. To correct the problem, make the
  reference a 32-bit reference. This error may be generated for object
  code produced by third-party assemblers and compilers

Error 516: Attempt to merge BSS with CODE or CODE/DATA

  Either you have attempted to merge the far BSS section with the far
  data section, or you have attempted to merge the near or far BSS
  section with the code section. You can merge a BSS section with the
  __MERGED section only. You will see this message if you have assigned
  the same name to either the far BSS section and the far data section or
  the far BSS section and the code section.

If you get this error in another situation, please call the Technical
  Support Division.

Note: Do not name the code section __MERGED.

Error 600: Invalid command command

  The option listed is not a valid slink option.

Error 601: option option specified more than once

 The option has been specified twice.

262 Appendix 2




Error 602: Unable to open output file filename

 slink cannot open the output file for write access. Another program
 such as CodeProbe may have left a lock on the file. Alternatively, the
 protection bits may prohibit write access to the file, or that the name
 specified may be a directory.

Error 603: string is not a valid number
 
 The linker found a non-numerical character in a field where it expected
 to find a number.

Error 604: with file is not readable

 The with file may contain binary characters or may be locked.

Error 605: Cannot open with file filename

 The with file does not exist or may be locked.

Error 607: No FROM/ROOT files specified

 You did not specify an object module, or if you are using overlays, the
 root node did not contain any objects.

Error 608: Premature EOF encountered

 The object module is corrupt. Try recompiling the source file.

Error 609: Error seeking in file filename

 The object module is corrupt. Try recompiling the source file.

Error 610: module-name has no parent in overlay tree

 The with file specifies an overlay with no parent node.

Error 611: Reloc found with odd address for symbol symbol-
 name, file filename

 The linker has found a relocation record with an odd address. This
 message can only be generated if your program is written in assembler
 and is usually caused by placing an odd length character string in the
 code section.

Error 612: MERGED Data relocation to non-code section in
 Overlay Node
 Reference at offset hex-address in module-name, To
 Unit module-name

 The linker found a relocation from the near data section, which is
 placed in the root node, to the data section of an overlay node. This
 type of relocation is illegal.

 Error and Warning Messages 263




Error 613: MERGED Data relocation to static function is not
 resolvable by Overlay Manager.
 Reference at offset hex-address in filename , To
 Unit filename

  The overlay manager cannot resolve an indirect function call from the
  root node to a static function in a overlay node. To correct the problem,
  remove the static keyword from the function declaration.

Error 614: More than one MERGED data section found

  Only one near data section is allowed. This error occurs only when
  using slink to strip debug information from an executable generated
  by a third party linker. If you get this message, do not use slink to
  strip debug information from this executable.

Error 615: Code hunk named __MERGED

  slink merges all hunks with the name __MERGED and performs
  relocations to this hunk relative to register A4. Do not name the code
  hunk __MERGED .

Error 616: ALVs were generated

  You have linked with the noalvs linker option, but the linker could
  not resolve all relocations without generating ALV instructions. Either
  the total code size is greater than 32K, or there are multiple code
  hunks. The executable will run, but the code section is not totally PC-
  relative.

Error 617: MERGED data greater than 64K

  If your program does not generate any additional messages, then the
  program will still run. However, a 16-bit data relocation record may
  not be able to reach its target, and if this happens, slink will generate
  an error.

Error 618: Multiple OVERLAY usage-previous occurrences were
 ignored

  You can only specify one overlay manager.

Error 619: Ignoring null OVERLAY list

  You did not specify any files in the overlay list.

264 Appendix 2




Error 620: Missing '#' at end of OVERLAY list

 Enter a pound sign (#) at the end of the overlay tree. For more
 information on creating overlay trees, see Chapter 8, "Compiling and
 Linking Your Program."

Error 621: Conflicting integer sizes found

 Some modules were compiled using short integers and some were
 compiled using long integers. You cannot mix integer sizes in an
 executable. Alternatively, you may have linked in the wrong version of
 the library.

Error 622: Conflicting math types found

 You may have compiled the various object modules with conflicting
 math options. All object modules must be compiled with the same math
 library. Alternatively, you may have linked in the wrong math library.

Error 623: Regargs function function called through overlay
 manager. Parameters passed in registers to this
 function will be destroyed.

 The regargs function passes parameters in scratch registers, but the
 overlay manager does not preserve scratch registers. You cannot call a
 regargs function across an overlay node.

Error 624: Absolute reference to symbol module: file filename

 If you reference far data in a module linked with cres.o or when you
 are generating a shared library, your program may function improperly
 unless the data are read-only. slink cannot determine if the reference
 is read-only, so it generates this warning.

Error 625: Proper math library has not been included

 You have not linked in the math library that is needed for the current
 math options.

Error 626: Libcode used on module module

 You have compiled the module with the libcode compiler option that
 was used on the module, but the module is being linked into an
 executable. Use the libcode option for generating shared libraries
 only.

Error 627: Near references found in executable that has a
 module compiled with FARONLY option

 You cannot mix modules compiled with data= faronly and modules
 that refer to near data.

Error and Warning Messages 265




Enabling Suppressed Messages
Many messages are suppressed by default. The strict and ansi
compiler options turn on some of these messages, but you must use the
warn option to enable the remaining messages. The ansi option enables
the following messages:

185170108  111  137  162  176  180  213

The strict option enables the following messages:

1870111  137  159  163  176  179  187  220
51108  120  149  162  164  178  180  213

The following messages can be enabled only with the warn option:

22148  156  165  190  195  212

The following table lists each message that is suppressed by default and
indicates which compiler options enable the message.



Number Message Text ansi strict warn

18 sizeof operator used in preprocessor X  X  X
condition

22 structure used as function argumentX

51 C++ comment detectedX  X  X

70 unrecognized escape sequence  X  X  X

108zero-length arrays are not an ansi featureX  X  X

111non-portable enum type specifiedX  X  X

120Integral type mismatch: possible portabilityX  X
problem
Expecting "type1", found "type2"

137ansi limits #line numbers to between 1 andX  X  X
32767


(cont~nued)


End Of Part 3

