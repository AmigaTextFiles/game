Part 2



  Table 8.1Negative
(continued)  Option Name Form?Default Value
________________________________________________________________________
GenProtoTypeDEFs Yes  gptdef
GlobalSymbolTable=  Yes  nogst
GSTIMMediateYes  nogstimm
ICONsYes  icons
IDentif ierLENgth=  No255
IGNore=No
IncludeDIRectory=No
KeepLINE  Yes  nokline
LIBCODEYes  nolibcode
LIBrary=  No
LINX Yes  nolink
LINKerOPTions=Yes  nolinkopt
LIST Yes  nolist
ListFILE= Yes  filename.1st
ListHEADers Yes  nolhead
ListINCludesYes  listinc
ListMACrosYes  nolmac
ListNARRowYes  lnarr
ListSYStemYes  nolsys
MakeGlobalSymbolTable=  Yes
MAP  Yes  nomap
MapFILE=  Yes  executable.map
MapHUNKYes  nomaphunk
MapLIBYes  nomlib
MapOVerLaYYes  nomovly
MapSYMbolsYes  nomsym
MapXREFerenceYes  nomxref
  (continued)

Using Compiler Options 83






Option Name Form?Default Value
____________________________________________________________
MATH=Yes  nomath
MAXimumERRors=Yes  50
MAXimumWaRNings= Yes  nomaxwrn
MEMorySIZE= Nolarge
MODified  Yes  nomod
MultipleCharacterCONStants Yes  nomccons
MultipleINCludes Yes  minc
OBJect=No
OBJectLIBrary=Yes
OBJectNAME= Yes
OLDPreProcessor  Yes  nooldpp
ONERRor=  Nostop
OPTimize  Yes  noopt
OPTimizerALIASYes  optalias
OPTimizerCOMPlexity=Yes  3
OPTimizerDEPth=  Yes  3
OPTimizerGlObal  Yes  optgo
OPTimizerINLine  Yes  optinl
OPTimizerINLOCAL Yes  nooptinlocal
OPTimizerLOOPYes  optloop
OPTimizerPEEPholeYes  optpeep
OPTimizerRecurDEPth=Yes  3
OPTimizerSIZEYes  nooptsize
OPTimizerTIMEYes  noopttime
PARaMeters= Nostack
PRECision=Nomixed
PreProcessorBUFfer=No8192
PreProcessorONLY Yes  nopponly
ProgramNAME=No

 (continued)

84  Chapter 8


Negative
Option Name Form?Default Value
______________________________________________________________
RESetOPTionsNo
SAVEDSYes  nosaveds
ShortINTegersYes  nosint
SmallCODE Yes  noscode
SmallDATA Yes  nosdata
SouRCeIS= Yes
STacKCHecKYes  stkchk
STacKEXTend Yes  nostkext
STanDardIOYes  stdio
STaRTup=  Yes  c (for c.o)
STRICTYes  nostrict
STRingsCONstYes  nostrcons
STRingMERge Yes  nostrmer
STRIPDeBuGYes  nostripdbg
STRuctureEQuivalenceYes  nostreq
TO=  No
TRIGraph  Yes  notrig
UnderSCOREYes  nouscore
UnsignedCHARYes  nouchar
UTILityLIBraryYes  noutillib
VERBOSEYes  noverbose
VERsionYes  version
WaRN=No
WarnVoidRETurnYes  wvret
WITH=No
XREFerenceYes  noxref
XreferenceHEADersYes  noxhead
Xref erenceSYStemYes  noxsys

Using Compiler Options 85




Compiler Option Descriptions
The following pages describe each of the options accepted by the s~
command. The compiler options are not case-sensitive. You can enter
options in upper, lower, or mixed case.


AbsFuncPointer
generates 32-bit references to functions when loading function
pointers. The default value is noabsfuncpointer. The minimum
acceptable abbreviation is afp.
  If you specify noabsfuncpointer and you take the address of a
function that is more than 32k away, the linker generates an ALV
(automatic link vector) jump instruction that allows your code to work.
However, if you compare the address of the function to a function
pointer assigned elsewhere, you may get a different value. Specify
absfuncpointer if your code is larger than 64K or in multiple
code hunks and you compare function pointers. Specifying
absfuncpointer may increase the size of your executable.


AddSymbols
tells the linker to add symbol information to the executable module.
The default value is noaddsymbols. The minimum acceptable
abbreviation is add sym.
  This option is automatically enabled if you specify the debug
option. This option is ignored if you do not specify the link option.


ANSI
enforces the strictest interpretation of the ANSI C standard. Using this
option produces many additional warning messages. The default value
isnoansi.
  To be completely ANSI-compliant (that is, if you require a pure
ANSI namespace), you should also define the preprocessor symbol
_ STRICT _ ANSI before including any header files. For more
information about_ STRICT_ANSI, refer to Chapter 7, "Library
Reference," in SAS/C Development System Library Reference,
Version 6.0. If you require support for ANSI trigraphs, specify the
trigraph option also.
  For more information about improving the portability of your code,
see Chapter 13, "Writing Portable Code."


ArgumentSize=n
sets the size of the maximum argument to a preprocessor macro. The
minimum acceptable abbreviation is argsiz. This option does not
have a negative form. The default value is 512. However, the

86 Chapter 8




  memorysize option sets the argumentsize (and other internal
  limits) to different default values if you do not specify
  argumentsize.
 See the description of the memorysize option for more
  information.


Assembler=filename(s)
  specifies assembly-language files that are to be assembled and, if you
  specify the link option, linked into the program. The minimum
  acceptable abbreviation is asm. This option does not have a negative
  form.
 You can use AmigaDOS wildcard characters to specify filenames. To
  specify several filenames or wildcard patterns, separate each filename
  with a plus (+) sign or a comma (,). You can specify the assembler
  option as many times as necessary.
 If you are assembling a disassembly that was generated with the
  disassemble compiler option, specify the underscore compiler
  option also. (If you assemble a disassembly by calling the assembler
  directly, specify the -u assembler option.)
 See also the descriptions of the csource, ob ject, and library
  options.


AutoRegister
  enables automatic register selection by the code generator. The default
  value is autoregi ster. The minimum acceptable abbreviation is
  autoreg.
 If you specify autoregister, the compiler attempts to add
  register variables to the variables that have already been chosen by
  the global optimizer or declared with the register keyword.


Batch
  tells the linker not to prompt for definitions of undefined symbols. The
  default value is nobatch. This option is ignored if you do not specify
  the link option. See also the description of the batch linker option.


BSSMemory=type
  specifies the type of memory into which uninitialized external data
  items should be loaded. You can specify any, chip, or fast for type.
  You can abbreviate these values as a, c, or f. The default value is
  any. This option does not have a negative form.
 This option affects code generated by both the compiler and the
  assembler. See also the descriptions of the datamem and codemem
  options.

Using Compiler Options 87





BSSName=name
 names the uninitialized data section. The default value is udata. You
 can specify bssname=none or nobssname if you want an unnamed
 BSS section. The linker automatically merges all sections with the
 same name. See also the descriptions of the codename and
 dataname options. See Chapter 12, "How Does the Compiler Work?"
 for information on data and code sections.


Code = reference-type
 specifies whether you want 16-bit or 32-bit references to functions not
 declared in the current file. You can specify near or n for 16-bit
 references or far or f for 32-bit references. The default value is
 near. This option does not have a negative form.
  Most programs do not need this option even if they are very large,
because the linker creates a jump instruction (an ALV) for any
references to functions that are out of range. See also the description
of the data option.


CodeMemory=type
specifies the type of memory into which code should be loaded. You
can specify any, chip, or fast. You can abbreviate these values as
a, c, or f. The default value is any. This option does not have a
negative form.
  This option affects code generated by both the compiler and the
assembler. See also the descriptions of the bssmem and datamem
options.


CodeName =name
names the code section. The default value is text. You can specify
codename=none or nocodename if you want an unnamed code
section. The linker automatically merges all sections with the same
name. See also the descriptions of the bssname and dataname
options. See Chapter 12, "How Does the Compiler Work?" for
information on data and code sections.


CommentNest
allows nested comments. The default value is nocommentnest. The
minimum acceptable abbreviation is cnest.
  Nested comments occur when one comment is totally contained
inside another. The ANSI Standard prohibits nested comments, so in
ANSI compliant code, the first comment end sequence (*/) terminates
both comments. For example, the statement below generates an error

88 Chapter 8




  with nocommentnest, but compiles successfully with
  commentnest.

/* i = i+1;/* This is a comment */ */

  The statement below compiles successfully with nocommentnest, but
  generates an error with commentnest.

/* i = i+l; /* This is a comment */




Common
  tells the compiler to use the common model for external data. If you
  specify nocommon, the compiler uses the strict reference-definition
  model. The default value is nocommon.
 The section "Using Common Model External Data" in Chapter 11,
  "Using Amiga Specific Features of the SAS/C Language," describes
  common and strict reference-definition models.


ConstLibBase
  tells the compiler that library base pointers are set once then remain
  constant throughout your entire program. The default value is
  constlibbase. The minimum acceptable abbreviation is
  constlib.
 If you change the value of your library bases after setting them, you
  should specify the noconstlibbase option. Specifying
  constlibbase allows the compiler to prevent extra register loading
  when making a series of calls to library functions through an external
  variable containing the library base.


Coverage
  tells the compiler to generate code to collect coverage analysis
  information. The default value is nocover. The minimum acceptable
  abbreviation is c over.
 Coverage analysis information allows you to determine which lines
  of your program have been executed by your test cases. For more
  information, refer to the description of the cover utility in SAS/C
  Development System User's Guide, Volume 2: Debugger, Utlities,
  Assembler, Version 6.0.

Using Compiler Options 89




  If you specify the cover option, make sure that you:
[] Link with the file sc: examples/cover/covutil.o or
LIB:covutil.o.
[] Do not specify the nostdio option.
[] Use startupsc to link with the standard c.o startup module.



CPU=processor
generates code specific to the specified processor. You can specify any,
a, or 68000 to generate code for any processor. You can also specify
68010, 68020, 68030, or 68040 to generate code for a specific
processor. The default value is any. This option does not have a
negative form.
  This option defines one or more preprocessor symbols. See the
section "Using Preprocessor Symbols Defined by the Compiler," later
in this chapter for a list of those symbols.
  This option affects code generated by both the compiler and the
assembler.


CSource=filename
specifies C source files that are to be compiled and, if you specify the
link option, linked into the program. The minimum acceptable
abbreviation is csrc. This option does not have a negative form.
  You can use AmigaDOS wildcard characters to specify filenames. To
specify several filenames or wildcard patterns, separate each filename
with a plus (+) sign or a comma (,). You can specify the csource
option as many times as necessary. See also the descriptions of the
assembler, object, and library options.


Data =reference-type
specifies whether you want the compiler to generate 16-bit or 32-bit
references to external and static data items. You can specify any of the
following:

near or n
tells the compiler to use 16-bit references. If you specify near, all
data not declared with the _ _ far or _ _ chip keyword are placed
into the near data section. The default value is near.

far or f
tells the compiler to use 32-bit references. Register A4 is still
reserved to point to the near data section so that you can mix code
compiled with data=near and data=far.

90 Chapter 8




faronly or fo
  tells the compiler that your program never uses near data. If you
  specify faronly, the compiler generates 32-bit references and
  may use register A4 as an additional register variable. If you
  compile with the data = faronly option, and you declare data
  with the __near keyword, the compiler displays the warning
  message 194:


  too much local data for NEAR reference,
  some changed to FAR


  If your entire project is in one source file or is compiled with
  data=faronly, you can ignore this warning unless you get an
  error later in the compilation or link.

auto or a
  indicates that the first 64k of external data should generate 16-bit
  references and the remaining external data should generate 32-bit
  references. This option does not have a negative form.

 You can override this option on individual data items by using the
  _ _ near, _ _ far, or _ _ chip keywords. _ _ near forces the
  compiler to generate a 16-bit reference, and _ _ far forces the
  compiler to generate a 32-bit reference. _ _ chip forces the compiler
  to place the data item into chip memory. For more information, refer
  to the section "Using Special Keywords" in Chapter 11, "Using Amiga
  Specific Features of the SAS/C Language."
  See also the description of the code option.


DataMemory=type
  specifies the type of memory into which initialized static or external
  data should be loaded. You can specify any, chip, or fast. You can
  abbreviate these values as a, c, or f. The default value is any. This
  option does not have a negative form.
 This option affects code generated by both the compiler and the
  assembler. See also the descriptions of the bssmem and codemem
  options.

Using CompilerOptions 91





DataName=name
names the initialized data section. The default value is data. You can
specify dataname=none or nodataname if you want an unnamed
data section.
  The linker automatically merges all sections with the same name.
See also the descriptions of the bssname and codename options. See
Chapter 12, "How Does the Compiler Work?" for information on data
and code sections.


Debug=level
sets the debugging level of the compiler. If you do not want the
compiler to generate debugging information, specify nodebug. The
default value is nodebug. The minimum acceptable abbreviation is
dbg.
  To generate debugging information, specify debug=level, where
level is one of the following:

line or l
produces line number information only.

symbol or s
produces line number information, information on automatic and
formal variables, and information on external and static symbols
that are referenced in the module being compiled.

symbolflush or sf
produces the same information as symbol, and flushes any non-
register variables being held in registers to memory at each line
boundary to allow the debugger to accurately display their values
in C source mode.

full or f
produces the same information as symbol. However,
debug=full produces information on au symbols whether or not
the module references the symbol.

fullflush or ff
produces the same information as full, and flushes any non-
register variables being held in registers to memory at each line
boundary to allow the debugger to accurately display their values
in C source mode.

  Any debug option except nodebug adds the -d assembler option to
any assembled files to force debugging line number information on
assembler output. Also, if you specify the link option and any debug
option except nodebug, the addsym option is passed to the linker.

92 Chapter 8






Define[=]symbol[=value]
  defines the specified preprocessor symbol, as if with a #define
  statement. The minimum acceptable abbreviation is def. This option
  does not have a negative form.
 Do not enter a space between the symbol name and the following
  equal sign. If the value contains a space, enclose the entire argument
  in double quotes ("). As with all other compiler options, the equal sign
  between the define option and the symbol name is optional, so both
  of the following examples are acceptable:


  define foo=bar
  define=foo=bar


  You can specify the define option as many times as necessary.
 Any symbols defined with the define option are defined in the
  assembler as well.
 Note: The define compiler option does not affect the linker. Do
  not confuse this option with the define linker option.


DisAssemble=filename
  tells the compiler to disassemble the code as it is generated and to
  send the disassembly to the file you specify. The default value is
  nodisassemble. The minimum acceptable abbreviation is disasm.
 To send the disassembly to the Shell, use disasm=*.


Error=n
  tells the compiler to treat the specified message as an error. You can
  specify all or a to promote all enabled warnings to errors, or you
  can specify one or more message numbers to promote only those
  messages. The minimum acceptable abbreviation is err. This option
  does not have a negative form.
 To specify several message numbers, separate each number with a
  plus (+) sign or a comma (,). You can specify the error option as
  many times as necessary. See also the descriptions of the warn and
  ignore options.


ErrorConsole
  enables printing of diagnostics to the console (stdout). The default
  value is errconsole. The minimum acceptable abbreviation is
  errcon.

Using Compiler Options 93






ErrorHighlight
highlights the token that caused the error using ANSI escape
sequences in diagnostic output that is sent to the console. The default
value is errorhighlight. The minimum acceptable abbreviation is
errhigh.


ErrorList
prints diagnostic messages to the listing file. The default value is
error list. The minimum acceptable abbreviation is errlist. This
option is ignored if you do not specify the list option.


ErrorRexx
sends diagnostic messages to the scmsg utility. The default value is
noerrorrexx. The minimum acceptable abbreviation is errrexx.
  For more information, refer to the description of the scmsg utility
in SAS/C Development System User's Guide, Volume 2.


ErrorSource
prints lines from the C source file with the diagnostic messages that
are sent to the console. The default value is errorsource. The
minimum acceptable abbreviation is errsrc.


ExternalDefs
treats all external definitions as definitions. The default value is
externaldefs. The minimum acceptable abbreviation is extdef.
  If you specify noexternaldefs, all external definitions are
treated as external declarations. This action has the same effect as if
you had declared each variable with the extern keyword. For
example, int i is treated as extern int i, and it would need to
be defined in a file compiled without noexternaldefs.


FindSymbol=symbol-name
tells the compiler to print a warning message each time the specified
symbol is defined. The minimum abbreviation is fsym. This option
does not have a negative form. You can specify the findsymbol
option as many times as necessary.
  If you specify the findsymbol option, a message is produced for
any definition of the symbol, including #def ine statements, structure
and union declarations, prototypes, and extern, static, and local
variable definitions. Use the fsym option to quickly determine where
a given preprocessor symbol or prototype is coming from.

94 Chapter 8






  From
 is included only for compatibility with the slink command. The
 compiler ignores this option. This option does not have a negative
 form.


  GenProtoDataItems
 generates external declarations for variables defined in the source files
 that are not defined as static. The minimum abbreviation is
 gpdata. The default value is gpdata. This option is ignored if you
 do not specify the genprotos option.


  GenProtoExterns
 generates prototypes for externally-known routines. The default value
 is genprotoexterns. The minimum acceptable abbreviation is
 gpext.
This option is ignored if you do not specify the genprotos option.


  GenProtoFile=filename
 specifies the name of the file in which to place the generated
 prototypes. The default value is filename_protos.h. The
 minimum acceptable abbreviation is gpfile.
This option is ignored if you do not specify the genprotos option.


  GenProtoParameters
 generates prototypes using the __PARMS macro. The default value is
 nogenprotoparameters. The minimum acceptable abbreviation is
 gpparm.
This option allows your C code to compile successfully on compilers
 that support prototypes and on those that do not. On ANSI compilers,
 the __PARMS macro expands to the parameter list for the function,
 thereby creating a prototype. On non-ANSI compilers, the __PARMS
 macro expands to an open-close parentheses pair, which declares the
 function's return type without defining a prototype. This option is
 ignored if you do not specify the genprotos option.


  GenProtos
 generates prototypes and data declarations instead of compiling your
 file. The default value is nogenprotos. The minimum acceptable
 abbreviation is gproto.
 This option defines the preprocessor symbol _GENPROTO. If you
 specify a filename with the genprotofile option, the prototypes are

Using Compiler Options 95




written to the specified file. Otherwise, the prototypes are written to
the file filename_ protos .h.
  While generating prototypes, the compiler suppresses most warnings
automatically, because many of the warnings may be due to incorrect
or missing prototypes. The compiler also checks all #include
statements as they are reached. If your file #includes the same
prototype file that is being generated, the compiler skips that
#include statement. This feature allows you to use this option to
maintain declarations for all externally-known symbols in each C
source file and regenerate the declarations as the files change.
  To set up your project so that you can use this option to maintain
prototype files, do the following:
  1. Create a header file that contains # include statements for each
 of the files in your project, as follows:


 #include "file1_protos.h"
 #include "file2_protos.h"
.
.
.
 #include "filen_protos.h"


  2. Include this header file in each file in your project.
  3. Compile your entire project with the genproto option.

As each .c file is compiled, the compiler creates the corresponding
_protos.h file. The compiler suppresses the header file not
found warnings that would normally be produced.


GenProtoStatics
generates prototypes for static routines. The default value is
nogenprotostatics. The minimum acceptable abbreviation is
gpstat.
  This option is ignored if you do not specify the genprotos option.


GenProtoTypedefs
tells the compiler to use typedefs instead of resolved types when
generating prototypes for any functions using typedefs for parameters
or return values. The default value is genprototypedefs. The
minimum acceptable abbreviation is gptdef.
  This option is ignored if you do not specify the genprotos option.

96 Chapter 8






  GlobalSymbolTable=gst
 tells the compiler to use the specified GST (Global Symbol Table). The
 default value is noglobalsymboltable. The minimum acceptable
 abbreviation is gst.
The GST must have been created using the
 makeglobalsymboltable option during a previous compilation.
 The gst option is ignored if you specify the
 makeglobalsymboltable option. Therefore, you can enter the
 makeglobalsymboltable in the sc command even if your
 scoptions file contains the gst option.
This option defines the preprocessor symbol _ GST.
 
  GST=gst-filename
 is a synonym for the GlobalSymbolTable option.


  GSTImmediate
 is included for compatibility with projects using precompiled header
 files as implemented in Version 5 of the compiler. This option makes
 the contents of the GST you specify with the gst option immediately
 available to the program. The default value is nogstimmediate. The
 minimum acceptable abbreviation is gstimm.
Normally, symbols defined in a specific header file in the GST are
 available to your program only after you have included the header file
 with a #include statement. This option makes the contents of the
 GST you specify with the gst option immediately available to the
 program, even if your program does not contain #include
 statements for the header file. With Version 5 precompiled header
 files, all symbols in the precompiled header files were available to
 your program even if your program did not contain #include
 statements for the header file.


  Icons
 tells the compiler to create icons for files that it creates, including
 listing files, preprocessor output files, prototype files, and object files.
 The default value is icon.
If you specify icons, then each time the compiler generates a file,
 it looks in the drawer sc: icons for an icon named
 def_extension, where extension is the filename extension of
 the file it created. If the compiler finds an icon file appropriate to the
 file extension, it copies the icon to the directory in which the file was
 created. If the compiler cannot find sc: icons or cannot find an icon
 with the appropriate extension, it does not create an icon. If you
 
UsingCompilerOptions 97




specify noicons and link, the noicons option is also passed to the
linker. For more information, see the section "Using Icons" in
Chapter 2, "Using Your SAS/C Development System."


IdentifierLength=n
specifies the maximum number of significant characters in an
identifier. The default value is 255. The minimum acceptable
abbreviation is idlen. This option does not have a negative form.
  Identifiers longer than n are truncated without warning. Identifiers
longer than n bytes that differ after the first n bytes are treated as
identical.


Ignore=n
tells the compiler to ignore the specified warning message. The
minimum acceptable abbreviation is ign. This option does not have a
negative form.
  You cannot ignore error messages. You can specify a 11 or a to
ignore all warning messages, or you can specify one or more message
numbers to ignore only those messages. To specify several message
numbers, separate each number with a plus (+) sign or a comma (,).
You can specify the ignore option as many times as necessary.
  See also the descriptions of the error and warn options.


IncludeDirectory=directory
adds a directory to the list of directories to search for include files.
The default list is the current directory and include:. The minimum
acceptable abbreviation is idir. This option does not have a negative
form. You can specify the incdirectory option as many times as
necessary.
  Any directories you specify with includedirectory are also
passed to the assembler as header file search directories.


ReepLine
generates #line directives in the preprocessor output file that
correspond to the lines in the original source files. The default value is
nokeepline. The minimum abbreviation is kline.
  This option allows you to compile the preprocessed source and get
error and warning messages that refer you to the correct line in the
nonpreprocessed version of the file.
  This option is ignored if you do not specify the pponly option.

98 Chapter 8






LibCode
  tells the compiler that the compiled code will be linked into a shared
  library. The default value is nolibcode.
 Any functions compiled with libcode and either the __saveds
  keyword or the saveds option load their near data section from a
  point relative to the library base register A6 instead of from a global
  data area. libcode also guarantees that the current library base will
  be in register A6 whenever A6 is referenced or an internal call is
  made.
 Do not use this option when creating a normal executable module.


Library=link-library-filename(s)
  specifies the link libraries that are to be passed to the linker. The
  minimum acceptable abbreviation is lib. This option does not have a
  negative form.
 You can use AmigaDOS wildcard characters to specify filenames. To
  specify several filenames or wildcard patterns, separate each filename
  with a plus (+) sign or a comma (,). You can specify the library
  option as many times as necessary. Any libraries you specify are
  passed to the linker before the SAS/C libraries. This option is ignored
  if you do not specify the link option.
 See also the description of the csource, object, and asm
  options.


Link
  tells the compiler to invoke the linker to produce a final executable.
  The default value is nolink.
 If you do not specify link, the compiler ignores any object files and
  link libraries that you specify.
 The options passed to the linker are placed into the file
  program. lnk, and the linker is invoked using this file as a with
  file. To see which linker options were generated, look at the . lnk file
  after sc runs the linker.


LinkerOptions=option(s)
  passes the provided parameter to the linker as command line options.
  The default value is nolinkeroptions. The minimum acceptable
  abbreviation is linkopt.

Using Compiler Options 99




  If you want to specify more than one option, or if the option you
want to specify contains a blank, surround the entire option string
with double quotes ("), as in the following example:


 sc linkeroptions=llbufsize 10000 maxhunk 2" link myprog.c


Any options specified in the options string are passed to the linker
after any compiler options that are identified as valid only if you
specify link. Therefore, the linkeroptions values override the
values passed by the sc options.
  This option is ignored if you do not specify the link option.


List
tells the compiler or assembler to produce a listing file. The default
value is nolist.
  The compiler writes the output to the filename you specify with the
listfile option. If you do not specify an output filename, the
compiler uses the name of the first source file you specify but with the
extension.lst.


ListFile=filename
names the listing and/or cross reference file. The default filename is
the same filename as the source file but with the extension.lst. The
minimum acceptable abbreviation is lfile .
  This option is ignored if you do not specify the list or
xreference options.


ListHeaders
tells the compiler or assembler to include user header files in the
listing. The default value is listheaders. The minimum acceptable
abbreviation is lhead.
  This option is ignored if you do not specify the list option.


ListIncludes
lists the names of all included .h files in the listing file. The default
value is listinc. The minimum acceptable abbreviation is linc.
  This option is useful for determining:

[] .h file dependencies for smake
[] the exact path of each .h file used
[] exactly which .h files are included by other .h files.

100 Chapter 8




 The hierarchy of files is indicated by indention levels; a file included
  by another file is indented one level deeper than the parent file. This
  option is ignored if you do not specify the list option.


ListMacros
  tells the compiler or assembler to expand macros in the listing. The
  default value is nolistmacros. The minimum acceptable
  abbreviation is lmac.
 This option is ignored if you do not specify the list option.


ListNarrow
  tells the compiler or assembler to produce a narrow listing (less than
  80 columns wide). The default value is listnarrow. The minimum
  acceptable abbreviation is lnarr.
 This option is ignored if you do not specify the list option.
  
ListSystem
  tells the compiler to include system header files in the listing. The
  default value is nolistsystem. The minimum acceptable
  abbreviation is lsys .
 This option is ignored if you do not specify the list option.


MakeGlobalSymbolTable=gst-filename
  creates a GST (Global Symbol Table). The minimum acceptable
  abbreviation is mgst.
 If you specify the gst and makegst options, the gst option is
  ignored. Therefore, you can enter the makegst in the sc command
  even if your scoptions file contains the gst option. This option
  automatically enables the nomultipleincludes and
  noexternaldefs options. For more information on creating and
  using GSTs, refer to SAS/C Development System Library Reference.
 This option defines the preprocessor symbol _ MGST.


Map
  produces a map of the executable module. The default value is nomap.
  This option is ignored if you do not specify the link option.


MapFile=filename
  names the map file. The default value is executable.map. The
  minimum acceptable abbreviation is mfile.
 This option is ignored if you do not specify the link and map
  options.

  Using Compiler Options 101






MapHunk
maps all output hunks by size and originating function. The default
value is nomaphunk. The minimum acceptable abbreviation is
nomhunk .
  This option is ignored if you do not specify the link and map
options.


MapLib
generates a list of hunks by library symbol in the map. The default
value is nomaplib. The minimum acceptable abbreviation is mlib.
  This option is ignored if you do not specify the link and map
options.


MapOverlay
includes a list of hunks in each overlay in the map. The default value
is nomapoverlay. The minimum acceptable abbreviation is movly.
  This option is ignored if you do not specify the link and map
options.


MapSymbols
includes a list of defined symbols and the location at which they are
defined. The default value is nomapsymbols. The minimum
acceptable abbreviation is msym.
  This option is ignored if you do not specify the link and map
options.


MapXreference
writes a symbol cross-reference to the map file that lists each symbol
definition and the places each symbol is used. The default value is
nomapxreference. The minimum acceptable abbreviation is
mxref.
  This option can generate a lot of output, but it is useful when you
are trying to track down where an unresolved symbol is referenced.
This option is ignored if you do not specify the link and map
options.

102 Chapter 8






Math=type
  chooses a format for floating-point math and, if you also specify the
  link option, links with the appropriate math library. The default
  value is nomath.
 You can specify one of the following as the type:

  standard or s
 links with the library scm.lib (or with scms.lib if you specify
 the shortint option). The math format is IEEE.

  ffp or f
 generates code to call the FFP shared library provided by
 Commodore. The math format is FFP.

  68881, 68882, or 8
 generates inline code for the 68881 and 68882 coprocessors. If
 you specify one of these coprocessor options, your program will not
 run if a coprocessor is not available. coprocessor is a synonym
 for these options. The math format is IEEE.

  ieee or i
 generates code to call the IEEE shared library provided by
 Commodore. The math format is IEEE.
 
  Some math options define preprocessor symbols. See the section
  "Using Preprocessor Symbols Defined by the Compiler," later in this
  chapter, for a list of those symbols.
 For additional information about compiling and linking with math
  libraries, refer to Chapter 3, "Using the SAS/C Libraries," in SAS/C
  Development System Library Reference.


MaximumErrors=n
  sets the limit on the number of errors for a single compilation. The
  default value is 50. The minimum acceptable abbreviation is maxerr.
 If a single compilation generates more than n errors, the compiler
  aborts the compilation. nomaxerr removes any limits.


MaximumWarnings=n
  sets the limit on the number of warnings for a single compilation. The
  default value is nomaxwrn. The minimum acceptable abbreviation is
  maxwrn.
 If a single compilation generates more than n warnings, the
  compiler aborts the compilation. nomaxwrn removes any limits.

Using Compiler Options 103





MemorySize=size
tells the compiler approximately how much memory you have on your
system. You can specify one of the following:

[] tiny or t
[] small or s
[] medium or m
[] large or l
[] huge or h

The default value is large. The minimum acceptable abbreviation is
memsize. This option does not have a negative form.
  Larger sizes allow sc to compile more complex programs and to
compile faster. Smaller sizes allow sc to continue to work under low-
memory conditions. If the compiler runs out of memory during a
compilation, it displays the message ***Freeing Resources,
attempts to free up memory, and automatically drops to a lower
memorysize value.
  memorysize affects how and where the compiler stores any
debugging information. If the compiler begins to run out of memory, it
starts writing debugging information to a disk file. This file is referred
to as a debug side file.
  memorysize also affects the disposition and buffering of the
compiler intermediate file. This option tells the compiler how much
initial memory space to reserve for the intermediate information. For
large and huge, the intermediate file is kept totally in memory,
which is much faster than writing it to disk when the memory is
available. At smaller values, the intermediate file is written to disk,
but the memorysize value affects the amount that is buffered.
  In addition, if you do not specify the preprocessorbuffer
(ppbuf) and/or argumentsize (argsize) options, the
memorysize option sets these values for you. If you specify the
preprocessorbuffer and/or argumentsize options, the values
you specify override the values set by memorysize.

104 Chapter 8




  The following table lists the default values for argumentsize and
preprocessorbuffer by memorysize. It also lists the buffer size
and location of the compiler intermediate file.



Intermediate Debug Side
memsizeargsizeppbuf File Buffer  File Buffer

tiny1271024  1024  2K
small  2552048  4096  8K
medium 5114096  8192  32K
large  10238192  no limit 64K
huge480016384 no limit 128K



  See also the descriptions of the prepro~essorbuffer and
argumentsize options.

Modified
  tells the sc command to process only files that are out of date with
  respect to their output files. The default value is nomodified. The
  minimum acceptable abbreviation is mod.
 This option is useful if you are compiling several files with a single
  sc command and only some of the files need to be recompiled. This
  option also works when you are generating prototypes or preprocessor
  output. If you also specify the link option, all object files are
  included in the link, even if their source files were not recompiled.


MultipleCharacterConstants
  allows up to four bytes to appear within single quotes as a character
  constant. This option is included only for compatibility with previous
  releases of the compiler, and its use is not recommended. The
  minimum acceptable abbreviation is mccons. The default value is
  nomccons.

Using Compiler Ophons 105




  If you specify mccons, a single constant of type int is generated.
If fewer than four bytes are provided, they are padded on the left with
~eroes, as in the following example:


#include <stdio.h>
void main(void)


  long l = 'abcd';
  long m = '\x01\x02\x03';
  printf("l=0x%081x, m=0x%081x\n", l, m);



This example program prints the following:


l=0x61626364, m=0x00010203




MultipleIncludes
tells the compiler to include header files that are included more than
once. The default value is multipleincludes. The minimum
acceptable abbreviation is minc.
  This behavior is required by the ANSI Standard. However, many
projects do not need this behavior, and specifying nominc can save
compilation time.


Object=filename(s)
lists the object files that are to be linked into the program. The
minimum acceptable abbreviation is obj. This option does not have a
negative form.
  The object files must have been created during a previous
compilation. Do not specify object files that will be created by the
same sc command in which you specify the ob ject option. You can
use AmigaDOS wildcard characters to specify filenames. To specify
several filenames or wildcard patterns, separate each filename with a
plus (+) sign or a comma (,). You can specify the ob ject option as
many times as necessary.
  This option is ignored if you do not specify the 1 ink option. See
also the descriptions of the csource, library, and assembler
options.

106 Chapter 8





ObjectLibrary=link-library-name
  specifies that any resulting object files are to be placed in the named
  link library. The minimum acceptable abbreviation is objlib.
 Do not specify this option if you also specify the link option.


ObjectName=file-or-directory-name
  specifies the name of the file or directory to hold compiler and
  assembler output. The minimum acceptable abbreviation is objname.
  If you are compiling or assembling only one C source file or
  assembly-language file, you can use this option to specify the file
  where you want the compiler or assembler output. If you are
  compiling or assembling more than one file, you can use this option to
  specify a directory where you want the output, and sc uses the same
  filename as the source file but replaces the extension with .o. The
  directory name must end with a forward slash (/) or a colon (:). If you
  do not use the objectname option, sc uses the same filename with
  the extension of .o, but it places the files in the same directory as the
  source file.


OldPreprocessor
  is provided for compatibility with pre-ANSI style preprocessors. The
  default value is nooldpreprocessor. The minimum acceptable
  abbreviation is oldpp.
 The oldpp option does the following:

  [] allows old-style token pasting using comments
  [] substitutes values for parameters specified as quoted strings in
  macro definitions.

  For example, suppose you have the following program:


  #define FOO ( bar ) "bar"
void main(void)
{
  printf ( "%s\n", FOO(test) );
}

Using Compiler Options 107




If you compile this program with oldpp, the program prints test. If
you compile this program with nooldpp, the program prints bar. To
make this program work with the ANSI features and the nooldpp
option, substitute the following for the #define:


  #define FOO(bar) #bar


 As an additional example, suppose you have the following program:


  #define FOO(bar) foo_/**/bar
void main(void)
{

 int foo_test;
 int foo_xxx;


 FOO(test) = 10;
 FOO(xxx)  = 20;
 printf("%d %d\n", foo_test, foo_xxx);
}


If you compile this program with oldpp, the #define concatenates
the text of the argument after the string foo_ and the program prints
10 20. If you compile this program with nooldpp, the program
produces a compilation error. To make this program work with the
ANSI features and the nooldpp option, substitute the following for
the #define:


  #define FOO(bar) foo_##bar



OnError=x
tells sc what action to take if a C or assembly language source file
generates an error. The minimum acceptable abbreviation is onerr.
This option does not have a negative form.

108 Chapter 8




 You can specify one of the following:

  stop or s
 tells sc not to process any more source files. The default value is
 stop.

  continue or c
 tells sc to process the next source file.

  If you specify the link option, but your program generates errors,
your program is not linked even if you specify onerr=continue.


Optimize
  enables the global optimizer (unless you specify nooptglobal) and
  peephole optimizer (unless you specify nooptpeep). The default value
  is nooptimize. The minimum acceptable abbreviation is opt.


OptimizerAlias
  disables type-based aliasing assumptions in the optimizer. The default
  value is nooptimizeralias. The minimum acceptable abbreviation
  is optalias.
 If you specify optimizeralias, the global optimizer uses worst-
  case aliasing. Specifying optimizeralias can significantly reduce
  the amount of optimization that can be performed. This option is
  ignored if you do not specify the optimize and optglobal options.


OptimizerComplexity=n
  defines the maximum complexity level of functions to be automatically
  inlined. The default value is 3. The minimum acceptable abbreviation
  is optcomp.
 The parameter n represents the relative complexity of the function
  to be inlined and is a count of the number of discrete operations in
  the function. Try different values for this number until you get the
  results you want. Specify a value of 3 or higher. The higher the
  number, the more functions you can inline, but the size of your code
  will grow significantly as well.
 If you specify nooptcomp, no complexity-based inlining occurs.
  This option is ignored if you do not specify the optimize,
  optglobal, and optimizerinline options.

Using Compiler Options 109






OptimizerDepth=n
defines the maximum nesting depth of automatically inlined functions.
The default value is 3. The minimum acceptable abbreviation is
optdep.
  Specify a value of 3 or higher. This option is ignored if you do not
specify the optimize, optglobal, and optimizerinline
options.


OptimizerGlobal
enables the global optimizer. The default value is
optimizerglobal. The minimum abbreviation is optgo. This
option is ignored if you do not specify the optimize option.


OptimizerInline
allows inlining of functions, including functions defined with the
_ _ inline keyword. The default value is optimizerinline. The
minimum acceptable abbreviation is optinl.
  This option is ignored if you do not specify the optglobal and
opt imi z e options.
  If you do not specify this option, the optinlocal, optdepth,
optcomplexity, and optrdepth options are ignored.


OptimizerInLocal
inlines single use static functions. The default value is
nooptimizerinlocal. The minimum acceptable abbreviation is
optinlocal.
  This option is ignored if you do not specify the optimize,
optglobal, and optimizerinline options.


OptimizerLoop
enables loop optimizations. The default value is optimizerloop.
The minimum acceptable abbreviation is optloop.
  This option is ignored if you do not specify the optimize and
optglobal options.


OptimizerPeephole
enables the peephole optimizer. The default value is
optimizerpeephole. The minimum acceptable abbreviation is
optpeep.
  This option is ignored if you do not specify the optimize option.

110 Chapter 8






OptimizerRecurDepth=n
  defines the maximum depth of recursion of automatically inlined
  functions. The default value is 3. The minimum acceptable
  abbreviation is optrdep.
 Specify a value of 3 or higher. This option is ignored if you do not
  specify the optimize, optglobal, and optimizerinline
  options.


OptimizerSize
  disables optimizations that may sacrifice code size to save time. The
  default value is nooptsize. The minimum acceptable abbreviation is
  optsize.
 This option is ignored if you do not specify the optimize and
  optglobal options. Do not specify both the optimizersize and
  optimizertime options.


OptimizerTime
  disables optimizations that may sacrifice time to save space. The
  default value is nooptimizertime. The minimum acceptable
  abbreviation is opttime.
 This option is ignored if you do not specify the optimize and
  optglobal options. Do not specify both the optimizersize and
  optimizertime options.


Parameters =method
  indicates how parameters should be passed. The minimum acceptable
  abbreviation is parm. This option does not have a negative form.
 You can specify one of the following:

  stack or s
 indicates parameters should be passed on the stack. The default
 value is stack.

  register or r
 indicates parameters should be passed in registers.

  both or b
 generates a combination prolog that allows parameters to be passed
 on the stack or in registers.

  If your program has prototypes for all routines, you should probably
  use parameters=register for increased efficiency. If you are
  placing code into a link library, specify parms=both so that your
  library functions accept registerized parameters and parameters that
  are passed on the stack.

Using Compiler Options 111




  If you write a function that has the same name as a library function,
you need to add the __regargs keyword to your function or
compile with the parms=both or parms=register option. For
example, you may want to replace the SAS/C library function malloc
with your own version of malloc. If you compile with the
parms=stack option or define your version of malloc with the
__stdargs keyword, then two versions of malloc are linked into
your executable. If you use other SAS/C library functions that call
malloc, these functions use the version of malloc in the SAS/C
libraries. However, your functions that call malloc use your version
of malloc. To make sure that all calls to malloc are using your
version of malloc, define your version with __regargs or compile
with the parms=both or parms=register option.
  For information about passing parameters between C language
functions and assembly-language functions, refer to Chapter 11,
"Using Assembly Language with C Language," in SAS/C Development
System User's Guide, Volume 2.


Precision=precision
specifies the size of floating-point variables. You can specify double
or mixed. The default value is mixed. The minimum acceptable
abbreviation is prec. This option does not have a negative form.
  If you specify double, data declared as float are treated as if
they were declared as double. If you specify mixed, data declared as
float and data declared as double are different sizes.


PreprocessorBuffer=n
sets the maximum number of bytes to which a macro can be expanded
by the preprocessor. The default value is 8192 unless set differently
by the memorysize option. The minimum acceptable abbreviation is
ppbuf. This option does not have a negative form.
  If a macro expands to greater than n bytes, the compiler issues an
error message and aborts the compilation. See the description of the
memorysize option for more information.


PreprocessorOnly
tells the compiler to run only the preprocessor on the C source files.
The default value is nopreprocessoronly. The minimum
acceptable abbreviation is pponly.

112 Chapter 8




 If you specify a filename with the ob jectname option, the
  compiler writes the output to the file you specify. If you do not specify
  an output filename, the compiler writes the output to the same
  filename as the source file but with the extension . p.
 This option defines the preprocessor symbol _ PPONLY.


ProgramName=output-module-name
  specifies the name of the executable module. The default value is the
  root name of the first source file specified in the sc command. The
  minimum acceptable abbreviation is pname. This option does not have
  a negative form.
 This option is ignored if you do not specify the 1 ink option.


ResetOptions
  resets all options to their default values. The minimum acceptable
  abbreviation is resopt. This option does not have a negative form.
 If you specify this option as the first option in the sc command, it
  resets any option specified in the scoptions file. If you specify this
  option after other options or filenames in the sc command, it resets
  the options preceding it, including the filenames.


Saveds
  generates code as if you had defined all functions in the source files
  with the __saveds keyword. The default value is nosaveds.
 The __saveds keyword restores the near data pointer in register
  A4 at each function entry point. You should specify this option if you
  are compiling code that is used as an interrupt routine, called with the
  AddTask function, used in a shared library, or called from another
  process. This option does not work if your code is linked with the
  cres.o or catchres.o startup modules.


ShortIntegers
  enables 16-bit integers. The default value is noshortintegers. The
  minimum acceptable abbreviation is sint.
 If you specify shortintegers, types int and short are the
  same size. If you specify noshortintegers, types int and long
  are the same size. If you are running the assembler, this option
  defines the symbol shortint. This option also defines the
  preprocessor symbol _SHORTINT.

Using Compiler Options 113






SmallCode
tells the linker to merge all code hunks into a single hunk. The
default value is nosmallcode. The minimum acceptable abbreviation
is scode.
  This option is ignored if you do not specify the link option. See
also the description of the smallcode linker option.


SmallData
tells the linker to merge all data and bss sections into a single hunk.
The default value is nosmalldata. The minimum acceptable
abbreviation is sdata.
  This option is ignored if you do not specify the link option. See
also the description of the smalldata linker option.


SourceIs=filename
sets the name of the C source file in the object file and in debugging
information to the specified value instead of the actual name of the C
source file. The minimum acceptable abbreviation is srcis.
  You can use this option if you plan to rename or move the source
file before using the debugger to debug your program. If you are
compiling or assembling exactly one source file, sourceis can
specify the name of the file to be placed into the debug information. If
you are compiling or assembling multiple files, sourceis should
specify a directory name (ending with a forward slash or colon).


StackCheck
 generates stack overflow checking code at each function entry. The
 default value is stackcheck. The minimum acceptable abbreviation
 is stkchk.
  When a program is about to run out of stack space, the program
displays a requestor and terminates gracefully. For a complete
description of the stackcheck option, see Chapter 11, "Using Amiga
Specific Features of the SAS/C Language."


StackExtend
 generates stack extension code at each function entry. The default
 value is nostackext. The minimum acceptable abbreviation is
 stkext.
  When a program runs out of space in the current stack, a new stack
is allocated, and your program continues to run. For a complete
description of the stackext option, see Chapter 11, "Using Amiga
Specific Features of the SAS/C Language."

114 Chapter 8






StandardIO
  specifies the use of __main instead of __tinymain. The default
  value is standardio. The minimum acceptable abbreviation is
  stdio.
 To use __tinymain, specify nostdio. Using __tinymain
  makes your program require less space, but you cannot read from or
  send output to stdin, stdout, and stderr. This option is ignored
  if you do not specify the link option.


StartUp=module-name
  specifies which startup module to use. The default value is c (for
  c.o). The minimum acceptable abbreviation is strt.
 If the module name that you specify does not contain a colon (:),
  forward slash (/), or period (.), the compiler adds lib: to the
  beginning and . o to the end of the name you specify. If you do not
  want to compile with a startup module, specify nostartup. This
  option is ignored if you do not specify the link option.


Strict
  enables a large number of diagnostics dealing with portability and
  questionable situations in your code. The default value is nostrict.
 Specifying strict may produce warning messages for situations
  that are not a problem.
 For more information on improving the portability of your code, see
  Chapter 13, "Writing Portable Code."


StringsConst
  tells the compiler to consider all string constants to be of type
  const char *. The default value is nostringsconst. The
  minimum acceptable abbreviation is strcons .
  If you do not specify stringsconst, the compiler considers string
  constants to be of type char *. If you specify stringsconst,
  passing a string constant to a function that expects the type char *
  generates a warning message indicating that the function may modify
  the string constant.


StringMerge
  merges all identical string constants in the C source file and places all
  strings, all data declared static const, and all auto initializers in
  the code section instead of the data section. The default value is
  nostringmerge. The minimum acceptable abbreviation is strmer.

Using Compiler Options 115




  If you specify stringmerge, the compiler examines each string
constant defined in the code and checks for duplicates. If the compiler
finds a duplicate string constant, it forces both references to refer to
the same memory location.
If you specify stringmerge and you modify a string constant, the
constant is modified in all locations. For example, suppose you have
the following program:


#include <stdio.h>
void modifyme(char *);
void main(void)
{

  modifyme("Hello, World! \n");
  printf("Hello, World ! \n");

}

void modifyme(char *msg)
{
  strcpy(msg, "Foobar\n");

}

If you compile the program with stringmerge, the program prints
Foobar. If you compile the program with nostringmerge, the
program prints Hello, World!.
The stringmerge option has two useful side effects. Because some
data are placed in the code section:

[] Less data needs to be placed into the near data section. If you have
more than 64k of data, you can use the stringmerge option to
try to reduce the amount of data and allow your code to continue to
use the near data model.
[] The string constants are addressed relative to the PC (program
counter) instead of the beginning of the near data section.
Therefore, it is possible to generate programs with no near or far
data.

For more information on the code and near data sections, see
Chapter 12, "How Does the Compiler Work?"

116 Chapter 8






StripDebug
  strips all debugging information from the final executable. The default
  value is nostripdebug. The minimum acceptable abbreviation is
  stripdbg.
 This option is ignored if you do not specify the link option.


StructureEquivalence
  tells the compiler not to issue messages if a pointer to one structure
  type is passed to a function when the function expects a pointer to a
  different type, if the type passed is equivalent to the type expected.
  The default value is nostructureequivalence. The minimum
  acceptable abbreviation is streq.
  For information on using"equivalent structures, see Chapter 11,
  "Using Amiga Specific Features of the SAS/C Language."


To =filename
  is included only for compatibility with the slink command. to is a
  synonym for the programname option. This option does not have a
  negative form.


Trigraph
  specifies whether to use ANSI trigraphs. The default value is
  notrigraph. The minimum acceptable abbreviation is trig.
 Specifying trigraph slows down the compiler.


Underscore
  adds underscores to the beginning of all external names defined in any
  assembler source files assembled. The default value is
  nounderscore. The minimum acceptable abbreviation is uscore.
  The underscores allow you to refer to these names in assembly
  language in the same way you do in C source files. This option is
  ignored if you do not specify any assembly-language files in the sc
  command. For more information, refer to Chapter 11, "Using
  Assembly Language with C Language," in SAS/C Development System
  User's Guide Volume 2.


UnsignedChar
  makes the default type of char variables unsigned instead of
  signed. The default value is nounsignedchar. The minimum
  acceptable abbreviation is uchar. This option defines the preprocessor
  symbol _UNSCHAR.

Using Compiler Options 117





UtilityLibrary
generates inline calls to the AmigaDOS 2.0 ROM-resident library
utility. library to do integer multiplication and division instead
of calling SAS/C library functions to do these operations. The default
value is noutilitylibrary. The minimum acceptable abbreviation
is utillib.
  Specifying utilitylibrary makes your executable smaller and
faster by taking advantage of 68020 instructions if they are available,
but your program runs only under AmigaDOS 2.0. If you link using
the sc command and the utilitylibrary and link options, sc
defines all the SAS/C library integer conversion stub routines to stubs
that call utility. library. This action prevents the SAS/C library
routines that use integer conversion routines from using the SAS/C
versions of the routines. If you link using the slink command, you
need to specify the following def ine linker options:


  define __CXM33=__UCXM33
  define __CXD33=__UCXD33
  define __CXM22=__UCXM22
  define __CXD22=__UCXD22


These define options are in the file LIB:utillib.with, so you
can link with the following command:


  slink with LIB:utillib.with options




Verbose
displays messages about each stage of compiling and linking. The
default value is noverbose.


Version
prints a banner containing the compiler version number and a
copyright message. The default value is version. The minimum
acceptable abbreviation is ver.


Warn=n
enables the specified compiler warning message. The minimum
acceptable abbreviation is wrn. This option does not have a negative
form.
  You can specify a 11 or a to enable all warning messages, or you
can specify one or more message numbers to enable only those

118 Chapter 8




  messages. To specify several message numbers, separate each number
  with a plus (+) sign or a comma (,). You can specify the warn option
  as many times as necessary.
  See also the description of the error and ignore options.


WarnVoidReturn
  issues a warning message if a function declared as returning an
  integer actually returns no value. The default value is
  warnvoidreturn. The minimum acceptable abbreviation is wvret.
  The nowarnvoidreturn option suppresses the return value
  mismatch warning message for functions declared as returning an
  integer, but that do not contain a return statement or that do not
  include an expression in the return statement.


With=filename
  specifies the name of a file containing additional options. The
  additional options are read immediately, as if they were specified in
  the sc command at the position occupied by the with option. Options
  specified after the with option may override options specified in the
  with file. This option does not have a negative form. You can specify
  the with option as many times as necessary.
 Note: Do not confuse this option with the with linker option.


XREF
  is a synonym for the xreference option.


XReference
  produces a cross-reference. The default value is noxreference. The
  minimum acceptable abbreviation is xref.
  The compiler writes the output to the filename you specify with the
  listfile option. If you do not specify an output filename, the
  compiler uses the name of the first source file you specify but with the
  extension.lst.


XReferenceHeaders
  generates a cross-reference of user header files. The default value is
  xreferenceheaders. The minimum acceptable abbreviation is
  xhead.
 This option is ignored if you do not specify the xre f erence
  option.

Using Compiler Options 119






XReferenceSystem
 includes symbols defined in system header files in the cross-reference.
 The default value is xreferencesystem. The minimum acceptable
 abbreviation is xsys.
 This option is ignored if you do not specify the xreference
 option.


Using The compiler automatically defines certain preprocessor symbols each
Preprocessor time you run the compiler, and it defines other symbols only when you
Symbols Defined use specific compiler options.
by the CompilerTable 8.2 lists each of the symbols that the compiler automatically
defines each time you run the compiler.


 Table 8.2
Preprocessor SymbolsSymbolValue
Defined by the_AMIGA1
  Compiler_M680001
 __SASC1
 __SASC_60  1
 __VERSION__6
 __REVISION__  0
 __STDC__1
 __ FILE __ current filename
 __ LINE __ current line number
 __ FUNC __ current function
 __ DATE __ current date
 __ TIME __ current time




 Table 8.3 lists each of these preprocessor symbols defined when you
use specific compiler options and the options that #def ine these
symbols. These symbols are defined to 1 when you specify the
corresponding option. For example, if you specify the noansi option, the
AMIGA symbol is defined as follows:


 #define AMIGA  1

120 Chapter 8




  Table 8.3
 Preprocessor SymbolsSymbolCompiler Options
  Defined by CompilerAMIGA  noansi
OptionsLPTRnoansi and noshortint
SPTRnoansi and shortint
LATTICEnoansi
LATTICE_50 noansi
_M68010cpu=68010|68020|68030|68040
_M68020cpu=68020|68030|68040
_M68030cpu=68030|68040
_M68040cpu=68040
_M68881math=68881
_FFPmath=FFP
_IEEE  math=IEEE
_SHORTINT  shortint
_UNSCHARunschar
_PPONLYpponly
_GENPROTO  genproto
_MGST  makegst
_GSTgst



Linking Your Program

As described in Chapter 2, "Using Your SAS/C Development System,"
you can link your program from the Shell by specifying the link option
in the sc command or from the Workbench screen by specifying the
link option in your scoptions file and double-clicking on the Build
icon.
  You can also compile and link your program in separate steps. If you
do not specify the link option on the sc command line, you need to call
the linker, slink, to link your program. Use the slink command only
if you are limited by the s c command. For the majority of programs,
linking with the sc command is much simpler and easier than linking
with the slink command. If you link using the sc command, you can
specify linker options with the linkeropt compiler option.

Using Compiler Options 121




Entering  The After you have compiled your program, you can enter the slink
slink Command  command as follows:
slink object-files [options]

You must specify at least one object file. You probably also need to
specify a startup module and one or more libraries.


Specifying Linker  The slink command accepts the following options:
Options
addsym
  generates hunk_symbol records for all externally-visible symbols in
  each object file and library module whether or not the object file was
  compiled with the debug compiler option. This option gives
  CodeProbe the location, but not the size or type, of any externally
  visible symbols in your program.

batch
sets the value of all undefined data symbols to 0 and all undefined
code symbols to _ _ _ stub. Normally, slink asks you to enter a
value for each undefined symbol. However, if you specify batch,
slink does not prompt you to enter values for undefined symbols.
If an undefined function is called, the library function _ _ stub
(_ _ _stub to the linker) is called instead. The library's version of
 _ _ stub displays a requester telling you that an undefined routine
 was called and allows you to choose whether to abort or continue.

bufsize n
sets the I/O buffer size for slink. By default, slink buffers all
object modules. Buffering requires more memory but reduces the time
required to link your program. If you run out of memory while
linking, try linking with bufsize 4096. This specification tells
slink to buffer only one file at a time and to use a buffer size of
4096 bytes.

 chip
specifies that all hunks are to be placed in chip memory regardless of
the input object hunk specifications. However, if you specify f a st or
chip for the datamem, codemem, or bssmem compiler options, that
value overrides this option.
  The chip option is provided for compatibility with previous
versions of the linker. It is recommended that you use the datamem,
codemem, and bssmem compiler options instead.

define symbol[=value]
defines a symbol to be used in the linking process. You can use this
option with the prelink option to force specific routines from the

122 Chapter 8




  libraries to be linked into your program even though your program
  does not contain any references to the routines.
 Remember that linker symbols have an extra underscore added to
  the beginning of the symbol name. To refer to a function f oo using
  the define option, you must specify _foo. To refer to registerized
  functions, add an at (@) sign to the beginning of the symbol name, as
  in @foo.
 Note: Do not confuse this option with the define compiler
  option.

fancy
  enters control characters to highlight and bold headings in the map
  file. The option is on by default. To disable the use of these control
  characters, specify the plain option. fancy is ignored if you do not
  specify the map option.

fast
  specifies that all hunks are to be placed in fast or expansion memory
  regardless of the input object hunk specifications. However, if you
  specify fast or chip for the datamem, codemem, or bssmem
  compiler options, that value overrides this option.
 The fast option is provided for compatibility with previous
  versions of the linker. It is recommended that you use the datamem,
  codemem, and bssmem compiler options instead.

faster
  is included only for compatibility with the Commodore linker, alink.

from object-filename(s)
  identifies the object files that are the primary input to the linker. You
  can specify the from option as many times as necessary in the slink
  command. If you specify the object files as the first items in the
  slink command, you do not need to use the from option. The root
  option is a synonym for this option.
 The object files are copied to the root of the object module. You
  must specify at least one object file in the slink command.

fwidth n
  specifies the filename width, in columns, in the map file. The default
  value is 16. This option is ignored if you do not specify the map
  option.

height n
  specifies the total number of lines on a page in a map file. If you
  specify 0, the linker does not add form feed characters to the file. The
  default value is 55. This option is ignored if you do not specify the
  map option.

  Specifying Linker Options 123




hwidth n
specifies the hunk name field width, in columns, in the map file. The
default value is 8. This option is ignored if you do not specify the map
option.

indent n
specifies the number of columns to indent on a line in the map file.
The map file is indented n columns from the value specified by the
width option. The default value is 0. This option is ignored if you do
not specify the map option.

libfd filename
specifies the name of a function description ( . fd) file. Use this option
only if you are building a shared library.
  For information on creating shared libraries, refer to SAS/C
Development System Library Reference.

libprefix prefix
specifies the prefix you want added to the functions listed in the
function description ( .fd) file. The default prefix is an underscore ( _ ).
Use this option only if you are building a shared library. The
libpref ix option allows the library to call entry points within itself,
without using the library base.
  Make sure that the function declarations in your source code match
the full name, including any specified prefix. For example, suppose
your library has a function called myfunc. Your . fd file contains the
following line:


myfunc(a)(dO)


If you specify a prefix of _ LIB, you should declare the function in
your source code as LIBmyfunc, as shown in the following example:


#pragma mylibbase myfunc 1e OOl


__asm LIBmyfunc(register __d int a)

{
 return a+l;
}


void test(void)
{

  LIBmyfunc(l); /* Call myfunc directly. */
  myfunc(2);/* Call myfunc through the library base. */
}

124 Chapter 8




 For information on creating shared libraries, refer to SAS/C
  Development System Library Reference.

library link-library-filename(s)
  specifies the library files that you want the linker to search for
  modules referenced in your code. Only referenced modules from
  library files are included in the final executable module. You can
  abbreviate this option as lib.

librevision n
  specifies a minor revision number of the library you are creating. If
  you do not specify a revision number, it defaults to 0. Use this option
  only if you are building a shared library.
 For information on creating shared libraries, refer to SAS/C
  Development System Library Reference.

libversion n
  sets the version number of the library you are creating. You can set
  the version number to any number from 0 to 255. The default is 1.
  Use this option only if you are building a shared library.
 For information on creating shared libraries, refer to SAS/C
  Development System Library Reference.

map [mapfile [map-option[,]map-optlon...]]
  tells slink to create a map file. The map file contains information on
  the size and location of all hunks and the value of all symbols.
 If you do not specify a mapfile, the linker writes the map
  information to the file executable.map. If you specify a mapfile,
  you can also specify the following map file options:
f  lists the hunks in each file
h  lists hunks by size and originating function
l  lists hunks by library function
o lists hunks in each overlay
s lists where symbols are defined
x creates a symbol cross-reference that lists where the symbols are
  defined and their definition.

maxhunk n
  limits to n bytes the size of the hunks that slink creates when
  merging hunks. By default, there is no limit on hunk size.

noalvs
  issues warning messages if slink generates an automatic link vector
  (ALV) instruction to resolve 16-bit program counter-relative
  references. Using this option stops slink from creating a non-
  relocatable module from what was intended to be relocatable code.

  Specifying Linker Options 125




nodebug
is included for compatibility with previous release of the linker. Use
the stripdebug option instead. You can abbreviate this option as
nd.

onedata
tells the linker to merge all data, bss, and chip sections. Merging
hunks may decrease the time required to load your program but may
produce larger hunks that are difficult to scatter load.

overlay
identifies the start of an overlay tree. You should enter the overlay
option and the list of files in each overlay in a with file, as follows:

overlay
overlay-1-filename(s)
*overlay-2-filename(s)
.
.
.
#

You must terminate the overlay tree with a line consisting of a single
pound (#) sign. For more information, see " Using Overlays," later in
this chapter. See also the description of the with option.

ovlymgr filename
tells slink to use the filename you specify as the overlay manager
instead of the default filename, ovs .o, which is contained in the
libraries. The file you specify should consist of a single code hunk
named NTRYHUNK and define the global symbol _ ovlyMgr.

prelink
tells slink to produce an object module with symbol references and
definitions still intact. You can then link with this object module to
produce an executable module. This option is useful if you are
developing a large application and changing only a single source
module. Do not specify this option if you are using overlays.

plain
turns off the fancy option. This option tells the linker not to enter
control characters for highlighting and bold in the map file. This
option is ignored if you do not specify the map option.

pwidth n
specifies the width of program unit name field in the map file. The
default value is 8. This option is ignored if you do not specify the map
option.

126 Chapter 8




quiet
  suppresses all linker messages except error messages.

root object-filename(s)
  specifies the object files that are the primary input to the linker. These
  object files are always copied to the root of the object module. You
  must specify at least one object file for the root. If the primary input
  files appear as the first option to slink, then the root keyword is
  optional and may be omitted. The from option is a synonym for
  root. You can specify the root option more than once. The files you
  specify with root are added to the list of files to be linked.

swidth n
  specifies the width of the symbol names field in the map file. Default
  value is 8. This option is ignored if you do not specify the map option.

smallcode
  tells the linker to merge all code hunks. You can abbreviate this
  option as sc.

smalldata
  tells the linker to merge all data and bss sections. Merging hunks
  may decrease the time required to load your program, but may
  produce larger hunks that are difficult to scatter load. You can
  abbreviate this option as sd. The smalldata option does not merge
  chip data with non-chip data. To merge chip data also, specify the
  onedata option instead.

stripdebug
  suppresses any H_DEBUG and H_SYMBOL debug information in the
  final executable file.

to filename
  specifies the name of the final executable module. If you do not specify
  a to filename, the linker uses the filename of the second object
  module listed with the from option but drops any file extension. The
  first module is assumed to be startup code.

verbose
  prints the names of each file as the file is processed.

verify filename
  specifies a file to which you want the linker to write all messages. If
  you do not specify the verify option, the linker writes all messages
  to stdout. You can abbreviate this option as ver.

width n
  sets the maximum line length for the map and cross reference listing
  files. The default value is 80. This option is ignored if you do not
  specify the map option.

  Specifying Linker Options 127




with filename
 specifies a file containing slink options. The linker processes the
 contents of with files as if you had specified the option in the slink
 command. You can specify the with option as many times as
 necessary. Also, you can enter with options in a with file.
  The following is an example with file.


from lib:c.o vtl00.o init.o window.o xmodem.o remote.o
  kermit.o script.o
  library lib:sc.lib lib:amiga.lib
  verbose
  smallcode
  smalldata
  to vtl00


  Note: Do not confuse this option with the with compiler option.

xref filename
specifies a file to which you want the linker to write cross reference
information. If you do not specify xref, but you specify the map
option, the linker writes the cross reference information in the map
file.
  Note: Do not confuse this option with the xref compiler option.


Using Overlays

Overlays are intended primarily for large applications (l00k or more)
that must run in a small amount of memory and leave more room for
data. Overlays are groups of functions (and the data they require) that
reside in memory only while in use. When the group in memory is no
longer needed, the overlay manager reclaims the memory used by this
group and loads in the next group of functions (and data).
Before deciding to use overlays, consider using multiple shared
libraries instead. If memory is tight, the AmigaDOS system removes
unused shared libraries, thereby giving you some of the benefits of
overlays. On systems with more memory, the AmigaDOS system allows
shared libraries to remain resident, which improves performance. Use
overlays only in very tight memory situations.
The overlays are organized into an overlay tree. The overlay tree
consists of a root node, which is always resident in memory, and one or
more overlays. Figure 8.1 shows an example overlay tree.

128 Chapter 8



 Figure 8.1root
An Example Overlay  .-------|---------------.
Tree  | |
 overlay1overlay2
 |
 .-----------|-----------.
 | |
overlay3overlay4
 |
overlay5



erlays at the same level in the tree are mutually exclusive. In this
ample tree, the functions in overlays 1 and 2 are mutually exclusive,
d the functions in overlays 3 and 4 are mutually exclusive. If any
nction in overlay 1 is running, overlay 2 cannot be loaded. However, if
ur program calls a function that is in overlay 2, the overlay manager
claims the memory occupied by overlay 1 and loads overlay 2. Then, if
ur program calls a function in overlay 3, the overlay manager loads
erlay 3. If overlay 3 is loaded, overlay 5 can be loaded if necessary,
t overlay 4 cannot be loaded.
A function in an overlay can call functions in only certain other
erlays. For example, a function in overlay 3 can call a function in
erlays 5 and 2 and in the root node. The following list shows which
nctions the functions in each overlay of the example tree can call.



  Functions
  in.........Can call functions in
  rootcan call functions in overlays 1 and 2
  1can call functions in the root node
  2can call functions in the root node and overlays 3 and 4
  3can call functions in the root node and overlays 2 and 5
  4can call functions in the root node and overlay 2
  5can call functions in the root node and overlays 2 and 3.




As you can see, applications best suited to overlays are those that are
  modular and have a definite calling hierarchy among the functions.
You must determine which functions should be in each overlay. Decide
  which functions can operate independently of others. The root node must

Compiling and Linking Your Program 129




contain your main program and should contain any functions that are
called frequently or by many other functions in the program. The root
node usually contains the libraries also. In general, the more frequently
you call a function, the closer it should be to the root node.
  You can have up to 50 overlays. Your tree could have all overlays
hanging from the root node, or your tree could be organized as one long
chain of overlays. Organize the overlays of your tree efflciently; that is,
according to the calling hierarchy of your program. If you create an
inefficient tree, your program may not run efficiently because the overlays
will have to be swapped more often. If you create an incorrect tree,
slink issues a warning message.
  To use overlays, you should enter the overlay option and the overlay
filenames in a with file, as follows:

overlay
overlay-1-filenames
*overlay-2-filenames







List the filenames for each overlay on a separate line, and separate the
filenames with plus ( + ) signs. If you cannot fit all of the filenames on one
line, end the line with a plus sign, and enter the remaining filenames on
the next line. Indicate the depth in the tree of the overlay by entering the
appropriate number of asterisks at the beginning of the line. The overlays
immediately beneath the root node are at depth 1, but you should not list
them with asterisks. For overlays at depth 2, begin the line(s) with one
asterisk; for overlays at depth 3, begin the line(s) with two asterisks, and
so on. Enter an overlay immediately after the overlay to which it is
subordinate. Terminate the overlay tree with a line consisting of a single
pound (#) sign.
  For example, Figure 8.2 shows the same overlay tree as in Figure 8.1,
but figure 8.2 shows which object files comprise each overlay.

130 Chapter 8



Figure 8.2  root node  __________
Example Overlay Tree| |
with Filenames|  main  |
  \________/
 |
  _____/\______
 /\
_____|________|_____
 overlay1  | || | overlay2
|beech.o || ash.o  |
|maple.o |\________/
\________/ |
  _____________/\____ 
 /  \
_______|____  ________|_________
overlay3 ||  |  |  overlay4
|  fir.o|  | sweetgum.o  |
|  pine.o  |  |  pecan.o |
\__________/\______________/
______|_____
overlay5 ||
|  birch.o |
\__________/




  The with file for the example in Figure 8.2 looks like this:
  
  overlay
  beech.o+maple.o
  ash.o
  *fir.o+pine.o
  **birch.o
  *sweetgum.o+pecan.o
  #


 Suppose you have three files: hw.c, hello.c, and world.c. The file
 hw.c contains the following functions:


  #include <stdio.h>
  int main(void)
  {

Hello(void);
World(void);
return(O);
  }
 
Compiling and Linking Your Program 131




void SayWord ( s )
char *s;
{
printf ("%s", s);
}


The file hello.c contains only one function:


void Hello ( void )

{
SayWord("\nHello, " );
}


world.c also contains only one function:


 void World ( void )

 {
SayWord("World! \n");
 }


After you compiled these three files, you have the three object files hw.o,
hello.o, and world.o. To link this application, you can create a with
file that contains all of the link options you need, including overlay
specifications.


from lib:c.o hw.o
overlay
hello . o
world . o
#
library lib:sc.lib lib:amiga.lib
map fhlosx
to hw


slink evaluates the with file, creates an executable module named hw,
and creates a map file named hw.map. The executable module consists of
a root node and two overlays. The root node contains all of the code and
data for c.o, hw.o, sc.lib, and amiga.lib. One overlay contains
the code and data for hello.o, and the other overlay contains the code
and data for world.o. Figure 8.3 shows the overlay tree for this
application.

132 Chapter 8



  Figure 8.3  ____________
Overlay Tree for hw | c.o  |
 | hw.o |
 |sc.lib|
 | amiga.lib  |
  \__________/
________|___________
_____|__________|____
| hello.c  | |world.c |
|__________| |___________|




You can run this application in the same way you run an application
that does not use overlays. The overlay manager loads overlays as
necessary.


Specifying Using overlays modifies the behavior of some compiler options. The
Compiler Options following list describes each of the options affected by overlays.
with Overlays
data=near
places all data not declared with __ far or __ chip in the near
data section. If you are using overlays, the near data segments of all
files compiled with data=near are moved to the root node.
Therefore, you cannot statically initialize near data items into code
hunks that are not in the root node. For example, you cannot initialize
a character pointer to a constant string in an overlay node if you
specify the stringmerge option.

smallcode
 merges all code hunks into a single hunk. If you are using overlays
 and you specify smallcode, slink merges as much of the code as
 possible without crossing overlay boundaries. The linker does not
 move code out of the overlay in which it was defined.

smalldata
 merges all data and bss hunks into a single hunk. The near data
 section is always placed in the root node. However, sl i nk does not
 merge hunks that are in overlays that are not named __MERGED into
 the near data section.

stringmerge
 places string constants into the code section, and the strings
 themselves are overlaid if the module they are used in is overlaid.
 Therefore, the value of the string constant may change as its overlay
 node is swapped out. For example, a function may return a string

  Compiling and Linking Your Program 133




constant or assign it to an external variable. It is recommended that
you do not compile with stringmerge if you are using overlays.


Customizing theFor some applications, you may want to replace the overlay manager with
Overlay Managera custom overlay manager. For example, you can write an overlay
 manager to support function calls across mutually exclusive overlays. This
 section describes the necessary attributes of an overlay manager.
The overlay manager must contain one code hunk named NTRYHUNK
 and define the global symbol _ ovlyMgr.


 section NTRYHUNK,code
 xdefovlyMgr


First:
 bra FirstModule


 ovlyMqr:


 ;Overlay manager code goes here.



 FirstModule:
leaFirst(PC),a3  ; pointer to start of module
move.l-4(a3),d7  ; BPTR to next seglist entry
asl.l t4,d7  ; make into APTR
move.ld7,a3
jmp4(a3)  ; jump to code in next hunk


Assemble this code with the -u assembler option so that the assembler
 adds the necessary underscores to all global symbols.
The linker makes NTRYHUNK the first hunk in the executable and does
 not merge this hunk with any other hunks. Therefore, NTRYHUNK must
 also contain a valid entry point to the program and properly transfer
 control to the rest of the program. The first instruction in the preceding
 code branches to the symbol FirstModule, where the seglist is
 decoded, and a jump instruction transfers control to the next hunk in the
 segment list.
For more information, examine the file ovs.a in the source
 directory. This file contains the source to the default overlay manager.

134

135





9 Running Your Program from
the Workbench Screen


135 Introductlon
135 Working with argc and argv
 135 Running From the Shell
 136 Running From the Workbench Screen
137 Managing the Standard I/O Window
 137 Eliminating the Window
 137 Changing the Window Attributes




 Introduction

 If you run your program by double-clicking its icon from the Workbench
 screen, your program runs under a different environment than programs
 that are run from the Shell. Specifically:

 [] If not handled correctly, the command line arguments argc and argv
receive different values that may cause unwary programs to crash.
 [] If your program uses stdin, stdout, or stderr, the library routine
__main opens a console window to which your program writes
output and from which it reads input.

 The following sections describe how to manage these unusual situations.



 Working with argc and argv

 Programs that run from the Workbench screen receive a different
 environment than those run from the Shell. The following sections
 describe the different environments.

Running From the  If you run your program from the Shell, your program receives two
 Shell  arguments, argc and argv. argc is an integer guaranteed to have a
 value of at least 1. Unless you modify __main as described in
 Chapter 10, "Using Startup Modules, Autoinitialization, and

136 Chapter 9




 Autotermination Functions," argv is an array of 32 character pointers
 that point to the different items on the command line:

 argv[0]
is a pointer to the name of the command that was executed.

 argv[1] to argv[nl
are pointers to the arguments entered after the command. The number
n represents the number of arguments specified. The maximum
number of arguments is 30.

 argv[n+1] to argv[31]
are NULL.


Running From the  If you run your program from the Workbench screen, the startup code
Workbench  sets up argv and argc in a different way than if your program is run
Screen  from the Shell. argc is set to O (zero) to give you a quick way to check
 in your program if you are running from the Workbench screen, and
 argv is a pointer to a struct WBStartup instead of an array of
 character pointers. The definition of struct WBStartup is in the
 header file workbench/startup.h.
To eliminate any problems caused by running your program from the
 Workbench environment, structure your program as follows:


int main(int argc, char *argv[1])

{
 struct WBStartup *startup;
 if(argc == O)
 {

/* The program was started from the Workbench.  */
/* Use the WBStartup message instead of argc and argv. */
  startup = (struct WBStartup *)argv;
  ...
}
else
{


  /* The program was started from the Shell. */
  /* Use argc and argv as usual.*/
  ...
}
}



For more information on main, refer to SAS/C Development System
 Library Reference, Version 6.0.

Running Your Program from the Workbench 137




 Managing the Standard I/O Window

 When you run a program from the Workbench screen, the compiler
 opens a standard I/O window in which your program can read from and
 write to stdin, stdout, and stderr. You can delete the window,
 change its size, or add a title.
 The window is opened by the library routine __main, which is
 automatically run before your main routine if you link with a startup
 module.


Eliminating theIf your application does not use stdin, stdout, or stderr, you can
  Windowuse an alternate routine that does not open the window:

 [] You can use the alternate routine __tinymain. If you link your
program using the link compiler option, specify the nostdio option
to delete the window. If you run the linker by specifying the slink
command, specify the define linker option as follows:


 define ___main=___tinymain


Use this define option regardless of any other compiler options you
are using. This option works even if you are using registerized
parameters.
[] You can write your own routine.
You can copy main.c from the sc: source directory and modify it
for your application.


>>  Caution Your program may crash.
If you attempt to use any function that refers to stdin, stdout, or
stderr in a program run from the Workbench screen after deleting the
standard I/O window, your program will crash. Such functions include
printf and scanf (but not fprintf or fscanf).


Changing the  To keep the window but change its attributes you need to declare the
  Window  external variable __ stdiowin in your program. Normally, __main
 Attributes  gets the definition of __ stdiowin from the library with which you link
your program. However, if you declare __ stdiowin in your program,
__main uses the definition in your program.
This variable is declared in the SAS/C Libraries as follows:


char __stdiowin[]= "CON:10/10/320/80/";

138 Chapter 9




  This specification opens a console window starting at location (10,10)
that is 320 pixels wide and 80 pixels high. For more information on
console specifications, refer to The AmigaDOS Manual, 3rd Edition
(Commodore-Amiga, Inc. 1991).
  To change the window attributes, include a line similar to the previous
line in any C source file in your project. Declare this variable external to
any function, and be sure to statically initialize the variable. (Any changes
made to this external variable after your program starts do not affect the
window.) For example, to make the initial window 600 pixels wide and
100 pixels tall and add a window title of "My Window," you would enter
the following line:


  char __stdiowin[]= "CON:10/10/600/100/My Window";


  If you are running under AmigaDOS 2.0, __main appends the
contents of the array __stdiov37 to the __stdiowin variable before
opening the window. This array contains keywords that control other
aspects of the window and is defined in the SAS/C Libraries as follows:


char __stdiov37[]= "/AUTO/CLOSE/WAIT";


These keywords do the following to your startup window:

  /AUTO  indicates that you do not want the window to open unless
  output is written to or input is read from the window.

 /CLOSE  adds a Close gadget to the window.

  /WAIT  specifies that you do not want the window to close until the
  user clicks on the Close gadget or presses Ctrl-\ (End-of-File).

  For more information on CON: keywords, refer to The AmigaDOS
Manual, 3rd Edition (Commodore-Amiga, Inc. 1991).
  To change these keywords or add additional AmigaDOS 2.0 keywords,
include a line similar to the previous line in any C source file in your
project. Declare this variable external to any function, and be sure to
statically initialize the variable. (Any changes made to this external
variable after your program starts do not affect the window.) The
keywords you specify are appended to __stdiowin only if your
program is running under AmigaDOS 2.0. If your program is run under
earlier versions of the AmigaDOS operating system, you get a normal
console window.
  Note: You must declare _ _ stdiowin and _ _ stdiov37 as external
variables exactly as shown. Do not declare them as follows:
  char *__stdiowin = "specification"; /* WRONG! */

139





  10 Using Startup Modules,
 Autoinitialization, and
 Autotermination Functions


 139 Introduction
 140 Understanding Startup Modules
 140 Modifying__main
 141 Linking with a Startup Module
  142 Creating Standard Programs
  142 Creating Detachable (Load and Stay Resident) Programs
  143 Creating Residentable Programs
  144 Creating Shared Libraries
 145 Writing Applications without a Startup Module
 145 Using Autoinitialization and Autotermination Functions
 147 Initializing System Library Bases




 Introduction

 This chapter describes how to use startup modules, autoinitialization
 functions, and autotermination functions. Specifically, it describes the
 following:

 [] the function of a startup module
 [] how to link your program with a startup module
 [] how to use the startup modules distributed with the SAS/C
 Development System
 [] how to write a program that does not use a startup module
 [] how to specify autoinitialization and autotermination functions.

140 Chapter 10




Understanding Startup Modules

A startup module initializes the environment in which your program runs
and performs certain cleanup tasks after your program has finished
running. The SAS/C Development System provides six startup modules:

  c.o  is for use with standard programs.
cres.o  is for use with residentable programs.
  cback.o  is for use with detachable programs.
  catch.o  is for use when you are debugging standard programs.
  catchres.o  is for use when you are debugging residentable
programs.

The specific things that the startup module does depends on the startup
module with which you link your program and on whether you run your
program from the Shell or the Workbench screen. However, all startup
modules perform some of the same tasks. For example, each startup
module does the following:

[] initializes the near BSS section.
[] gets startup information from the Workbench screen (if invoked from
the Workbench screen).
[] initializes DOSBase and SysBase.
[] marks the bottom of the stack.
[] calls __fpinit, which looks for autoinitialization functions.
[] calls __main, which calls your program. If your program requires
more than 30 command line arguments, you need to modify the default
__main function as described under "Modifying __main."
calls __fpterm, which also looks for autotermination functions.



Modifying __main

The default __main function must convert the incoming command line
to the (argc, argv) format required by the ANSI Standard. __main
performs this conversion by using a local array with 32 elements to
represent argv. One element is used for the program name, and the
ANSI Standard requires at least one NULL element at the end. Therefore,
you are limited to 30 arguments on the command line of your program.
If you need more arguments on the command line, you have two choices:

[] If you only want to raise the argument limit, copy
sc: source/ _main.c to your project directory. Change the
#define statement for the symbol MAXARG to the new maximum
number of arguments. Then, recompile _main.c and link it into your
program.

Using Startup Modules 141




[] If you need an unlimited number of arguments, copy
sc:source/_main.c to your project directory. Modify the source
code to allocate an array of pointers to use for argv. Make sure you
use the malloc or calloc function to allocate the memory. These
functions will free the memory correctly when your program exits.



Linking with a Startup Module

To use a startup module, you must link your program with it. You can
link your program by using the link option on the sc command or by
entering the slink command.
You can specify the link and, if necessary, the startup option on
the sc command line. If you specify only the link option, sc tells the
linker to link your program with c.o. If you want to link with another
startup module, specify the module name with the startup option. If
the module name that you specify does not contain a colon (:), forward
slash (/), or period (.), sc adds the LIB: prefix and .o extension to the
filename that you specify. For example, to link with cres.o, you can
enter the sc command as follows:

sc startup=cres linkC-source-file


  To specify a startup module with the slink command, enter the
slink command in the following format:


slink startup-module+obj-module to executable
lib library-files


  To use some startup modules, you need to declare certain variables in
your program. The following sections describe how to use startup
modules for the type of program you want to run.
  Programs linked with any startup module except cback.o run under
the process in which they were invoked. When you enter the name of an
executable module at the Shell prompt, that program runs in that Shell's
process and uses the Shell's process number and stack (unless you specify
a value for __stack and the Shell's stack is smaller than the specified
value). Therefore, you cannot enter commands into or close the Shell
from which the program was invoked until the program finishes running.
Note: Even if you use the run command to run the program, you
cannot close the window from which the program is run unless you
redirect the input and output as in the following example:
run >nil: <nil: program-name

142 Chapter 10




  Creating  For most of your programs, you can use the default startup module, c . o.
  Standard  If you are debugging a standard program, you can use the catch . o
  Programs  startup module to capture information if your program terminates
  abnormally. If you link with catch . o and your program terminates
  abnormally, catch . o asks you if you want to create a snapshot file. A
  snapshot file contains traceback information for your program such as
  register values, symbol cross references, and stack information.


>> Caution  Creating this snapshot file may corrupt your hard drive.
Do not ship commercial products linked with catch.o.


You can use the tb utility to process this snapshot file and display the
traceback information. For more information about processing snapshot
files, refer to the description of the tb utility in SAS/C Development
System User's Guide, Volume 2: Debugger, Utilities, Assembler,
Version 6.0.


 CreatingA detachable program is a program that runs in the background. It does
Detachable (Loadnot run as part of the originating Shell's process. You can continue to
 and Stayenter commands into, or even close, the Shell from which the program
Resident)was started without affecting the program.
ProgramsYou can use the startup module cback.o to create detachable
  programs. When you link with cback.o, your program allocates a new
  stack and launches itself as a new process. For an example of a program
  that links with cback.o, see the directory sc:examples/cback.
You should use cback.o for any program that:

[] does not send output to the Shell from which it was invoked (except an
 initial banner)
[] needs to be memory resident.

To use cback.o, you add the following external definitions to your
main program if your program requires values other than the defaults:

long __stack = amount;
 allocates stack space for the created task. Many detachable programs
 only need a stack size of 4000 bytes (the default). However, you can
 change this figure to suit your application.

char *__procname ="program-name";
 specifies the name of the process to be created. The default value is
 Background_Process.

long __priority = priority;
 sets the priority of the process to be created. For most programs, you
 should set the task priority to 0, which is the default. However, you
 can change this figure to suit your application.

Using Startup Modules 143




long __BackGroundIO = value;
indicates whether output will be sent to the Shell from which the
program was invoked. The default value is 0, which tells cback.o
that no output is sent to the originating Shell. Setting this value to 1
tells cback.o to set _ Backstdout to point to the Shell.

extern BPTR _Backstdout;
contains the file handle of the originating Shell (if __ BackGroundIO
was set to 1).

  _ Backstdout is an AmigaDOS file handle and, therefore, you must
use the AmigaDOS function Write instead of the SAS/C functions such
as write or fprintf to write to this file.
You must close this file with the AmigaDOS Close function when you
have finished writing to the Shell window. If you do not close
_ Backstdout, the originating Shell cannot close.
  If your program creates a resident task that needs to print messages in
the Shell, your program should pass _ Backstdout to this task.
  If the _ Backstdout file handle is NULL, your program cannot send
output to the window. The handle may be NULL if the program was
invoked from the Workbench screen or from another program that did
not have a Shell open.
  If you want to make sure that only one copy of your program is
running in the background, have your program create a global message
port with an unique name. Subsequent invocations of your program
should use the exec function FindPort to see if the port exists and, if
the port exists, pass any commands to the running program through the
message port and exit immediately. See the directory
sc:examples/cback for sample code.
Programs linked with cback.o cannot be made resident with the
AmigaDOS resident command.


 Creating  A resident program is a program that remains loaded in RAM. You do not
Residentable  have to reload a resident program each time you want to run it.
 Programs  To create a resident program, follow these rules:

[] Compile with the data=near option (the default).
[] Make sure that all external data declared with the __far or __chip
keywords are read-only.
[] Use #pragma statements instead of the linker stubs in amiga . lib
when possible because amiga.lib uses absolute addressing. If
required, you can link with amiga . lib if the linker does not generate
any warnings about references to absolute data.
[] Link your program with cres.o instead of c.o.
[] Use the AmigaDOS resident command to add the program to the
resident list maintained by the Shell.

144 Chapter 10





A resident program must be re entrant and re-executable, and it cannot
write to far data. For each invocation of a resident program, cres.o
copies the near data section, so the program can read and write to near
data. If you link your program with cres.o and your program refers to
f ar or chip data, the linker issues warnings. If your program reads this
data only, you can ignore the warnings.
You cannot use the __saveds keyword or compile with the saveds
option if you link with cres.o.
Each time the program is run, a new near data segment is created,
initialized data are copied into the new segment, and relocations are
performed inside the segment. When the program finishes, the segment is
released.
slink creates the following symbols when you link your program:

_LinkerDB  points to the near data section.

  RESBASE  specifies the offset of _ LinkerDB in the near data
section (0 or 0x8000).

RESLEN  specifies the total number of bytes of initialized and BSS
data.

 NEWDATAL  specifies the number of longwords of initialized data.

For more information about resident programs, refer to the description
of the AmigaDOS resident command in Using the System Software
(Commodore-Amiga, Inc. 1990) or see the example in
sc:examples/cres.
If you are debugging a residentable program, you can use the
catchres.o startup module to capture information if your program
terminates abnormally. If you link with catchres.o and your program
terminates abnormally, catchres.o asks you if you want to create a
snapshot file. A snapshot file contains traceback information for your
program such as register values, symbol cross references, and stack
information.


 >> Caution Creating this snapshot file may corrupt your hard drive.
Do not ship commercial products linked with catchres.o.


You can use the tb utility to process this snapshot file and display the
traceback information. For more information about processing snapshot
files, refer to the description of the tb utility in SAS/C Development
System User's Guide, Volume 2.

Creating SharedYou can use the modules libent.o, libinit.o, and libinitr.o to
  Librariescreate shared libraries. For information on creating shared libraries,
refer to SAS/C Development System Library Reference, Version 6.0.

Using Startup Modules 145




Writing Applications without a Startup
Module

If you do not want to link your program with a startup module, follow
these guidelines when writing and compiling your program:

[] Your program must initialize DOSBase and SysBase, if your
program makes any calls to dos.library and exec.library,
respectively. For additional information, see "Initializing System
Library Bases," later in this chapter.
[] Do not use any SAS/C I/O functions such as fopen, read, printf,
and so on.
[] Add the _ _ saveds keyword to the first function in the first object
module in your program.
[] Compile your program with the nostackcheck option.
[] Be aware that the uninitialized near data are not initialized to 0.
[] Register A0 points to the command line entered by the user. You can
parse the arguments from A0 or, under AmigaDOS 2.0, call
ReadArgs to get the arguments.
[] Your program will start executing at the first function in the first
module specified on your slink or sc command line. This function
should be declared with the _ _ saveds keyword.
[] Unless you write code to reply to the Workbench startup message, your
program will not run from the Workbench screen without crashing the
machine.

For an example, see sc:examples/nostartup.



Using Autoinitialization and Autotermination
Functions

If you link with one of the startup modules provided by the SAS/C
Development System, you can designate functions to be called before your
program starts (autoinitialization functions) and after it terminates
(autotermination functions).
To designate an autoinitialization function, begin the function name
with _ STI. To designate an autotermination function, begin the function
name with _ STD. The linker searches the functions defined in your
program for functions whose names start with the _ STI or _ STD. All
functions starting with _ STI are assumed to be autoinitialization
functions and are called from the startup code before _ _ main is called.
All functions starting with _ STD are assumed to be autotermination
functions and are called after your program exits.

146 Chapter 10




  Autoinitialization and autotermination functions take no parameters and
return no values, as shown in the following example:
  void _STImyinit(void)

  {
.
/* your code here */
.
  }

  void _STDmyterm(void)
  {
 .
 /* your code here */
 .
  }


  If the linker finds at least one autoinitialization function, it creates an
array of function pointers containing one pointer for each
autoinitialization function. The array is named _ _ ctors (for
"constructors"), and its last entry is always NULL. The __ fpinit
function looks through this array and calls each autoinitialization function
before calling _ _ main.
  Similarly, if the linker finds at least one autotermination function, it
creates an array of function pointers called__ dtors (for "destructors")
containing one pointer for each autotermination function. The array's last
entry is always NULL. The _ _ fpterm function looks through this array
and calls each autotermination function after your program exits.
  The following figure shows the order in which modules are called when
you run your program.

Using Startup Modules 147



Figure 10.1Startup module
  Startup Modules,____________________
Autoinitialization  || __________________________________________
 Functions, and  |  Call __fpinit ----|-->| Set up for floating-point operations  |
Autotermination  ||| Call the funtion in __ctors  |
  Functions  |||__________________________________________|
|| __________________________________________
|  Call __main ------|-->| Initialize file I/O|
||| Call main (your program)|
||| Cleanup file I/O |
|||__________________________________________|
|| __________________________________________
|  Call __fpterm ----|-->| Cleanup from floating point operations|
||| Call the functions in __dtors  |
|||__________________________________________|
|| __________________________________________
| Call _MemCleanup --|-->| Free heap memory |
|____________________||__________________________________________|




  If slink does not find any autoinitialization or autotermination
functions, it substitutes a longword zero for any references to __ctors
or __dtors. If you write your own startup module, check that
__ctors and __dtors are not NULL before accessing the array.
  Do not use level 1 or 2 I/O functions (such as fopen and open) in
your autoinitialization functions because they have not yet been
initialized. However, you can use AmigaDOS I/O functions (such as
Open). Similarly, you cannot use level 1 and 2 I/O functions in your
autotermination functions because all level 1 and 2 files have already
been closed.
  You can use the ANSI standard memory allocation routines (such as
malloc, free, and calloc) in autoinitialization and autotermination
functions. All memory allocated with these routines and not yet freed in
your program is still valid in your autotermination functions.



Initializing System Library Bases

If you declare but do not define a system library base in your own code,
the library base is automatically initialized. The autoinitialization code
calls OpenLibrary to initialize the library base, and the

148 Chapter 10




  autotermination code calls CloseLibrary to close the library. In the
  following example, IntuitionBase is automatically initialized.
  
#include <proto/intuition.h>




/* The following line declares Intuition8ase but does  */
/* not define it.  This line is not required, because  */
/* proto/intuition.h also declares IntuitionBase. In*/
/* this program, IntuitionBase is automatically */
/* initialized.  */


extern struct IntuitionBase *IntuitionBase;


int main(void)

{
struct Window *w;


w = OpenWindow(...);
...
 }


The following table lists the system libraries whose bases are
  automatically initialized by the autoinitialization code.



Table 10.1
Library Bases forNameBase
.library Filesasl.library (2.0)AslBase
commodities.library (2.0)CxBase
diskfont.library DiskfontBase
expansion.libraryExpansionBase
gadtools.library (2.0)GadToolsBase
graphics.library GfxBase
icon.libraryIconBase
iffparse.library IFFParseBase
intuition.libraryIntuitionBase

  ( continued)

 Using Startup Modules 149



Table 10.1
(continued) Name  Base
keymap.library  KeymapBase
layers.library  LayersBase
mathffp.libraryMathBase
mathieeedoubbas.libraryMathIeeeDoubBasBase
mathieeedoubtrans.library  MathIeeeDoubTransBase
mathieeesingbas.libraryMathIeeeSingBasBase
mathieeesingtrans.library  MathIeeeSingTransBase
mathtrans.libraryMathTransBase
translator.library  TranslatorBase
utility.libraryUtilityBase
workbench.libraryWorkbenchBase

.



Note: DOSBase and SysBase are initialized by the startup code
  even if you define them.
As stated before, a system library base is not initialized if you define
  the library base in your code (except DOSBase and SysBase). For
  example, the following code defines the library base and, therefore, the
  base is not automatically initialized.


#include <proto/intuition.h>


/* The following line defines IntuitionBase, so */
/* it is not automatically initialized.  */


struct IntuitionBase *Intuition8ase;

150 Chapter 10




int main(void)
{
struct Window *w;
w = OpenWindow( . . . ); /* Crash! IntuitionBase in NULL */
...
}



  For more information on defining library bases, refer to SAS/C
Development System Library Reference.
  The autoinitialization functions pass the value of the external long
integer _ _ OSlibversion to OpenLibrary. If your program runs
only under a specific version of the operating system, declare this
variable in your code and initialize it as necessary. For example, if your
program requires the AmigaDOS operating system, Version 2.0 (which is
library revision 37), you can enter the following line in your program
external to any function:


long_ _ OSlibversion = 37;


The following table lists the library revision numbers for each version of
the operating system.



 OSLibrary
 Version Revision
 1.2 33
 1.334
 2.036 (Preliminary 2.0)
 2.04  37




  If the autoinitialized libraries cannot be opened, the library function
__autoopenfail is called. The version of __autoopenfail in the
libraries prints a message indicating which library could not be opened
and then terminates your program. You can replace this function by
declaring it in your code as follows:


  void __autoopenfail(char *lib)
  {
 
Using Startup Modules 151




/* your code here */
}


The lib parameter is the name of the library that failed to open. If you
want your program to terminate after the call to __autoopenfail, the
last action of __autoopenfail should be to call _XCEXIT. If
__autoopenfail returns without calling _XCEXIT, the startup
proceeds normally.
  The source code to the default __autoopenfail function is in
sc:source/autoopenfail.c. As an additional example,
sc:source/intuitlib.c contains the autoinitialization and
autotermination code for intuition. library.

152
153


 11 Using Amiga Specific
Features of the SAS/C
Language


153 Introduction
154 Using Special Keywords
155 Using__aligned
156 Using__chip, __far, and__near
157 Using __interrupt
157 Using __asm, __regargs, And __stdargs
158 Using__saveds
159 Using__inline
160 Managing Stack Space
161 Using #pragma Statements
163 Using Unnamed Unions
164 Using Implicit Structure References
164 Using Equivalent Structures
166 Using Zero-Length Arrays
167 Specifying the Size of Enumerated Types
168 Using the sizeof and Comma Operators in Preprocessor Directives
168 Using C++ Style and Nested Comments
168 Using National Characters in Variable Names
168 Using Common Model External Data




  Introduction

  This chapter describes features of the SAS/C Compiler that are not
  defined by the ANSI Standard. Specifically, the compiler allows you to do
  the following:

  [] use special keywords such as __ aligned and __ saveds
  [] use #pragma statements
  [] declare and refer to structure members in special ways
  [] change the size of enumerated types
  [] use the sizeof and comma (,) operators in #if directives
  [] use C+ + style and nested comments
  [] use national characters in variable names
  [] use the common model or the strict reference-definition model for
  external data.

154 Chapter 11




Using Special Keywords
The SAS/C Compiler allows the following keywords:

__aligned
  forces an item to be aligned on a four-byte (longword) boundary or
  forces the declared function to align its stack in the prolog.

__chip
  places the declared static or extern data into chip memory.

__far
  places the declared static or extern data into the far data section
  or forces calls to the declared function to be made with 32-bit
  references.

__near
  places the declared static or extern data into the near data
  section or forces calls to the declared function to be made with 16-bit
  references.

__interrupt
  indicates that a function may be called as an interrupt routine.

__asm
  allows you to specify which registers a function uses to receive
  parameters.

__regargs
  forces a function to receive parameters in registers.

__stdargs
  forces a function to receive parameters on the stack.

__saveds
  loads the global data register at the entry to the function. The method
  used depends on the compiler options you specify.

__inline
  indicates a function that can be inlined by the global optimizer.

__stackext
  indicates a function that should allocate a new stack if the old one is
  too small.

The following sections describe each of these keywords. The
__stackext keyword is described under "Managing Stack Space."
  When used on functions, these keywords must be specified in the
correct places, depending on whether the keyword affects the calling
function (the caller) or the function being called (the callee). The following
list summarizes these points.

Using Amiga Specific Features of the SAS/C Language 155




[] Keywords that affect the function's definition (the callee) only may
 appear on prototypes, but they are optional. These keywords generate
 warnings if placed on function pointers or data items because they are
 unnecessary, but the compiler still generates correct code. Keywords in
 this category are __aligned, __interrupt, __saveds, and
 __stackext.
[] Keywords that affect both the caller and the callee must appear both on
 the function definition and its prototype. You are required to have a
 prototype for the function and to add the keywords to the declaration
 of any function pointers. If you do not do this, incorrect code is
 generated to pass parameters. For example, if you assign a
 __regargs function to a function pointer and compile with the
 parms=stack option, parameters are passed to the __regargs
 function on the stack instead of in registers. Keywords in this category
 are __asm, __stdargs, and __regargs.
[] Keywords that affect only the calling function are required on function
 prototypes only. The keywords are ignored if they appear on function
 definitions or function pointers. Keywords in this category are
 __near and __far.

 Be careful when specifying a keyword on a function pointer. The
indirection operator (*) in a function definition resets all special
keywords. To declare a pointer to a function that, for example, takes its
arguments in registers, declare the pointer as follows:


void (* __regargs func)(int x, char *p);


If you declare the pointer as in the following example, the __ regargs
keyword is attached to the function pointer itself rather than the function
to which the pointer points:


void __regargs (*func)(int x, char *p);


Using __aligned  The __aligned keyword on a declaration forces the variable being
declared to be aligned on a four-byte data boundary relative to the start
of the data area in which it is being declared. For structure members, the
data area is the start of the structure. For automatic variables, the data
area is the beginning of the stack frame for the function in which they
are declared. For static and extern variables, the data area is the
base of the chip, near, or far data section, depending on the section in
which the variable is being allocated.

156 Chapter 11




The __aligned keyword is valid on both functions and data items.
For example, the following code declares the structure f ib and the
function func:


 __aligned struct
FileInfoBlock fib;

 int __aligned func(int x)
 {
/* your code here */
 }


The SAS/C Compiler normally makes sure that the stack is aligned at
the beginning of your program and remains aligned for the duration of
the program. However, if your code is called from code not compiled
with the SAS/C Compiler, you cannot be sure that the stack is correctly
aligned at the start of your program. In that case, the __aligned
keyword may not work for automatic variables. For example, your code
may be:

[] called from assembly-language code
[] an interrupt routine
[] a callback function
[] in a shared library.

To make sure that the stack is aligned at the beginning of a function,
declare the function itself with the __aligned keyword. This action
forces the code generated for the function to align the stack on entry.
However, the compiler devotes an address register to pointing to the old
stack, thereby reducing the number of address registers available for
register variables.

Using __chip,The __near, __far, and __chip keywords on data items allow you
__far, andto specify the section in which you want the compiler to place the item.
__nearOn functions, the __near and __far keywords are required on the
function prototype only.
By default, the compiler puts all declared static or external data into
the near data section. Register A4 points to the start of this section. The
compiler generates 16-bit references relative to A4 for external or static
items in the near data section. These references generate less code than
full 32-bit references.
For all items in the far data section, the compiler generates 32-bit
references. When the system loader loads your program, it changes these
32-bit references to the actual address of the data item.

 Using Amiga Specific Features of the SAS/C Language 157




The compiler also generates 32-bit references to items placed in chip
  memory. Chip memory is the lowest 512K to 2M of system memory,
  depending on the version of the hardware that you are running. This
  memory is the memory on your machine that is usable by the custom
  graphics and sound chips to store bitmaps, sound samples, and so on.
You can use the data compiler option to change the default data
  section for external and static data. You can also override the default for
  individual data items by declaring the item with the __near, __far, or
  __chip keyword, as in the following example:


__near char a[10];/* Allocate a 10-byte array in the near sec*/
__far  char b[10];/* Allocate a 10-byte array in the far sec */
__chip char c[10l;/* Allocate a 10-byte array in the chip sec*/


For compatibility with previous releases, the compiler accepts the
  near, far, and chip keywords without the leading underscores.
  However, these forms of the keywords violate the ANSI Standard and are
  not allowed if you specify the ansi compiler option.
On function declarations, the __chip keyword is meaningless.
  However, functions declared with the __near keyword are always
  called with a 16-bit relative branch even if you compile with the
  code= far option. Functions declared with the __far keyword are
  always called with a 32-bit branch even if you compile with the
  code=near option. For example, the following function is called with a
  32-bit branch:


 __far int func(int x);


 Using  You can declare a function with the __interrupt keyword to indicate
 __ interrupt  that the function is called from an interrupt routine. Defining a function
 with the __ interrupt keyword turns off the stack checking and
 extension code for that function and sets condition codes on return. The
 __interrupt keyword is required on function definitions and tolerated
 on function prototypes. This keyword is meaningless on function pointers
 and other data items.


  Using __asm, Normally, C functions pass and receive parameters by placing them on
__regargs, And the stack. To force a function to receive some or all parameters in
  __stdargs registers, you can declare the function with the __asm or __regargs
 keyword or compile the function with the parameters=register
 option.
If you declare a function with the __asm keyword, you can specify the
 registers in which the function receives each parameter. For more

158 Chapter 11




  information about the __asm keyword, refer to Chapter 11, "Using
  Assembly Language with the SAS/C Language," in SAS/C Development
  System User's Guide, Volume 2: Debugger, Utilities, Assembler,
  Version 6.0.
 If you declare a function with the __regargs keyword or if you
  compile the function with parameters=register, the function
  receives some of its arguments in registers instead of on the stack.
  Specifically, the first two pointer arguments are in registers A0 and A1,
  and the first two integral arguments are in D0 and D1. If you compiled
  with the math=68881 option, the first two doubles are in registers
  FPO and FP1. All other arguments are passed on the stack.
 The compiler identifies functions that expect arguments in registers to
  the linker by placing an at sign (@) in front of the function name. The at
  sign replaces the underscore that the compiler normally places at the
  beginning of function names.
 If you compile your application using parameters=register but
  you want one or more functions to receive parameters on the stack,
  declare those functions with the __stdargs keyword. The __stdargs
  keyword forces a function to receive parameters on the stack.
 If you write a function that has the same name as a library function,
  you need to add the __regargs keyword to your function or compile
  with the parms=both or parms=register option. For example, you
  may want to replace the SAS/C library function malloc with your own
  version of malloc. If you compile with the parms=stack option or
  define your version of malloc with the __stdargs keyword, then two
  versions of malloc are linked into your executable. If you use other
  SAS/C library functions that call malloc, these functions use the version
  of malloc in the SAS/C libraries. However, your functions that call
  malloc use your version of malloc. To make sure that all calls to
  malloc are using your version of malloc, define your version with
  __regargs or compile with the parms=both or parms=register
  option.
 The __asm, __regargs, and __stdargs keywords are important
  on function definitions and prototypes, and function pointers.


Using __saveds  If you define a function with the __saveds keyword, the compiler
  generates extra code at the beginning of the function that loads the
  address of the near data section into register A4. Defining a function with
  the __saveds keyword is equivalent to compiling that function with the
  saveds compiler option.
 Loading A4 with the address of the near data section is useful if the
  function in question is called from outside your program. For example,
  your function may be a callback function or may be a function in a
  shared library.

Using Amiga Specific Features of the SAS/C Language 159




  If you do not compile your function with the libcode option, register
A4 is initialized with the contents of the absolute symbol _LinkerDB, as
follows:


LEA_LinkerDB,A4


  If you compile your program with the libcode option, the linker
treats _LinkerDB as an offset relative to register A6 (the library base)
instead of an absolute symbol. Register A6 points to the library base at
all entry points to the library. In this case, the instruction generated to
load A4 is as follows:


LEA_LinkerDB(A6),A4


  _LinkerDB is initialized by the linker to point to the near data
section.
  Programs that are residentable cannot refer to absolute symbols.
Therefore, you cannot use the __saveds keyword or saveds compiler
option if you intend to link your program with the cres.o or
catchres.o startup modules.
  Defining your function with the __saveds keyword is equivalent to
calling the function geta4 as the first executable statement of your
function. geta4 is provided for compatibility with previous versions of
the SAS/C Compiler and with other Amiga compilers.
  The __saveds keyword is important in function definitions and is
tolerated but not required in function prototypes. If you include the
__saveds keyword on the prototype for a function, an error message is
issued if the keyword is missing from the function definition. This
keyword is meaningless on function pointers and other data items.

Using __inlineIf you define a function with the __inline keyword, the global
optimizer generates code for the specified function at the point the
function is called, instead of generating an actual call to the function.
Using the __inline keyword can increase code size, but it can make
your code run faster. It also allows the global optimizer to perform more
optimizations. If you do not compile with the optimize option, the
__inline keyword is ignored, and code is generated to call the
function normally.
  The __inline keyword is required on both function prototypes and
function definitions. This keyword is meaningless on function pointers.

160 Chapter 11




Managing Stack Space

The stack is a writeable memory area whose size is set by the AmigaDOS
stack command or by the external long integer __stack . The default
stack size is four kilobytes. This stack is used during function calls for
saving registers and passing arguments. Within a function, automatic
variables are allocated from the stack. For many C programs, a four-
kilobyte stack is adequate.
  If you compile your program with the stackcheck option (the
default) and your program overflows its assigned stack area, the stack
overflow routine __CXOVF is called. The __CXOVF routine provided
with the SAS/C libraries displays a requester and aborts the program.
However, you can replace the version of __CXOVF supplied by the
SAS/C libraries with your own version.
  If you do not want your program to abort because of a lack of stack
space, you can allocate additional stack space in one of four ways:

[] Increase the value of the external long integer __stack. __stack
specifies the minimum stack size needed for your program to run. If
the default stack is smaller than __stack, the startup code allocates a
new stack of __stack bytes. If you do not compile with stackext,
the stack space is allocated once by the startup code, so your program
does not take longer to run. Changes made to __stack after your
program starts take effect only if new stack extents are allocated
because of code compiled with the __stackext keyword or the
stackext compiler option.
[] Declare functions that require a large amount of stack space with the
__stackext keyword. This keyword generates extra code at the start
of the function. This extra code compares the amount of stack available
with the amount specified in the external long integer __STKNEED.
__STKNEED specifies the minimum amount of stack needed by each
function in your program. If enough stack is not available, the function
allocates a new stack extent whose size is specified in the external long
integer __stack. If there is not enough memory to allocate the new
stack, the stack overflow routine __CXOVF is called, just as if normal
stack-checking code was active instead of the stack extension code.
When the function returns, the old stack is restored and the extra
stack is freed. Declaring a function with the __stackext keyword is
equivalent to compiling the funcvion with the stackext compiler
option.
[] Compile your program with the stackext option. Compiling with the
stackext option is equivalent to defining all functions in your
program with the __stackext keyword. If you have specific
functions that use a lot of stack space or are recursive, you may want

Using Amiga Specific Features of the SAS/C Language 161




to define those functions with the __stackext keyword instead of
compiling your entire program with the stackext option.
[] Increase the value of the external long integer __STKNEED and
compile your program with the stackext option. You should never
set __STKNEED to less than 400 bytes (which is the default value).

  Note: __stack specifies the total number of bytes needed during the
entire duration of your program. __STKNEED gives the minimum free
stack required by each function.
  Note: Using the stack extension feature adds overhead to each
function entry point and requires the use of an additional address
register. Therefore, your program will run slower.
  The __stackext keyword is important only on function definitions.
This keyword is meaningless on function pointers and tolerated on
function prototypes, but not required. If you include the __stackext
keyword on the prototype for a function, an error message is issued if the
keyword is missing from the function definition.
  Even if you compile your program with stackext, your program may
still run out of stack space if it calls a function not compiled with
stackext. If you call shared libraries or code compiled with other
languages, your program may run out of stack space. Also, the SAS/C
library routines are not compiled with stackext, but they use little
stack space. The stack extension code allows some extra space for the
library routines.
  In the same application, you can use functions compiled with
stackcheck, functions compiled with stackext, functions compiled
with neither option, and functions defined with the __stackext
keyword. If you compile a function with both stackext and
stackcheck, the compiler ignores the stackcheck option.
  For more information on the __ stack integer, refer to SAS/C
Development System Library Reference, Version 6.0.


Using #pragma Statements
The SAS/C Development System supports five types of #pragma
statements:

[] flibcall
[] libcall
[] syscall
[] tagcall
[] msg.

The libcall, syscall, and tagcall #pragma statements allow you
to call various library routines directly. These #pragma statements are

162 Chapter 11




described in SAS/C Development System Library Reference. The
flibcall #pragma statement also allows you to call various library
routines directly. The flibcall statement is similar to libcall,
except that each byte instead of each nibble is interpreted as a register.
#pragma flibcall allows you to use floating-point registers.
However, you can only pass 6 parameters instead of fourteen. Currently,
the AmigaDOS system libraries do not accept parameters in floating-point
registers. However, if you create your own libraries that accept
parameters in floating-point registers, you should use #pragma
flibcall.
  The SAS/C Compiler also supports #pragma msg statements.
#pragma msg statements allow you to specify whether a message should
be ignored, treated as an error, or treated as a warning message. For
example, if you know that your code produces a specified warning on a
certain line, you can use a #pragma msg statement to suppress the
warning on that line.
  Note: You cannot turn a message that is by default an error into a
warning.
  How a specific message is treated is referred to as its state. Using
#pragma msg statements, you can save the state of a message, change
its state, or restore a message's previous state.
  The msg statement can take one of the following forms:

#pragma msg num [error | warn | ignore] [push]


#pragma msg num pop
  where
  numidentifies the number of the message.

errorindicates that the message should be treated as an error. You
 can abbreviate this keyword as err.

 warnindicates that the message should be treated as a warning, if
 possible. You can abbreviate this keyword as wrn.

  ignoreindicates that the message should be ignored, if possible. You
 can abbreviate this keyword as ign.

 pushsaves the message's state (before changing it). If you specify
 push, this keyword must appear after the error, warn, or
 ignore keyword.

  poprestores the message's previous state.

With the push and pop keywords, you can turn a message on or off for
a specific line, series of lines, or header file, then restore the message to
the value the user specified on the command line.

Using Amiga Specific Features of the SAS/C Language 163




  For example, the following code produces message number 85 because
it returns an int but no return value is specified. However, the code is
correct because the exit function never returns. The first #pragma
statement tells the compiler not to produce a warning on that line. The
second #pragma tells the compiler to generate a message for the
remaining functions in the file, if necessary.

  int func(void)

  {
 .
 .
 .

 exit(O);  /* Never returns */
  #pragma msg 85 ignore/* Turn off warning 85 */
  }
  #pragma msg 85 warning  /* Turn on warning 85  */

  int func2(void)
  {
 .
 .
 .
  }  /* A warning here is VALID and is produced due to the */
  /* second #pragma statement above.*/



Using Unnamed Unions
The SAS/C Compiler supports unnamed unions as structure members.
For example, you could define the following structure:


struct FOO
{

union
{

  int x;
  double d;
};

long l;

} foo;


The union in this structure does not have a name. The union members
are treated as if they are members of the structure, except that the union

164 Chapter 11




members start at the same offset relative to the base of the structure. In
this example, you can refer to member x as foo.x.



Using Implicit Structure References

If you declare a substructure in your program, and the names of the
members in the substructure are unique, you can refer to the members
using only the structure name and member name. You do not need to
include the substructure name in the reference. For example, you could
declare the structure BAR and the substructure FOO as follows:


  struct FOO
  {

int x;
double d;
  };


  struct BAR
  {

struct FOO foo;
int l;
  } bar;


You can refer to members x and d in the substructure as follows:

bar.x = 10;
bar.d = 10.0;


Referring to substructure members as shown generates warning message
193. If your program refers to substructure members in this way,
suppress warning 193 by compiling your program with the ignore 193
compiler option.
  If two or more substructures contain a member with the same name
and you do not specify the substructure name when you refer to the
member, the compiler generates error message 123. The compiler cannot
determine which substructure member you are trying to reference.



Using Equivalent Structures

If you compile your program with the StructureEquivalence
option, the compiler does not issue messages if a pointer to one structure
type is passed to a function when the function expects a pointer to a
different type, if the type passed is equivalent to the type expected.

Using Amiga Specific Features of the SAS/C Language 165




  A structure is defined to be equivalent if it maps the same base data
types in the same order as the desired structure type. If one structure is
longer than another, but it is identical through the length of the shorter
one, then the longer structure is an acceptable substitute for the shorter,
but the shorter structure is not an acceptable substitute for the longer
structure. The function receiving the pointer may try to write to one of
the fields that does not exist in the shorter structure. Therefore, you can
pass an IntuiMessage structure to the exec function PutMsg without
getting a warning, but the compiler issues a warning if you assign the
result of a call to GetMsg to an IntuiMessage pointer.
  For example, you could define the following structures:


  struct FOO
  {

 int x;
 int y;
  };

  struct 8AR
  {
  int x, y, z;
  };



The structure BAR is equivalent to the structure FOO. If you specify
structureequivalence, the compiler does not issue a warning for
passing a pointer of type BAR to a function whose prototype specifies a
structure of type FOO. However, the structure FOO is not equivalent to
BAR because FOO is not long enough. If you tried to pass a pointer to a
structure of type FOO to a function whose prototype specified a pointer to
a structure of type BAR, you would get a compiler warning.
  BAR is also equivalent to FOO if you define them as follows:


struct FOO
{
 int x, y;
};

struct BAR
{
 struct FOO foo;
 int z;
};

166 Chapter 11




  Similarly, you can pass a struct IntuiMessage * to a function
that requires a struct Message *, since a struct Message is the
first element of a struct IntuiMessage. (struct IntuiMessage
is defined in the system header file intuition/intuition.h.) This
option also allows you to pass a pointer to an IOExtSer structure to a
routine that wants a pointer to an IoRequest structure, such as the
routine DoIO. IOExtSer is identical to IoRequest for the length of
the IoRequest structure.
  The following example is more complicated, but BAR is still equivalent
to FOO:


struct FOO
{

 int x, y, z;
};
struct BAR
{
 struct
 {
 int a;
 } x;
 struct
 {
 int b, c;
 } y;
 int z;
};



The structure type FOO defines memory as three consecutive integers.
BAR also defines memory as three consecutive integers, although it does
so through the use of two different substructures. The substructures are
not considered when determining equivalence.



Using Zero-Length Arrays
You can use zero-length arrays as the last element of a structure. For
example, you can declare structure FOO as follows:


struct FOO
{
 long maxalloc;
 long curalloc;

Using Amiga Specific Features of the SAS/C Language 167




long mem[0];
 };


This structure is 8 bytes in length as reported by sizeof. Using zero-
length arrays is most useful when you need to allocate variable-sized data
items. For example, if you need 100 elements in the above array at run-
time, you can do the following:


struct FOO *foo;
foo = malloc(sizeof(struct FOO) + lOO*sizeof(long));
foo->mem[50] = 10;
foo->mem[56] = .....



Specifying the Size of Enumerated Types
By default, enumerated types are integers and integers are 4 bytes long.
For example, each of the identifiers of type cats is 4 bytes long.


enum cats [bombay, ocicat, somali];


If you compile this line with the shortintegers option, the identifiers
are 2 bytes long.
  The SAS/C Compiler also allows you to control the size of enumerated
types by declaring them with the char, short, or long keywords, as in
the following examples:


char enum flintstones (Fred, Barney, Wilma];
short enum colors (red, green, blue, black, white);
long enum seasons (spring, summer, fall, winter);


The identifiers of type flintstones are 1 byte long; the colors are 2
bytes long, and the seasons are 4 bytes long. When you declare a
variable of a specific enum type, you must include the extra keyword on
the variable's declaration:


char enum flintstones var1;

168 Chapter 11




Using the sizeof and Comma Operators in
Preprocessor Directives

The SAS/C Compiler allows you to use the sizeof and comma (,)
operators in preprocessor #if directives, as in the following example:


 #if (sizeof(int) == 2)
#error short integers
 #endif


However, the ANSI Standard does not allow these operators in
preprocessor directives. Therefore, the compiler produces a warning
message if you compile with your program with the ansi or strict
option.



Using C++ Style and Nested Comments

In C++ programs, two consecutive slashes (//) define a comment block
that extends to the end of the current line. You can use two slashes to
designate comments in your SAS/C programs. However, if you compile
with the ansi or strict options, the compiler generates a warning
message for these comments.
  The ANSI Standard states that a C program cannot have nested
comments. Therefore, if you enter the comment start sequence (/*) inside
of a comment, the sequence is not recognized as the beginning of a
second, or nested, comment. The first comment end sequence (*/)
terminates comment mode. However, if you specify the commentnest
compiler option, as described in Chapter 8, "Compiling and Linking Your
Program," the compiler allows nested comments.



Using National Characters in Variable
Names

If you do not compile your program with the ansi option, you can use
accented characters in variable names.



Using Common Model External Data

The ANSI Standard does not define how external data should be handled.
Typical UNIX compilers allow you to declare external variables in
multiple places, as long as you do not initialize the variable in more

Using Amiga Specific Features of the SAS/C Language 169




than one of those declarations. For example, you could define the
following variable in a header file:
 int i;


If this header file is included by all files in a project, each file defines a
variable i. The linker merges all these independent definitions into one,
creating a common model for external data.
  Most microcomputer compilers use what is called the strict reference-
definition model (or strict ref-def) for external data. This model requires
that one and only one source file in a project define the external variable.
The remaining files in a project can only declare the external variable. To
change the definition of variable i to a declaration, use the extern
keyword as follows:
extern int i;


  The SAS/C Compiler supports both the common model and the strict
reference definition model. The default model is strict reference-definition.
If you want to use the common model, compile your program with the
common compiler option.

171




170

  12  How Does the Compiler
  Work?

  171 Introduction
  171 Compiling Your Program
  173 Linking Your Program
  174 Running Your Program
  174 Stack Area
  175 Heap Area
  175 Changing Hunk Names
  176 Addressing Data
  177 Understanding Data Types and Sizes
  179 Storing Data




Introduction

Programming with the SAS/C Compiler is not much different than
programming in C on other compilers. Most of the books about the C
language that are at your local bookstore are applicable to the SAS/C
Compiler. If you confine your programming to the features that these
books describe, you do not need much specific information about how the
SAS/C Compiler works. However, if you want to perform special tasks
such as linking with assembly language functions, writing I/O drivers in
C, or using overlays, you may need to know how your C program is
translated into executable code.
  This chapter describes how your program is translated into executable
code. This chapter assumes a basic knowledge of object file format as
described in The AmigaDOS Manual, 3rd Edition (Commodore-Amiga, Inc.
1991).



Compiling Your Program

The compiler produces an object module (a .o file) for each assembler or
C source file. Each object module is organized into hunks. In general, a
hunk contains the following information:

[] program code or data. The program code is written into the code hunk.
The data for your program are written into one of several hunks,
depending on how the data are declared. For example, data declared
with the __chip keyword are placed in the chip hunk.

172 Chapter 12




[] external symbol information, including subroutine entry points and
global data. This information is also referred to as global symbols or
XDEFs.
[] relocation records. The linker uses these records to produce a load file.
A load file is also called an executable module.

Your program code and data are organized into the following hunks:

Code hunk
  contains the machine instructions for your program, any string
  constants (if you compile with stringmerge), and anything else that
  the compiler decides is definitely read-only. By default, this hunk is
  named text, but you change this name with the codename option.
  See the section "Changing Hunk Names," later in this chapter, for
  more information.

Near data hunk
  contains all initialized near data, including constants and string
  constants (if you do not compile with the stringmerge option). Near
  data are data that are declared with the __ near keyword or are
  defined in modules compiled with the data=near option.
  data=near is the default setting, so unless you specify otherwise, all
  of your initialized data are placed in the near data hunk. Near data
  can be accessed by resident programs and libraries. This hunk is
  named __MERGED.

Near BSS hunk
  specifies the amount of memory to allocate for all uninitialized near
  data. The startup code initializes the near BSS hunk to 0. This hunk is
  also named __MERGED.

Chip hunk
  contains all data that are declared with the __chip keyword or
  compiled with the datamem=chip option. This hunk is named chip.

Far data hunk
  contains all initialized far data. Far data are data that are declared
  with the __far keyword or are defined in modules compiled with the
  data=far or data=faronly options. By default, this hunk is
  named data, but you can change the name with the dataname
  option. See the section "Changing Hunk Names," later in this chapter,
  for more information.

Far BSS hunk
  specifies the amount of memory to allocate for all uninitialized far
  data. The system loader allocates this memory and sets it to zero. By
  default, this hunk is named udata, but you can change the name with

How Does the Compiler Work? 173




  the bssname option. See the section "Changing Hunk Names," later
  in this chapter, for more information.

  When you compile your program with the verbose option, the
compiler produces a message in the following format:


  Module size P=00000000 D=00000000 U=00000000 C=00000000
  F=00000000 UF=00000000


The letters indicate which hunks were produced for your program:

 P code hunk (your program)

 D near data hunk

 U near BSS (uninitialized data) hunk

 C chip hunk

 F far data hunk

  UF far BSS (uninitialized data) hunk

The numbers give the size in bytes, using hexadecimal notation, of each
hunk. If the compiler does not create certain hunks, then the compiler
either displays zeroes or does not display any numbers for these hunks.
If you compile your program using a debug option, the compiler
generates debugging information and writes this information into two
types of hunks that hold debugging information:

H_DEBUG  contains line numbers, and information about
  variables, typedefs, and structures. H_DEBUG
  hunks are generated by the compiler or the
  assembler.

H_SYMBOL contains absolute addresses of global symbols.
  H_SYMBOL hunks are generated by the compiler or
  the linker.



Linking Your Program

The linker combines the object modules to produce a single executable
module or shared library. To produce an executable module, the linker
does the following:

[] reads each of the object modules.
[] reads each of the link libraries, if necessary.
[] writes the contents of the object modules to the executable module. In
the process, the linker resolves all intra-hunk and near data relocations

174 Chapter 12

End Of Part 2

