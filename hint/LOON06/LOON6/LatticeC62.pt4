Part 4


CSECT name,type,align,rtype,rsize
defines section type and alignment requirements. The section
"Defining Control Sections," later in this chapter, discusses the
CSECT macro.
[label] DC[.size] expression[,expression] . . .
defines a constant value in memory.
[label] DCB[.size] n,expression
defines a constant block in memory. Using the DCB directive is
equivalent to using the DC directive n times.
[label] DS[.size] n
reserves (defines) n memory locations of the size indicated by .size.
ELSE
begins an alternative for the IF directive.
[label] END
defines the end of the program.
ENDC
defines the end of conditional assembly. This directive turns off
each of the IFxx directives.
ENDM
ends a macro definition.
label EQU expression
assigns permanently the value of expression to label.
label EQUR register
equates an address or data register with label.
EXITM
exits the macro expansion. This directive is a synonym for MEXIT.
FAIL
generates an error for the next input line.
FORMAT
is included for compatibility only.
IDNT name
defines a program unit name.
IF expression
assemb]es the following statemeIIts to the next ELSE or ENDIF if
the expression supplied as its argument is not 0. IF statements may
be nested.
IFC string, string
assembles if the strings are identical.306 Chapter 11

 IFD symbol
assembles if the symbol is defined.
 IFEQ expression
assembles if the expression is 0.
 IFGE expression
assembles if the expression is greater than or equal to 0.
 IFGT expression
assembles if the expression is greater than 0.
 IFLE expression
assembles if the expression is less than or equal to 0.
 IFLT expression
assembles if the expression is less than 0.
 IFNC string,string
assembles if the strings are not identical.
 IFND symbol
assembles if the symbol is not defined.
 IFNE expression
assembles if the expression is not equal to 0.
 INCLUDE "filename"
includes external files into the source. You can nest INCLUDE
directives up to a depth of 3.
 LIST
tells the assembler to produce a listing file.
 LLEN n
sets the number of characters per line in the listing file. n can be
any value from 60 to 132. The default value is 132 characters.
 label MACRO
begins a macro definition. The following section, "Defining and
Using Macros," describes how to define and use macros.
 MASK2
is included for compatibility only.
 MEXIT
exits the macro expansion. This directive is a synonym for EXITM.
 NARG
is the reserved symbol to which the assembler assigns the index of
the last argument passed to the macro in the parameter list.
 NOFORMAT
is included for compatibility only.307  Using Assembly Language with C Language

NOLIST
tells the assembler to stop producing a listing file.
NOPAGE
tells the assembler to stop inserting page breaks and title headers in
the listing file.
NOOBJ
stops the production of the object file.
OFFSET n
defines offsets. To define a table of offsets using the DS directive,
you use the OFFSET directive. To end an offset section, use a
RORG, OFFSET, SECTION, or END directive.
OPSYN oldname newname
defines a synonym for opcodes.
PAGE
inserts a page break into the listing file.
PLEN n
sets the number of lines per page in the listing file. n can be any
value from 24 to 100. The default is 60 lines.
label REG R1[-R2][/R3 [-R4]] . . .
assigns permanently the register list to label. You can specify
individual registers by separating each register with a slash
(R1/R2/R3), or you can specify a range of registers by specifying
the first and last registers separated with a hyphen (R1-R3). You
can also combine individual registers with a range of registers
(R1/R3-R5/R7). The assembler translates this list into the register
list mask format used by the MOVEM instruction.
[label] RORG n
sets the program counter to n bytes from the start of the current
relocatable section.
[label] SECTION name[,type]
defines a program section. name is a character string, and type must
be CODE, DATA, or BSS. The section "Defining Control Sections,
later in this chapter, discusses the SECTION macro.
label SET expression
assigns temporarily the value of the expression to the symbol
identified by label.
SPC n
skips n blank lines in the listing file.308 Chapter 11

  TTL title
  sets the title string that is printed in the page headers in the listing
  file. The title can be no longer than 40 characters.

  XDEF label[,label] . . .
  defines an internal label as an external entry. By using the XREF
  directive, you can then refer to the symbols generated by these
  labels from other modules and from routines written in the C
  language.

  XREF label[,label]. . .
  references an external symbol defined with the XDEF directive.

 Defining and Using Macros

  You can define a macro using the following sequence of directives and
  instructions:

  label MACRO
.
ENDM


You must begin the definition with a MACRO directive on a line by
  itself. After the MACRO directive, enter the lines that constitute the
  macro procedure. End the macro definition with the ENDM directive on
  a line by itself. You can use the EXITM directive within the macro
  procedure to exit the macro before the ENDM directive.
  For example, you could define a macro called acopy as follows:

  acopy MACRO
 move.w4(sp),\1
 move.l6(sp),\2
 ENDM


  You can invoke this macro with the following statement:

  acopyd0,a5

  The assembler expands the macro as follows:

  move.w  4(sp),d0
  move.l  6(sp),a5309 Using Assembly Language with C Language

Defining Control Sections
  The SAS/C Macro Assembler does not assume any default control
  sections. You must use either the SECTION or CSECT directive before
  you define any code or data. A SECTION or CSECT directive defines
  the beginning of a relocatable control section. Pararneters on these
  directives allow you to name each control section. The assembler uses
  these named control sections to control the location of data and code
  during linking.
Chapter 12, "How Does the Compiler Work?," in SAS/C
  Development User's Guide, Volume I, describes the sections produced
  by the compiler.


Using the SECTION Directive
The SECTION directive follows this format:

[label] SECTION name[,type]

The following list describes each of the parameters.

name specifies the name of the control section. You can use the name
 __MERGED for near data. You can use a specific name only
 once in a given asm file.
type specifies the type of section. The type can be BSS, DATA, or
 CODE.

Specifying Addresses with the SECTION Directive
You can define symbols to be in the data section by USillg XREF and
XDEF after the SECTION directive. The following exarnple uses 16-bit
addressing to reference both code and data:


  SECTION__MERGED,DATA
  XREF  xdata
  data1DC.W 10
  data2DC.L 20
  .
  .
  .
SECTION TEXT,CODE
XREFcfunc
XDEFafunc
  afunc JSR cfunc(PC)
MOVE.W  data1(A4),D0
MOVE.L  data2(A4),D1
MOVE.L  d1,xdata(A4)310 Chapter 11

  To use 32-bit addressing, remove references to the register A4 and to
  the Program Counter (PC).


  Using the CSECT Directive
  The CSECT directive follows this format:

  CSECT name[, type][, align][, rtype][, rsize]

  The name and type parameters describe the control section being
  defined. The rtype and rsize parameters define how to access the
  information in the section. The align parameter is ignored. The
  following list describes each of the parameters:

  name  specifies the name of the control section. You can use the name
__MERGED for near data. You can use a specific name only
once in a given asm file.

  type  specifies the type of section. A value of 0 indicates a code
section, 1 indicates a data section, and 2 indicates an
uninitialized data section (like the udata section used by the
compiler). The default value is 0 (code).

  align specifies the alignment requirements of the control section as a
power of 2. For example, an alignment of 1 means that the
section will begin on an even address, and a value of 2 means
that the section will begin at an address divisible by 4.
  Note: This parameter is not used on the Amiga. All sections
are long-word aligned.

  rtype specifies whether the code or data in the section are addressed
relative to register A4 or to the PC. The default value is 0.

  rsize specifies the size of the offset for the address. If you specify an
rsize of 4, the assembler uses absolute addressing. If you
specify an rsize of 2, the assembler uses the value of rtype to
determine how to address code or data in the section. The
default value is 4.311 Using Assembly Language with C Language

  The following table summarizes the valid types and sizes of
relocation information on the 68000:

  rtypersizeDescription

  0,1,2432-bit absolute address
  02PC-relative address (code section)
  12A4-relative address (data section)
  22A4-relative address (BSS section)


Specifying Addresses with the CSECT Directive

By specifying parameters in the CSECT directive, you can generate
assembler modules that are compatible with C programs compiled with
the data=near (base-relative data) and code=near (program
counter-relative addressing) compiler options.
  You can force address register-relative addressing of data in the BSS
section by specifying an rtype of 2 and an rsize of 2. Any XREF
statements for external data elements must appear after the CSECT
statement, and all data must be addressed relative to register A4. For
example, the following code moves data around:


CSECT__MERGED,1,,2,2
XREFxdata
  datalDC.W10
  data2DC.L20
.
.
.
CSECT TEXT,0
MOVE.Wdatal(A4),DO
MOVE.Ldata2(A4),D1
MOVE.Ld1,xdata(A4)


  Note: If the XREF statement for the external data precedes the
CSECT statement, you can use a standard reference to a four byte
external address.
  You can force program counter-relative addressing of data in the
code section by specifying an rtype of 0 and an rsize of 2. The
XREF statement for the external function must appear after the CSECT312 Chapter 11

  statement. and the function must be called relative to the program
  counter. For example, the following code calls the function cfunc
  relative to the PC:

CSECT  TEXT,0,,0,2
XREFcfunc
XDEFafunc
 afunc  JSRcfunc(PC)
RTS

Note: If the XREF statement for the external function precedes the
  CSECT statement, you can use a standard JSR instruction to a 4-byte
  external address.
In addition to specifying addresses relative to address registers and
  to the program counter, you also can specify absolute addresses or
  enter immediate data. The following tables summarize the addressing
  modes supported by the SAS/C Assembler and provide examples of
  each mode. The notation used in these tables is as follows:

  NotationMeaning

 Anan address register (a0 a7)
 bda  32-bit byte displacemer1t
data  actual data you want loaded into the register
 Dna data register (d0--d7)
 d8an 8 bit displacement
 d16  a 16-bit displacement
 odthe 32 bit outer displacement
 PCprogram counter
 Xnan index register (a0.w--a7.1)
 xxx  any number in decimal, hexadecimal, octal, or binary format


You can specify the displacements, data, and numbers in decimal,
  hexadecimal, octal, or binary format. The information on entering
  operands in the section "Writing Assembler Statements," earlier in this
  chapter, describes how to specify each type of constant.313 Using Assembly Language with C Language



  Note: All fields of the operands on the addressing modes marked
68020 are optional.
  The following table shows examples of register-direct addressing
modes:



  ModeExample

  Dn  add.w d1 ,d0

  An  addq.w #1 ,a1


  The following table shows examples of register-indirect addressing
modes:


  Mode  Example

  (An)  add.w (a1) ,d0
  (An)+ add.w (a1)+,d0
  -(An) add.w -(a1),d0
  d16(An)add.w 10(a1),d0
  d8(An,Xn) add.w 10(a1,a2.l),d0
  bd(An,Xn) add.w $10000(a1,a2.l),d0  (68020 only)
  ([bd,An],Xn,od)add.w ([10,a1],a2.l,20),d0(68020 only)
  ([bd,An,Xn],od)add.w ([10,a1,a2.l],20),d0(68020 only)


  The following table shows examples of absolute addressing modes:


  Mode  Example

  (xxx).Wadd.w (100).w,d0
  (xxx).Ladd.l (100).l,d0
314 Chapter 11




The following table shows how to specify immediate data:


  Mode  Example

  #data add.1 #100,d0


The following table shows examples of program counter-relative
  addressing modes:



  Mode  Example

  d16(PC)add.w 10(PC),d0
  d8(PC,Xn) add.w 10(PC,a2.l), d0
  bd(PC,Xn) add.w $10000(PC,a2.l)(68020 only)
  ([bd,PC],Xn,od)add.w ([10,PC],a2.l,20),d0  (680Z0 only)
  ([bd,PC,Xn],od)add.w ([10,PC,a2.l],20),d0  (68020 only)


Communicating between Assembly
Language and C Language

The following sections describe how to call assembler functions from C
functions and how to call C functions from assembler modules.


  Calling Assembler Functions from C Functions 
  Assembler modules may be called from C functions in three ways:
 [] passing parameters by placing them on the stack. Unless you specify
the parameters=register option or use the __asm keyword, C
functlons pass parameters on the stack.
 [] compiling your program with the parameters=register option.
This option tells the compiler to pass parameters in registers, but it
allows the compiler to determine which registers to use.
 [] using the __asm keyword and specifying which registers
parameters are placed in.

Passing parameters in registers produces a faster, smaller executable
module.315 Using Assembly Language with C Language




Passing Parameters on the Stack

As previously stated, C functions pass parameters on the stack if you
do not specify the parameters=register option or use the __asm
keyword.
  For example, the following assembler module, func, adds or
subtracts an integer argument and a double argument depending on
whether a plus ( + ) sign or a minus (--) sign is passed in the
character argument.


;  NOTE:  This code assumes that you have a math co-processor.
;If you do not, your machine will crash when you run
;this program.
 xdef _func


 section code
 _func:
 fmove.d 8(a7),fp0  ; middle

 cmpi.b #'+',7(a7)  ; should I add?
 bne.b noadd; no, check subtract

 fadd.l 16(a7),fpO  ; add 'mrright' to 'middle'
 bra.b exitpoint; ready to return

 noadd:
 cmpi.b #'-',7(a7)  ; should I subtract?
 bne.b nosub; no, exit with error


 fsub.l 16(a7),fp0  ; subtract 'mrright'
 bra.b exitpointfrom 'middle'

 nosub:
 fmove.b #-1,fpO; return -1 for error

 exitpoint:
 fmove.l fp0,d0 ; return 'int' in d0
 rts
 end

The func assembler module returns an integer.316 Chapter 11

To call an assembler module from your C program, include the
  prototype for the assembler module in your C source file before calling
  the function. The prototype for the previous example is the following:

int func (char lefty, double middle, int mrright);

  For example, you can write the following program to call the f unc
  module:

  #include <stdio.h>

  int func(char lefty, double middle, int mrright);

  void main(void)
  {
char lefty;
double middle;
int mrright;

lefty = '+';
middle = 12345.;
mrright = 99;

printf("func(+) = %d\n", func(lefty, middle, mrright));
  }

  If you save the assembler module func in a file named testa.a, you
  can assemble test.a with the following command:

asm -m2 testa.a

  If you save the C source code in a file named test, you can compile
  and link test with the following commands:

sc math=868881 test
slink lib:c.o test.o testa.o lib lib:sc.lib

  The test program will pass parameters on the stack. When you run
  test, you should see the following output:

func(+) = 12444317 Using Assembly Language with C Language

 To use the parameters inside your assembler module, you must
retrieve the parameters from the stack. The arguments are placed on
the stack from right to left; that is, the leftmost argument is
immediately above the 4-byte return address in the stack. For example,
in the following function call, the compiler generates code to push the
arguments mrright, middle, and then lefty onto the stack.


char lefty;
double middle,
int mrright;

func(lefty,middle,mrright);

Next, the func module is called, and the return address is pushed
onto the stack. Figure 11.1 shows the stack after the func module has
been called.

 Figure 11.1| Bottom of Stack |
  The Stack after the| |  
  func Module Is High| mrright | 
  Called Memory | | <-- A7+12+n
| middle  |
| | <-- A7+8+n
|  lefty  |
| | <-- A7+4+n
|  return address |
| | <-- A7+n
 Low|work area |
 Memory |of size n |
| |
|Top of Stack  |


 The arguments mrright, middle, and lefty use 4 bytes, 8
bytes, and 4 bytes, respectively.* Register A7 is the stack pointer, and
it points to the 4-byte return address.
 Note: If you specify the shortintegers option, integers will be
2 bytes instead of 4.
 Before retrieving arguments from the stack into non-scratch
registers, you must first save the contents of those registers, so they
--------------------------------------------------------------------------------
* The smallest item that can be pushed onto the stack is the size of an integer.
The size depends on whether you specify the shortint compiler OptiOII. A char
will be promoted to an int.318 Chapter 11

  may be restored when your function terminates. Scratch registers are
  registers D0, D1, A0, A1, FP0, and FP1.
The following list describes the steps your assembler module should
  take to save register values and establish frame pointers. In these
  steps, n refers to the size of your work area in bytes.

1. Enter the SUBI instruction if you need local storage:

SUBI  n,A7

2. Save registers D2 through D7, A2 through A6 if they will be
 changed during execution of the module.
3. Save floating-point registers FP2 through FP7 if a 68881 math
 coprocessor is present and will be used by the module.

You can address the arguments from A7 as follows:


  LocationSizeContents

  (A7) + n4return address
  (A7)+4+n4argument lefty
  (A7)+8+n8argument middle
  (A7)+16+n4argument mrright

  Using the parameters=register Option
  Using the parameters=register option tells the compiler to pass
  some of the function arguments in registers instead of on the stack.
  Specifically, the first two pointer arguments are in A0 and A1, and the
  first two integral arguments are in D0 and D1. All other arguments
  are passed on the stack.
The compiler identifies functions that expect arguments in registers
  by placing an @ in front of the function name. The @ replaces the
  underscore (_) that the compiler normally places at the beginning of
  function names.
319 Using Assembly Language with C Language

  Using the parameters=register option is similar to passing
parameters using the stack. For example, make sure you:

[]  include a prototype of your assembler module in your C source
program.
[]  retrieve any parameters that are passed on the stack before using
them.
[]  use the same asm command to assemble your assembler code.
[]  use the same slink command to link your C code.

  However, you must specify the parameters=register option in
the sc command as follows:

sc parameters=register test

Using the __asm Keyword

Using the __asm keyword on a function prototype or definition tells
the compiler to pass parameters in specific registers.
When you use __asm, the calling C function places the parameters
in the registers required by the assembler module, so no stack
manipulation inside the assembler module is necessary.
The following assembler code is the same f unc module that is
described previously in the section "Passing Parameters on the Stack,"
but it is modified to use the __asm keyword.


;  NOTE:  This code assumes that you have a math co-processor.
;If you do not, your machine will crash when you run
;this program.

xdef _func


section code
_func:
cmpi.b #'+',d0; should I add?
bne.b noadd  ; no, check subtract

fadd.l d1,fp0; add 'mrright' to 'middle'
bra.b exitpoint  ; ready to return

noadd:
cmpi.b #'-',d0; should I subtract?
bne.b nosub  ; no, exit with error
320 Chapter 11




fsub.l dl,fp0; subtract 'mrright' from 'mlddle'
bra.b exitpoint


nosub:
fmove.b #-1,fp0  ; return -1 for error

exitpoint:
fmove.l fp0,d0  ; return 'int' in d0
rts
end

To use the __asm keyword, you must modify the prototype of the
  assembler module in your C source file. For each parameter that you
  want to pass in a register, precede the parameter with the register
  keyword, two underscores (__), and the register into which you want
  the parameter placed.
The prototype for the previous example is the following:

int __asm func(register __d0 char lefty,
register __fp0 double middle,
register __d1 int mrright);


  The lefty argument is placed into register d0, the middle argument
  is placed into register fp0, and the mrright argument is placed into
  register d1.
The remainder of your C program is the same as that shown earlier
  in the section "Passing Parameters on the Stack." You also use the
  same asm, sc, and slink commands as shown in in the section
  "Passing Parameters on the Stack."

  Returning Values to the Calling Function

  Your assembler module should return values in one or more registers.
  The register(s) depend on the data type of the calling function.
  Function return values are passed back in one or more registers,321 Using Assembly Language with C Language

depending on the data type declared for the calling function. The
conventions are as follows:



  ReturnLength
  Type  (Bits)  Syntax  Meaning

  char  8D0.Blow byte of D0
  short 16  D0.Wlow word of D0
  long  32  D0.Lall of D0
  pointer32  D0.Lall of D0
  float 32  D0.Lall of D0
  float (68881) 32  FP0. S  single precision in FP0
  double (IEEE) 64  D0.L,D1.Lhigh bits in D0
  double (FFP)  32  D0.Lall of D0
  double (68881)96  FP0.Xall of FP0


  If the assembler module returns a structure or union, it must define
a static work area (not on the stack) to hold the returned object and
return a pointer to this object in the D0 register. The calling function
should immediately move the data to the appropriate place.
  Note: This approach implies that functions returning structures or
unions are not re-entrant, although they are serially reusable. Such a
function can be recursive if it is designed carefully with this return
technique in mind.
  After setting up the return value, the assembler module exits by
reversing the steps described earlier:

  1. restore registers that were saved.
  2. advance the stack pointer in register A7 past the work area.
  3. return to the caller using an RTS instruction.
  The calling function removes the arguments from the stack.322 Chapter 11



Calling C Functions from Assembler Functions
  The steps you take to call a C function from an assembler program
vary, depending on whether or not you compile your C function using
the parameters=register option.
  If you are not using registerized parameters, follow these steps:

1. push the arguments on the stack in the correct order.
2. call the function using the JSR instruction.
3. after control returns from the called function, adjust the stack
 pointer to account for pushed arguments.

  For example, the following code calls the function cfunc with two
  parameters that are currently in registers D7 and D6 and stores the
  return code in the ret variable.

 XREF cfunc
 MOVE.LD7,-(A7);push argument
 HOVE.LD6,-(A7)
 JSR  cfunc;call function
 ADDQ #8,A7;restore stack ptr
 MOVE.LD0,ret  ;save return value

  If you are using registerized parameters, follow these steps:

1. place the appropriate arguments in the correct registers.
2. push any remaining arguments onto the stack.
3. add an ~ to the front of the function name, and call the function
 using the JSR instruction.
4. after control returns from the called function, adjust the stack
 pointer to account for pushed arguments (if any).

  For example, the following code calls the function cfunc with two
  parameters that are currently in registers D7 and D6 and stores the
  return code in the ret variable.

 XREF @cfunc
 MOVE.LD7,D0
 MOVE.LD6,D0
 JSR  @cfunc  ;call function
 MOVE.LD0,ret  ;save return value

  If your C function is declared using the __asm keyword, you should
  pass the parameters in the appropriate registers.

Referencing Global Data

  Instead of passing parameters into and out of a function, you can use
global data.323 Using Assembly Language with C Language


  You can access data declared in an assembler module from a C
function by placing the data declarations inside a data section and
defining the data with an XDEF statement. The following code defines
two variables in assembly language and shows how to declare them in
a C function.

  In Assembly Language  In C Language

CSECT data  extern long VAR1;
XDEF VAR1,VAR2,VAR3 extern long VAR2;
  VAR1 DC.L $4000
  VAR2 DC.L $8000


  You can access data declared in a C function from an assembler
module using the XREF statement, as follows:


  In C Language In Assembly Language

  long VAR1=0x4000; XREF VAR1,VAR2
  long VAR1=0x4000; .
.
.
MOVE.L VAR1,D0

Running the Assembler

After you have created your modules or programs in assembly
language, you can run the Assembler by entering the asm command as
follows:

  asm [>listfile] [options] filename


  The filename is the name of the assembly language source file that
you want to assemble. The assembler assumes a source filename
extension of .a, and it produces an object file with the same filename
but with the .o extension. You can then use the linker, slink, to324 Chapter 11

  combine these object modules into an executable file, called a load
  module.
If you include >listfile, the assembler sends the source listing and
  error messages to that file.
The assembler supports the following options:

  -cx
 specifies that the sections designated by x are to be loaded into
 memory addressable by the Amiga system's custom hardware. You
 should specify -c for screen image and audio data. The x can be
 one or more of the following:

b bss or uninitialized data
c code segment
d data segment

 By default, the assembler loads the segments into memory not
 addressable by custom hardware, if it is available. This action
 avoids bus contention between the processor and the custom
 hardware. For example, the following command causes all segments
 to be loaded into chip-addressable memory, regard0ess of the system
 memory configuration:

asm -ccdb prog.a

-d
activates the debugging mode.

-dsymbol [ =valuel
defines symbol as if your source file contained this statement:

  symbol EQU value

If you do not specify a value, the assembler assigns a value of 1.

-hx
specifies that the sections designated by x are to be loaded into
memory not addressable by the Amiga system's custom hardware.
The x can be one or more of the following:

b bss or uninitialized data
c code segment
d data segment

By default, the assembler loads the segments into memory not
addressable by custom hardware, if it is available. This action325 Using ~ssembly Language with C Language



prevents the specified segments from being loaded into chip-
addressable memory even if no other memory is available. This
action could also prevent programs from running if external high-
speed memory is not available on the machine. For example, the
following command loads all three sections into high-speed r~AM

  asm -hcdb prog . a

-iprefix
specifies a prefix that should be placed in front of filenames in
INCLUDE directives. You can enter up to four -i options. The
assembler will search for the files in the order in which you specify
the prefixes. If you specify a directory name as a prefix, include the
trailing slash (/). For example, you can assemble the file named
testprog. a with the following command:


  asm -imyinc/ -iyourinc/ testprog.a


If your program contains the statement include abc . i, the
assembler searches for the file in the current directory. If that fails,
it searches for myinc/abc . i and then yourinc/abc . i.

-l[x][m][i]
sends a listing of the source file to the standard output, usually the
screen. The listing displays the appropriate location counter and
code- or data-generated information beside the source line. The x,
m, and i produce the following slightly different listings:

x lists the expansion text for macros.

m  lists additional data generated for source lines that camlot be
listed beside the original source line. This option allows
multiple listing lines for each source line.

i  lists the source for text from INCLUDE files as well as the
original source file.

-m0
specifies that only 68000 instructions are allowed. This option
issues warning messages if, for example, you use instructions that
are only available on the 68020. This option is the default.

-m2
turns off the warnings generated by the -mO option. Use this option
if 68020 instructions are allowed.326 Chapter 11




 -m3
turns off the warnings generated by the -m0 option. Use this option
if 68030 instructions are allowed.

 -m4
turns off the warnings generated by the -mO option. Use this option
if 68040 instructions are allowed.

 -oprefix
specifies a prefix that you want placed in front of the output
filename. If you specify a directory name as a prefix, include the (/).
Any drive or directory prefixes in the input filename are discarded
before the new prefix is added. Do not include blanks in the prefix.

 -s
includes the section name at the beginning of each hunk.

 -u
specifies that you want the assembler to prefix external references
with an underscore (_). Do not use this option if you entered all
external names with leading underscores. You should specify this
option when you assemble startup code.

 -w
defines the symbol shortint to be 1. This option works as if you
had specified -dshortint= 1.

 For example, the following command assembles the file named
 modn.a, produces an object file named modn.o, and generates a
 listing file named modn. 1st that lists the source code and any error
 messages:


asm >modn.lst -l modn327




 Part 4
Using the SAS/C
Optimizer





  Chapter 12 Optimizing Your Code

328329





  12 Optimizing Your Code




 329 Introduction
 329 The Global Optimizer
 334 The Peephole Optimizer
 334 Running the Optimizers
 335 Global Optimization Compiler Options
 336 Global Optimization and the Debugger



 Introduction

 Your SAS/C Development System provides the following two
 optimizers:

 global optimizer (GO)
analyzes the intermediate code produced by the compiler, performs
several types of optimizations, and produces output in the same
form as the compiler. Because the global optimizer works on
intermediate code, it has no knowledge of the target processor or its
instructions.

 peephole optimizer
analyzes the assembler instructions and replaces inefficient
sequences of instructions with shorter, more efflcient sequences.



 The Global Optimizer

 The global optimizer optimizes the flow of control and data through an
 entire function. The global optimizer performs several types of
 optimizations:

 register assignment
analyzes the function to determine which auto variables, formal
variables, temporary values, and constant values should be assigned
to registers at each point in the function. The optimizer assigns up
to three address registers, four data registers, and, if a math
coprocessor is present, four floating point registers for the use of
register variables.
Generally speaking, the variables that are most used at a given
point are assigned to registers. For example, variables occurring in330 Chapter12




 loops are more likely to be assigned to registers. The global
 optimizer attempts to keep a variable assigned to a register for as
 long as possible.
Using the ampersand (&) operator with a variable prevents the
 global optimizer from allocating that variable to a register because
 it cannot predict when the resultant pointer will be used to read or
 modify the variable's value in memory. The same condition applies
 to an external variable because it may appear in another function
 or the & operator may be used with it elsewhere.
The effect of global optimization's register allocation is quite
 different from the use of the register storage class. In general, a
 variable declared using the register keyword is associated with a
 machine register throughout the entire block in which it is declared
 (usually the entire function). In most functions, the variable is
 heavily used in some places and not used in other places. Yet, if a
 machine register is assigned to the variable, then the same register
 cannot be reused even in those sections where the variable is not
 used. Therefore, global optimization changes a register's assigned
 variable during the evaluation of the expression to ensure that the
 most heavily used variables are always in machine registers.
The global optimizer overrides the register keyword in the
 declarations of integer, double, and pointer variables. Because of
 the portability of the C language, it is difficult for a programmer to
 know the number of available registers provided by the target
 machine and the compiler. The concept of a register variable is
 based on the idea that the variable is kept in a register for the
 entirety of its scope. Such restrictions no longer apply when a
 compiler uses the more advanced registration allocation algorithms
 in SAS/C software. Even though the compiler does not have
 dynamic information about program execution that would indicate
 which statements are executed more heavily, it can use the loop
 nesting structure to make a reasonable approximation.

  dead store elimination
 eliminates the assignment of a value to a variable if the value is not
 used. The assignment can be eliminated as in this example:

 index = 23;
  .
  .
  .
  /* code that does not refer to index */
  .
  .
  .
 index = 12;
331 Optimizing Your Code




 The first assignment to index can be removed. Since the global
optimizer inspects all references to the variable throughout the
entire function, even subtle dead stores are eliminated.

dead code elimination
eliminates code that never can be executed.

common subexpression merging
eliminates recalculation of values that have been computed
previously within the same function. For example, the following
code


 x = i / 3;
 y = i / 3 + 4;

can be changed to

 temp = i / 3;
 x = temp;
 y = temp + 4;

moving invariants out of loops
moves a calculation in a loop, whose value is the same on each
iteration, to the outside of the loop. For example, the loop


  for (i = O; i < j; i++)
  {
  a[i]= p->q.r[10];
  }

can be changed to

  temp = p->q.r[10];
  for (i = 0; i < j; i++)
  {
  a[i]= temp;
  }

Refer to the explanation for optloop later in this chapter for
more information about this type of optimization.

induction variable transformations
changes to addition loops containing multiplications (usually those
associated with array indexing).332 Chapter 12




  copy propagation
 eliminates definitions of the form leftvar = rightvar when all
 uses of leftvar have this definition as the single reaching
 definition and rightvar will not change before each use. This
 optimization supports other optimizations.

  constant propagation and folding
 replaces references to a variable with a constant when the variable
 is defined as that constant. If the variable is used only in
 expressions with a different type (for example, if an int variable is
 only used in a comparison with f loat variables), global
 optimization creates a constant of the correct type. If the variable is
 used only as a constant, global optimization eliminates the variable
 entirely. The following example demonstrates these optimizations:


  void f(double d)
  {
  i = 10;
  for (; d < i; ++d)
{
.
.
.
}
  return;
  }

 The previous code can be changed to the following:

  void f(double d)
  {
  for (; d < 10.0; ++d)
{
.
.
.
}
  return;
  }

Constant propagation is often useful in programs that contain
 inline functions since one or more parameters to the inlined
 function actually may be constants.333 Optimizing Your Code




auto variable elimination and remapping
eliminates unused auto variables and reassigns storage offsets. Often
the variable is unused because of previous optimizations.

very busy expression hoisting
moves an expression that is computed along all paths from a point
in the code to a single, common location. For example, the code

if (expression
 x = i + j;
else
 y = (i + j) * 2;

can be changed to

  temp = i + j;
  if (expression
x = temp;
  else
  y = temp * 2;

various reductions in strength
performs associative reordering of additive operations involving
constants to reduce the operation count.
 Various arithmetic operations involving constants are reduced in
strength.
 Conditional and logical expressions whose results are unused are
converted into corresponding if code. For instance, putchar
from stdio.h is implemented with a conditional expression. If the
result (the original character or an error indication) is not used, GO
converts it into if else code, eliminating a load into a register.

various control flow transformations
performs various transformations to eliminate unreachable code or
useless control structures.

reordering of operations to reduce value lifetimes
moves expressions with a single use adjacent to the operation that
uses them. This optimization helps reduce temporary lifetimes and
supports optimizations that move code around. For example, in the
following code, the computation of the address ~ p 1 i ] can be
moved after the call:


  P[i] = f();
334 Chapter 12




 The Peephole Optimizer
  The code generator contains all of the knowledge about the target
  processor and its instructions and makes full use of the 680x0
  instruction set. The code generator tries not to generate extra
  instructions, but the peephole optimizer can help catch the few places
  where this is not possible.
As stated earlier, the peephole optimizer analyzes the assembler
  instructions and replaces inefficient sequences of instructions with
  shorter, more efficient sequences. For example, for the following set of
  instructions, the peephole optimizer deletes the TST.L instruction:


 MOVE.LD1,D2
 TST. LD2
 BNE  LABEL


The test instruction is not needed because the condition codes for the
  branch instruction are set by the move instruction.
Currently, the peephole optimizer optimizes 22 patterns of assembler
  instructions. If you find additional patterns that the optimizer should
  recognize, contact the Technical Support Division at SAS Institute Inc.

  Running the Optimizers
  To run the optimizers, specify the appropriate compiler option:


  Option  Effect

  optimizeturns on both the global and peephole optimizers.
  optimizeturns on only the global optimizer.
  nooptpeep

  In many cases, optimized code is more difflcult to debug than non-
  optimized code. You may want to use the optimizer only after the main
  program has been tested and most errors have been corrected.335 Optimizing Your Code




Global Optimization Compiler Options
  The compiler accepts the following options to modify the operation of
the global optimizer:

optalias
  disables typebased aliasing assumptions. If optalias is used, the
  global optimizer uses worst-case aliasing. Using this option can
  significantly reduce the amount of optimization that can be
  performed. The nooptalias option is the default.

optcomplexity
  defines the complexity of functions considered small by
  optinline. For more information, refer to Chapter 8, "Compiling
  and Linking Your Program," of SAS/C Development System User's
  Guide, Volume I: Introduction, Compiler, Editor.

optdepth
  defines the maximum depth of function calls to be inlined. The
  range is 0 to 6, and the default value is 3.

optinline
  inlines small functions (as defined by optcomplexity) as well as
  those with the __inline keyword. The optinline option is the
  default when optimize is used. Refer to Chapter 11, "Using
  Amiga Specific Features of the SAS/C Language," in the SAS/C
  Development System User's Guide, Volume I, for information about
  the _\ts_inline keyword.

optinlocal
  inlines single-call static (local) functions.

optloop
  assumes that loops have multiple iterations when the number of
  iterations is variable. This assumption enables the movement of safe
  code out of loops. The optloop option is the default. For more
  information, see "moving invariants out of loops," earlier in this
  chapter.
When a loop is not executed at all, the moved code is executed in
  cases where it previously would not have been. For example, the
  code

for (i = 0; i < n; ++i)
for (j = 0; j < m; ++j)
 p[i * m + j] += 1;
336 Chapter 12




 can be changed to


  for (i = 0; i < n; ++i)
{
temp = i * m;
for (j = 0; j < m; ++j)
  p[temp + j] += 1;
}

 In the changed code, i*m can be calculated when m is less than or
 equal to 0. When optloop has been specified, there may be a
 small cost in time for every loop that is not executed. There is also
 a significant time saving for loops that are executed many times, as
 most are.
Some types of code may cause an exception, for example, division
 by 0. For this reason, the global optimizer restricts moved code to
 safe operations, including integral and pointer arithmetic other than
 division by 0, but not including iloating-point operations. The global
 optimizer avoids incorrect exceptions regard0ess of the setting of
 optloop.

 optrdepth
  defines the maximum level of recursive function calls to be inlined.
  The range is 0 to 6, and the default is 1.

 optsize
  disables optimizations that might sacrifice code size to save time.
  Only some loop optimizations do this. The nooptsize option is
  the default. Specifying both opttime and optsize may result in
  code that is both slower and larger than most optimized code.
  
 opttime
  disables optimizations that might sacrifice time to save space. The
  noopttime option is the default.


Global Optimization and the Debugger
  To use all the capabilities of the debugger, the lines in the source code
file must correspond exactly with the lines in the object code file.
Optimizing your code may change this correspondence. Also, the
debugger may not know about variables that the optimizer moves or
eliminates.
  If you use the debugger on optimized code, run the debugger in
 mixed mode by entering the following command on the debugger
 command line:


 opt source mixed337 Optimizing Your Code




In mixed mode, the debugger displays both assembly language
instructions and C source lines in the source window. Use the
assembly language code to determine if the variables you examine are
actually located where the debugger thinks they are.338339

Part 5
Appendix

  Appendixdiff File-Matching Algorithm
340341

Appendix
diff File-Matching Algorithm

This appendix describes the file-matching algorithm used by the diff
utility. The algorithm used by the diff utility is described in A
Technique for Isolating Differences Between Files by P. Heckel.*
The matching algorithm described by Heckel is simple, fast, and
effective. Briefly, it works as follows:

[] Identify those lines that occur only once in each file. Assume that
these lines match one another.
[] Sweep downward into the first file. Each time you come to a line L
that is already matched to the line L1 in the second file, examine the
next line. This second line is referred to as L+1.
[] If L+1 is the same as the corresponding line L1+1 in the second
file, then match those lines as well.
[] After this downward sweep is completed, sweep upward in the first
file attempting to match lines in the same way (except that you look
at L-1 and L1-1 when finding a matched line L).

The effect of the matching algorithm is to match blocks of text to each
other in the two files.
However, the algorithm frequently cross-matches single lines or two
blocks of lines. That is, lines L and L+k may be matched to lines L1
and L1-j. Consequently, after the process described previously is
completed, the matches must be untangled to generate a coherent
report of the differences. Therefore, the diff utility cross-matches
blocks and then unmatches the smaller of the blocks. This process is
an attempt to satisfy the notion that the differences reported should be
minimal.
In addition, this algorithm must first seed itself by identifying lines
that occur exactly once in each file. Therefore, this algorithm may fail
to match any lines even when there is an obvious match.

----------------------------------------------------------------------------
* Heckel, P. (1978), "A Technique for Isolating Differences Between Files,"
Communications of the ACM (April), 264-8.342 Appendix

For example, you may have two files with the following contents:

  File 1  File 2

  aaa bbb
  xxx xxx
  xxx xxx
  yyy zzz

  The algorithm will fail to match the blocks of xxx lines because it does
  not find any lines that occur exactly once in each file to seed the
  algorithm.343

Index

Anesting aliases 92
 positional parameters 90
-a option, smake utility 289 referencing aliases commands with
abort command, SC_SCMSG AREXX portback-tick character (`) 92
 262, 262-264syntax 89, 128
absolute addressing modes 313aliases for dump command in previous
absolute expressions 304  releases 146 147
accelerator keys 23-24, 29, 34alternate targets, smake utility 283 284
actions, smake utility 273altfile command, SC _ SCMSG AREXX port
actions gadget 267262
activate command 107, 111, 127altline command, SC _ SCMSG AREXX
Address field, tasks command 109  port 262
address parameter 118-119ampersand operator (&)
 examples 118-119 identifying addresses 118
 using with location parameter 40 using with global optimizer 330
addressesampersand symbol (&)
 absolute addressing modes 313special symbol in smake utility 277
 addressing modes supported by SAS/C and operator (&)
 assembler 312not used with register variables 58
 dumping 62 append block, diff utility 221
 forcing program counter-relativeAREXX interface 101
 addressing 311invoking editors 261-262
 register-direct addressing modes  313AREXX macros 101-104
 specifying with CSECT directive 311-314  command output 103-104
 specifying with SECTION directiveinvoking macros 102-103
 309-310  libraries.cpr 106
addsym option macros provided by CodeProbe 101-102
 adding to slink automatically 8, 9return codes 103
 generating H_SYMBOL hunk 8values returned from CodeProbe
 purpose 74 commands 103-104
AddTask function 114AREXX port 262-264
after optionargs command 130
 break command 49, 135  array-slice parameter 119-120
 go command 40, 42, 156 arrays
alias command 89-92, 128-129  displaying 31, 59-61
 See also define command  setting watches or watch breaks 71
 See also expand commandarrdim option, opt command 86 87, 165
 compared with define command 92,93 ASCII option, dump command 65-66
 displaying alias definitions 90asm command 323-326
 displaying current aliases 89-90 -c option 324
 escape characters 19 -d option 324
 examples 91, 128-129 -d symbol(=value) option  324
 expanding alias names  90, 91-h option  324-325344 Index


asm command (continued)used in array-slice parameter  119
 -i option 325wild card indicator 34
 -m0 option 325 asynchronous tasks 108
 -m2 option 325 at sign ((?)
 -m3 option 326oml utility 251, 253
 -m4 option 326replacing underscore in function names
 -o option 326  for compiler 318
 options supported  324  326  special symbol in smake utility 277
 s option 326 specifying octal numbers in assembler
 syntax 323 statement expressions 303
 u option 326auto variable elimination and remapping
 w OptiOII 326  333
__asm keyword 319  320  autoedit option, scmsg utility 255
assembler directives 304-308autoswap mode 29, 88
 See also specific directivesautoswap option, opt command 88, 165
assembly language 299 326
 addresses, specifying with CSECT
 directive 311 314B
 assembler directives 304-308
 assembler statements, writing 300-304-b option
 __asm keyword 319-320  diff utility  219
 calling assembler functions from C oml utility 253
 functiolls 314 321 smake utility 289
 calling C functions from assemblerback-tick character (`)
 fullctions 322 non-expansion of escaped macro
 communicating with C language 314-323definitions 92 93, 141
 control sections, defining 309-314 referencing aliased commands 92
 CSECT directive 310 314  backslash character (\)
 expressions, specifying 302 304continuing lines in aliases 90
 fields in source line 300-301 Control-\ for terminating oml 251
 format of source lines 300escape character in grep searches 227,
 macros, defining and using 308231, 232-233
 options supported by assembler 324-326 escape character preceding semicolon 93
 parameters=register option 318-319extending commands across lines 18
 passing parameters on the stack 315-318  interpretation in character strings 19,
 referencing global data 322-323  123
 returning values to calling function  special symbol in smake utility 277
 320 321  badchar option, opt command  87, 165
 rulming the assembler 323-326bclear command 131
 SECTION directive 309-310  definition 36, 48
 size sumxes, specifying 301 302examples 131
 writing assembly language functionssyntax 131
 300 314  bdisable command 48, 132
assembly mode benable command 48, 133
 ps command 47blist command 36, 48, 134
 setting 46, 83bottom command, SC_SCMSG AREXX
 trace command 45port 262
asterisk ( )  braces ({})
 grep search pattern 225, 226, 230-231  defining aliases 90
 removing all aliases 92using in cmd_list parameters 50
345 Index


brackets ([])C
 enclosing characters in grep search 226,
 228-230  C functions, calling
See calling assembler functions from
 branch instructionsC functions
 assembler statement size suffixes 302 See calling C functions from assembler
break command 48-53, 135 136functions
  See also bclear command  C mode 83
  See also bdisable command-c option
  See also benable command  asm command 324
  See also blist commanddiff utility 219
  after option 49, 135  grep utility 225
  cmd0ist parameter 50, 135 smake utility 289
  call command 137-138
  definition 39call frame 6
  examples 136calling assembler functions from C
  go command as last command of cmd list functions 314-321
 parameter 51 __asm keyword 319-320
  quiet option 52 53, 135 calling an assembler module 316
  syntax 48-49, 135parameters=register option 318-319
  temp option 52-53, 135  passing parameters on the stack 315  
  318
  trace option 51, 52-53, 135 retrieving parameters from the stack
  when option 49, 135317
  returning values to calling function
Break menu 21 22320-321
breakpointssaving register contents 317-318
  attaching actions to 50  53 stack, example 317
  caution against placing in libraries 110calling C functions from assembler
  conditional 49 50 functions 322
  definition 5, 32, 47Calls window l4
  executing up to a breakpoint 32 caret (^)
  multitasking programs 108 grep search pattern 226
  nesting 52  case option, opt command 85, 165
  catch command 107, 112, 139
  preventing debugger from stoppin 51 Catch New Devices option
  resident libraries 105, 106See devices option, opt command
  setting 32, 47-48catch option, opt command 89, 166
  temporary, set by go command 40, 43 change block, diff utility 221
  turning off 32  character classes, grep utility 226
  using with detach command 111 112 specifying 228-230
-buffer command-line option 78 79 characters and strings, dumping 65 66
build command, SC_SCMSG AREXX portclass command, SC _ SCMSG AREXX port
262clear command SC SCMSG AREXX port
Build menu, scmsg utility 259 262
built-in functions 202-203-cli command-line option 11, 79
  See also specific functions cmd_list parameter, break command 50,
  list of functions 203 135
  parameters 202  CNOP assembler directive 304
  purpose 202 Code Generation Options window 266
346 Index



CodeProbe 3-24command-line editing 16-19
 See also debugging programsdetermining editing modes 17
 basic features 4editing function keys 17-18
 changes and enhancements 5 escape characters in commands 19
 command line 16-19 escape sequences in character 
 compiling and linking programs 9 strings18 19
 controlling 8  extending commands across lines
 cpr command 9-10 using backslash (\) 18
 debugging procedure 7-8  command-line options 78-81
 entering commands 16-24adding as tool types 78
 function and special keys 22-23-buffer 78-79
 introduction 3 4-cli 11, 79
 line mode 11-command 79
 menu accelerator keys 23-24-device 97
 multitasking features 4-5  -i 79
 opening windows 15-16  -line 79
 pull-down menus 20-22  -nok 98
 quit command 10-noprofile 79-80
 requirements 7 -pipe 97
 running 9-11
 running on optimized code 336 337  -screen 80
 starting 25 34setting up in Workbench screen 11
 terminology 5_7-speed 97
 windowing interface 12-16  -startup 26, 80
 Workbench support 10-11-symfile 98
CodeProbe sample session 25-34  -unit 97
 activating autoswap mode 29using with cpr command 10
 breakpoints, setting 32-w 80
 clearing watches and watch breaks 34-wb. 11, 80
 compiling and linking 25-wd0alog 81
 continuing execution 30-wregister 81
 controlling debugging session 27-34-wsource 81
 displaying arrays and structures 30-32 -wwatch 81
 displaying variable values and types 32command output for AREXX macros
 executing breakpoints 32103-104
 executing until variable changes valuecommand parameter, help command 27
 33-34 commands
 go command 26  See also specific commands
 invoking the debugger 26address parameter 118 119
 online help 26-27  array-slice parameter 119
 quitting the debugger 34command-line editing 16-19
 restart command 26command-line equivalents for menu items
 source mode, setting 27-2820-22
 starting the debugger 25-26  customizing Dialog window commands
 stepping over code 29-30 89-94
 watch and watch break commands  32-34editing function keys 17-18
comma (,) editing modes 17
 separating multiple arguments in display entering on command line 16-19
 command 58escape characters in strings 18-19
command command line option 79expression parameter 120347 Index



  extending across lines using backslashcontrolling program execution
 (\) 18 See program execution, controlling
  function and special keys 22-23 copy propagation 332
  list of commands 116-118cover utility 216-218
  location parameter 120 121dir= option 217
  menu accelerator keys 23-24example 217-218
  number parameter 121  merge option 217
  pull-down menus 20-22 nosource option 217
  range parameter 121-122options supported 217
  register parameter 122-123running 216
  SC_SCMSG AREXX port 262-264syntax and description 216 217
  shortcuts for command names 16  cpr command 9-10
  speclal parameterS 118-125 available command-line options 10
  specifying in oml utility 252-253changing the default environment 11
  subrange parameter 123-124  -cli option 11
  syntax 16invoking the debugger 26
  type parameter 124  syntax 9, 75
  variable parameter 125  -wb option 11
  >prompt 16  .cpr extension for macros 102
  comment field, assembly language source cprinit file
line 301 comment lines 82
  comment lines, cprinit file 82examples 81-82
 communications parametersinitializing CodeProbe 81-82
  defining for cross debugging 97 suppresSing execution with -noprofile
 -device 97 option 79 80
 -pipe 97 CPRK
 -speed 97  See also cross-development mode
 -unit 97examples 99
comparing files options 98
  See diH utilityrequired on target machine 96
compilerrunning 96
 See sc command starting before CPRX 97, 98
compiler options, settingstarting the kernel 98
 See scopts utility terminating 99-100
Compiler Options Index window 266 CPRX
Compiler Options window 266 See also cross-development mode
compilingexamples 99
 compiling and linking programs 7-nok option 98
 sample program (lines.c) 25starting 98-99
condition control register (CCR) flags 110stripping debug information with -x
config= option, scmsg utility 255option 96
constants-symfile option 98
 assembler statement expressions 303syntax 98
 optimizing 332, 333terminating 99-100
 reductions in strength 333 -x option 99
context option, opt command 85, 166 cross-debugging 6
control flow transformations 333cross-development mode  95-100
control sections  See also CPRK
 See CSECT assembler directiveSee also CPRX
 See SECTION assembler directivedebugging applications 99348 Index



cross-development mode (continued)data structures, displaying
 defining communications parameters 97See structures, displaying
 examples 99  DC assembler directive 305
 host machine 96  DCB assembler directive 305
 Nl LL modem cable 96 deactivate command 107, 111, 140
 preparing to use cross debugger 96dead code elimination 331
 procedure 96 99  dead store elimination 330
 reasolls for cross-debugging 95-96Debug field, tasks command  109
 running cross debugger 96-100DEBUG tool 11
 starting the cross debugger (CPRX)debug= options 74-76
 98 99determining which option to use  76-77
 starting the kernel (CPRK) 98  list of options 74
 target machine 96debug=full option 74
 terminating CPRX and CPRK 99-100using 76
CSECT assembler directive 310-314when to use 76 77
 addressing modes supported 312debug=fullflush option 74
 definition 304 using 76
 forcing program counter-relativewhen to use 76-77
 addressing 311debug=line option 74
 format 310 generating H DEBUG hunks 8
 parameters 310 using 75
 program counter-relative addressing  debug=symbol option 74
 modes, examples 314generating H DEBUG hunks 8
  register-direct addressing modes 313  using 75-76
 specifying addresses 311-314when to use 76-77
 specifying immediate data 314debug=symbolflush option 74
 valid types and sizes of relocationadding to sc command 9
 informatioll 311displaying full debugging information 25
CTRL-C, terminating CPRK and CPRX  99using 76
Ctrl-L key 23when to use 76-77
Ctrl-W key 23 debugger
curly bracesSee CodeProbe
 See braces ({})  debugging environment, setting up 73-94
cllrrellt task, displaying 89alias command 89 92
cycles gadget  267  arrdim option 86-87
autoswap mode 88
badchar option 87
Dcase option 85
Catch New Devices option 88
d command catch option 89
 oml utility252changing default environment
 short form of display command 30with -cli and wb options 11
-d Option choosing command-line options 78-81
 asm command 324  context option 85
 smake utility 289current task 89
 splat utility 291customizing Dialog window commands
-d symbol(=value) option, asm command 89-94
324debug= options 74-76
data, examiningdebug=full option 76
 See dump command debug=fullflush option 76349 Index



 debug=line option 75 restart command 26
 debug=symbol option 75-76running CodeProbe 9-11
 debug=symbolflush option 76  sample program 1 37-38
 define command 92-93 sample program 2 53-56
 echo mode 84 setting breakpoints 32
 ibytes option 84-85  setting source mode 27-28
 ignorepath option 85 single stepping 44-47
 initializing CodeProbe  81-82starting the debugger 25-26
 list option 86stepping over code 29-30
 radix option 86  steps for debugging 8
 rangelen option 87trace commands 45-46
 search path 87 88watch and wbreak commands32-34,
 setting and showing options  82-89 70-72
 source file location 77 78watches and watch breaks 69-72
 source modes 83 84whatis command 68-69
 Step Into ResLib option 88 89  decimal option, dump command 65
 strlen option 86.DEFAULT fake target 281-282
 unalias command 92 default files, smake utility 287 288
 unassemble option 86#define capability, C preprocessor 93
 undefine command 94define command 141
 when to use debug= options76-77  compared with alias command 92, 93
debugging programs 25 34, 35 72compared with C preprocessor #define
 See also multitasking programs,  capability 93
 debugging  defining symbols to nothing 93
 See also resident libraries, debuggingdisplaying macro definitions 93
 activating autoswap mode 29examples 141
 break command 48-53syntax 93, 141
 breakpoints 47-53  delcomp command, SC_SCMSG AREXX
 clearing watches and watch breaks 34port 262
 commands for running sampledelete block, diff utility 220
 programs 36delete command, SC_SCMSG AREXX port
 compiling and linking programs 9, 25 263
 continuing execution 30delfile command, SC_SCMSG AREXX
 controlling program execution 27-34, port 263
 39-53  delnum command, SC_SCMSG AREXX
 display command 57 61port 263
 displaying arrays and structures 30-32dependent file, smake utility 273
 displaying variable values and types  32  detach command 111-112, 142
 dump command 61-66definition 107
 examining data and data structuresexamples 142
57-72 precautions 111-112
 executing breakpoints 32 syntax 111, 142
 executing until variable changes valuedevice command-line option 97
 33-34devices option, opt command 88, 166
 go command 26, 39-44Diagnostic Message Options window  266
 invoking the debugger 26Dialog window
 online help 26-27echo mode 84
 proceed commands 46-47functions 14
 quitting the debugger 34 open by default 12, 26
 register command 66-68scrolling 31350 Index



Dialog window (continued) special symbol in smake utility 277
 specifying start-up window coordinatesspecifying hexadecimal numbers in
 81 assembler statement expressions
 zooming to full size 30303
Dialog window commands-$ option, grep utility 225
 alias 89-92DS assembler directive 305
 customizing 89-94  dump command 61-66, 145 147
 wclear 34addresses, dumping 62
diff file-matching algorithm  341-342 ASCII option 65-66
diff utility 219-223  characters and strings, dumping  65-66
 append block 221 compared with register command 77
 -b option 219compatibility aliases 146-147
 -c option 219decimal option 65
 change block 221 examples 147
 delete block 220 float option 64
  error messageS 222-223  floating-point numbers, dumping  64-65
  examples 221-222format parameter 145
  -F option 219integers, dumping 65
  -L option 219pointers, dumping 63-64
  -I option 219ranges, dumping 62-63
  -o option 219syntax 61, 145
  options supported 219-220variables, dumping 61-62, 75
  -p Option 220 dzero command 148
  -q Option 220displaying ASCII text string 66
  syntax and description 219-221  examples 31, 148
  -w Option 220syntax 148
dir= option, cover utility 217
disassembling object modules (omd utility)  E
249
display command 57-61, 143-144  -e option, smake utility  289
 compared with register command 77  echo command 149
 examples 143-144echo option, opt command 84, 166
 expresslon parameter 57Edit menu, scmsg utility 260
 format parameter 57  AREXX for invoking editors 261-262
 multiple arguments 58examples 264-265
 overriding default format  57SC_SCMSG AREXX port 262-264
 string parameter 58  editcommand option, scmsg Project menu
 structures and arrays 30-32, 59-61 257
 syntax 57, 143editing modes 17
 value and type of variables 32 ELSE assembler directive 305
 variable types 75  END assembler directive 305
dollar parameter ($)ENDC assembler directive 305
 dump command 145ENDM assembler directive 305, 307
 line command 161env command 150-151
 set command 177environment 6
dollar sign ($)See also debugging environment, setting
 grep search pattern 227, 229, 231up
 indicating macros 277, 278representing state of the machine 14
 positional parameters in aliases 90, 128  run environment 6
 prefixing register names 119 user environment 6351 Index 



environment variable (sc/cprpath) 11FAIL assembler directive 305
EQU assembler directive 305 fake targets, smake utility 281-283
equals sign (=) file command, SC _ SCMSG AREXX port
 defining macros in smake utility 277-278 263
EQUR assembler directive 305file comparison
errnum command, SC_SCMSG AREXXSee diff utility
port 263 file dependencies, tracking
errors and warnings, searching forSee smake utility
 See scmsg utility  file-matching algorithm 341-342
escape characters 18-19 File menu
 alias command 19 Line and Find Current Line items 20
 backslash (\) in character strings 19menu items and command-line
 backslash (\) in grep searches 227 equivalents 20-22
 character strings 18-19finish command 100, 154
 commands 19flags, modifying
 double quotes (" ") around 18-19 See rflag command
 dumping with ASCII option 66float option, dump command 64
 single quotes (' ') around 19  floating-point instructions
 string parameter support 123 assembler statement size suffixes 301
exception hand0ing 113-114  floating-point numbers
exclamation mark (!)  dumping 64-65
 marking watch breaks 33  hexadecimal notation in assembler
 negation character in grep search 226,statement expressions 303
 230FORMAT assembler directive 305
execute command 152 format parameter
executing codedisplay command 57
  See program execution, controlling  dump command 145
EXITM assembler directive 305, 307  fregister command 155
expand command 153  function keys
expression parameter  actions performed 22-23
 display command 57command-line editing 17-18
  operators not accepted 120function line parameter, location
expressionsparameter 41
  absolute 304  function parameter, location parameter 41,
  optimizing subexpressions 331 42
  reductions in strength 333functions
  relocatable 304 See built-in functions
 reordering 333
 specifying in assembler statements
 302-304G
 very busy expression hoisting 333
gadgets in scopts utility 267 268
global data, referencing 322-323
  F global optimizer 329 333
  auto variable elimination and
-f optionremapping 332
 grep utility 225 common subexpression merging 331
  Istat utility 244constant propagation and folding 332
  smake utility 289control flow transformations 333
-F option, diff utility 219copy propagation 332352 Index



global optimizer (continued)  -f option 225
 dead code elimination 331-n option 225
 dead store elimination 330-331number of times characters may appear,
 induction variable transformations  331specifying 230-231
 moving invariants out of loops 331options supported 225
 optalias option 335  -p option 225
 optcomplexity option 335 patterns at beginning or end of line,
 optdepth option 335  specifying 231
 optinlille option 335patterns containing special characters,
 optinlocal option 335  specifying 232 234
 optloop option 335-336-q option 225
 optrdepth option 336 redirecting output 224
 optsize option 336-s option 225
 opttime option 336single character, specifying 228
 reduction5 in strengtll 333  specifying patterns  225-227
 register assignment 329-330  syntax 224
 reordering of operations 333 -v option 225
 runnirlg 333_337 -V option 225
 running the debugger on optimized code-$ option 225
336 337gst utility 237 239
 very busy expression hoisting 333error messages 239
global symbol information  8  examples 238 239
global symbol tables  list optlon 237 238
 See gst utility  options supported 237 238
 See hypergst utility syntax and description 237_238
go command 39-44, 156-157 unload option 238
 after clause 42, 156 verbose option238
 completing execution before running other
 commands 30H
 examples 44, l56 157
 executing until breakpoint 30, 32 -h option
 last command of cmd list parameter 51asm command 324-325
 location parameter 156smake utility 290
 location parameter forms 40 42 H_DEBUG hunks 7, 8
 parameters 40  help command 26 27, 158
 starting execution of sample program 26Help key 23
 syntax 39  Help menu 16
 syntax errors 43-44Help window 14
 when clause 42 44, 156 hidden option, scmsg Project menu  258
go main command 26, 80  hidden option, scmsg utility 255
gotofile option, scmsg Project menu 257hide command, SC_SCMSG AREXX port
gotoline option, scmsg Project menu 258263
greater than sign (>)host machine 6, 96
 See also redirecting output (>)hunks
 > prornpt for command line 16H_DEBUG hunks 7, 8
grep utility 224 236  H_SYMBOL hunks 8
 -c option 225  hunks command 159
 description 224 227hypergst utility 240-241
 error messages 234 236 hyphen (-)
 examples 227 specifying range in grep search 226353 Index



Ikeys
  function key actions 22-23
-i command-line option 79 function keys for command-line editing
-i option 17-18
 asm command 325  menu accelerator keys  23  24, 29, 34
 smake utility 290special keys 23
ibytes option, opt command 84 85, 166
IDNT assembler directive 305
IF assembler directive 305L
IFC assembler directive 305
IFD assembler directive 306 l command, oml utility 252
IFEQ assembler directive 306-l option
IFGE assembler directive 306  diff utility 219
IFGT assembler directive 306  tb utility 295
IFLE assembler directive 306-L option, diff utility 219
IFLT assembler directive 306label field, assembly language source line
IFNC assembler directive 306300
IFND assembler directive 306left-Amiga m keyboard shortcut  29, 34
IFNE assembler directive 306less than sign (<)
.IGNORE fake target 282diff utility 220
ignorepath option, opt command  85, 166oml utility 251
image 6 libraries
image parameter, location parameter 42See resident libraries, debugging
INCLUDE assembler directive 306 libraries, managing
infinite loops 112See oml utility
initializing CodeProbe  libraries.cpr AREXX macro 106
 See cprinit fileline boundary 6
Input window 15 line command, SC_SCMSG AREXX port
insert editing mode 17  263
instruction bytes-line command-line option 11, 79
 See ibytes option, opt command line parameter, location parameter 41
integers, dumping 65link library 250
interlace mode  link option 9, 25
 See -i command-line option linker
invoking the debugger See slink
 See cpr commandLinker Options window 267
linking programs 9, 25
LIST assembler directive 306
  J list command 161 162
list option
jump command  89, 160 gst utility 237
  opt command 86, 166
Listing/Cross Reference Options window
  K 266
lists gadget 267
-k option, smake utility 290LLEN assembler directive 306
kernel  load module 324
  See CPRK  local input files, smake utility 284-286
354 Index



location parameter 40 42, 123-124Memory window 15
 address parameter 40memory, dumping
 definition 40, 120See dump command
 forms 40memset function 207
 function line parameter 41 menu accelerator keys  23-24, 29, 34
 function parameter 41, 42, 121 menus
 go command 40 42, 156See pull-down menus
 image parameter 42, 120merge option, cover utility  217
 integer parameter 121  Message window 15
 line parameter 41See also wmsg command
 module parameter 42, 120MEXIT assembler directive306
 syntax 120 minus sign (-)
log command 163-164special symbol in smake utility  229, 277
log file 6  mixed mode 83-84
loops opt source mixed command 46, 77
 induction variable transformations 331running the debugger on optimized code
 moving invariants out of loops  331  336-337
Iprof utility 242 243 setting 83-84
Istat utility 244 248module 7
 -f option 244  module parameter, location parameter 42
 options supported 244  Modules window 15
 syntax and description 244 multiple targets, smake utility 283
 -t option 244  multitasking programs, debugging 107-114
  z option 244activate command 111
  asynchronous tasks 108
  breakpoints and task handling 108
M catch command 112
  CodeProbe features 4-5
-m option, tb utility 295 commands for controlling tasks 107,
MACRO assembler directive  306  109 113
macrosdeactivate command 111
 See also AREXX macrosdesign considerations 113-114
 See also define command  detach command 111-112
 defining assembly language macros  308exception hand0ing 113-114
 escaped macros not expanded 92-93opt task command 110 111
 hiding in double quotes 92symload command 112-113
macros, smake utility 277-281 synchronous tasks 108
 default macros 279-280task handling by CodeProbe  108
 defining transformation rules  280-281tasks command 109-110
 defining with equals sign (=)  277-278terminating tasks 108
 overriding definitions 278trap handling 113-114
 referring to macros 278  types of tasks 108
Map Options window 267  -m0 option, asm command 325
MASK2 assembler directive 306-m2 option, asm command 325
maximum bad characters  -m3 option, asm command 326
 See badchar option, opt command-m4 option, asm command 326
memcmp function 204
memcpy function 205
memmove function 206
Memory menu 22355 Index



N -n option 253
  -o option 253
-n option options, specifying 253
 grep utility 225 r command 252
 oml utility 253  -s option 253
 smake utility 290syntax and description  250-251
Name field, tasks command 109 -t option 253
name= option, gst utility 238 terminating 251
NARG assembler directive 306  -v option 253
nested breakpoints 52 x command 252
networks  -x option 253
  using for cross debugging 97@ command 253
next command, SC_SCMSG AREXX port.ONEERROR fake target 282
263  online help
nodebug option 74 See help command
NOFORMAT assembler directive 306OpenDevice function 114
-nok option 98  OpenLibrary function 114
NOLIST assembler directive 307  operand field, assembly language source
non-floating-point instructionsline 300
  assembler statement size suffixes 301  operation field, assembly language 
NOOB) assembler directive 307source line 300
NOPAGE assembler directive 307  operators
-noprofile command-line option 79-80  assembler statement expressions
nosource option, cover utility 217  303-304
NULL modem cable for cross debugging 96 OPSYN assembler directive 307
number parameter 121opt command 82-89, 165 167
numeric keypad modes  17  arrdim option 86-87, 165
  autoswap option 88, 165
  badchar option 87, 165
O case option 85, 165
  catch option 89, 166
-o option context option 85, 166
  asm command 326 devices option 88, 166
  diff utility 219displaying current task 89
  oml utility 253 echo option 84, 166
 splat utility 291env option 112
Object Module Disassembler 249examples 167
Object Module Librarianibytes option 84-85, 166
 See oml utility  ignorepath option 85, 166
objects, determining type or configuration  list option 86, 166
 See whatis commandradix option 86, 167
OFFSET assembler directive  307rangelen option 87, 167
omd utility 249reslib option 88 89, 167
oml utility 250-254search option 87-88, 166
 -b option 253source option 46, 77, 83, 84, 166, 336
  commands, specifying  252-253strlen option  86, 167
  d command 252syntax 165
  examples 254task option 107, 110-111, 167
  invoking 250unassemble option 86, 167
  I command 252 opt env command 112356 Index



opt source asm command 46Output window 15
opt source mixed command46, 77, 84,  overwrite editing mode  17
336
opt task command 110 111
 definition 107P
 examples 111
 task addresses 111 -p option
 task-lD argument 110 diff utility 2Z0
 using 110 111grep utility 225
optalias option, global optimizer 335 smake utility 290
optcomplexity option, global optimizer 335 PAGE assembler directive 307
optdepth option, global optimizer 335parameters=register option  318  319
optimized code, rumling debugger on  pass count 7, 40, 42
336-337specifying 135
Optimizer Optiolls window  266  patterns, searching for
optimizing codeSee grep utility
 See global optimizerpausing 179
 See peephole Optimizer peephole optimizer 329
optinline option, global optimizer 335functions 334
optinlocal option, global optimizer 335running 334
option results command (AREXX) 103beginning AREXX templates 261
optionsspecifying binary numbers in assembler
 See also command-line options
 See also debug= options statement expressions 303
 See also opt commandPeriod (.)
 See also scopts utility  grep wildcard character 225, 228, 230
-pipe command-line option 97
 addsym 8, 9, 74PLEN assembler directive 307
 cover utility options 217  plus sign (+)
 default options, displaying 82
 diff utility options 219 220 grep search pattern 226, 231
 global optimizer compiler options  portname option, scmsg Project menu 258
  335-336pound sign (#)
 grep utllity options 225 ANSI # and ## operators not supported
 lstat utility options 244Indicating comments m smakefiles 274
 oml utility options 253  inserting before undefine command 191
 parameters=register option 318-319  prev command, SC_SCMSG AREXX port
 scmsg utility options 255-256263
 scmsg utility Project menu optionsPri field, tasks command 109
 257 258printing expressions
 setting and showing within CodeProbe See grep utility
 82-89  proceed command 46-47, 168
 smake utility 289-290See also ps command
 splat utility 291assigned to Return key 29
 tb utility 295compared with trace command 44,
Options menu 20 2146 47
optloop option, global optimizer  335-336 definition 29, 39
optrdepth option, global optimizer 336examples 47, 168
optsize option, global optimizer 336  integer parameter 47
opttime option, global optimizer  336 syntax  46, 168357 Index



profile scripts quit option, scmsg utility 255
 See also cprinit file  quotes, double (" ")
 suppressing execution with -noprofiledefining aliases 90
 option 79-80 hiding macros 92
program counter-relative addressingsurrounding character strings 18
 examples 314 using in grep patterns 227
 forcing 31]quotes, single ('')
program execution, controllingenclosing literals in assembler statement
 See also debugging programsexpressions 303
 break command 48-53  surrounding character strings 19
 clearing watches and watch breaks 34
 continuing execution 30
 executing until variable changes value R
 33 34
 executing up to breakpoints 32 r command, oml utility 252
 go command 26, 30, 32, 39-44-r option
 proceed commands 29, 46-47tb utility 295
 setting breakpoints 32, 47-53radix option, opt command 86, 167
 single stepping 29, 44-47  range parameter 121 122
 stepping into called functions 29  rangelen option, opt command 87, 167
 stepping over code 29-30ranges
 trace commands 45-46  caution when using variables for setting
 using watch and watch break commandswatches 71
 32-33dumping 62-63
Project menu, scmsg utility 257-259re-attaching tasks 112
Prototype Generation Options window 267redirecting output (>)
ps command 169  diff utility 219
 assembly mode 47grep utility 224
 example 169lprof utility 242
 syntax 46, 169 lstat utility 244
public screen, specifying  80omd utility 249
public symbol 250oml utility 251
pull-down menus 20 22splat utility 291
 See also specific menustb utility 294
 list of pull-down menus and command-line  REG assembler directive 307
 equivalents  20-22register command 66-68, 171
See also fregister command
altering register contents 67-68
Qdetermining variable values 77
displaying register contents 67
q optionexamples 171
 diffutility 220syntax 66 67, 171
 grep utility 225 register-direct addressing modes 313
 smake utility 290register parameter 122-123
quiet option, break command  52-53, 135Register window 15, 81
quit command 170  registers
 quitting the debugger 10, 34altering contents 67-68
 SC_SCMSG AREXX port 263displaying contents 67
 syntax and description 170 effect of opt task command 110
 terminating CPRX  100  modifying  110358 Index



registers (continued)splat utility 291
 optimizing 329-330 tb utility 295
 saving contents before retrievingsample CodeProbe session
 arguments from stack 317See CodeProbe sample session
 scratch registers 318sample programs
relocatable expressions 304 commands for running sample
RemTask function 114  programs 36
resident libraries, debugging 105-106lines.c 25
 cautions for setting breakpoints 106,  sample program 1 37-39
 110sample program 2 53-56
 example 106sc.examples drawer 25
 libraries.cpr AREXX macro  106saving option settings in scopts utility
 limitations 106268-269
 setting breakpoints 105sc command
 symload command 106  adding addsym option to slink
reslib option, opt command  88-89, 167  automatically 8
restart command 172-173debug=symbolflush option 9, 25
 compared with start command 181  link option 9
 crashes caused by improper use 26parameters=register option 319
 definition 26, 36typical usage 9
 examples 1 73  SC_CPR 101
 running go command before using 30See also AREXX macros
 syntax and description 172 SC_SCMSG AREXX port 262-264
restoring previously saved options in scoptsscmsg utility 255-265
utility 269autoedit option 255
results variable, AREXX 103  Build menu 259
return codes available to AREXX macroscommand options 255-256
103config=option 255
return command 174Edit menu 260
Return key for executing proceed format of messages 256-257
command 29hidden option 255
REXX languageProject menu 257-259
 See AREXX interface quit option 255
rexxonly command, SC_SCMSG AREXX rexxonly option 256
port 264  syntax and description 255-257
rexxonly option, scmsg utility 256scopts utility 266-270
rflag command 175  entering options on command line 269
right-Amiga key 23 exiting without saving changes 269
RORG assembler directive307gadgets 267-268
run environment 6  restoring previously saved options 269
Run menu21  saving option settings 268-269
tasks performed by 269-270
windows for setting options 266-267
  Sscratch registers 318
  -screen command-line option 80
-s option script files
 asm command 326See cprinit file
 grep utility 225See profile scripts
 oml utility 253  scsetup utility 9, 271-272
 smake utility 290search command 176359 Index


search option, opt command87-88, 166 addsym option 8, 9
search path 87 88generating H_SYMBOL hunk 8
searching for expressionsstripdebug option 77
 See grep utility smake utility 273 290
searching for patterns  -a option 289
 See splat utility  actions performed by 274
SECTION assembler directive309-310  alternate targets 283 284
 definition 307 -b option 289
 format 309 -c option 289
 specifying addresses 309-310comments in smakefiles 274
segment listscreating and using default files 288
 assigning pointers 113 creating smakefiles 274-276
 determining address 112-d option 289
select command, SC_SCMSG AREXX port default (.def) files 287-288
264  default macros 279-280
semicolon (;)  defining transformation rules 280-281
 escaping with backslash (\) in echo-e option 289
 command 149-f option 289
 expanding alias names 90fake targets 281-283
 preceding with escape character 93 file dependencies, example 275
 using in cmd list parameters 50-h option 290
serial ports-i option 290
 using for cross debugging 97, 98-k option 290
SET assembler direetive 307 local input files 284  286
set eommand 177 178 macros 277-281
.SET fake target 282-283multiple targets 283
setenv command 11-n option 290
SetFunction 114 options 289-290
  setting up new projectsoverriding macro definitions 278
See scsetup utility -p option 290
 Shell  -q option 290
starting across serial line11running smake 288-290
shortcut keys 23-24, 29, 34 -s option 290
shortcuts for command names 16  smake.def file 287-288
show [activate] command, SC_SCMSGspecial symbols 277
AREXX port 264syntax 273, 289
SigWait field, tasks command 109-t option 290
.SILENT fake target 283 terminology 273
single stepping through programs 29,-u option 290
44-47-x option 290
size field, assembly language source linesmake.def file 287-288
300smakefile 273
size suffixes, assembler statements 301-302  source command 78, 180
slash (/)source file
 second character in Dialog window's title specifying location 77-78
 bar 17 source line fields, assembly language
sleep command 179 300 301
slinkcomment 301
 adding or stripping debugging  label 300
 information 7  operand 300360 Index



source line fields, assembly language strcpy function 210
(continued)string parameter 123
 operation 300  display command 58
 size 300support for escape characters 123
source modes 83-84strings, dumping 65 66
 assembly mode 45, 46, 47, 83 strings gadget 267
 C mode 83stripdebug option 77
 definition 27strlen function 211
 illustrations 26 strlen option, opt command  86, 167
  mixed mode 46, 83-84, 336structures
  setting 27-28, 83-84  displaying 30-31, 57, 59-60
  syntax of opt source command 83 setting watches or watch breaks 71
source option, opt command  83  84, 166subrange parameter 119, lZ3 124
Source window symbol 7
 functions 15See also debug=symbol option
 illustrations 26global symbol information 8
 open by default 12, 26symbol command 183
 specifying start-up window coordinatessymbol= option, gst utility 238
 81symbol tables, global
sourceis option 77-78See gst utility
SPC assembler directive 307 See hypergst utility
special keys 23-symfile option 98
-speed command-line option  97symload command 112-113, 184
splat utility 291-293debugging resident libraries 106
 -d option 291  definition 107
 description 291examples 184
 examples 291-293syntax and description 112-113, 184
 -o option 291
 -s option 291
 syntax 291T
 -v option 291
stack, assembly language programs 317 -t option
stack variables 110 oml utility 253
StackPtr field, tasks command 109smake utility 290
start command 181-182 -t= option, lstat utility  244, 245-248
 See also restart command target files, smake utility 273
starting the debugger 25-34 alternate targets 283 284
-startup command-line option 26, 80 fake targets 281-283
State field, tasks command 109  multiple targets 283
state of the machine  target machine 7, 96
 See environmentfiles required 96
statistics utilities  task addresses 111
 Iprof utility 242-243task ID 110
 Istat utility 244 248task option, opt command 107, 110  111,
Step Into ResLib option167
 See reslib option, opt commandtasks
stepping through codeSee also multitasking programs,
 See program execution, controlling debugging
strcat function 208 displaying current task 89
strcmp function  209turning task catching on or off 89361 Index


tasks command 109 110, 185transformation rules for macros, smake
 Address field 109  utility 280 281
  all option 110, 112 trap handling 113 114
  Debug field 109 ts command 45, 187
  definition 107  TTL assembler directive 308
  displaying tasks, example 109Type field, tasks command 109
  examples 185type parameter 124
 finding specific tasks 112
  Name field 109
  Pri field 109 U
  SigWait field 109
  StackPtr field 109  -u option
  State field 109asm command 326
  syntax and description 185smake utihty 290
tb utility 294-296  tb utility 295
 description 294-295  unalias command 92, 188
 examples 295-296 unassemble command 189 190
 -l option 295unassemble option, opt command  86, 167
 -m optlon 295undefine command 94, 191
 -r option 295underscore (_)
 -s option 295  replaced by @ sign for compiler 318
 syntax 294-unit command-line Option 97
  u option 295unload option, gst utility 238
 -v option 295user environment 6
 -x option 295utilities
temp option, break command  52-53, 135  See specific utilities
terminating programs and tasks
 See also quit command
 CodeProbe tasks 108V
 CPRK and CPRX 99
 oml utility 251  -v option
 scmsg utility 255  grep utility 225
text command, SC SCMSG AREXX portoml utility 253
264  tb utility 295
tool types, adding 78 -V option, grep utility 225
top command, SC _ SCMSG AREXX portvariable parameter 125
264variables
trace command 45 46, 186, 187assembler statement expressions302
 compared with proceed command 44,  displaying value and type 32
 46-47  dumping 61-62, 75
 debugging programs 45-46 verbose option, gst utility238
 definition 39View menu  21
 examples 45 46, 186
 integer parameter 45
 stepping into a called function 29 W
 syntax and description 45, 186
trace option, break command 51, 52  53,-w command line option 80
135-w option
traceback information, displayingasm command 326
 See tb utility diff utility 220362 Index



wait option, scmsg Project menu  258  where command 110, 198
watch breaks 32-34window command 199
 clearing 34  windowing interface 12-16
 creating 33See also specific windows
 example 34 functions of CodeProbe windows 14-16
 function 70opening windows 15
 marked by exclamation mark (!) 33  screen layout 12-13
 setting on structures or arrays 71windows displayed in scopts utility
 setting ranges 71  266-267
 slow execution while using  33, 72wlist command 69, 71, 200
 static by default 70 wmsg command 201
watch command 70-72, 192  Workbench process, invoking  80
 See also wbreak command  Workbench screen
 See also wclear commandinvoking CodeProbe 11
 See also wdisable command  running CodeProbe 10-11
 See also wenable command  specifying with -screen command-line
 See also wlist commandoption 80
 creating watches 33specifying with -w command-line option
 definibon 69 80
 examples 192 -wregister command-line option 81
 syntax and description 70, 192-wsource command-line option 81
-watch command line option 81 -wwatch command-line option 81
Watch window
 displaying watches and watch breaks 69,
 70X
functions 15
opening 335x command, oml utility 252
 specifying start-up window coordinates-x option
 81 omd utility 249
watches 26, 69  oml utility 253
 caution when using variables for rangessmake utility 290
 71 stripping debug information 96
 clearing 34tb utility 295
 creating 33using with CPRX 99
 dynamic by default 70XDEF assembler directive 308
 function 69-70 defining symbols in data section  309
 setting on structures or arrays  71referencing global data 322-323
-wb command-line option 11, 80XREF assembler directive 308
wbreak command 70-72, 193defining symbols in data section 309
wclear command 34, 194  referencing global data 322-323
-wdialog command-line option  81using with CSECT directive  311-312
wdisable command 195
wenable command 196
whatis command 68-69, 197 Z
 displaying value and type of variables 32
 examples 68-69, 197  -z option, Istat utility  244
 syntax and description 68, 197
when option
 break command 49, 135
  go command 40, 42-44, 156363 Index


Special Characters  @ (at sign)
  See at sign (@)
{} (braces) ' (single quotes)
 See braces ({})  See quotes, single ('')
\ (backslash character) " (quotes)
 See backslash character (\)  See quotes, double ("")
/ (slash)
 See slash (/)
= (equals sign)
 See equals sign (=)
[] (brackets)
 See brackets ([])
. (period)
 See period (.)
< (less than sign)
 See less than sign (<)
+ (plus sign)
 See plus sign ( +)
& (ampersand operator)
 See ampersand operator (&)
& (ampersand symbol)
 See ampersand symbol (&)
& (and operator)
 See and operator (&)
! (exclamation mark)
 See exclamation mark (!)
$ (dollar sign)
 See dollar parameter ($)
 See dollar sign ($)
 (asterisk)
 See asterisk (*)
; (semicolon)
 See semicolon (;)
^ (caret)
 See caret (^)
- (hyphen)
 See hyphen (-)
- (minus sign)
 See minus sign (-)
, (comma)
 See comma (,)
% (percent sign)
 See percent sign (%)
_ (underscore)
 See underscore (_)
> (greater than sign)
 See greater than sign (>)
 (back-tick character)
 See back-tick character (')
# (pound sign)
 See pound sign (#)




