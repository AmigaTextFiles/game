"Mapping the Amiga" by Rhett Anderson and Randy Thompson.  A comprehensive
guide to the inner world of the Amiga.  Covers libraries and hardware
registers.  Examples in C, Assembly Language, and Modula 2.


Preface

There are so many programming books for the Amiga. Why should there be 
another one?
Frankly, we wrote this book for ourselves. When we sit down to program, 
we find that no single book is enough. The typical Amiga programmer may 
have Commodore's official reference manuals, several Sybex, Abacus, and 
COMPUTE! books, the complete set of Amiga Transactor magazines, and even 
several printouts of downloaded programming information and source code, all 
scattered across desks, chairs, and, of course, the floor. As you know, program-
ming the Amiga is a tough job. You might spend an hour just tracking down 
the right source. What is the solution to this problem?
We turned for inspiration to two books that helped us in the past: Mapping 
the Atari by Ian Chadwick (1983, COMPUTE! Books) and Mapping the Commo-
dore 64 by Sheldon Leemon (1984, COMPUTE! Books). These books had it 
all-explanations of how the respective machines organized memory, detailed 
listings of what various memory locations were and how to use them, descrip-
tions of input/output registers, and discussions of the functions of various 
ROM routines.
These books were so detailed a programmer could literally write a program 
without putting fingerprints on a single other book.
But of course you can't really do the same thing for the Amiga. The above-
mentioned books were slightly over 200 pages. This book is more than twice as 
large and comes nowhere near to saying everything that can be said about the 
Amiga. If the Apple II's built-in software and hardware is an apartment, and the 
Commodore 64's is a townhouse, then the Amiga's is a Manhattan city block.
And the problem is not just a matter of scale. Unlike earlier computers, the 
Amiga doesn't set aside areas of memory for this or that purpose. Instead, the 
Amiga has libraries of routines, which can show up virtually anywhere in the 
RAM space of the machine. These routines aren't even all in ROM; some are 
loaded from disk. The screen is not in a fixed location. Commodore even 
threatens that the locations of the memory-mapped custom chips may change 
at any time. The Amiga doesn't go through all these contortions to be contrary. 
Instead, this level of indirection provides the Amiga with prodigious flexibility. 
Libraries and devices are easily upgraded and added. Peripherals and input de-
vices are easily accommodated.
 

Aware of the problems of scale and flexibility, we set out to accomplish a 
different and (somewhat) more reasonable task: to enable a programmer to use 
our book as a reference work that answers 90 percent of his or her questions. 
This task took the two of us a year. We couldn't have done it alone. We'd like 
to thank Stephen Levy, our editor, for his patience. We would also like to 
thank our friends and co-workers at Amiga Resource and COMPUTE!, and also, 
especially, our wives, for putting up with months of odd moods and the occa-
sional bout of crankiness. A special thanks goes out to Sheldon Leemon for his 
many suggestions and observations.

How to Use This Book:
First, we suggest a little window shopping. Browse among the chapters and the 
appendices. Ever wonder how the blitter works? Curious about the HAM video 
mode? Cruise through the Hardware chapter. Want to know how the Amiga 
organizes its data? Want to know how to use the Amiga's built-in functions? 
The Structures and Libraries chapters tell you. Becoming familiar with the 
structure and content of the book will pay off later.
If you're an expert programmer, we suggest a quick scan of the book. 
You'll probably use this book as a reference. Read the introductions to each 
chapter, and don't forget to check out the appendices.
The majority of the book consists of tables and charts-a compilation of 
vital programming information organized in understandable and usable for-
mats. Much of this information can't be found in any other single place. For ex-
ample, where else can you find a complete listing of library functions that gives 
the syntax of each function in C, machine language, and Modula-2?
Each major section of the book begins with an introduction that explains 
how to use the information that follows. So even if you're a beginner, you'll 
find this book a great way to learn about the Amiga's inner workings.
If you already have a stable of Amiga programming books, notice how the 
layouts of those books compare with ours. For instance, some books group 
functions by the library in which they're found; Mapping the Amiga orders the 
functions alphabetically. Knowing this can save you some time and help you 
learn how to use Mapping in conjunction with your other programming books.
If you don't have any other Amiga programming books, we'd like to sug-
gest a few. Commodore's set of reference manuals (published by Addison Wes-
ley) are invaluable. Be sure to get the latest set; new examples and tables have 
been included in every update so far. Sybex sells three excellent books: Eugene 
Mortimore's two-volume Amiga Programmer's Handbook and Rob Peck's Pro-
gramming the Amiga. Abacus publishes many Amiga books. Our favorites are 
Amiga System Programmer's Guide and Amiga Graphics Inside & Out. COMPUTE!
books also has many titles. We often turn to COMPUTE!'s Amiga Programming 
Guide and Sheldon Leemon's Inside Amiga Graphics. You'll also want a manual 
for the language you're using.

Programming and Mapping:
You can program the Amiga in just about any language you've ever heard of 
(with the possible exception of COBOL). Each language has different syntax, 
requirements, and interfacing details. For this book, we've supported the lan-
guages most familiar to us: Lattice C, M2S's M2Sprint Modula-2, and machine 
language. All programming examples given in this book were written using one 
of these languages. Users of other C and Modula-2 implementations should 
have little trouble using this book. If you use a different language, see the man-
ual for information about how structure offsets are named and what parameters 
are passed to the various system functions.
We hope this book will be useful to you. Don't hesitate to let us know 
what helped you and what you found lacking. Send mail to:

Rhett & Randy
COMPUTE! Publications
324 W. Wendover Ave., Suite 200
Greensboro, NC 27408

You might also be able to find us on your favorite online service, such as 
CompuServe, PLink, or GEnie. Ask your friendly local sysop.
As Bill Wilkinson said in the introduction to Mapping the Atari, good luck 
and happy mapping.
 
Notes from BSI: It took about eight hours to scan and fix the majority of
the typos caused by the scanner (HP ScanJet+) reading bold text incorrect-
ly.  For that reason, I have not scanned the "Structures" part of the book.
You can use you include files for DevPac2 instead.  (Or with Lattice, or
with...)  However, I have included the "hardware" part since I manually
typed that up when I first got my Amiga so I could learn where all the
hardware registers are.  Enjoy the text.  Any questions can be left to me
(Bansai) on Motherboard East 1.5 at 1(215)792-0167.  Slates!
-------------------------
Library Functions

The Amiga is an incredibly capable machine. It has so much to offer, from digi-
tized sounds and dazzling color graphics to a window-based user interface and 
a true multitasking operating system. Library functions are the key to accessing 
these features.
The Amiga's library functions are similar to the Commodore 64's ROM
Kernal subroutines, the IBM PC's BIOS interrupt calls, and the Apple Macin-
tosh's Toolbox procedures-they are a collection of routines that allow you to 
control almost every aspect of your computer. They're called functions because 
the majority of them were written in the C programming language. In C, all
user-defined commands are referred to as functions.

Linked Libraries
There are really two types of libraries on the Amiga: linked libraries and shared 
libraries. (Note: Amiga Basic and Modula-2 do not use linked libraries.)
Linked libraries are a collection of external functions that you make part of 
your program. When you link your program with Alink or Blink, each linked li-
brary function you use is brought in from one of the specified .lib files and
stuffed into your program. The Lattice C file lc.lib and the Manx C file c.lib are 
both examples of linked libraries.
The functions offered by a linked library are dependent upon your compil-
er or assembler. However, one linked library is common-amiga.lib. The
amiga.lib library offers common functions such as printf( ), atoi( ), and
BeginIO( ). Only amiga.lib is documented in this chapter. Language-specific 
linked libraries are explained in the manual that came with your compiler or 
assembler.
Using an amiga.lib function in C is incredibly easy: Simply call the func-
tion by name and then link your program with amiga.lib. For Lattice C users, 
linking with amiga.lib is automatic when you use the compiler's -L option.
Other compilers simply have you provide the amiga.lib filename as one of the 
library parameters in the Alink or Blink command sequence.
Accessing amiga.lib from machine language is a bit tougher. First you must 
declare that function with an XREF statement, preceding the function name with 
an underline character (xref _CreateExtIO, for example). Second, you must 
push the function arguments onto the stack, not place them into registers. To 
actually call the function you simply JSR to the function name, as in JSR
_CreateExtIO. Finally, you must remove the function arguments from the 
stack- the function does not do this for you. A simple addq.l #8,sp would suf-
fice for CreateExtIO( ) since this function accepts two long words (eight bytes) 
worth of arguments.
All of the amiga.lib functions are described in the function tables found at 
the end of this chapter. Here's the entry for amiga.lib's printf( ) function:
-------------------------
printf
Description:		prints a formatted string to the standard output (Lattice and Manx
			users: if you link with lc.lib or c.lib, this is not the function you're
			calling)
Library:		amiga.lib (linked library)
Modula-2 Module: 	none
Syntax:       		printf(string, values...)
C:            		void printf(char *, long...)
Machine Language: 	move.l #value,-(sp) ;may have several values
			pea string
			jsr _printf
			add.l #8,sp ;(2 arguments * 4 bytes = 8)
Modula-2:		not available
Arguments:string = pointer to string containing optional C formatting com-
	mands (%); if you're passing longword values on the stack (as
	shown above), be sure to follow the percent symbol with a lower-
	case L
	values = values or addresses of strings to print; this routine
	knows how many values are on the stack by checking the number
	of formatting commands in the string argument
Result:	none
-------------------------
The Machine Language entry in this table illustrates how you might call 
the printf( ) function from machine language. Specifically, it shows the order in 
which you must push the function's arguments onto the stack. In all cases, the 
arguments are pushed onto the stack in the order opposite to that shown in the 
Syntax entry (right to left instead of left to right).
In these crude machine language examples, all pointer arguments are 
placed onto the stack using a PEA instruction. In actual use, the argument's ad-
dress may be contained in a register or a memory location, in which case you 
would MOVE it onto the stack. The examples shown here use PEA simply so 
you understand that the function expects an address and not an actual value. If 
the argument is supposed to be a value, we place it onto the stack via a MOVE 
instruction.
  
For a real-world example, the following machine language program makes 
use of amiga.lib's printf( ) function to output the solution to a simple equation:
-------------------------
Program 1-1. Simple Addition

* Machine language example for using the printf( ) linked library function
* -Be sure to link with amiga.lib

* Hard-coded function offsets 
OpenLibrary  equ -552 
CloseLibrary equ -414 
Output       equ -60

AbsExecBase equ 4	;Absolute location of ExecBase pointer

   XREF printf	;Declaration for amiga.lib function
   XDEF SysBase	;Make this available to amiga.lib
   XDEF DOSBase	;Make this available to amiga lib
   XDEF stdout	;Make this available to amiga lib

SECTION code,CODE

* Short-but-effective startup code
   movea.l AbsExecBase,a6	;Pointer to IntuitionBase in a6
   move.l a6, SysBase		;Store it in external location for amiga.lib
   clr.l d0			;Version number goes in d0
   movea.l #DOSName,a1		;Pointer to library's name goes in a1
   ]sr OpenLibrary(a6)		;Open DOS library and return libBase in d0
   move.l d0, d0SBase		;Save library base pointer
   beq.s Abort2			;Abort if dos.library could not be opened
   move.l d0,a6			;Pointer to DOSBase in a6
   jsr Output(a6)		;Call Output to get an output file handle
   move.l d0, stdout		;and store it for amiga.lib
   beq.s Abortl			;Abort if unable to get a file handle

* Main program that adds Num1 and Num2 
move.l Num1,d0              	;Get Num1 into d0 
add.l Num2,d0              	;Add the two numbers and put result in d0

* Call printf( ) to print the addition result in decimal and in hex format
   move.l d0,-(sp)	;Push result onto stack for hex output
   move.l d0,-(sp)	;Push result onto stack for decimal output
   move.l Num2,-(sp)	;Push Num2 value on stack
   move.l Num1,-(sp)	;Push Num1 value on stack
   pea formatString	;Push address of formatString onto stack
   jsr printf		;Call printf( )
   add.l #20,sp		;Remove arguments from stack-
			;(5 arguments * 4 bytes = 20 bytes)

* Close DOS library
Abort1:
   move.l DOSBase,a1	;Pointer to DOSBase in a1
   move.l SysBase,a6	;Pointer to ExecBase in a6
   jsr CloseLibrary(a6)	;Call CloseLibrary( )

* Exit program
Abort2:
   clr.l d0		;Set return code
   rts			;Drop out of program
   

SECTION data,DATA

Num1:

   dc.l 8723	;Value 1 that will be added to
Num2:
   dc.l 434	;Value 2

 SysBase:
   dc.l 0	;Location to hold ExecBase pointer
 DOSBase:
   dc.l 0	;Location to hold DOSBase pointer
 stdout:
   dc.l 0	;Location to hold output handle

DOSName:
   dc.b 'dos.library',0	;Name of dos library

* The following statements define the format string to be used by printf( ) 
* Note that a lowercase L follows all percent symbols (%)-this is required 
* if you pass your values as 32-bit quantities, as we do in this program 
formatString: 
dc.b '%ld + %ld = %ld (%lx hex)',10,0

END
-------------------------
Shared Libraries 
When someone refers to an Amiga library, they're usually talking about a 
shared library. The same is true of this book.
As the name implies, a shared library is accessible to all Amiga programs. 
When you use a shared library function, its code does not become part of your 
program on disk; shared libraries are located in ROM (writable control memory 
on the Amiga 1000) or loaded into RAM from the libs directory of your Work-
bench disk.
Shared libraries are more memory conservative than linked libraries. Every 
program that accesses a function from a linked library must contain its own 
copy of that function. Only one copy of a shared library function ever needs to 
be in memory because all programs have access to it.
At this writing, there are 15 libraries available with Kickstart/Workbench 
1.3, each one covering a different aspect of the Amiga. For graphics program-
ming, you use the graphics.library; for creating windows, requesters, and pull-
down menus, you use the intuition.library; for disk access, you use the 
dos.library.
The clist.library has been removed from Kickstart 1.2 and 1.3, but it is 
available with Kickstart 1.1 and is documented here for the sake of complete-
ness. Two special libraries-romboot.library and version.library-are not cov-
ered in this chapter since the functions they contain are private to the Amiga's 
system software and cannot be called by the user.
------------------------- 
Opening and Closing Libraries 
A library must be opened before you can access its functions. Like your local 
Seven-Eleven store, the Exec library is always open. This works out rather well 
considering OpenLibrary( ), the one function required to open other libraries, is 
contained in Exec. When you link with startup code such as Lattice's c.o, the 
DOS library is opened for you as well. If you program with M2Sprint, you'll 
find that several libraries are automatically opened for you. 
You open a library using the aptly named OpenLibrary( ) function. 
OpenLibrary( ) expects two arguments: the library name and the library version 
number. (See Table 1-2 for a complete list of available libraries.) The sample 
code below shows the C, machine language, and Modula-2 syntax for using the 
OpenLibrary( ) function.

In C: 
libBase = OpenLibrary(libraryName,version);

In machine language: 
move.l ExecBase,a6   	;Pointer to ExecBase 
lea libraryName,a1 	;Pointer to the library's name goes in a1 
moveq #version,d0    	;Version number goes in d0 
jsr OpenLibrary(a6) 	;Open library and return libBase in d0 
move.l d0,libBase    	;Save library base pointer

In Modula-2: 
libBase := OpenLibrary(libraryName,version);

where libBase is the name of the library's base pointer, libraryName is the 
name of the library, and version is the lowest acceptable version of the library 
you require. In most cases, you should use a version number of 0 or 33. The 
following table explains all the possible version numbers you can use: 

Table 1 1. Library Version Numbers 
Version Number 	Kickstart Version
0		Any version
30		Kickstart version 1.0
31		NTSC Kickstart version 1.1
32		PAL Kickstart version 1.1
33		Kickstart 1.2 (the oldest version still supported)
34		Kickstart 1.3

If you specify a version that is higher than what is available on the Amiga 
you run your program, OpenLibrary( ) will fail and return a NULL value. If the 
library is opened successfully, the base address of the library is returned in libBase.
   

Table 1-2 shows the library base pointer names (libBase) and their corre-
sponding library names (libraryName) that you should use when opening a li-
brary. In machine language, you can use practically any name you choose, as 
long as you define an area in memory to store the pointer and label that loca-
tion using the name you select. By convention, it's recommended you use the 
library base pointer name provided in Table 1-2 and precede it with an under-
line character, as in the name _DOSBase. In Lattice C, you must use the names 
given below. If you don't, your program will compile and link correctly, and 
then happily guru when it is run.

Table 1-2. Library Names
Library Name			Library Base Pointer Name
clist.library			ClistBase (unavailable in Kickstart 1.2 and 1.3)
diskfont.library		DiskfontBase
dos.library			DOSBase (normally opened by startup code)
exec.library			ExecBase (ExecBase found at location 4)
expansion.library		ExpansionBase
graphics.library		GfxBase
icon.library			IconBase
intuition.library		IntuitionBase
layers.library			LayersBase
mathffp.library			MathBase
mathieeedoubbas.library		MathleeeDoubBasBase
mathieeedoubtrans.library	MathleeeDoubTransBase
mathtrans.library		MathTransBase
romboot.library			(system private-not accessible to user)
translator.library		TranslatorBase
version.library			(system private-not accessible to user)

When your program is finished, you must be sure to close all of the librar-
ies you opened. To accomplish this you use yet another aptly named Exec 
function, CloseLibrary( ). The only argument that the CloseLibrary( ) function 
requires is the base address of the library you wish to close. This is the same 
base address that was returned by OpenLibrary( ). Here are some examples on
using CloseLibrary( ):

In C and Modula-2 use:
CloseLibrary(libBase);

In machine language:
move.l libBase,a1	;libBase goes in register a1
move.l ExecBase,a6	;Pointer to ExecBase goes in a6
jsr CloseLibrary(a6) 	;Close the library
   

If you neglect to close a library, you run the risk of wasting memory since 
the system will not know if it can throw out an unused, RAM-based library.
-------------------------
Calling Functions 
The end of this chapter contains an alphabetical listing of every user-accessible 
Amiga library function. Each table entry gives the function's name; a brief de-
scription of that function; the library in which the function is contained; its 
negative offset from the library base (useful to the "take charge" machine lan-
guage programmer); the Modula-2 module in which it is contained; its syntax; 
its C, machine language, and Modula-2 usage; a description of its arguments 
(sometimes referred to as parameters); and a description of the value (if any) 
that is returned by the function. For example, here's the entry for Intuition's 
OpenWindow( ) function:

OpenWindow 
Description:     	opens an Intuition window 
Library:        	intuition.library 
Offset:         	-$00CC (-204) 
Modula-2 Module: 	Intuition 
Syntax:        		window = OpenWindow(newWindow) 
C:            		struct Window *OpenWindow(struct NewWindow *) 
Machine Language: 	d0 = OpenWindow(a0) 
Modula-2:       	OpenWindow(VAR newWindow: NewWindow): WindowPtr 
Arguments:     		newWindow = NewWindow structure that describes window to 
			open 
Result:		        window = pointer to Window structure; NULL if unsuccessful

The Syntax section gives you a general idea of what the function expects 
and what it returns. If you look at the C description, you can see that 
OpenWindow( ) expects a pointer to a NewWindow structure and returns a 
pointer to a Window structure. The Machine Language description shows that 
the Window pointer should be placed in a0 and the pointer to the opened Win-
dow is returned in d0 (all functions that return values return them in d0). For 
Modula-2, you can see you must pass the function a NewWindow structure 
and the value it returns is of type WindowPtr. The following C, machine lan-
guage, and Modula-2 programs are examples of how you can use this infor-
mation to open a window. Five library functions are used in these program: 
OpenLibrary( ), OpenWindow( ), Wait( ), CloseWindow( ), and CloseLibrary( ).
-------------------------  
Program 1-2. C Window

C code that opens a window and waits for you to close it

#include <intuition/intuition.h> /* Include Intuition stuff */

struct IntuitionBase *IntuitionBase = NULL; /* Define IntuitionBase */ 
struct Window *MyWindow = NULL; /* Define Window pointer */ 
struct NewWindow MyNewWindow = { /* Set up NewWindow structure */ 
0,12, 
200,100, 
-1 , -1 , 
CLOSEWINDOW, 
WINDOWCLOSE | WINDOWDEPTH | WINDOWDRAG | WINDOWSIZING | ACTIVATE, 
NULL, 
NULL, 
"Close Me", 
NULL, 
NULL, 
80,24, 
-1 , -1 , 
WBENCHSCREEN 
};

void main()

/* Open intuition.library */ 
if ((IntuitionBase=(struct IntuitionBase *) 
OpenLibrary("intuition.library",0))==NULL) 
exit(0);

/* Open window */ 
if ((MyWindow=(struct Window *)OpenWindow(&MyNewWindow))==NULL) ( 
CloseLibrary(IntuitionBase); 
exit(0);

/* Wait for user to click close box */ 
Wait(l<<MyWindow->UserPort->mp SigBit);

CloseWindow(MyWindow); /* Close window */ 
CloseLibrary(IntuitionBase); /* Close intuition.library */
-------------------------
Program 1-3. Machine Language Window

*Open a window and wait for user to close it

*Include Intuition stuff
INCLUDE "intuition/intuition.i"

*Address that holds pointer to ExecBase (this is ALWAYS 4) 
ExecBase equ 4

* Hard-coded function offsets-no need to link with amiga.lib with these! 
OpenLibrary equ -552 
CloseLibrary equ -414 
OpenWindow equ -204 
CloseWindow equ -72
 

Wait equ -318

   SECTION code,CODE

*Open intuition.library
   movea.l #IntuitionName,a1	;Library name in a1
   move.l #0,d0			;Version number in d0
   movea.l ExecBase,a6		;Pointer to ExecBase in a6
   jsr OpenLibrary(a6)		;Call OpenLibrary( )
   move.l d0, IntuitionBase	;Save intuition.library base
   beq.s Abort2			;Exit program if OpenLibrary fails

*Open a window
   movea.l #MyNewWindow,a0	;Pointer to NewWindow in a0
   move.l IntuitionBase,a6	;Pointer to IntuitionBase in a6
   jsr OpenWindow(a6)		;Call OpenWindow( )
   move.l d0,MyWindow		;Save pointer to newly opened window
   beq.s Abort1			;Exit program in OpenWindow fails

*Wait for user to click close box 
movea.l MyWindow,a0          	;Pointer to window's 
movea.l wd_UserPort(a0),a0 	;user port in a0
   move.b MP SIGBIT(a0),d1	;Window's signal bits
   moveq.l #l,d0		;Convert bit number to mask
   lsl.l d1,d0			;and place the result in d0
   movea.l ExecBase,a6		;Pointer to ExecBase in a6
   jsr Wait(a6)			;Call Wait( )

*Close the window
   movea.l MyWindow,a0		;Pointer to window in a0
   move.l IntuitionBase,a6	;Pointer to IntuitionBase in a6
   jsr CloseWindow(a6)		;Call CloseWindow( )

*Close intuition.library
Abort1:
   move.l IntuitionBase,a1	;Pointer to IntuitionBase in a1
   movea.l ExecBase,a6		;Pointer to ExecBase in a6
   jsr CloseLibrary(a6)		;Call CloseLibrary( )

*Exit the program
Abort2:
   clr.l d0	;Set return code
   rts	;Drop out of program

SECTION data,DATA

*NewWindow structure 
MyNewWindow: 
dc.w 0,12 
dc.w 200,100 
dc.b -1,-1 
dc.l CLOSEWINDOW 
dc.l WINDOWCLOSE|WINDOWDEPTH|WINDOWDRAG|WINDOWSIZING|ACTIVATE 
dc.l 0 
dc.l 0 
dc.l WindowTitle 
dc.l 0 
dc.l 0 
dc.w 80,24 
dc.w -1,-1 
dc.w WBENCHSCREEN
  

IntuitionName: 
dc.b 'intuition.library',0 ;Library name
WindowTitle:
   dc.b 'Close Me',0	;Text to appear in window's drag bar

   SECTION mem,BSS

_IntuitionBase:
   ds.l l	;Place to store IntuitionBase
MyWindow
   ds.l l	;Place to store Window pointer

END
-------------------------
Program 1-4. Modula-2 Window

MODULE SharedLibExample;
(* Modula-2 code that opens a window and waits for you to close it *)

FROM Intuition IMPORT NewWindow, WindowFlagSet, WindowFlags, IDCMPFlags, 
IDCMPFlagSet, ScreenFlagSet, WBenchScreen, WindowPtr, OpenWindow, 
CloseWindow;
FROM SYSTEM IMPORT BYTE, ADR, ADDRESS;
FROM Ports IMPORT WaitPort;

VAR 
newWindow: NewWindow; 
myWindowPtr: WindowPtr; 
dummy: ADDRESS;

BEGIN

(* Setup NewWindow structure *)

WITH newWindow DO 
LeftEdge := 0; TopEdge := 12; 
Width := 200; Height := 100; 
DetailPen := BYTE(0); BlockPen := BYTE(l); 
Title := ADR("Close Me"); 
Flags := WindowFlagSet{Activate,WindowClose,WindowDepth, 
WindowDrag,WindowSizing}; 
IDCMPFlags := IDCMPFlagSet{CloseWindowFlag}; 
Type := WBenchScreen; 
FirstGadget := NIL; 
CheckMark := NIL; 
Screen := NIL; 
BitMap := NIL; 
MinWidth := 80; MinHeight := 24; 
MaxWidth := -1; MaxHeight 
END;

(* Try to open window *)

myWindowPtr := OpenWindow(ADR(newWindow));

IF myWindowPtr # NIL THEN 
dummy := WaitPort(myWindowPtr^.UserPort); 
CloseWindow(myWindowPtr); 
END;
END SharedLibExample.
-------------------------  
Machine Language and Function Offsets 
In machine language, library functions are called with a JSR using address indi-
rect with displacement addressing mode, which generates the destination ad-
dress from the contents of register a6. For example, our previous machine 
language window program contains the following instructions:

OpenWindow equ -552

move.l _IntuitionBase,a6 ;Pointer to IntuitionBase in a6 
jsr OpenWindow(a6) ;Call OpenWindow( )

The MOVE instruction puts the base address of the Intuition library in reg-
ister a6. The label OpenWindow contains the offset of OpenWindow( ) function 
from the base address of Intuition. The JSR instruction combines the base ad-
dress with the offset to produce an actual destination address. By putting the 
base address in a6, we also tell OpenWindow( ) where its current library base is.
To tell you the truth, our machine language program is breaking a few 
rules because it hard codes the library offsets in the beginning of the program 
using EQU directives. Purists obtain their function offsets using XREF state-
ments. If we were to program this "by the book," the above lines would read 
xref _LVOOpenLibrary

move.l _IntuitionBase,a6      	;Pointer to IntuitionBase in a6 
jsr _LVOOpenWindow(a6) 		;Call OpenWindow( )

so the OpenWindow( ) offset would be obtained at link time. All of the pro-
gram's library calls could (and some would say, should) be coded this way.
Where does the _LVOOpenLibrary offset come from? Besides containing 
linked library functions, amiga.lib also contains the function offsets for every 
Amiga library. That's why so many machine language programs must be linked 
with amiga.lib. If you use the XREF method, you must precede all function 
names with an _LVO in order for amiga.lib to recognize them. If you hard-
code your offsets as we did in Program 1-3, however, you can call the func-
tions whatever you like-you won't even have to take the time to link with 
amiga.lib (unless, of course, you used one of amiga.lib's linked library 
functions).
------------------------- 
Final Notes 
There are a few macros included in the following function list. Accessing a 
macro is much like accessing a library function. In Modula-2, all supported 
macros are defined as standard procedures and placed into modules. With C 
and machine language, they are actual compiler/assembler macros that must be 
included in your source code. The include file, header file, and Modula-2 mod-
ule that contains the macro definitions are included in the macro's table entry.
A few last minute points should be made regarding the terminology used 
in the following list of functions: By convention, a NULL value is equivalent to 
0. The Modula-2 equivalent of NULL is NIL, which is defined as ADDRESS(0). 
In C, TRUE represents a nonzero value (usually equal to 1) and FALSE equals 
0. In Modula-2, TRUE and FALSE are elements of the type BOOLEAN. If you 
see an _fptr in a C usage description, it specifies a pointer to a function.
The following table is mainly for reference purposes-it's a place you can 
look up information about any Amiga library function, quickly and easily. For 
more details about using a specific function, we suggest you refer to the auto-
docs section of the Commodore-Amiga ROM Kernel Reference Manual.

-------------------------Functions Start Here-------------------------
AbortIO
Description:     	attempts to abort an I/O request already in progress
Library:        	exec.library
Offset:         	-$01E0 (-480)
Modula-2 Module: 	IO
Syntax:        		error = AbortIO(ioRequest)
C:            		long AbortIO(struct IORequest *)
Machine Language: 	d0 = AbortIO(a1)
Modula-2:		AbortIO(ioRequest: ADDRESS): LONGINT
Arguments:		ioRequest = IORequest block containing I/O request to abort
Result:			error = 0 if successful; nonzero error value if unsuccessful
-------------------------
ActivateGadget
Description:		activates a string gadget so the user does not have to click in the
			gadget box to bring up a cursor
Library:		intuition.library
Offset:			-$01CE (-462)
Modula-2 Module: 	Intuition
Syntax:			success = ActivateGadget(gadget, window, requester)
C:            long ActivateGadget(struct Gadget *, struct Window *, struct 
Requester *)
Machine Language: 	d0 = ActivateGadget(a0, a1, a2)
Modula-2:		ActivateGadget(gadget: GadgetPtr; window: WindowPtr; request-
			er: RequesterPtr): BOOLEAN
Arguments:		gadget = string gadget to activate
			window = window containing gadget
			requester = requester to receive gadgets; NULL if gadgets are not
			to be part of a requester
Result:			success = TRUE if successful; FALSE if arguments are bogus
-------------------------
ActivateWindow
Description:		activates a window
Library:		intuition.library
Offset:			-$01C2 (-450)
Modula-2 Module: 	Intuition
Syntax:        		ActivateWindow(window)
C:            		long ActivateWindow(struct Window *)
Machine Language: 	ActivateWindow(a0)
Modula-2:		ActivateWindow(window: WindowPtr)
Arguments:		window = window to activate
Result:			none
-------------------------
AddAnimOb
Description:		adds an AnimOb to the linked list of AnimObs
Library:		graphics.library
Modula-2 Module: 	Gels
Offset:         	-$009C (-156)
Syntax:        		AddAnimOb(anOb, anKey, rastPort)
C:            		void AddAnimOb(struct AnimOb *, long, struct RastPort *)
Machine Language: 	AddAnimOb(a0, a1, a2)
Modula-2:		AddAnimOb(anOb: AnimObPtr; anKey: ADDRESS; rastPort:
			RastPortPtr)
Arguments:		anOb = AnimOb structure to be added to list
			anKey = address of pointer to the first AnimOb in the list
			(anKey=NULL if none in list so far)
			rastPort = RastPort structure
Result:			none
-------------------------
AddBob
Description:     	adds a Bob to GEL list
Library:        	graphics.library
Offset:         	-$0060 (-96)
Modula-2 Module: 	Gels
Syntax:        		AddBob(bob, rastPort)
C:           		void AddBob(struct Bob *, struct RastPort *)
Machine Language: 	AddBob(a0, a1)
Modula-2:		AddBob(bob: BobPtr; VAR rastPort: RastPortPtr)
Arguments:		bob = Bob structure to be added to GEL list
			rastPort = RastPort structure
Result:			none
-------------------------
AddConfigDev
Description:		adds a new ConfigDev structure to the system's list of configura-
			tion devices
Library:		expansion.library
Offset:			-$001E (-30)
Modula-2 Module: 	ConfigVars
Syntax:        		AddConfigDev(configDev)
C:            		void AddConfigDev(long)
Machine Language: 	AddConfigDev(a0)
Modula-2:		AddConfigDev(configDev: ConfigDevPtr)
Arguments:		configDef = a valid ConfigDev structure
Result:			none
-------------------------
AddDevice
Description:		adds a device to the system
Library:		exec.library
Offset:			-$01B0 (-432)
Modula-2 Module: 	Devices
Syntax:        		AddDevice(device)
C:            		void AddDevice(struct Device *)
Machine Language: 	AddDevice(a1)
Modula-2:      		AddDevice(device: DevicePtr)
Arguments:     		device = initialized device node
Result:			none
-------------------------
AddDosNode
Description:     	mounts a disk
Library:        	expansion.library
Offset:         	-$0096 (-150)
Modula-2 Module: 	Expansion
Syntax:        		AddDosNode(bootPri, flags, deviceNode)
C:            		void AddDosNode(long, long, struct dosNode *)
Machine Language: 	AddDosNode(d0, d1, a0)
Modula-2:		AddDosNode(bootPri: INTEGER; flags: BITSET; deviceNode:
			DeviceNodePtr): BOOLEAN
Arguments:		bootPri = boot priority of disk-+5 for floppy disk, 0 for hard
			disk,-5 for a network disk,-128 non-bootable device
			flags = ADN_STARTPROC (1) to start handler process
			immediately
			dosNode = initialized device node, as returned by
			MakeDosNode( )
Result:			none
-------------------------
AddFont
Description:		adds a font to the system
Library:		graphics.library
Offset:			-$01E0 (-480)
Modula-2 Module: 	Text
Syntax:        		AddFont(textFont)
C:            		void AddFont(struct TextFont *)
Machine Language: 	AddFont(a1)
Modula-2:		AddFont(textFont: TextFontPtr)
Arguments:		textFont = TextFont structure (in public RAM) to add
Result:			none
-------------------------
AddFreeList
Description:		adds memory to the free list
Library:		icon.library
Offset:			-$0048 (72)
Modula-2 Module: 	Icon
Syntax:        		status = AddFreeList(free, mem, len)
C:            		long AddFreeList(struct FreeList *, char *, long)
Machine Language: 	d0 = AddFreeList(a0, a1, a2)
Modula-2:       	AddFreeList(free: FreeListPtr; mem: ADDRESS; len:
			LONGCARD): BOOLEAN
Arguments:		free = FreeList structure
			mem = memory to record
			len = length of the memory to record
Result:			status = nonzero value if the call succeeded
-------------------------
AddGadget
Description:		adds gadget to window
Library:		intuition.library
Offset:			-$002A (-42)
Modula-2 Module: 	Intuition
Syntax:        		position = AddGadget(window, gadget, position)
C:            		long AddGadget(struct Window *, struct Gadget *, long)
Machine Language: 	d0 = AddGadget(a0, a1, d0)
Modula-2:		AddGadget(window: WindowPtr; gadget: GadgetPtr; position:
			INTEGER): INTEGER
Arguments:		window = window to contain gadget
			gadget = gadget to add
			position = position in gadget list for new gadget; -1 for end of
			list
Result:			position = position where gadget is actually added
-------------------------
AddGList
Description:		adds or inserts a gadget list to an existing gadget list
Library:		intuition.library
Offset:			-$01B6 (-438)
Modula-2 Module: 	Intuition
Syntax: 	    	position = AddGList(window, gadget, position, numGadgets, 
			requester)
C:		        long AddGList(struct Window *, Gadget *, long, long, struct
			Requester *)
Machine Language: 	d0 = AddGList(a0, a1, d0, d1, a2)
Modula-2:		AddGList(window: WindowPtr; gadget: GadgetPtr; position:
			INTEGER; numGadgets: INTEGER; requester: RequesterPtr):
			CARDINAL

Arguments:		window = window to receive gadgets
			gadget = first gadget in new gadget list
			position = position in existing gadget list where new gadget list
			should be added
			numGadgets = number of gadgets to add
			requester = requester to receive gadgets; NULL if gadgets are not
			to be part of a requester
Result:			position = position where gadget list is actually added
-------------------------  
AddHead
Description:   		inserts a node at the head of a list
Library:        	exec.library
Offset:         	-$00F0 (-240)
Modula-2 Module: 	Lists
Syntax:        		AddHead(list, node)
C:            		void AddHead(struct List *, struct Node *)
Machine Language:	AddHead(a0, a1)
Modula-2:		AddHead(list: ListPtr; VAR node: NodePtr)
Arguments:		list = list header
			node = node to insert
Result:			none
-------------------------
AddIntServer
Description:		adds an interrupt server to the system
Library:		exec.library
Offset:			-$00A8 (-168)
Modula-2 Module: 	Interrupts
Syntax:        		AddlntServer(intNum, interrupt)
C:            		void AddIntServer(long, struct Interrupt *)
Machine Language: 	AddIntServer(d0, a1)
Modula-2:		AddIntServer(intNum: CARDINAL; interrupt: InterruptPtr)
Arguments:		intNum = portia interrupt bit (0-4)
			interrupt = interrupt server node
Result:			none
------------------------
AddLibrary
Description:		adds a library to the system
Library:		exec.library
Offset:			-$018C (-396)
Modula-2 Module: 	Libraries
Syntax:       		AddLibrary(library)
C:            		void AddLibrary(struct Library *)
Machine Language: 	AddLibrary(a1)
Modula-2:       	AddLibrary(library:LibraryPtr)
Arguments:      	library = initialized Library structure
Result:			none
-------------------------
AddMemList
Description:		adds memory to the system's pool of free memory
Library:        	exec.library
Offset:         	-$026A (-618)
Modula-2 Module: 	Memory
Syntax:        		AddMemList(size, attributes, pri, base, name)
C:            		void AddMemList(long, long, long, char *, char *)
Machine Language: 	AddMemList(d0, d1, d2, a0, a1)
Modula-2:		AddMemList(size: LONGCARD; attributes: MemReqSet; pri:
			INTEGER; base: ADDRESS; name: STRPTR)
Arguments:		size = size of memory block in bytes
			attributes = type of memory-MEMF_PUBLIC, MEMF_CHIP,
			MEMF_FAST, MEMB_CLEAR
			pri = priority of memory-CHIP memory has a priority of -10;
			16-bit expansion memory has a priority of 0
			base = address of the first location in the memory block
			name = name to be used in memory header; NULL for no name
Result:			none
-------------------------
AddPort
Description:		adds a message port to the system
Library:		exec.library
Offset:			-$0162 (-354)
Modula-2 Module: 	Ports
Syntax:        		AddPort(port)
C:            		void AddPort(struct MsgPort *)
Machine Language: 	AddPort(a1)
Modula-2:		AddPort(port: MsgPortPtr)
Arguments:		port = message port to add
Result:			none
-------------------------
AddResouree
Description:		adds a resource to the system
Library:		exec.library
Offset:			-$01E6 (-486)
Modula-2 Module: 	Resources
Syntax:        		AddResource(resource)
C:            		void AddResource(struct Resource *)
Machine Language: 	AddResource(a1)
Modula-2:		AddResource(resource: ResourcePtr)
Arguments:		resource = resource node
Result:			none
-------------------------
AddSemaphore
Description:		attaches a signal semaphore to the system
Library:		exec.library
Offset:			-$0258 (-600)
Modula-2 Module: 	Semaphores
Syntax:        		AddSemaphore(signalSemaphore)
C:            		void AddSemaphore(struct SignalSemaphore *)
Machine Language: 	AddSemaphore(a1)
Modula-2:		AddSemaphore(signalSemaphore: SignalSemaphorePtr)
Arguments:		signalSemaphore = initialized SignalSemaphore structure
Result:			none
-------------------------
AddTail
Description:		appends a node to the tail of a list
Library:		exec.library
Offset:			-$00F6 (-246)
Modula-2 Module: 	Lists
Syntax:        		AddTail(list, node)
C:            		void AddTail(struct List *, struct Node *)
Machine Language: 	AddTail(a0, a1)
Modula-2:		AddTail(list: ListPtr; node: NodePtr)
Arguments:		list = list header
			node = node to insert
Result:			none
-------------------------
AddTask
Description:		adds a task to the system
Library:		exec.library
Offset:			-$011A (-282)
Modula-2 Module: 	Tasks
Syntax:        		AddTask(task, initialPC, finalPC)
C:            		void AddTask(struct Task *, char *, char *)
Machine Language: 	AddTask(a1, a2, a3)
Modula-2:		AddTask(task: TaskPtr; initialPC, finalPC:ADDRESS)
Arguments:		task = task control block
			initialPC = initial entry point
			finalPC = address of entry point of finalization code
Result:			none
-------------------------
AddTOF
Description:		adds a task to the TopOfFrame (vertical-blanking interval) inter-
			rupt server chain
Library:		amiga.lib (linked library)
Modula-2 Module: 	none
Syntax:       		AddTOF(i, p, a)
C:            		void AddTOF(struct Isrvstr *, APTR, APTR)
Machine Language: 	pea a
			pea p
			pea i
			jsr _AddTOF
			add.l #12,sp
Modula-2:		not available
Arguments:		i = Isrvstr structure
			p = entry point of routine to call at every vertical blank
			a = array of long words that will receive routine's arguments
Result:			none
-------------------------
AddVSprite
Description:		adds VSprite to GEL list
Library:		graphics.library
Offset:			-$0066 (-102)
Modula-2 Module: 	Gels
Syntax:       		AddVSprite(vSprite, rastPort)
C:            		void AddVSprite(struct VSprite *, struct RastPort *)
Machine Language: 	AddVSprite(a0, a1)
Modula-2:      		AddVSprite(vSprite: VSpritePtr; rastPort: RastPortPtr)
Arguments:     		vSprite = initialized VSprite structure
			rastPort = RastPort structure
Result:			none
-------------------------   
afp
Description:     	converts an ASCII string into a fast floating point number
Library:        	amiga.lib (linked library)
Modula-2 Module: 	none
Syntax:        		fnum = afp(string)
C:           		float afp(char *)
Machine Language: 	pea string
			jsr _afp ;fnum returned in d0/d1
			addq.l #4,sp
Modula-2:		not available; use ConvStrToReal in RealConversions module
Arguments:		string = string to convert
Result:			fnum = floating point equivalent of string arguments
-------------------------
Alert
Description:		alerts the user of a serious error
Library:		exec.library
Offset:			-$006C (-108)
Modula-2 Module: 	Alerts
Syntax:        		Alert(alertNum, flags)
C:            		void Alert(long, char *)
Machine Language: 	Alert(d7, a5)
Modula-2:		Alert(alertNum: LONGCARD; flags: LONGCARD)
Arguments:		alertNum = alert number
			flags = second part of Guru Meditation number (usually the ad-
			dress of the offending task)
Result:			none
-------------------------
AllocAbs
Description:		allocates a block of memory from a specified location
Library:		exec.library
Offset:			-$00CC (-204)
Modula-2 Module:	 Memory
Syntax:        		memoryBlock = AllocAbs(byteSize, location)
C:            		void *AllocAbs(long, void *)
Machine Language: 	d0 = AllocAbs(d0, a1)
Modula-2:     		AllocAbs(byteSize: LONGCARD; location: ADDRESS): ADDRESS
Arguments:     		byteSize = size of desired block in bytes
			location = address where the memory must be
Result:			memoryBlock = pointer to allocated block; NULL if unsuccessful
------------------------- 
Allocate
Description:		allocates a block of memory
Library:        	exec.library
Offset:         	-$00BA (-186)
Modula-2 Module: 	Memory
Syntax:        		memoryBlock = Allocate(freeList, byteSize)
C:            		void *Allocate(struct MemHeader *, long)
Machine Language: 	d0 = Allocate(a0, d0)
Modula-2:		Allocate(freeList: MemHeaderPtr; byteSize: LONGCARD):
			ADDRESS
Arguments:		freeList = memory list header
			byteSize = size of desired block in bytes
Result:			memoryBlock = pointer to allocated block; NULL if unsuccessful.
-------------------------
AllocBoardMem
Description:		allocates expansion board memory
Library:		expansion.library
Offset:			-$002A (-42)
Modula-2 Module: 	Expansion
Syntax:        		startSlot = AllocBoardMem(slotSpec)
C:           		long AllocBoardMem(long)
Machine Language: 	d0 = AllocBoardMem(d0)
Modula-2:		AllocBoardMem(slotSpec: INTEGER): INTEGER
Arguments:		slotSpec = number of slots to allocate
Result:			startSlot = slot allocated; -1 if unsuccessful
------------------------
AllocCList
Description:		allocates and initializes a clist
Library:		clist.library
Offset:			$0024 (-36)
Modula-2 Module: 	none
Syntax:        		cList = AllocCList(cLPool)
C:            		long AllocCList(long)
Machine Language: 	d0 = AllocCList(a1)
Modula-2:      		not available
Arguments:     		cLPool = initialized CListPool
Result:			cList = longword cList descriptor; negative if unsuccessful.
------------------------- 
AllocConfigDev
Description:  		allocates a ConfigDev structure
Library:        	expansion.library
Offset:         	-$0030 (-48)
Modula-2 Module: 	ConfigVars
Syntax:        		configDev = AllocConfigDev( )
C:            		struct ConfigDev *AllocConfigDev(void)
Machine Language: 	d0 = AllocConfigDev( )
Modula-2:		AllocConfigDev( ): ConfigDevPtr
Arguments:		none
Result:			configDef = a valid ConfigDev structure; NULL if unsuccessful
-------------------------
AllocEntry
Description:		allocates many regions of memory
Library:		exec.library
Offset:			-$00DE (-222)
Modula-2 Module: 	Memory
Syntax:        		memlist = AllocEntry(memlist)
C:            		struct MemList *AllocEntry(stuct MemList *)
Machine Language: 	d0 = AllocEntry(a0)
Modula-2:       	AllocEntry(memList: MemListPtr): MemListPtr
Arguments:      	memList = initialized cList pool
Result:         	memList = different memList filled with allocated memory
------------------------
AllocExpansionMem
Description:     	allocates expansion memory
Library:        	expansion.library
Offset:         	-$0036 (-54)
Modula-2 Module: 	Expansion
Syntax:        		startSlot = AllocExpansionMem(numSlots, slotOffset)
C:            		CPTR AllocExpansionMem(long, long)
Machine Language: 	d0 = AllocExpansionMem(d0, d1)
Modula-2:      		AllocExpansionMem(numSlots, slot Offset: INTEGER): INTEGER
Arguments:     		numSlots = number slots to allocate
			slotOffset = boundary offset
Result:			startSlot = slot allocated; -1 if unsuccessful
------------------------- 
AllocMem
Description:		allocates many regions of memory
Library:        	exec.library
Offset:         	-$00C6 (-198)
Modula-2 Module: 	Memory
Syntax:        		memoryBlock = AllocMem(byteSize, requirements)
C:            		void *AllocMem(long, long)
Machine Language: 	d0 = AllocMem(d0, d1)
Modula-2:		AllocMem(byteSize: LONGCARD; requirements: MemReqSet):
			ADDRESS
Arguments:		byteSize = size of desired block in bytes
			requirements = type of memory-MEMF_PUBLIC,
			MEMF_CHIP, MEMF_FAST, MEMB_CLEAR
Result:			memoryBlock = pointer to allocated block
-------------------------
AllocRaster
Description:		allocates space for a bit plane
Library:		graphics.library
Offset:			-$01EC (-492)
Modula-2 Module: 	Rasters
Syntax:        		raster = AllocRaster(width, height)
C:            		PLANEPTR AllocRaster(long, long)
Machine Language: 	d0 = AllocRaster(d0, d1)
Modula-2:		AllocRaster(width, height: CARDINAL): PlanePtr
Arguments:		width = width of bitplane in pixels
			height = height of bitplane in pixels
Result:			raster = pointer to allocated memory; NULL if unsuccessful
-------------------------
AllocRemember
Description:		calls AllocMem and creates a link node
Library:		intuition.library
Offset:			-$018C (-396)
Modula-2 Module: 	Intuition
Syntax:        		memoryBlock = AllocRemember(rememberKey, size, flags)
C:            		char *AllocRemember(struct Remember *, long, long)
Machine Language: 	d0 = AllocRemember(a0, d0, d1)
Modula-2:      		AllocRemember(VAR rememberKey: RememberPrt; size:
			LONGCARD; flags: MemReqSet): ADDRESS
Arguments:		rememberKey = address of pointer to Remember structure
			size = size of desired block in bytes
 			flags = type of memory-MEMF_PUBLIC, MEMF_CHIP, 
			MEMF_FAST, MEMB_CLEAR
Result:			memoryBlock = pointer to allocated block
-------------------------
AllocSignal
Description:		allocates a signal bit
Library:		exec.library
Offset:			-$014A (-330)
Modula-2 Module: 	Tasks
Syntax:        		signalNum = AllocSignal(signalNum)
C:            		long AllocSignal(long)
Machine Language: 	d0 = AllocSignal(d0)
Modula-2:		AllocSignal(signalNum: SIGNAL): SIGNAL
Arguments:		signalNum = desired signal number (0-31); -1 for no preference
Result:			signalNum = signal number allocated; -1 if no signal is
			available
-------------------------
AllocTrap
Description:		allocates a processor trap vector
Library:		exec.library
Offset:			-$0156 (-342)
Modula-2 Module: 	Tasks
Syntax:        		trapNum = AllocTrap(trapNum)
C:            		long AllocTrap(long)
Machine Language: 	d0 = AllocTrap(d0)
Modula-2:		AllocTrap(trapNum: TRAP): TRAP
Arguments:		trapNum = desired trap number (0-15); -1 for no preference
Result:			trapNum = trap number allocated; -1 if no trap is available
-------------------------
AllocWBObject
Description:		allocates a Workbench object
Library:		icon.library
Offset:			-$0042 (-66)
Modula-2 Module: 	none
Syntax:        		object = AllocWBObject( )
C:            		struct WBObject AllocWBObject(void)
Machine Language: 	d0 = AllocWBObject( )
Modula-2:       	not available
Arguments:      	none
Result:			object = the WBObject; NULL if unsuccessful
-------------------------
AndRectRegion
Description:		performs a two-dimensional AND operation of a rectangle with a
			region, leaving the result in the region
Library:		graphics.library
Offset:			-$01F8 (-504)
Modula-2 Module: 	Regions
Syntax:        		AndRectRegion(region, rectangle)
C:            		void AndRectRegion(struct Region *, struct Rectangle *)
Machine Language: 	AndRectRegion(a0, a1)
Modula-2:		AndRectRegion(region: RegionPtr; rectangle: RectanglePtr)
Arguments:		region = Region structure
			rectangle = Rectangle structure
Result:			none
-------------------------
AndRegionRegion
Description:		performs a two-dimensional AND operation of one region with a
			second region, leaving the result in second region
Library:		graphics.library
Offset:			-$0270 (-624)
Modula-2 Module: 	Regions
Syntax:        		success = AndRegionRegion(region1, region2)
C:            		long AndRegionRegion(struct Region *, struct Region *)
Machine Language: 	d0 = AndRegionRegion(a0, a1)
Modula-2:		AndRegionRegion(region1, region2: RegionPtr): BOOLEAN
Arguments:		region1 = Region structure
			region2 = Region structure
Result:	success = 	TRUE if successful; FALSE if unsuccessful
-------------------------
Animate
Description:		processes every AnimOb in the current animation list
Library:		graphics.library
Offset:			-$00A2 (-162)
Modula-2 Module: 	Gels
Syntax:        		Animate(anKey, rastPort)
C:            		void Animate(long, struct RastPort *)
Machine Language: 	Animate(a0, a1)
Modula-2:       	Animate(ankey: ADDRESS; rastPort: RastPortPtr)
Arguments:     		anKey = address of variable that points to the head AnimOb
			rastPort = RastPort structure
Result:			none
-------------------------
AreaCircle (macro)
Description:     	adds a circle to the list of points used to fill an area
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module: 	Areas
Syntax:        		error = AreaCircle(rastPort, cx, cy, radius)
C:            		long AreaCircle(struct RastPort *, long, long, long)
Machine Language: 	not available, use AreaEllipse
Modula-2:		AreaCircle(rp: RastPortPtr; cx, cy, radius: INTEGER): INTEGER
Arguments:		rastPort = RastPort structure
			cx = horizontal coordinate of circle's center
			cy = vertical coordinate of circle's center
			radius = circle's radius
Result:			error = 0 if successful; -1 if no room left in list of points
-------------------------
AreaDraw
Description:		adds a point to the list of points used to fill an area
Library:		graphics.library
Offset:			-$0102 (-258)
Modula-2 Module: 	Areas
Syntax:        		error = AreaDraw(rastPort, x, y)
C:            		long AreaDraw(struct RastPort *, long, long)
Machine Language: 	d0 = AreaDraw(a1, d0, d1)
Modula-2:		AreaDraw(rastPort: RastPortPtr; x, y: INTEGER): INTEGER
Arguments:		rastPort = RastPort structure
			x = horizontal coordinate of point
			y = vertical coordinate of point
Result:			error = 0 if successful; -1 if no room left in list of points
-------------------------
AreaEllipse
Description:		adds an ellipse to the list of points used to fill an area
Library:		graphics.library
Offset:			-$00BA (-186)
Modula-2 Module: 	Areas
Syntax:        		error = AreaEllipse(rastPort, cx, cy, a, b)
C:            		long AreaEllipse(struct RastPort *, long, long, long, long)
Machine Language: 	d0 = AreaEllipse(a1, d0, d1, d2, d3)
Modula-2:       	AreaEllipse(rastPort: RastPortPtr; cx, cy, a, b: INTEGER):
			INTEGER
-------------------------
AttemptLockLayerRom
Description:		attempts to lock a Layer structure
Library:        	graphics.library
Offset:         	-$028E (-582)
Modula-2 Module: 	Clip
Syntax:        		success = AttemptLockLayerRom(layer)
C:            		long AttemptLockLayerRom(struct Layer *)
Machine Language: 	d0 = AttemptLockLayerRom(a5)
Modula-2:		AttemptLockLayerRom(layer: LayerPtr): BOOLEAN
Arguments:		layer = Layer structure to lock
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
AttemptSemaphore
Description:		attempts to obtain access to a SignalSemaphore structure
Library:		exec.library
Offset:			-$0240 (-576)
Modula-2 Module: 	Semaphores
Syntax:        		success = AttemptSemaphore(signalSemaphore)
C:            		long AttemptSemaphore(struct SignalSemaphore *)
Machine Language: 	d0 = AttemptSemaphore(a0)
Modula-2:		AttemptSemaphore(signalSemaphore: SignalSemaphorePtr):
			BOOLEAN
Arguments:		signalSemaphore = initialized SignalSemaphore structure
Result:			success = TRUE if successful; FALSE if another task is using
			specified SignalSemaphore structure
-------------------------
AutoRequest
Description:		automatically creates and gets a response from a requester
Library:		intuition.library
Offset:			-$015C (-348)
Modula-2 Module: 	Intuition
Syntax:        		response = AutoRequest(window, bodyText, positiveText,
			negativeText, positiveFlags, negativeFlags, width, height)
C:            		long AutoRequest(struct Window *, struct IntuiText *, struct
			IntuiText *, struct IntuiText *, long, long, long)
Machine Language: 	d0 = AutoRequest(a0, a1, a2, a3, d0, d1, d2, d3)
Modula-2:      		AutoRequest(window: WindowPtr; bodyText, positiveText,
			negativeText: IntuiTextPtr; positiveFlags, negativeFlags:
			IDCMPFlagsSet; width, height: INTEGER): BOOLEAN
Arguments:		window = Window structure
			bodyText = IntuiText structure
			positiveText = IntuiText structure
			negativeText = IntuiText structure
			positiveFlags = flags for the IDCMP
			negativeFlags = flags for the IDCMP
			width = width of requester
			height = height of requester
Result:			response = TRUE for a positive response; FALSE for a negative
			response
-------------------------
AvailFonts
Description:		builds an array of all available fonts on disk and/or in memory
Library:		diskfont.library
Offset:			-$0024 (-36)
Modula-2 Module: 	DiskFont
Syntax:        		error = AvailFonts(buffer, bufBytes, types)
C:            		long AvailFonts(char *, long, long)
Machine Language: 	d0 = AvailFonts(a0, d0, d1)
Modula-2:		AvailFonts(buffer: ADDRESS; bufBytes: LONGCARD; types:
			AFTypeSet): LONGCARD
Arguments:		buffer = memory buffer used to hold the array
			bufBytes = size of buffer in bytes
			types = type of fonts to search for-AFF_MEMORY and/or
			AFF_DISK
Result:			error = 0 if successful, otherwise, error contains the number of
			additional bytes that must be added to the buffer size (bufBytes)
			to contain all of the font information
-------------------------
AvailMem
Description:		returns memory available given certain requirements
Library:		exec.library
Offset:			-$00D8 (-216)
Modula-2 Module: 	Memory
Syntax:        		size = AvailMem(requirements)
C:            		long AvailMem(long)
Machine Language: 	d0 = AvailMem(d1)
Modula-2:      		AvailMem(requirements: MemReqSet): LONGCARD
Arguments:     		requirements = type of memory required-MEMF_PUBLIC,
			MEMF_CHIP, MEMF_FAST, MEMB_CLEAR
Result:			size = total free space remaining
------------------------- MISSING IN ORIGINAL TEXT!!!! -------------------------
Arguments:		rastPort = RastPort structure
			cx = horizontal coordinate of ellipse's center
			cy = vertical coordinate of ellipse's center
			a = horizontal radius of ellipse (must be greater than O)
			b = vertical radius of ellipse (must be greater than O)
Result:			error = 0 if successful; -1 if no room left in list of points
-------------------------
AreaEnd
Description:		fills an area using a list of vertices
Library:		graphics.library
Offset:			-$0108 (-264)
Modula-2 Module: 	Areas
Syntax:        		error = AreaEnd(rastPort)
C:            		long AreaEnd(struct RastPort *)
Machine Language: 	d0 = AreaEnd(a1)
Modula-2:		AreaEnd(rastPort: RastPortPtr): INTEGER
Arguments:		rastPort = RastPort structure
Result:			error = 0 if successful; -1 if unsuccessful
-------------------------
AreaMove
Description:		closes the current polygon described by a table of vertices and de-
			fines the starting point for a new polygon
Library:		graphics.library
Offset:			-$00FC (-252)
Modula-2 Module: 	Areas
Syntax:        		error = AreaMove(rastPort, x, y)
C:            		long AreaMove(struct RastPort *, long, long)
Machine Language: 	d0 = AreaMove(a1, d0, d1)
Modula-2:		AreaMove(rastPort: RastPortPtr; x, y: INTEGER): INTEGER
Arguments:		rastPort = RastPort structure
			x = horizontal coordinate of point
			y = vertical coordinate of point
Result:			error = 0 if successful; -1 if no room left in list of points
-------------------------
arnd
Description:		rounds a floating point number contained in an ASCII string
Library:		amiga.lib (linked library)
Modula-2 Module: 	none
Syntax:        		arnd(place, exp, string)
C:			void arnd(long, long, char *)
Machine Language: 	pea string 
			move.l #exp,-(sp) 
			move.l #place,-(sp) 
			jsr _arnd 		;string contents are modified 
			add.l #12,sp
Modula-2:		not available
Arguments:		place = number of desired decimal places
			exp = exponent value of number in string argument
			string = string containing number to round
Result:			string argument is modified to contain rounded number
-------------------------
AskFont
Description:		puts text attributes of the current font in the specified TextAttr
			structure
Library:		graphics.library
Offset:			-$01DA (-474)
Modula-2 Module: 	Text
Syntax:        		AskFont(rastPort, textAttr)
C:            		void AskFont(struct RastPort *, struct TextAttr *)
Machine Language: 	AskFont(a1, a0)
Modula-2:		AskFont(rastPort: RastPortPtr; textAttr: TextAttrPtr)
Arguments:		rastPort = RastPort structure
			textAttr = TextAttr structure to be filled
Result:			returns results in textAttr argument
-------------------------
AskSoftStyle
Description:		returns the soft style bits of the current font
Library:		graphics.library
Offset:			-$0054 (-84)
Modula-2 Module: 	Text
Syntax:        		enable = AskSoftStyle(rastPort)
C:            		long AskSoftStyle(struct RastPort *)
Machine Language: 	d0 = AskSoftStyle(a1)
Modula-2:      		AskSoftStyle(rastPort: RastPortPtr): FontStyleSet
Arguments:     		rastPort = RastPort structure
Result:			enable = valid style bits
-------------------------
BeginIO 
Description: 		initiates an IO request like SendIO( ), but does not clear io_Flags 
			field 
Library:	        amiga.lib (linked library) 
Modula-2 Module: 	IO 
Syntax:        		BeginIO(ioRequest) 
C:            		void BeginIO(struct IORequest *) 
Machine Language: 	pea ioRequest
			jsr _BeginIO
			addq.l #4,sp
Modula-2:		BeginIO(ioRequest: ADDRESS)
Arguments:		IORequest = initialized IORequest structure
Result:			none
-------------------------
BeginRefresh
Description:		sets up a window for optimized refreshing
Library:		intuition.library
Offset:			-$0162 (-354)
Modula-2 Module: 	Intuition
Syntax:        		BeginRefresh(window)
C:            		void BeginRefresh(struct Window *)
Machine Language: 	BeginRefresh(a0)
Modula-2:		BeginRefresh(window: WindowPtr)
Arguments:		window = window that needs updating
Result:			none
-------------------------
BeginUpdate
Description:		prepares to repair a damaged layer
Library:		layers.library
Offset:			-$004E (-78)
Modula-2 Module: 	Layers
Syntax:        		success = BeginUpdate(layer)
C:            		long BeginUpdate(struct Layer *)
Machine Language: 	d0 = BeginUpdate(a0)
Modula-2:      		BeginUpdate(layer: LayerPtr): BOOLEAN
Arguments:     		layer = Layer to be repaired
Result:			TRUE if successful; FALSE if unsuccessful
------------------------- 
BehindLayer
Description:     	moves a layer behind other layers
Library:        	layers.library
Offset:         	-$0036 (-54)
Modula-2 Module: 	Layers
Syntax:       		success = BehindLayer(dummy, layer)
C:            		long BehindLayer(struct Layer_Info, struct Layer *)
Machine Language: 	d0 = BehindLayer(a0, a1)
Modula-2:		BehindLayer(layer: LayerPtr): BOOLEAN
Arguments:		dummy = unused
			layer = Layer to move behind other layers
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
BltBitMap
Description:		uses the blitter chip to move (blit) a rectangular region of bits from
			a BitMap to a BitMap
Library:		graphics.library
Offset:			-$001E (-30)
Modula-2 Module: 	Blitter
Syntax:   		planes = BltBitMap(scrBitMap, srcX, srcY, destBitMap, destX, 
			destY, sizeX, sizeY, miniterm, mask, tempA)

C:		        long BltBitMap(struct BitMap *, long, long, struct BitMap *, long, 
			long, long, long, long, long, char *)
Machine Language: 	d0 = BltBitMap(a0, d0, d1, a1, d2, d3, d4, d5, d6, d7, a2)
Modula-2:		BltBitMap(scrBitMap: BitMapPtr; srcX, srcY: INTEGER;
			destBitMap: BitMapPtr; destX, destY: INTEGER; sizeX, sizeY:
			INTEGER; miniterm: BYTE; mask: BITSET; tempA: ADDRESS):
			LONGCARD
Arguments:		scrBitMap = source BitMap structure
			srcX = horizontal coordinate of upper left corner of source
			rectangle
			srcY = vertical coordinate of upper left corner of source rectangle
			destBitMap = destination BitMap structure
			destX = horizontal coordinate of upper left corner of destination
			rectangle
			destY = vertical coordinate of upper left corner of destination
			rectangle
			sizeX = width of rectangle
			sizeY = height of rectangle
			miniterm = logic function to apply to rectangle
			mask = bit planes to be affected
			tempA = pointer to chip memory for one source line or NULL
Result:			planes = actual number of planes involved in blit
-------------------------
BltBltMapRastPort
Description:		moves a rectangular region from a BitMap to a RastPort
Library: 		graphics.library
Offset: 	        -$025E (-606)
Modula-2 Module:	Blitter
Syntax:        		BltBitMapRastPort(srcBitMap, srcX, srcY, destRastPort, destX, 
			destY, sizeX, sizeY, miniterm)
C:		        void BltBitMapRastPort(struct BitMap *, long, long, struct RastPort
			*, long, long, long, long, long)
Machine Language: 	BltBitMapRastPort(a0, d0, d1, a1, d2, d3, d4, d5, d6)
Modula-2:		BltBitMapRastPort(srcBitMap: BitMapPtr; srcX, srcY: INTEGER;
			destRastPort: RastPortPtr; destX, destY: INTEGER; sizeX, sizeY:
			INTEGER; miniterm: BYTE)
Arguments:		srcBitMap = source BitMap structure
			srcX = horizontal coordinate of upper left corner of source
			rectangle
			srcY = vertical coordinate of upper left corner of source rectangle
			destRastPort = destination RastPort structure
			destX = horizontal coordinate of upper left corner of destination
			rectangle
			destY = vertical coordinate of upper left corner of destination
			rectangle
			sizeX = width of rectangle
			sizeY = height of rectangle
			miniterm = logic function to apply to rectangle
Result:			none
-------------------------
BltClear
Description:		fills a section of chip memory with zeros
Library:		graphics.library
Offset:			-$012C (-300)
Modula-2 Module: 	Blitter
Syntax:        		BltClear(memBlock, byteCount, flags)
C:            		void BltClear(char *, long, long)
Machine Language: 	BltClear(a1, d0, d1)
Modula-2:      		BltClear(memBlock: ADDRESS; byteCount: LONGCARD; flags:
			BltClearFlagSet)

Arguments:		memBlock = memory to clear (must start on a word boundary)
			byteCount = number of bytes to clear
			flags = set bit 0 to force function to wait until memory is cleared;
			set bit 1 if byteCount is to be interpreted as the number of rows
			and bytes per row to clear; clear bit 1 if byteCount is to be inter-
			preted as an even number of bytes
Result:			none
-------------------------
BltMaskBitMapRastPort
Description: 		moves a rectangular region from a BitMap to a RastPort through a 
			mask
Library:	        graphics.library
Offset:         	-$027C (-636)
Modula-2 Module: 	Blitter
Syntax:        		BltMaskBitMapRastPort(srcBitMap, srcX, srcY, destRastPort, destX, 
			destY, sizeX, sizeY, miniterm, mask)
C:		        void BltMaskBitMapRastPort(struct BitMap *, long, long, struct 
			RastPort *, long, long, long, long, long, APTR)
Machine Language: 	BltMaskBitMapRastPort(a0, d0, d1, a1, d2, d3, d4, d5, d6, a2)
Modula-2:		BltMaskBitMapRastPort(srcBitMap: BitMapPtr; srcX, srcY: INTE-
			GER; destRastPort: RastPortPtr; destX, destY: INTEGER; sizeX,
			sizeY: INTEGER; miniterm: BYTE; mask: PlanePtr)
Arguments:		srcBitMap = source BitMap structure
			srcX = horizontal coordinate of upper left corner of source
			rectangle
			srcY = vertical coordinate of upper left corner of source rectangle
			destRastPort = destination RastPort structure
			destX = horizontal coordinate of upper left corner of destination
			rectangle
			destY = vertical coordinate of upper left corner of destination
			sizeX = width of rectangle
			sizeY = height of rectangle
			miniterm = logic function to apply to rectangle
			mask = pointer to bit-plane mask
Result:			none
-------------------------
BltPattern
Description:		draws through a mask using standard drawing rules
Library:		graphics.library
Offset:			-$0138 (-312)
Modula-2 Module: 	Blitter
Syntax:			BltPattern(destRastPort, pattern, x1, y1, x2, y2, width)
C:		        void BltPattern(struct RastPort *, struct RastPort *, long, long, 
			long, long, long)
Machine Language: 	BltPattern(a1, a0, d0, d1, d2, d3, d4)
Modula-2:		BltPattern(destRastPort: RastPortPtr; pattern: ADDRESS; x1, y1:
			INTEGER; x2, y2: INTEGER; width: INTEGER)
Arguments:		destRastPort = destination RastPort
			pattern = two-dimensional mask pattern
			x1 = horizontal coordinate of upper left corner in destination
			RastPort
			y1 = vertical coordinate of upper left corner in destination
			RastPort
			x2 = horizontal coordinate of lower right corner in destination
			RastPort
			y2 = vertical coordinate of lower right corner in destination
			RastPort
			width = width of mask in bytes
Result:			none
-------------------------
BltTemplate
Description:		"cookie cuts" a shape in a rectangle to a RastPort
Library:		graphics.library
Offset:			-$0024 (-36)
Modula-2 Module: 	Blitter
Syntax:		        BltTemplate(source, srcX, srcMod, destRastPort, destX, destY, 
			sizeX, sizeY)
C:		        void BltTemplate(char *, long, long, struct RastPort *, long, long, 
			long, long)
Machine Language: 	BltTemplate(a0, d0, d1, a1, d2, d3, d4, d5)
Modula-2:		BltTemplate(source: PlanePTR; srcX, srcMod: INTEGER;
			destRastPort: RastPortPtr; destX, destY: INTEGER; sizeX, sizeY:
			INTEGER) (changes)
Arguments:		source = template mask
			srcX = horizontal offset into template mask (0-15)
			srcMod = number of bytes per row in template mask
			destRastPort = destination RastPort
			destX = horizontal coordinate of upper left corner in destination
			RastPort
			destY = vertical coordinate of upper left corner in destination
			RastPort
			sizeX = width of rectangular template
			sizeY = height of rectangular template
Result:			none
-------------------------
BNDRYOFF (macro)
Description:    	turns boundary mode off
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module: 	Pens
Syntax:        		BNDRYOFF(rastPort)
C:            		void BNDRYOFF(struct RastPort *)
Machine Language: 	not available
Modula-2:		BNDRYOFF(rastPort: RastPortPtr)
Arguments:		rastPort = RastPort structure
Result:			none
-------------------------
BuildSysRequest
Description:		builds and displays a system requester
Library:		intuition.library
Offset:			-$0168 (-360)
Modula-2 Module: 	Intuition
Syntax:		        window = BuildSysRequest(window, bodyText, positiveText, 
			negativeText, flags, width, height)
C:		        struct Window *BuildSysRequest(struct Window *, struct IntuiText 
			*, struct IntuiText *, struct IntuiText *, long, long, long)
Machine Language: 	d0 = BuildSysRequest(a0, a1, a2, a3, d0, d1, d2)
Modula-2:		BuildSysRequest(window: WindowPtr; bodyText, positiveText,
			negativeText: IntuiTextPtr; flags: IDCMPFlagsSet; width, height:
			INTEGER): ADDRESS
Arguments:		window = Window to contain requester
			bodyText = IntuiText structure containing requester's main text
			positiveText = IntuiText structure containing text for positive
			gadget
			negativeText = IntuiText structure containing text for negative
			gadget
			flags = IDCMP flags for initialization of window containing
			requester
			width = requester width
			height = requester height
Result:			window = pointer to window containing requester; if requester
			could not be opened, DisplayAlert( ) is called and this function re-
			turns TRUE if the left mouse button is pressed and FALSE if the
			right mouse button is pressed
------------------------- 
BumpRevision
Description:  		creates a new name for the copy of a file, directory, or disk
Library:       		icon.library
Offset:         	-$006C (-108)
Modula-2 Module: 	Icon
Syntax:        		newname = BumpRevision(newbuf, oldname)
C:            		long BumpRevision(char *, char *)
Machine Language: 	d0 = BumpRevision(a0, a1)
Modula-2:		BumpRevision(newbuf, oldname: STRPTR)
Arguments:		newbuf = buffer to contain the new name (must be at least 31
			characters long)
			oldname = old name
Result:			newname = pointer to the new name contained in newbuf
-------------------------
Cause
Description:		causes a software interrupt
Library:		exec.library
Offset:			-$00B4 (-180)
Modula-2 Module: 	Interrupts
Syntax:        		Cause(interrupt)
C:            		void Cause(struct Interrupt *)
Machine Language: 	Cause(a1)
Modula-2:		Cause(interrupt: InterruptPtr)
Arguments:		interrupt = initialized interrupt node
Result:			none
-------------------------
CBump
Description:		moves to the next position in user copper list
Library:		exec.library
Offset:			-$016E (-366)
Modula-2 Module: 	Copper
Syntax:        		CBump(copList)
C:            		void CBump(struct UCopList *)
Machine Language: 	CBump(a1)
Modula-2:      		CBump(copList: UCopListPtr)
Arguments:     		copList = UCopList structure
Result:			none
-------------------------
CEND (macro)
Description:    	adds the final instruction to a user copper list
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module: 	Copper
Syntax:        		CEND(copList)
C:            		void CEND(struct UCopList *)
Machine Language: 	not available
Modula-2:		CEND(VAR copList: UCopList)
Arguments:		copList = UCopList structure
Result:			none
------------------------
ChangeSprite
Description:		changes the shape of a sprite
Library:		graphics.library
Offset:			-$01A4 (-420)
Modula-2 Module: 	Sprites
Syntax:        		ChangeSprite(viewPort, simpleSprite, newdata)
C:            		void ChangeSprite(struct ViewPort *, struct SimpleSprite *, short *)
Machine Language: 	ChangeSprite(a0, a1, a2)
Modula-2:		ChangeSprite(viewPort: ViewPortPtr; simpleSprite:
			SimpleSpritePtr; newdata: ADDRESS)
Arguments:		viewPort = ViewPort structure
			simpleSprite = initialized SimpleSprite structure
			newdata = table of sprite shape data
Result:			none
-------------------------
CheckIO
Description:		gets the status of an IO request
Library:		exec.library
Offset:			-$01D4 (-468)
Modula-2 Module: 	IO
Syntax:        		status = CheckIO(ioRequest)
C:            		long CheckIO(struct IORequest *)
Machine Language: 	d0 = CheckIO(a1)
Modula-2:       	CheckIO(ioRequest: ADDRESS): ADDRESS
Arguments:     		ioRequest = IORequest block
Result:         	status = NULL if I/O is still in progress; pointer to IORequest
			block if I/O has completed
-------------------------
CINIT (macro)
Description:     	initializes a user copper list
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module: 	Copper
Syntax:        		copList = CINIT(copList, num)
C:            		struct UCopList *CINIT(struct UCopList *, short)
Machine Language: 	not available
Modula-2:		CINIT(copList: UCopListPtr; num: CARDINAL): UCopListPtr
Arguments:		copList = UCopList structure
			num = number of instructions buffer must hold
Result:			copList = pointer to an initialized UCopList structure, ready to
			accept copper instructions
-------------------------
ClearDMRequest
Description:		clears the DMRequest of a window
Library:		intuition.library
Offset:			-$0030 (-48)
Modula-2 Module: 	Intuition
Syntax:        		success = ClearDMRequest(window)
C:            		long ClearDMRequest(struct Window *)
Machine Language: 	d0 = ClearDMRequest(a0)
Modula-2:		ClearDMRequest(window: WindowPtr): BOOLEAN
Arguments:		window = window from which DMRequest is to be cleared
Result:			success = TRUE if successful; FALSE if unsuccessful (DMRequest
			is still in use)
-------------------------
ClearEOL
Description:		clears from the current position to the end of the line
Library:		graphics.library
Offset:			-$002A (-42)
Modula-2 Module: 	Text
Syntax:        		ClearEOL(rastPort)
C:            		void ClearEOL(struct RastPort *)
Machine Language: 	ClearEOL(a1)
Modula-2:       	ClearEOL(rastPort: RastPortPtr)
Arguments:     		rastPort = RastPort structure to clear
Result:			none
------------------------- 
ClearMenuStrip
Description:  		clears (detaches) a window's menu strip
Library:        	intuition.library
Offset:         	-$0036 (-54)
Modula-2 Module: 	Intuition
Syntax:        		ClearMenuStrip(window)
C:            		void ClearMenuStrip(struct Window *)
Machine Language: 	ClearMenuStrip(a0)
Modula-2:		ClearMenuStrip(window: WindowPtr)
Arguments:		window = Window structure
Result:			none
-------------------------
ClearPointer
Description:		returns the mouse pointer to its default shape
Library:		intuition.library
Offset:			-$003C (-60)
Modula-2 Module: 	Intuition
Syntax:        		ClearPointer(region)
C:            		void ClearPointer(struct Region *)
Machine Language: 	ClearPointer(a0)
Modula-2:		ClearPointer(window: WindowPtr)
Arguments:		window = Window structure
Result:			none
-------------------------
ClearRectRegion
Description:		performs a two-dimensional clearing operation of a clipping rec
			tangle with a region, leaving the result in the region
Library:		graphics.library
Offset:			-$020A (-522)
Modula-2 Module: 	Regions
Syntax:        		success = ClearRectRegion(region, rectangle)
C:            		long ClearRectRegion(struct Region *, struct Rectangle *)
Machine Language: 	d0 = ClearRectRegion(a0, a1)
Modula-2:		ClearRectRegion(region: RegionPtr; rectangle: RectanglePtr):
			BOOLEAN
Arguments:		region = Region to clear
			rectangle = Rectangle to be used as the clipping rectangle
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
ClearRegion
Description:    	removes all rectangles from a region
Library:        	graphics.library
Offset:         	-$0210 (-528)
Modula-2 Module: 	Regions
Syntax:        		ClearRegion(region)
C:            		void ClearRegion(struct Region *)
Machine Language: 	ClearRegion(a0)
Modula-2:		ClearRegion(region: RegionPtr)
Arguments:		region = Region to clear
Result:			none
-------------------------
ClearScreen
Description:		clears from the current position to the end of the RastPort
Library:		graphics.library
Offset:			-$0030 (-48)
Modula-2 Module: 	Text
Syntax:        		ClearScreen(rastPort)
C:            		void ClearScreen(struct RastPort *)
Machine Language: 	ClearScreen(a1)
Modula-2:		ClearScreen(rastPort: RastPortPtr)
Arguments:		rastPort = RastPort to clear
Result:			none
-------------------------
ClipBlit
Description:		copies bit-map data (and optionally manipulates) from one
			RastPort to another
Library:		graphics.library
Offset:			-$0228 (-552)
Modula-2 Module: 	Blitter
Syntax:        		ClipBlit(scrRastPort, srcX, srcY, destRastPort, destX, destY, sizeX,
			sizeY, miniterm)
C:            		void ClipBlit(struct RastPort * long, long, struct RastPort *, long,
			long, long, long, long)
Machine Language: 	ClipBlit(a0, d0, d1, a1, d2, d3, d4, d5, d6)
Modula-2:       	ClipBlit(scrRPort: RastPortPtr; srcX, srcY: INTEGER; destRPort:
			RastPortPtr; destX, destY: INTEGER; sizeX, sizeY: INTEGER;
			miniterm: BYTE)
Arguments:		scrRastPort = source RastPort structure
			srcX = horizontal coordinate of upper left corner of source
			rectangle
			srcY = vertical coordinate of upper left corner of source rectangle
			destRastPort = destination RastPort structure
			destX = horizontal coordinate of upper left corner of destination
			rectangle
			destY = vertical coordinate of upper left corner of destination
			rectangle
			sizeX = width of rectangle
			sizeY = height of rectangle
			miniterm = logic function to apply to rectangle
Result:			none
-------------------------
Close
Description:		closes an open file
Library:		dos.library
Offset:			-$0024 (-36)
Modula-2 Module: 	DOS
Syntax:        		Close(file)
C:            		void Close(BPTR)
Machine Language: 	Close(d1)
Modula-2:		Close(file: FileHandle)
Arguments:		file = BCPL pointer to file handle of file to close
Result:			none
-------------------------
CloseDevice
Description:		terminates access to a device
Library:		exec.library
Offset:			-$01C2 (-450)
Modula-2 Module: 	Devices
Syntax:        		CloseDevice(ioRequest)
C:            		void CloseDevice(struct IORequest *)
Machine Language: 	CloseDevice(a1)
Modula-2:       	CloseDevice(ioRequest: ADDRESS)
Arguments:     		ioRequest = IORequest structure
Result:			none
-------------------------
CloseFont
Description:     	tells the system that an opened font is no longer in use
Library:        	graphics.library
Offset:         	-$004E (-78)
Modula-2 Module: 	Text
Syntax:        		CloseFont(font)
C:            		void CloseFont(struct TextFont *)
Machine Language: 	CloseFont(a1)
Modula-2:		CloseFont(textfont: TextFontPtr)
Arguments:		font = font descriptor as returned by OpenFont( ) or
			OpenDiskFont( )
Result:			none
-------------------------
CloseLibrary
Description:		tells the system that an opened library is no longer in use
Library:		exec.library
Offset:			-$019E (-414)
Modula-2 Module: 	Libraries
Syntax:        		CloseLibrary(library)
C:           		void CloseLibrary(struct Library *)
Machine Language: 	CloseLibrary(a1)
Modula-2:		CloseLibrary(library: LibraryPtr)
Arguments:		library = base address of a library, as returned by OpenLibrary( )
Result:			none
-------------------------
CloseScreen
Description:		closes an Intuition screen
Library:		intuition.library
Offset:			-$0042 (-66)
Modula-2 Module: 	Intuition
Syntax:        		CloseScreen(screen)
C:            		void CloseScreen(struct Screen *)
Machine Language: 	CloseScreen(a0)
Modula-2:       	CloseScreen(screen: ScreenPtr)
Arguments:     		screen = screen to close
Result:			none
-------------------------
CloseWindow
Description:     	closes an Intuition window
Library:        	intuition.library
Offset:         	-$0048 (-72)
Modula-2 Module: 	Intuition
Syntax:        		CloseWindow(window)
C:            		void CloseWindow(struct Window *)
Machine Language: 	CloseWindow(a0)
Modula-2:		CloseWindow(window: WindowPtr)
Arguments:		window = window to close
Result:			none
-------------------------
CloseWorkBench
Description:		attempts to close the Workbench screen
Library:		intuition.library
Offset:			-$004E (-78)
Modula-2 Module: 	Intuition
Syntax:        		success = CloseWorkBench( )
C:            		long CloseWorkBench(void)
Machine Language: 	d0 = CloseWorkBench( )
Modula-2:		CloseWorkBench( ): BOOLEAN
Arguments:		none
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
CMove
Description:		appends a copper move instruction to a user copper list without
			bumping the copper instruction pointer to the next instruction
Library:		graphics.library
Offset:			-$0174 (-372)
Modula-2 Module: 	Copper
Syntax:        		CMove(copList, r, v)
C:            		void CMove(struct UCopList *, long, long)
Machine Language: 	CMove(a1, d0, d1)
Modula-2:		CMove(copList: UCopListPtr; r: ADDRESS; v: WORD)
Arguments:		copList = UCopList structure
			a = address of hardware register to receive value
			v = value to store in hardware register
Result:			none
-------------------------
CMOVE (macro)
Description:		appends a copper move instruction to a user copper list and
			bumps the copper instruction pointer to the next instruction
C Include File:		include/graphics/gfxmacros.h
ML Include File:	none
Modula-2 Module: 	Copper
Syntax:        		CMOVE(copList, r, v)
C:            		void CMOVE(struct UCopList *, APTR, short)
Machine Language: 	not available
Modula-2:		CMOVE(copList: UCopListPtr; r: ADDRESS; v: WORD)
Arguments:		copList = UCopList structure
			a = address of hardware register to receive value
			v = value to store in hardware register
Result:			none
-------------------------
ConcatCList
Description:		concatenates two character lists
Library:		clist.library
Offset:			-$009C (-156)
Modula-2 Module: 	none
Syntax:        		error = ConcatCList(srcCList, destCList)
C:            		long ConcatCList(long, long)
Machine Language: 	d0 = ConcatCList(a0, a1)
Modula-2:		not available
Arguments:		srcCList = source character list
			destCList = destination character list
Result:			error = Zero if successful; Nonzero if unsuccessful (out of
			memory)
-------------------------
ConfigBoard
Description:		configures an expansion board
Library:		expansion.library
Offset:			-$003C (-60)
Modula-2 Module: 	Expansion
Syntax:        		error = ConfigBoard(board, configDev)
C:            		long ConfigBoard(long, long)
Machine Language: 	d0 = ConfigBoard(a0, a1)
Modula-2:       	ConfigBoard(board: ADDRESS; configDev: ADDRESS):
			BOOLEAN
Arguments:		board = base address of expansion board (most likely
			E_EXPANSIONBASE)
			configDev = initialized ConfigDev structure
Result:			error = nonzero if unsuccessful
-------------------------
ConfigChain
Description:		configures the entire system
Library:		expansion.library
Offset:			-$0042 (-66)
Modula-2 Module: 	Expansion
Syntax:        		error = ConfigChain(baseAddr)
C:            		long ConfigChain(long)
Machine Language: 	d0 = ConfigChain(a0)
Modula-2:		ConfigChain(baseAddr: ADDRESS): BOOLEAN
Arguments:		baseAddr = base address (most likely E_EXPANSIONBASE)
Result:			error = nonzero if unsuccessful
-------------------------
CopyCList
Description:		copies a character list to a new character list
Library:		clist.library
Offset:			-$0090 (-144)
Modula-2 Module: 	none
Syntax:       		cList = CopyCList(cList)
C:            		long CopyCList(long)
Machine Language: 	d0 = CopyCList(a0)
Modula-2:		not available
Arguments:		cList = original character list
Result:			cList = new character list; Negative is unsuccessful (not enough
			memory)
-------------------------
CopyMem
Description:		copies the contents of RAM from one location to another
Library:		exec.library
Offset:			-$0270 (-624)
Modula-2 Module: 	Memory
Syntax:        		CopyMem(srcPointer, destPointer, size)
C:            		void CopyMem(char *, char *, long)
Machine Language: 	CopyMem(a0, a1, d0)
Modula-2:		CopyMem(srcPointer, destPointer: ADDRESS; size: LONGCARD)
Arguments:		srcPointer = pointer to memory block to be copied
			destPointer = pointer to destination memory block
			size = size of memory block in bytes
Result:			none
-------------------------
CopyMemQuick
Description:		performs an optimized copy of RAM with some restrictions
Library:		exec.library
Offset:			-$0276 (-630)
Modula-2 Module: 	Memory
Syntax:        		CopyMemQuick(srcPointer, destPointer, size)
C:            		void CopyMemQuick(char *, char *, long)
Machine Language: 	CopyMemQuick(a0, a1, d0)
Modula-2:		CopyMemQuick(srcPointer, destPointer: ADDRESS; size:
			LONGCARD)
Arguments:		srcPointer = pointer to the long-word aligned memory block to
			be copied
			destPointer = pointer to the long-word aligned destination mem-
			ory block
			size = size of memory block in bytes
Result:			none
-------------------------
CopySBitMap
Description:		copies all bits from a SuperBitMap into the Layer bitmap
Library:		graphics.library
Offset:			-$01C2 (-450)
Modula-2 Module: 	Clip
Syntax:        		CopySBitMap(layer)
C:            		void CopySBitMap(struct Layer *)
Machine Language: 	CopySBitMap(a0)
Modula-2:		CopySBitMap(layer: LayerPtr)
Arguments:		layer = pointer to a locked Layer that has a SuperBitMap
Result:			none
-------------------------
CreateBehindlayer
Description:		creates a new layer behind all existing layers
Library:		layers.library
Offset:			-$002A (-42)
Modula-2 Module: 	Layers
Syntax:        		layer = CreateBehindLayer(layerInfo, bitMap, x0, y0, x1, y1, 
			flags, superBitMap)
C:            		struct Layer *CreateBehindLayer(struct LayerInfo *, struct Bit-
			Map *, long, long, long, long, long, struct BitMap *)
Machine Language: 	d0 = CreateBehindLayer(a0, a1, d0, d1, d2, d3, d4, a2)
Modula-2:		CreateBehindLayer(layerInfo: LayerInfoPtr; bitMap: BitMapPtr; x0,
			y0, x1, y1: LONGINT; flags: LayerFlagSet; superBitMap:
			BitMapPtr): LayerPtr
Arguments:		layerInfo = info structure of Layer to create
			bitMap = common BitMap used by all Layers
			x0 = horizontal coordinate of upper left corner of Layer
			y0 = vertical coordinate of upper left corner of Layer
			x1 = horizontal coordinate of lower right corner of Layer
			y1 = vertical coordinate of lower right corner of Layer
			flags = type of Layer
			superBitMap = NULL or a SuperBitMap
Result:			layer = pointer to Layer structure if successful; NULL if
			unsuccessful
-------------------------
CreateDir
Description:		creates a new directory
Library:		dos.library
Offset:			-$0078 (-120)
Modula-2 Module: 	DOS
Syntax:        		lock = CreateDir(name)
C:            		BPTR CreateDir(char *)
Machine Language: 	d0 = CreateDir(d1)
Modula-2:		CreateDir(name: STRPTR): FileLock
Arguments:		name = NULL terminate string that specifies the new directory
			name
Result:			lock = BCPL pointer to a lock
-------------------------
CreateExtIO
Description:		allocates memory for and initializes an IO request block
Library:		amiga.lib (linked library)
Modula-2 Module: 	IOUtils
Syntax:        		block = CreateExtIO(ioReplyPort, size)
C:            		struct IORequest *CreateExtIO(struct MsgPort *, long)
Machine Language: 	move.l #size,-(sp)
			pea ioReplyPort
			jsr _CreateExtIO ;block returned in d0
			addq.l #8,sp
Modula-2:		CreateExtIO(ioReplyPort: MsgPortPtr; size: CARDINAL):
			ADDRESS
Arguments:		ioReplyPort = initialized MsgPort
			size = IORequest block size
Result:			block = pointer to newly created IORequest block; NULL if un-
			successful (not enough memory)
-------------------------
CreatePort
Description:		allocates memory for and initializes a message port
Library:		amiga.lib (linked library)
Modula-2 Module: 	PortUtils
Syntax:        		port = CreatePort(name, pri)
C:            		struct MsgPort *CreatePort(char *, long)
Machine Language: 	move.l #pri,-(sp)
			pea name
			jsr _CreatePort ;port returned in d0
			addq.l #8,sp
Modula-2:		CreatePort(name: STRPTR; pri: INTEGER): MsgPortPtr
Arguments:		name = name of public port to create; NULL for private port
			pri = priority to assign to port
Result:			port = pointer to newly created message port; NULL if unsuc-
			cessful (not enough memory)
-------------------------
CreateProc
Description:		creates a new process
Library:		dos.library
Offset:			-$008A (-138)
Modula-2 Module: 	DOSProcess
Syntax:        		process = CreateProc(name, pri, segment, stackSize)
C:            		struct MsgPort *CreateProc(char *, long, BPTR, long)
Machine Language: 	d0 = CreateProc(d1, d2, d3, d4)
Modula-2:		CreateProc(name: STRPTR; pri: LONGINT; segment: BPTR;
			stackSize: LONGINT): ProcessID
Arguments:		name = NULL terminated string that specifies the new process
			name
			priority = priority to be given to process
			segment = segment list, as returned by LoadSeg( )
			stackSize = size of root stack in bytes
Result:			process = pointer to newly created IORequest block; NULL if un-
			successful (not enough memory)
-------------------------
CreateTask
Description:		creates a task
Library:        	amiga.lib (linked library)
Modula-2 Module: 	TaskUtils
Syntax:       		task = CreateTask(name, pri, initPC, stackSize)
C:            		struct Task *CreateTask(char *, long, _fptr, long)
Machine Language: 	move.l #stackSize,-(sp)
			pea initPC
			move.l #pri,-(sp)
			pea name
			jsr _CreateTask ;task returned in d0
			add.l #16,sp
Modula-2:		CreateTask(name: STRPTR; pri: INTEGER; initP
C:			PROC; stackSize: LONGCARD): TaskPtr
Arguments:		name = name of task
			pri = exec task priority (-128 through 127, usually 0)
			stackSize = size of stack in bytes
Result:			task = pointer to newly created task; NULL if unsuccessful (not
			enough memory)
-------------------------
CreateUpfrontLayer
Description:		creates a new layer on top of all existing layers
Library:		layers.library
Offset:		        -$0024 (-36)
Modula-2 Module: 	Layers
Syntax:		        layer = CreateUpfrontLayer(layerInfo, bitMap, x0, y0, x1, y1, 
			flags, superBitMap)
C:		        struct Layer *CreateUpfrontLayer(struct Layer_Info *, struct Bit-
			Map *, long, long, long, long, long, struct BitMap *)
Machine Language: 	d0 = CreateUpfrontLayer(a0, a1, d0, d1, d2, d3, d4, a2)
Modula-2:		CreateUpfrontLayer(layerInfo: LayerInfoPtr; bitMap: BitMapPtr;
			x0, y0, x1, y1: LONGINT; flags: LayerFlagSet; superBitMap:
			BitMapPtr): LayerPtr
Arguments:		layerInfo = info structure of Layer to create
			bitMap = common BitMap used by all Layers
			x0 = horizontal coordinate of upper left corner of Layer
			y0 = vertical coordinate of upper left corner of Layer
			x1 = horizontal coordinate of lower right corner of Layer
			y1 = vertical coordinate of lower right corner of Layer
			flags = type of Layer
			superBitMap = NULL or pointer to SuperBitMap
Result:			layer = pointer to Layer structure if successful; NULL if
			unsuccessful
-------------------------   
CurrentDir
Description:		changes the current directory and returns the old current directory
Library:        	dos.library
Offset:         	-$007E (-126)
Modula-2 Module: 	DOS
Syntax:        		oldlock = CurrentDir(lock)
C:            		BPTR CurrentDir(BPTR)
Machine Language: 	d0 = CurrentDir(d1)
Modula-2:		CurrentDir(lock: FileLock): FileLock
Arguments:		lock = BCPL pointer to lock associated with new current
			directory
Result:			oldlock = BCPL pointer to lock associated with old directory
-------------------------
CurrentTime
Description:		returns the current system time
Library:		intuition.library
Offset:       		-$0054 (-84)
Modula-2 Module: 	Intuition
Syntax:        		CurrentTime(seconds, micros)
C:            		void CurrentTime(long *, long *)
Machine Language: 	CurrentTime(d0, d1)
Modula-2:		CurrentTime(VAR seconds, micros: LONGCARD)
Arguments:		seconds = pointer to four-byte (LONG) variable to receive sec-
			onds value
			micros = pointer to four-byte (LONG) variable to receive micro-
			seconds value
Result:			returned in seconds and micros arguments
-------------------------
CWait
Description:		appends copper wait instruction to a user copper list without
			bumping the copper instruction pointer to the next instruction
Library:		graphics.library
Offset:       		-$017A (-378)
Modula-2 Module: 	CopperUtil
Syntax:        		CWait(copList, vert, horiz)
C:            		void CWait(struct UCopList *, short, short)
Machine Language: 	not available
Modula-2:		CWait(copList: UCopListPtr; vert, horiz: INTEGER)
Arguments:		copList = UCopList structure
			vert = vertical beam position relative to top of ViewPort
			horiz = horizontal beam position (must be less than 223)
Result:			none
-------------------------
CWAIT (macro)
Description:		appends copper wait instruction to a user copper list and bumps
			the copper instruction pointer to the next instruction
C Include File:		include/graphics/gfxmacros.h
ML Include File:	none
Modula-2 Module:	CopperUtil
Syntax:        		CWAIT(copList, vert, horiz)
C:            		void CWAIT(struct UCopList *, short, short)
Machine Language: 	not available
Modula-2:		CWAIT(copList: UCopListPtr; vert, horiz: INTEGER)
Arguments:		copList = UCopList structure
			vert = vertical beam position relative to top of ViewPort
			horiz = horizontal beam position (must be less than 223)
Result:			none
-------------------------
DateStamp
Description:		returns the current date and time in internal format
Library:		dos.library
Offset:           	-$00C0 (-192)
Modula-2 Module: 	DOS
Syntax:        		DateStamp(v)
C:            		long *DateStamp(long *)
Machine Language: 	DateStamp(d1)
Modula-2:		DateStamp(v: DateStampRecPtr)
Arguments:		v = pointer to the first element of an array of three long words
Result:			v argument points to result in RAM
-------------------------
dbf
Description:		converts a fast floating point dual-binary number to plain fast
			floating point format
Library:		amiga.lib (linked library)
Modula-2 Module: 	none
Syntax:        		fnum = dbf(exp, mant)
C:			float dbf(long, long)
Machine Language: 	move.l #mant,-(sp)
			move.l #exp,-(sp) 
			jsr _dfb ;fnum returned in d0/d1 
			addq.l #8,sp
Modula-2:		not available
Arguments:		exp = 16 bit integer representing the sign (bit 16 equals 0 for
			positive or 1 for negative) and base ten exponent (bits 0-15)
			mant = integer representing the mantissa
Result:			fnum = floating point equivalent of value specified by exp and
			mant arguments
-------------------------
Deallocate
Description:		deallocates a block of previously allocated memory
Library:		exec.library
Offset:       		-$00C0 (-192)
Modula-2 Module: 	Memory
Syntax:        		Deallocate(freeList, memoryBlock, byteSize)
C:            		void Deallocate(struct MemHeader *, void *, long)
Machine Language: 	Deallocate(a0, a1, d0)
Modula-2:		Deallocate(freeList: MemHeaderPtr; memoryBlock: ADDRESS;
			byteSize: LONGCARD)
Arguments:		freeList = memory list header
			memoryBlock = memory block to deallocate
			byteSize = size of memory block in bytes
Result:			none
-------------------------
Debug
Description:		runs the system debugger or the debugger installed by
			SetFunction
Library:		exec.library
Offset:       		-$0072 (-114)
Modula-2 Module: 	Exec
Syntax:        		Debug(num)
C:            		void Debug(long)
Machine Language: 	Debug(d0)
Modula-2:      		Debug(num: LONGCARD)
Arguments:     		num = should be set to 0
Result:			none
-------------------------  
Delay
Description:     	delays a process for a specified amount of time
Library:        	dos.library
Offset:         	-$00C6 (-198)
Modula-2 Module: 	DOSProcess
Syntax:        		Delay(ticks)
C:            		void Delay(long)
Machine Language: 	Delay(d1)
Modula-2:		Delay(ticks: LONGINT)
Arguments:		ticks = number of ticks to wait (50 ticks per second)
Result:	none
-------------------------
DeleteExtIO
Description:		returns memory allocated by CreateExtIO
Library:		amiga.lib (linked library)
Modula-2 Module: 	IOUtils
Syntax:        		DeleteExtIO(ioRequest, size)
C:            		void DeleteExtIO(struct IORequest *, long)
Machine Language: 	move.l #size,-(sp)
			pea ioRequest
			jsr _DeleteExtIO
			addq.l #4,sp
Modula-2:		DeleteExtIO(ioReq: ADDRESS; size: CARDINAL)
Arguments:		ioRequest = IORequest block to delete
			size = size of IORequest block in bytes
Result:			none
-------------------------
DeleteFile
Description:		deletes a file or directory
Library:		dos.library
Offset:       		-$0048 (-72)
Modula-2 Module: 	DOS
Syntax:        		success = DeleteFile(name)
C:            		long DeleteFile(char *)
Machine Language: 	d0 = DeleteFile(d1)
Modula-2:       	DeleteFile(name: STRPTR): BOOLEAN
Arguments:      	name = NULL terminated string that specifies the file to delete
Result:			TRUE if successful; FALSE if unsuccessful
-------------------------
DeleteLayer
Description:		deletes a layer from a layer list
Library:        	layers.library
Offset:         	-$005A (-90)
Modula-2 Module: 	Layers
Syntax:        		success = DeleteLayer(dummy, layer)
C:            		long DeleteLayer(struct Layer_Info, struct Layer *)
Machine Language: 	d0 = DeleteLayer(a0, a1)
Modula-2:		DeleteLayer(layer: LayerPtr): BOOLEAN
Arguments:		dummy = unused
			layer = layer to delete
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
DeletePort
Description:		frees a message port created by CreatePort( )
Library:		amiga.lib (linked library)
Modula-2 Module: 	PortUtils
Syntax:        		DeletePort(msgPort)
C:            		void DeletePort(struct MsgPort *)
Machine Language: 	pea msgPort
			jsr _DeletePort
			addq.l #4,sp
Modula-2:		DeletePort(msgPort: MsgPortPtr)
Arguments:		msgPort = message port to delete
Result:			none
-------------------------
DeleteTask
Description:		deletes a task created with CreateTask( )
Library:		amiga.lib (linked library)
Modula-2 Module: 	TaskUtils
Syntax:        		DeleteTask(task)
C:            		void DeleteTask(struct Task *)
Machine Language: 	pea task
			jsr _DeleteTask
			addq.l #4,sp
Modula-2:		DeleteTask(task: TaskPtr)
Arguments:		task = Task to delete
Result:			none
-------------------------
DeviceProc
Description:		returns the process identifier of specified process
Library:        	dos.library
Offset:         	-$00AE (-174)
Modula-2 Module: 	DOSProcess
Syntax:        		process = DeviceProc(name)
C:            		struct MsgPort *DeviceProc(char *)
Machine Language: 	d0 = DeviceProc(d1)
Modula-2:		DeviceProc(name: STRPTR): ProcessID
Arguments:		name = NULL terminated string that specifies the device name
Result:			process = BCPL pointer to a process; NULL if unsuccessful
-------------------------
Disable
Description:		disables interrupt processing
Library:		exec.library
Offset:        		-$0078 (-120)
Modula-2 Module: 	Interrupts
Syntax:        		Disable( )
C:            		void Disable(void)
Machine Language: 	Disable( )
Modula-2:		Disable( )
Arguments:		none
Result:			none
-------------------------
DisownBlitter
Description:		frees blitter for use by other programs
Library:		graphics.library
Offset:        		-$01CE (-462)
Modula-2 Module: 	Blitter
Syntax:        		DisownBlitter( )
C:            		void DisownBlitter(void)
Machine Language: 	DisownBlitter( )
Modula-2:       	DisownBlitter( )
Arguments:      	none
Result:			none
-------------------------
DisplayAlert
Description: 		creates an Alert
Library:        	intuition.library
Offset:         	-$005A (-90)
Modula-2 Module: 	Intuition
Syntax:        		response = DisplayAlert(alertNumber, message, height)
C:            		long DisplayAlert(long, char *, long)
Machine Language: 	d0 = DisplayAlert(d0, a0, d1)
Modula-2:		DisplayAlert(alertNumber: LONGCARD; message: ADDRESS;
			height: CARDINAL): BOOLEAN
Arguments:		alertNumber = AlertMessage number
			message = NULL terminated Alert message string
			height = minimum display lines required for your message
Result:			response = TRUE or FALSE, depending on alert type and user
			response
-------------------------
DisplayBeep
Description:		flashes the video display and emits a beep
Library:		intuition.library
Offset:       		-$0060 (-96)
Modula-2 Module: 	Intuition
Syntax:        		DisplayBeep(screen)
C:            		void DisplayBeep(struct Screen *)
Machine Language: 	DisplayBeep(a0)
Modula-2:       	DisplayBeep(screen: ScreenPtr)
Arguments:     		screen = screen to beep
Result:        		none
-------------------------
DisposeFontContents (available in library version 34)
Description:     	frees the array of FontContents returned by NewFontContents( )
Library:        	diskfont.library
Offset:         	-$0030 (-48)
Modula-2 Module: 	none
Syntax:        		DisposeFontContents(fontContentsHeader)
C:            		void DisposeFontContents(struct FontContentsHeader *)
Machine Language: 	DisposeFontContents(a1)
Modula-2:       	not available
Arguments:     		fontContentsHeader = FontContentsHeader as returned by
			NewFontContents( )
Result:			none
-------------------------  
DisposeLayerInfo
Description:		returns memory used by a LayerInfo structure
Library:        	layers.library
Offset:         	-$0096 (-150)
Modula-2 Module: 	Layers
Syntax:        		DisposeLayerInfo(layerInfo)
C:            		void DisposeLayerInfo(struct Layer_Info *)
Machine Language: 	DisposeLayerInfo(a0)
Modula-2:		DisposeLayerInfo(layerInfo: layerInfoPtr)
Arguments:		layerInfo = LayerInfo structure to remove
Result:			none
-------------------------
DisposeRegion
Description:		returns memory used by a Region structure and its
			RegionRectangles
Library:		graphics.library
Offset:        		-$0216 (-534)
Modula-2 Module: 	Regions
Syntax:        		DisposeRegion(region)
C:            		void DisposeRegion(struct Region *)
Machine Language: 	DisposeRegion(a0)
Modula-2:		DisposeRegion(region: RegionPtr)
Arguments:		region = Region structure to remove
Result:			none
-------------------------
DoCollision
Description:		tests all GELs in GEL list for GEL-to-GEL collisions
Library:		graphics.library
Offset:        		-$006C (-108)
Modula-2 Module: 	Gels
Syntax:        		DoCollision(rastPort)
C:            		void DoCollision(struct RastPort *)
Machine Language: 	DoCollision(a1)
Modula-2:       	DoCollision(rastPort: RastPortPtr)
Arguments:     		rastPort = RastPort with GEL list
Result:			none
-------------------------  
DoIO
Description:		performs IO command and waits for completion
Library:       		exec.library
Offset:        		-$01C8 (-465)
Modula-2 Module: 	IO
Syntax:        		error = DoIO(ioRequest)
C:            		long DoIO(struct IORequest *)
Machine Language: 	d0 = DoIO(a1)
Modula-2:		DoIO(ioRequest: ADDRESS): INTEGER
Arguments:		ioRequest = initialized IORequest structure
Result:			error = zero if successful; nonzero if unsuccessful
-------------------------
DoubleClick
Description:		test two time values for double-click timing
Library:		intuition.library
Offset:       		-$0066 (-102)
Modula-2 Module: 	Intuition
Syntax:        		double = DoubleClick(startSecs, startMicros, currentSecs,
			currentMicros)
C:            		long DoubleClick(long, long, long, long)
Machine Language: 	d0 = DoubleClick(d0, d1, d2, d3)
Modula-2:		DoubleClick(startSecs, startMicros, currentSecs, currentMicros:
			LONGCARD): BOOLEAN
Arguments:		startSecs = seconds value at time of first click
			startMicros = micros value at time of first click
			currentSecs = seconds value at time of second click
			currentMicros = micros value at time of second click
Result:			double = TRUE if valid double click; FALSE if not
-------------------------
Draw
Description:		draws a line from current pen position to specified point
Library:		graphics.library
Offset:       		-$00F6 (-246)
Modula-2 Module: 	Pens
Syntax:        		Draw(rastPort, x, y)
C:            		long Draw(struct RastPort *, long, long)
Machine Language:	Draw(a1, d0, d1)
Modula-2:		Draw(rastPort: RastPortPtr; x, y: INTEGER)
Arguments:		rastPort = RastPort to draw line in
			x = horizontal coordinate of line's destination
			y = vertical coordinate of line's destination
Result:			none
-------------------------
DrawBorder
Description:		draws a border
Library:		intuition.library
Offset:       		-$006C (-108)
Modula-2 Module: 	Intuition
Syntax:        		DrawBorder(rastPort, border, leftOffset, topOffset)
C:            		long DrawBorder(struct RastPort *, struct Border *, long, long)
Machine Language: 	DrawBorder(a0, a1, d0, d1)
Modula-2:		DrawBorder(rastPort: RastPortPtr; border: BorderPtr; leftOffset,
			topOffset: INTEGER)
Arguments:		rastPort = RastPort to draw border in
			border = Border to be drawn
			leftOffset = horizontal placement offset for border
			topOffset = vertical placement offset for border
Result:			none
-------------------------
DrawCircle (macro)
Description:     	draws a circle in the specified RastPort
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module: 	Pens
Syntax:        		DrawCircle(rastPort, cx, cy, radius)
C:            		void DrawCircle(struct RastPort *, long, long, long)
Machine Language: 	not available, use DrawEllipse instead
Modula-2:		DrawCircle(rastPort: RastPortPtr; cx, cy, radius: INTEGER)
Arguments:		rastPort = RastPort structure
			cx = horizontal coordinate of circle's center
			cy = vertical coordinate of circle's center
			radius = circle's radius
Result:			none
-------------------------
DrawEllipse
Description:     	draws an elliptical outline within a rectangular outline
Library:       		graphics.library
Offset:         	-$00B4 (-180)
Modula-2 Module: 	Pens
Syntax:        		DrawEllipse(rastPort, cx, cy, a, b)
C:            		void DrawEllipse(struct RastPort *, long, long, long, long)
Machine Language: 	DrawEllipse(a1, d0, d1, d2, d3)
Modula-2:		DrawEllipse(rastPort: RastPortPtr; cx, cy, a, b: INTEGER)
Arguments:		rastPort = RastPort into which ellipse will be drawn
			cx = horizontal coordinate of ellipse's center, relative to the
			RastPort
			cy = vertical coordinate of ellipse's center, relative to the RastPort
			a = ellipse's horizontal radius (must be greater than O)
			b = ellipse's vertical radius (must be greater than O)
Result:			none
-------------------------
DrawGList
Description:		processes a GEL list, drawing bobs and constructing a copper list
			for VSprites
Library:		graphics.library
Offset:       		-$0072 (-114)
Modula-2 Module: 	Gels
Syntax:        		DrawGList(rastPort, viewPort)
C:            		void DrawGList(struct RastPort *, struct ViewPort *)
Machine Language: 	DrawGList(a1, a0)
Modula-2:		DrawGList(rastPort: RastPortPtr; viewPort: ViewPortPtr)
Arguments:		rastPort = RastPort where bobs will be drawn
			viewPort = ViewPort in which VSprites will be created
Result:			none
-------------------------
DrawImage
Description:		draw the specified image
Library:		intuition.library
Offset:       		-$0072 (-114)
Modula-2 Module:	Intuition
Syntax:       		DrawImage(rastPort, image, leftOffset, topOffset)
C:            		long DrawImage(struct RastPort *, struct Image *, long, long)
Machine Language: 	DrawImage(a0, a1, d0, d1)
Modula-2:		DrawImage(rastPort: RastPortPtr; image: ImagePtr; leftOffset,
			topOffset: INTEGER)
Arguments:		rastPort = RastPort where image will be drawn
			image = Image to be drawn
			leftOffset = horizontal placement offset for image
			topOffset = vertical placement offset for image
Result:			none
-------------------------
Duplock
Description:		duplicates a lock
Library:		dos.library
Offset:       		-$0060 (-96)
Modula-2 Module: 	DOS
Syntax:        		newlock = DupLock(lock)
C:            		BPTR DupLock(BPTR)
Machine Language: 	d0 = DupLock(d1)
Modula-2:		DupLock(lock: FileLock): FileLock
Arguments:		lock = lock to duplicate
Result:			newlock = duplicate lock
-------------------------
Enable
Description:		enables interrupt processing
Library:		exec.library
Offset:       		-$007E (-126)
Modula-2 Module: 	Interrupts
Syntax:        		Enable( )
C:            		void Enable(void)
Machine Language: 	Enable( )
Modula-2:		Enable( )
Arguments:		none
Result:			none
-------------------------
EndRefresh
Description:		ends optimized refresh of a window
Library:		intuition.library
Offset:       		-$016E (-366)
Modula-2 Module: 	Intuition
Syntax:        		EndRefresh(window, complete)
C:            		void EndRefresh(struct Window *, long)
Machine Language: 	EndRefresh(a0, d0)
Modula-2:		EndRefresh(window: WindowPtr; complete: BOOLEAN)
Arguments:		window = window in optimized-refresh mode
			complete = TRUE if window is completely refreshed; FALSE if
			not
Result:			none
-------------------------
EndRequest
Description:		removes requester from window
Library:		intuition.library
Offset:       		-$0078 (-120)
Modula-2 Module: 	Intuition
Syntax:        		EndRequest(requester, window)
C:            		void EndRequest(struct Requester *, struct Window *)
Machine Language: 	EndRequest(a0, a1)
Modula-2:		EndRequest(requester: RequesterPtr; window: WindowPtr)
Arguments:		requester = requester to remove
			window = window which is associated with requester
Result:			none
-------------------------
EndUpdate
Description:		removes damage list and restores layer to normal state
Library:		layers.library
Offset:       		-$0054 (-84)
Modula-2 Module:	Layers
Syntax:        		EndUpdate(layer, flag)
C:            		void EndUpdate(struct Layer *, long)
Machine Language: 	EndUpdate(a0, d0)
Modula-2:		EndUpdate(layer: LayerPtr; flag: BOOLEAN)
Arguments:		layer = layer to return to normal state
			flag = TRUE if update was complete-damage list will be
			cleared; FALSE if update was not complete-damage list will be
			retained
Result:	none
-------------------------
Enqueue
Description:		inserts or appends node to a system queue
Library:		exec.library
Offset:       		-$010E (-270)
Modula-2 Module: 	Lists
Syntax:			Enqueue(list, node)
C:     			void Enqueue(struct List *, struct Node *)
Machine Language: 	Enqueue(a0, a0)
Modula-2:		Enqueue(list: ListPtr; node: NodePtr)
Arguments:		list = system queue header
			node = node to insert or append
Result:			none
-------------------------
Examine
Description:		examines a directory or file
Library:		dos.library
Offset:       		-$0066 (-102)
Modula-2 Module: 	DOS
Syntax:        		success = Examine(lock, infoBlock)
C:            		long Examine(BPTR, struct FileInfoBlock *)
Machine Language: 	d0 = Examine(d1, d2)
Modula-2:		Examine(lock: FileLock; infoBlock: FileInfoBlockPtr): BOOLEAN
Arguments:		lock = lock of directory or file to examine
			infoBlock = info block to receive directory or file information
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
Execute
Description:		executes a CLI command
Library:		dos.library
Offset:       		-$00DE (-222)
Modula-2 Module: 	DOSLoader
Syntax:        		success = Execute(command, input, output)
C:            		long Execute(char *, BPTR, BPTR)
Machine Language: 	d0 = Execute(d1, d2, d3)
Modula-2:		Execute(command: STRPTR; input, output: FileHandle):
			BOOLEAN
Arguments:		command = NULL terminated string containing CLI command
			input = file handle for input redirection; NULL if none
			output = file handle for output redirection; NULL if none
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
Exit
Description:		ends a program
Library:		dos.library
Offset:       		-$0090 (-144)
Modula-2 Module: 	DOSProcess
Syntax:		        Exit(returnCode)
C:            		void Exit(long)
Machine Language: 	Exit(d1)
Modula-2:		Exit(returnCode: LONGINT)
Arguments:		returnCode = return code passed to parent (usually the CLI)-by
			convention, a value of zero implies no error
Result:			none
-------------------------
ExNext
Description:		examines the next entry in a directory
Library:		dos.library
Offset:         	-$006C (-108)
Modula-2 Module: 	DOS
Syntax:        		success = ExNext(lock, infoBlock)
C:            		long ExNext(BPTR, struct FilelnfoBlock *)
Machine Language: 	d0 = ExNext(d1, d2)
Modula-2:		ExNext(lock: FileLock; infoBlock: FileInfoBlockPtr): BOOLEAN
Arguments:		lock = lock of directory to examine
			infoBlock = info block to receive entry information
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
FastRand
Description:		generates a somewhat random integer
Library:		amiga.lib (linked library)
Modula-2 Module: 	none
Syntax:        		rnd = FastRand(seed)
C:            		long FastRand(long)
Machine Language: 	move.l #long,-(sp)
			jsr _FastRand ;rnd returned in d0
			addq.l #4,sp
Modula-2:		not available, use Random in RandomNumbers module
Arguments:		seed = value used to seed random number
Result:			rnd = random number calculate using the following C equation:
			rnd=(seed << 1) ^ 0x1872B41
-------------------------
FattenLayerInfo
Description:		converts 1.0 LayerInfo structure to 1.1-1.3-compatible LayerInfo
			structure
Library:		layers.library
Offset:         	-$009C (-156)
Modula-2 Module: 	none
Syntax:        		FattenLayerInfo(layerInfo)
C:            		void FattenLayerInfo(struct Layer_Info *)
Machine Language: 	FattenLayerInfo(a0)
Modula-2:		not available
Arguments:		layerInfo = LayerInfo structure to update
Result:			none
-------------------------
FindConfigBoard
Description:		finds a matching ConfigDev entry
Library:		expansion.library
Offset:          	-$0048 (-72)
Modula-2 Module: 	none
Syntax:        		configDev = FindConfigBoard(oldConfigDev, manufacturer,
			product)
C:            		struct ConfigDev *FindConfigBoard(long, long, long)
Machine Language: 	d0 = FindConfigBoard(a0, d0, d1)
Modula-2:		not available
Arguments:		oldConfigDev = ConfigDev structure just before the location in
			ConfigDev list where search should begin; NULL to start search at
			the beginning of the list
			manufacturer = manufacturer code to search for; -1 to ignore
			manufacturer code
			product = product code to search for; -1 to ignore product coed
Result:			configDev = first ConfigDev structure that matches the manufac-
			turer and product codes specified; NULL if no more matches
-------------------------
FindName
Description:		finds a system list node
Library:		exec.library
Offset:         	-$0114 (-276)
Modula-2 Module: 	Lists
Syntax:        		node = FindName(start, name)
C:            		struct Node *FindName(struct List *, char *)
Machine Language: 	d0 = FindName(a0, a1)
Modula-2:		FindName(start: ADDRESS; name: STRPTR): NodePtr
Arguments:		start = list header or list node to start search (if node this one is
			skipped)
			name = NULL terminated string that specifies name of node
Result:			node = pointer to specified node; NULL if unsuccessful
-------------------------  
FindPort
Description:     	finds a public message port
Library:        	exec.library
Offset:         	-$0186 (-390)
Modula-2 Module: 	Ports
Syntax:        		port = FindPort(name)
C:            		struct MsgPort *FindPort(char *)
Machine Language: 	d0 = FindPort(a1)
Modula-2:		FindPort(name: STRPTR): MsgPortPtr
Arguments:		name = NULL terminated string that specifies name of port
Result:			port = pointer to specified port; NULL if unsuccessful
-------------------------
FindResident
Description:		finds a Resident structure
Library:		exec.library
Offset:        		-$0060 (-96)
Modula-2 Module: 	Resident
Syntax:        		resident = FindResident(name)
C:            		struct Resident *FindResident(char *)
Machine Language: 	d0 = FindResident(a1)
Modula-2:		FindResident(name: STRPTR): ResidentPtr
Arguments:		name = NULL terminated string that specifies name of Resident
			structure
Result:			resident = pointer to specified Resident structure; NULL if
			unsuccessful
-------------------------
FindSemaphore
Description:		finds a SignalSemaphore structure
Library:		exec.library
Offset:        		-$0252 (-612)
Modula-2 Module: 	Semaphores
Syntax:        		semaphore = FindSemaphore(name)
C:            		struct SignalSemaphore *FindSemaphore(char *)
Machine Language: 	d0 = FindSemaphore(a1)
Modula-2:		FindSemaphore(name: STRPTR): SignalSemaphorePtr
Arguments:		name = NULL terminated string that specifies name of
			semaphore
Result:			semaphore = pointer to specified SignalSemaphore structure;
			NULL if unsuccessful
-------------------------  
FindTask
Description:     	finds a task
Library:        	exec.library
Offset:         	-$0126 (-294)
Modula-2 Module: 	Tasks
Syntax:        		task = FindTask(name)
C:            		struct Task *FindTask(char *)
Machine Language:	d0 = FindTask(a1)
Modula-2:		FindTask(name: STRPTR): TaskPtr
Arguments:		name = NULL terminated string that specifies name of task
Result:			task = pointer to specified task; NULL if unsuccessful
-------------------------
FindToolType
Description:		finds value of a ToolType variable
Library:		icon.library
Offset:       		-$0060 (-96)
Modula-2 Module: 	Icon
Syntax:        		value = FindToolType(toolTypeArray, typeName)
C:            		struct char *FindToolType(char *, char *)
Machine Language: 	d0 = FindToolType(a0, a1)
Modula-2:		FindToolType(toolTypeArray: StrArrayPtr; typeName: STRPTR):
			ADDRESS
Arguments:		toolTypeArray = pointer to an array of strings containing tool
			types
			typeName = NULL terminated string that specifies tool type to
			find
Result:			value = pointer to string containing specified tool type; NULL if
			typeName not found in toolTypeArray
-------------------------
Flood
Description:	floods (fills) an area of a RastPort
Library:	graphics.library
Offset:       -$014A (-330)
Modula-2 Module: Pens
Syntax:        Flood(rastPort, mode, x, y)
C:            void Flood(struct RastPort *, long, long, long)
Machine Language: Flood(a1, d2, d0, d1)
Modula-2:		Flood(rastPort: RastPortPtr; mode: LONGCARD; x, y: INTEGER)  
Arguments:	rastPort = RastPort to fill
	mode = type of fill- 0 (fill pixels that are the same color as
	AOLPen) or 1 (fill pixels that are the same color as pixel at x,y)
	x = horizontal coordinate where fill will begin
	y = vertical coordinate where fill will begin

Result:			none
-------------------------
FlushCList
Description:		clears a character list
Library:		clist.library
Offset:			-$0030 (-48)
Modula-2 Module:	none
Syntax:			FlushCList(cList)
C:			void FlushCList(long)
Machine Language:	FlushCList(a0)
Modula-2:		not available
Arguments:		cList = CList header-as returned by AllocCList( )
			or StrToCL( )-used to manage character list to clear
Result:			none
-------------------------
Forbid
Description:		prevents task rescheduling
Library:		exec.library
Offset:			-$0084 (-132)
Modula-2 Module:	Interrupts
Syntax:			Forbid( )
C:			void Forbid(void)
Machine Language:	Forbid( )
Modula-2:		Forbid( )
Arguments:		none
Result:			none
-------------------------
fpa
Description:		converts a fast floating point number into an ASCII string
Library:		amiga.lib (linked library)
Modula-2 Module:	none
Syntax:			exp = fpa(fnum, string)
C:			long fpa(float, char *)
Machine Language:	pea string 
			move.l fnum,-(sp)
			jsr _fpa ;exp returned in d0 and string equals fnum 
			addq.l #8,sp
Modula-2:		not available
Arguments:		fnum = floating point number to convert
			string = address of string to receive ASCII equivalent of fnum
			argument
Result:			exp = integer exponent of fnum
-------------------------
fpbcd
Description:		converts a fast floating point number into BCD format
Library:		amiga.lib (linked library)
Modula-2 Module:	none
Syntax:			fpbcd(fnum, string)
C:			void fpbcd(float, char *)
Machine Language:	pea string
			move.l fnum,-(sp)
			jsr _fpbcd ;BCD equivalent of fnum returned in string
			addq.l #8,sp
Modula-2:		not available
Arguments:		fnum = floating point number to convert
			string = address of five-byte string to receive BCD equivalent of
			fnum argument
Result:			string argument receives the BCD equivalent of fnum argument
-------------------------
FreeBoardMem
Description:		frees expansion board memory (opposite of AllocBoardMem( )
Library:		expansion.library
Offset:			-$004E (-78)
Modula-2 Module:	Expansion
Syntax:			FreeBoardMem(startSlot, slotSpec)
C:			void FreeBoardMem(long, long)
Machine Language:	d0 = FreeBoardMem(d0, d1)
Modula-2:		FreeBoardMem(startslot, slotSpeC: INTEGER)
Arguments:		startSlot = slot number as returned by AllocBoardMem( )
			slotSpec = number of slots to free
Result:			none
-------------------------
Modula-2:		FreeMem(memoryBlock: ADDRESS: byteSize: LONGCARD)
Arguments:		memoryBlock = pointer to memory block to free
			byteSize = size of block in bytes
Result:			none
-------------------------  
FreeCList
Description:		releases character list descriptor and any resources it uses
Library:        	clist.library
Offset:			-$002A (-42)
Modula-2 Module:	none
Syntax:			FreeCList(cList)
C:			void FreeCList(long)
Machine Language:	FreeCList(a0)
Modula-2:		not available
Arguments:		cList = descriptor of character list to free
Result:			none
-------------------------
FreeColorMap
Description:		returns memory used by a ColorMap structure
Library:		graphics.library
Offset:			-$0240 (-576)
Modula-2 Module:	Views
Syntax:			FreeColorMap(colorMap)
C:			void FreeColorMap(struct ColorMap *)
Machine Language:	FreeColorMap(a0)
Modula-2:		FreeColorMap(colorMap: ColorMapPtr)
Arguments:		colorMap = ColorMap structure to free
Result:			none
-------------------------
FreeConfigDev
Description:		frees a ConfigDev structure
Library:		expansion.library
Offset:			-$0054 (-84)
Modula-2 Module:	ConfigVars
Syntax:			FreeConfigDev(configDev)
C:			void FreeConfigDev(struct ConfigDev *)
Machine Language:	FreeConfigDev(a0)
Modula-2:       	FreeConfigDev(configDev: ConfigDevPtr)
Arguments:     		configDev = ConfigDev structure as returned by AllocConfigDev( )
Result:			none
-------------------------  
FreeCopList
Description:		returns memory allocated for an intermediate copper list
Library:        	graphics.library
Offset:			-$0222 (-546)
Modula-2 Module:	Copper
Syntax:			FreeCopList(copList)
C:			void FreeCopList(struct CopList *)
Machine Language:	FreeCopList(a0)
Modula-2:		FreeCopList(copList: CopListPtr)
Arguments:		copList = CopList structure to free
Result:			none
-------------------------
FreeCprList
Description:		returns memory allocated for a hardware copper list
Library:		graphics.library
Offset:			-$0234 (-564)
Modula-2 Module:	Copper
Syntax:			FreeCprList(cprlist)
C:			void FreeCprList(struct cprlist *)
Machine Language:	FreeCprList(a0)
Modula-2:		FreeCprList(cprlist: cprlistPtr)
Arguments:		cprlist = cprlist structure to free
Result:			none
-------------------------
FreeDiskObject
Description:		frees memory allocated for a Workbench disk object
Library:		icon.library
Offset:			-$005A (-90)
Modula-2 Module:	Icon
Syntax:			FreeDiskObject(diskObj)
C:			void FreeDiskObject(struct DiskObject *)
Machine Language:	FreeDiskObject(a0)
Modula-2:		FreeDiskObject(diskObj: DiskObjectPtr)
Arguments:		diskObj = DiskObject structure to free
Result:			none
-------------------------  
FreeEntry
Description:		frees many regions of memory
Library:		exec.library
Offset:			-$00E4 (-228)
Modula-2 Module:	Memory
Syntax:			FreeEntry(memList)
C:			void FreeEntry(struct MemList *)
Machine Language:	FreeEntry(a0)
Modula-2:		FreeEntry(memList: MemListPtr)
Arguments:		memList = MemList structure
Result:			none
-------------------------
FreeExpansionMem
Description:		frees expansion memory
Library:		expansion.library
Offset:			-$005A (-90)
Modula-2 Module:	Expansion
Syntax:			FreeExpansionMem(startSlot, numSlots)
C:			void FreeExpansionMem(long, long)
Machine Language:	FreeExpansionMem(d0, d1)
Modula-2:		FreeExpansionMem(startSlot, numSlots: INTEGER)
Arguments:		startSlot = slot number as returned by AllocExpansionMem( )
			slotSpec = number of slots to free
Result:			none
-------------------------
FreeFreeList
Description:		frees all memory in a free list
Library:		icon.library
Offset:			-$0036 (-54)
Modula-2 Module:	Icon
Syntax:			FreeFreeList(freeList)
C:			void FreeFreeList(struct FreeList *)
Machine Language:	FreeFreeList(a0)
Modula-2:		FreeFreeList(freeList: FreeListPtr)
Arguments:		memList = FreeList structure
Result:			none
-------------------------
FreeGBuffers
Description:		frees memory allocated by GetGBuffers( )
Library:		graphics.library
Offset:			-$0258 (-600)
Modula-2 Module:	Gels
Syntax:			FreeGBuffers(animOb, rastPort, dBuffer)
C:			void FreeGBuffers(struct AnimOb *, struct RastPort *, long)
Machine Language:	FreeGBuffers(a0, a1, d0)
Modula-2:		FreeGBuffers(animOb: AnimObPtr; rastPort: RastPortPtr; dBuffer:
			BOOLEAN)
Arguments:		animOb = AnimOb structure
			rastPort = Rastport structure
			dBuffer = double-buffer flag-TRUE for double-buffering
Result:			none
-------------------------
FreeMem
Description:		frees memory allocated by GetGBuffers( )
Library:		exec.library
Offset:			-$00D2 (-210)
Modula-2 Module:	Memory
Syntax:			FreeMem(memoryBlock, byteSize)
C:			void FreeMem(void *, long)
Machine Language:	FreeMem(a1, d0)
Modula-2:		FreeMem(memoryBlock: ADDRESS: byteSize: LONGCARD)
Arguments:		memoryBlock = pointer to memory block to free
			byteSize = size of block in bytes
Result:			none
-------------------------
FreeRaster
Description:		frees memory allocated by AllocRaster( )
Library:		graphics.library
Offset:			-$01F2 (-498)
Modula-2 Module:	Rasters
Syntax:			FreeRaster(p, width, height)
C:			void FreeRaster(PLANEPTR, long, long)
Machine Language:	FreeRaster(a0, d0, d1)
Modula-2:		FreeRaster(p: PlanePtr; width, height: CARDINAL)
Arguments:		p = memory block returned by AllocRaster( )
		width = width of bitplanes in pixels
		height = height of bitplanes in pixels
Result:			none
-------------------------  
FreeRemember
Description:		frees memory allocated by AllocRemember( )
Library:		intuition.library
Offset:			-$0198 (-408)
Modula-2 Module:	Intuition
Syntax:			FreeRemember(rememberKey, reallyForget)
C:			void FreeRemember(struct Remember *, long)
Machine Language:	FreeRemember(a0, d0)
Modula-2:		FreeRemember(rememberKey: RememberPrt; reallyForget:
			BOOLEAN)
Arguments:		rememberKey = address of pointer to Remember structure
			reallyForget = TRUE to free memory and link nodes; FALSE to
			free only link nodes
Result:			none
-------------------------
FreeSignal
Description:		frees a signal bit
Library:		exec.library
Offset:			-$0150 (-336)
Modula-2 Module:	Tasks
Syntax:			FreeSignal(signalNum)
C:			void FreeSignal(long)
Machine Language:	FreeSignal(d0)
Modula-2:		FreeSignal(signalNum: SIGNAL)
Arguments:		signalNum = signal number to free (0-31)
Result:			none
-------------------------
FreeSprite
Description:		makes sprite available for others to use
Library:		graphics.library
Offset:			-$019E (-414)
Modula-2 Module:	Sprites
Syntax:			FreeSprite(pick)
C:			void FreeSprite(long)
Machine Language:	FreeSprite(d0)
Modula-2:		FreeSprite(pick: INTEGER)
Arguments:		pick = number of sprite to free (0-7)
Result:			none
-------------------------
FreeSysRequest
Description:		frees memory allocated by BuildSysRequest( )
Library:		intuition.library
Offset:			-$0174 (-372)
Modula-2 Module:	Intuition
Syntax:			FreeSysRequest(window)
C:			void FreeSysRequest(struct Window *)
Machine Language:	FreeSysRequest(a0)
Modula-2:		FreeSysRequest(window: WindowPtr)
Arguments:		window = Window structure as returned by BuildSysRequest( )
Result:			none
-------------------------
FreeTrap
Description:		frees a processor trap
Library:		exec.library
Offset:			-$015C (-348)
Modula-2 Module:	Tasks
Syntax:			FreeTrap(trapNum)
C:			void FreeTrap(long)
Machine Language:	FreeTrap(d0)
Modula-2:		FreeTrap(trapNum: TRAP)
Arguments:		trapNum = trap number to free (0-15)
Result:			none
-------------------------
FreeVPortCoplists
Description:		frees all intermediate copper lists and their headers from a
			ViewPort
Library:		graphics.library
Offset:			-$021C (-540)
Modula-2 Module:	Views
Syntax:			FreeVPortCopLists(viewPort)
C:			void FreeVPortCopLists(struct ViewPort *)
Machine Language:	FreeVPortCopLists(a0)
Modula-2:		FreeVPortCopLists(viewPort: ViewPortPtr)
Arguments:		viewPort = ViewPort structure containing copper lists
Result:			none
-------------------------  
FreeWBObject
Description:		frees memory allocated for a Workbench object
Library:		icon.library
Offset:			-$003C (-60)
Modula-2 Module:	none
Syntax:			FreeWBObject(object)
C:			void FreeWBObject(struct WBObject *)
Machine Language:	FreeWBObject(a0)
Modula-2:		not available
Arguments:		object = WBObject structure to free
Result:			none
--------------------------
GetCC
Description:		gets 68000/68010 condition codes
Library:		exec.library
Offset:			-$0210 (-528)
Modula-2 Module:	Exec
Syntax:			condition = GetCC( )
C:			long GetCC(void)
Machine Language:	d0 = GetCC( )
Modula-2:		GetCC( ): BITSET
Arguments:		none
Result:			condition = 68000/68010 condition code
-------------------------
GetCLBuf
Description:		converts character list into contiguous data
Library:		clist.library
Offset:			-$0072 (-114)
Modula-2 Module:	none
Syntax:			length = GetCLBuf(cList, buffer, maxLength)
C:			long GetCLBuf(long, char *, long)
Machine Language:	d0 = GetCLBuf(a0, a1, d1)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
			buffer = buffer to hold data
			maxLength = maximum size of buffer in bytes
Result:			length = number of bytes copied into buffer
-------------------------  
GetCLChar
Description:		gets a byte from the beginning of a character list
Library:		clist.library
Offset:			-$0042 (-66)
Modula-2 Module:	none
Syntax:			byte = GetCLChar(cList)
C:			long GetCLChar(long)
Machine Language:	d0 = GetCLChar(a0)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
Result:			byte = byte from beginning of character list; -1 if no data
-------------------------
GetCLWord
Description:		gets a word from the beginning of a character list
Library:		clist.library
Offset:			-$005A (-90)
Modula-2 Module:	none
Syntax:			word = GetCLWord(cList)
C:			long GetCLWord(long)
Machine Language:	d0 = GetCLWord(a0)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
Result:			word = word from beginning of character list; -1 if no data
-------------------------
GetColorMap
Description:		allocates and initializes a ColorMap structure
Library:		graphics.library
Offset:			-$023A (-570)
Modula-2 Module:	Views
Syntax:			colorMap = GetColorMap(entries)
C:			struct ColorMap *GetColorMap(long)
Machine Language:	d0 = GetColorMap(d0)
Modula-2:		GetColorMap(colorMap: LONGINT): ColorMapPtr
Arguments:		entries = number of entries for this color map
Result:			colorMap = pointer to ColorMap structure; O if unsuccessful
-------------------------  
GetCurrentBinding
Description:		sets static board configuration area
Library:		expansion.library
Offset:			-$008A (-138)
Modula-2 Module:	none
Syntax:			actual = GetCurrentBinding(currentBinding, size)
C:			long GetCurrentBinding(long, long)
Machine Language:	d0 = GetCurrentBinding(a0, d0)
Modula-2:		not available
Arguments:		currentBinding = CurrentBinding structure
			size = size of user's BindDriver structure
Result:			actual = actual size of the CurrentBinding structure
-------------------------
GetDefPrefs
Description:		gets a copy of the default Preferences
Library:		intuition.library
Offset:			-$007E (-126)
Modula-2 Module:	Preferences
Syntax:			prefBuffer = GetDefPrefs(prefBuffer, size)
C:			struct Preferences *GetDefPrefs(struct Preferences *, long)
Machine Language:	d0 = GetDefPrefs(a0, d0)
Modula-2:		GetDefPrefs(prefBuffer: ADDRESS; size: INTEGER): ADDRESS
Arguments:		prefBuffer = buffer to receive copy of default Preferences
			size = size of buffer in bytes
Result:			prefBuffer = pointer to your buffer
-------------------------
GetDiskObject
Description:		reads a Workbench DiskObject (.info file) from disk
Library:		icon.library
Offset:			-$004E (-78)
Modula-2 Module:	Icon
Syntax:			diskObj = GetDiskObject(name)
C:			struct DiskObject *GetDiskObject(char *)
Machine Language:	d0 = GetDiskObject(a0)
Modula-2:		GetDiskObject(name: STRPTR): DiskObjectPtr
Arguments:		name = name of Workbench object (.info file)
Result:			diskObj = pointer to DiskObject structure; 0 if unsuccessful
-------------------------  
GetGBuffers
Description:		attempts to allocate all buffers of an enter AnimOb
Library:		graphics.library
Offset:			-$00A8 (-168)
Modula-2 Module:	Gels
Syntax:			success = GetGBuffers(animOb, rastPort, dBuffer)
C:			long GetGBuffers(struct AnimOb *, struct RastPort *, long)
Machine Language:	d0 = GetGBuffers(a0, a1, d0)
Modula-2:		GetGBuffers(animOb: AnimObPtr; rastPort: RastPortPtr; dBuffer:
			BOOLEAN): BOOLEAN
Arguments:		animOb = AnimOb structure
			rastPort = Rastport structure
			dBuffer = double-buffer flag-TRUE for double-buffering
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
GetIcon
Description:		reads a DiskObject structure from disk
Library:		icon.library
Offset:			-$002A (-42)
Modula-2 Module:	none
Syntax:			status = GetIcon(name, icon, free)
C:			long GetIcon(char *, struct DiskObject *, struct FreeList *)
Machine Language:	d0 = GetIcon(a0, a1, a2)
Modula-2:		not available
Arguments:		name = name of icon (.info file)
			icon = DiskObject structure
			free = FreeList structure
Result:			status = nonzero if successful
-------------------------
GetMsg
Description:		gets next message from a message port
Library:		exec.library
Offset:			-$0174 (-372)
Modula-2 Module:	Ports
Syntax:			message = GetMsg(port)
C:			struct Message *GetMsg(struct MsgPort *)
Machine Language:	d0 = GetMsg(a0)
Modula-2:		GetMsg(port: MsgPortPtr): ADDRESS
Arguments:		port = receiving message port
Result:			message = pointer to first message; NULL if no message
-------------------------
GetPrefs
Description:		gets Preferences' current settings
Library:		intuition.library
Offset:			-$0084 (-132)
Modula-2 Module:	Preferences
Syntax:			prefBuffer = GetDefPrefs(prefBuffer, size)
C:			struct Preferences *GetDefPrefs(struct Preferences *, long)
Machine Language:	d0 = GetDefPrefs(a0, d0)
Modula-2:		GetDefPrefs(prefBuffer: ADDRESS; size: INTEGER): ADDRESS
Arguments:		prefBuffer = buffer to receive copy of Preferences
			size = size of buffer in bytes
Result:			prefBuffer = pointer to your buffer
-------------------------
GetRGB4
Description:		gets the value of an entry in a ColorMap structure
Library:		graphics.library
Offset:			-$0246 (-582)
Modula-2 Module:	Views
Syntax:			value = GetRGB4(colorMap, entry)
C:			long GetRGB4(struct ColorMap *, long)
Machine Language:	d0 = GetRGB4(a0, d0)
Modula-2:		GetRGB4(colorMap: ColorMapPtr; entry: LONGINT): INTEGER
Arguments:		colorMap = ColorMap structure
			entry = index into color table, specifying desired entry
Result:			value = two-byte, right-justified RGB value with four bits per
			color-red, green, blue; -1 if no valid entry
-------------------------
GetSereenData
Description:		copies all or part of a Screen structure into buffer; opens specifled
			screen if not already open
Library:		intuition.library
Offset:			-$01AA (-426)
Modula-2 Module:	Intuition
Syntax:			success = GetScreenData(buffer, size, type, screen)
C:			long GetScreenData(char *, long, long, struct Screen *)
Machine Language:	d0 = GetScreenData(a0, d0, d1, a1)
Modula-2:		GetScreenData(buffer: ADDRESS; size: CARDINAL; type:
			ScreenFlagSet; screen: ScreenPtr): BOOLEAN
Arguments:		buffer = buffer in which data will be placed
			size = size of buffer in bytes
			type = screen type-CUSTOMSCREEN, WORKBENCHSCREEN
			screen = custom Screen structure; ignored if type argument
			equals WORKBENCHSCREEN

Result:			success = TRUE if successful; FALSE if screen not available and
			could not be opened
-------------------------
GetSprite
Description:		allocates hardware sprite for simple sprite manager
Library:		graphics.library
Offset:			-$0198 (-408)
Modula-2 Module:	Sprites
Syntax:			spriteNumber = GetSprite(sprite, pick)
C:			long GetSprite(struct SimpleSprite *, long)
Machine Language:	d0 = GetSprite(a0, d0)
Modula-2:		GetSprite(sprite: SimpleSpritePtr; pick: INTEGER): INTEGER
Arguments:		sprite = SimpleSprite structure
			pick = number of desired sprite (0-7); -1 for next available
			sprite
Result:			spriteNumber = number of sprite allocated; -1 if sprite
			unavailable
-------------------------
GetWBObject
Description:		reads in a Workbench object from disk
Library:		icon.library
Offset:			-$001E (-30)
Modula-2 Module:	none
Syntax:			object = GetWBObject(name)
C:			struct WBObject *GetWBObject(char *)
Machine Language:	d0 = GetWBObject(a0)
Modula-2:		not available
Arguments:		name = NULL terminated string that specifies name of Work-
			bench object
Result:			object = pointer to Workbench object; 0 if unsuccessful
------------------------- 
IEEEDPAbs
Description:		obtains the absolute value of an IEEE double-precision floating-
			point number
Library:		mathieeedoubbas.library
Offset:			-$0036 (-54)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPAbs(fnum2)
C:			double IEEEDPAbs(double)
Machine Language:	d0/d1 = IEEEDPAbs(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
Result:			fnum1 = absolute value of fnum2 in IEEE double-precision
			floating-point format
-------------------------
IEEEDPAcos
Description:		obtains the arccosine of an IEEE double-precision floating-point
			number
Library:		mathieeedoubtrans.library
Offset:			-$0078 (-120)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPAcos(fnum2)
C:			double IEEEDPAcos(double)
Machine Language:	d0/d1 = IEEEDPAcos(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing the cosine of an angle
Result:			fnum1 = IEEE double-precision floating-point value of fnum2 an-
			gle in radians
-------------------------
IEEEDPAdd
Description:		adds two IEEE double-precision floating-point numbers
Library:		mathieeedoubbas.library
Offset:			-$0042 (-66)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPAdd(fnum2, fnum3)
C:			double IEEEDPAdd(double, d0uble)
Machine Language:	d0/d1 = IEEEDPAdd(d0/d1, d2/d3)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
			fnum3 = IEEE double-precision floating-point number
Result:			fnum1 = fnum2 plus fnum3 in IEEE double-precision floating-
			point format
-------------------------
IEEEDPAsin
Description:		obtains the arcsine of an IEEE double-precision floating-point
			number
Library:		mathieeedoubtrans.library
Offset:			-$0072 (-114)
Modula-2 Module:	none
Syntax:			fnum2 = IEEEDPAsin(fnum2)
C:			double IEEEDPAsin(double)
Machine Language:	d0/d1 = IEEEDPAsin(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing the sine of an angle
Result:			fnum1 = IEEE double-precision floating-point value of fnum2 an-
			gle in radians
-------------------------
IEEEDPAtan
Description:		obtains the arctangent of an IEEE double-precision floating-point
			number
Library:		mathieeedoubtrans.library
Offset:			-$0030 (-48)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPAtan(fnum2)
C:			double IEEEDPAtan(double)
Machine Language:	d0/d1 = IEEEDPAtan(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing the tangent of an angle
Result:			fnum1 = IEEE double-precision floating-point value of fnum2 an-
			gle in radians
-------------------------
IEEEDPCeil
Description:		obtains the Ceil function of an IEEE double-precision floating-
			point number (rounds it up)
Library:		mathieeedoubbas.library
Offset:			-$0060 (-96)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPCeil(fnum2)
C:			double IEEEDPCeil(double)
Machine Language:	d0/d1 = IEEEDPCeil(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
Result:			fnum1 = IEEE double-precision floating-point integer value that's
			closest to, but not less than the value of fnum2
-------------------------
IEEEDPCmp
Description:		compares two IEEE double-precision floating-point numbers
Library:		mathieeedoubbas.library
Offset:			-$002A (-42)
Modula-2 Module:	none
Syntax:			flag = IEEEDPCmp(fnum1, fnum2)
C:			long IEEEDPCmp(double, d0uble)
Machine Language:	d0 = IEEEDPCmp(d0/d1, d2/d3)
Modula-2:		not available
Arguments:		fnum1 = IEEE double-precision floating-point number
			fnum2 = IEEE double-precision floating-point number
Result:			flag = -1 if fnum1<fnum2; +1 if fnum1>fnum2; 0 if
			fnum1 = fnum2
-------------------------
IEEEDPCos
Description:		obtains the cosine of an IEEE double-precision floating-point
			number
Library:		mathieeedoubtrans.library
Offset:			-$002A (-42)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPCos(fnum2)
C:			double IEEEDPCos(double)
Machine Language:	d0/d1 = IEEEDPCos(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing an angle in radians
Result:			fnum1 = IEEE double-precision floating-point cosine of fnum2
-------------------------
IEEEDPCosh
Description:		obtains the hyperbolic cosine of an IEEE double-precision float-
			ing-point number
Library:		mathieeedoubtrans.library
Offset:			-$0042 (-66)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPCosh(fnum2)
C:			double IEEEDPCosh(double)
Machine Language:	d0/d1 = IEEEDPCosh(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing an angle in radians
Result:			fnum1 = IEEE double-precision floating-point hyperbolic cosine
			of fnum2
-------------------------
IEEEDPDiv
Description:		divides one IEEE double-precision floating-point number by
			another
Library:		mathieeedoubbas.library
Offset:			-$0054 (-84)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPDiv(fnum2, fnum3)
C:			double IEEEDPDiv(double, d0uble)
Machine Language:	d0/d1 = IEEEDPDiv(d0/d1, d2/d3)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point dividend
			fnum3 = IEEE double-precision floating-point divisor
Result:			fnum1 = IEEE double-precision floating-point format results of
			fnum2 divided by fnum3
-------------------------
IEEEDPExp
Description:		obtains the exponent of an IEEE double-precision floating-point
			number
Library:		mathieeedoubtrans.library
Offset:			-$004E (-78)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPExp(fnum2)
C:			double IEEEDPExp(double)
Machine Language:	d0/d1 = IEEEDPExp(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
Result:			fnum1 = IEEE double-precision floating-point value representing
			e raised to the power of fnum2
-------------------------
IEEEDPFieee
Description:		converts a IEEE single-precision floating-point number to an IEEE
			double-precision floating-point number
Library:		mathieeedoubtrans.library
Offset:			-$006C (-108)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPFieee(fnum2)
C:			double IEEEDPFieee(float)
Machine Language:	d0/d1 = IEEEDPFieee(d0)
Modula-2:		not available
Arguments:		fnum2 = IEEE single-precision floating-point number
Result:			fnum1 = IEEE double-precision floating-point equivalent to
			fnum2
-------------------------
IEEEDPFix
Description:		converts an IEEE double-precision floating-point number to an
			integer
Library:		mathieeedoubbas.library
Offset:			-$001E (-30)
Modula-2 Module:	none
Syntax:			inum = IEEEDPFix(fnum)
C:			long IEEEDPFix(double)
Machine Language:	d0 = IEEEDPFix(d0/d1)
Modula-2:		not available
Arguments:		fnum = IEEE double-precision floating-point number
Result:			inum = integer equivalent to fnum
-------------------------
IEEEDPFloor
Description:		obtains the Floor function of an IEEE double-precision floating-
			point number (rounds it down)
Library:		mathieeedoubbas.library
Offset:			-$005A (-90)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPFloor(fnum2)
C:			double IEEEDPFloor(double)
Machine Language:	d0/d1 = IEEEDPFloor(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
Result:			fnum1 = IEEE double-precision floating-point integer value that's
			closest to, but not greater than the value of fnum2
-------------------------
IEEEDPFlt
Description:		converts an integer to an IEEE double-precision floating-point
			number
Library:		mathieeedoubbas.library
Offset:			-$0024 (-36)
Modula-2 Module:	none
Syntax:			fnum = IEEEDPFlt(inum)
C:			double IEEEDPFlt(long)
Machine Language:	d0/d1 = IEEEDPFlt(d0)
Modula-2:		not available
Arguments:		inum = signed integer to be converted
Result:			fnum = IEEE double-precision floating-point equivalent to inum
-------------------------
IEEEDPLog
Description:		obtains the natural logarithm of an IEEE double-precision floating-
			point number
Library:		mathieeedoubtrans.library
Offset:			-$0054 (-84)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPLog(fnum2)
C:			double IEEEDPLog(double)
Machine Language:	d0/d1 = IEEEDPLog(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
Result:		        fnum1 = IEEE double-precision floating-point natural logarithm
			(base e) of fnum2
-------------------------
IEEEDPlog10
Description:		obtains the naparian logarithm (base 10) of an IEEE double-
			precision floating-point number
Library:		mathieeedoubtrans.library
Offset:			-$007E (-126)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPLog10(fnum2)
C:			double IEEEDPLog10(double)
Machine Language:	d0/d1 = IEEEDPLog10(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
Result:			fnum1 = IEEE double-precision floating-point naparian logarithm
			(base 10) of fnum2
-------------------------
IEEEDPMul
Description:		multiplies one IEEE double-precision floating-point number by
			another
Library:		mathieeedoubbas.library
Offset:			-$004E (-78)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPMul(fnum2, fnum3)
C:			double IEEEDPMul(double, d0uble)
Machine Language:	d0/d1 = IEEEDPMul(d0/d1, d2/d3)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
			fnum3 = IEEE double-precision floating-point number
Result:			fnum1 = product of fnum2 and fnum3 in IEEE double-precision
			floating-point format
-------------------------
IEEEDPNeg
Description:		negates the value of an IEEE double-precision floating-point number
Library:		mathieeedoubbas.library
Offset:			-$003C (-60)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPNeg(fnum2)
C:			double IEEEDPNeg(double)
Machine Language:	d0/d1 = IEEEDPNeg(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number to negate
Result:			fnum1 = negative fnum2 in IEEE double-precision floating-point
			format
-------------------------
IEEEDPPow
Description:		obtains the exponentiation of two IEEE double-precision floating-
			point numbers
Library:		mathieeedoubtrans.library
Offset:			-$005A (-90)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPPow(fnum2, fnum3)
C:			double IEEEDPPow(double, d0uble)
Machine Language:	d0/d1 = IEEEDPPow(d2/d3, d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
			fnum3 = IEEE double-precision floating-point number
Result:			fnum1 = IEEE double-precision floating-point value of fnum2
			raised to the power of fnum3
-------------------------
IEEEDPSin
Description:		obtains the sine of an IEEE double-precision floating-point
			number
Library:		mathieeedoubtrans.library
Offset:			-$0024 (-36)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPSin(fnum2)
C:			double IEEEDPSin(double, d0uble)
Machine Language:	d0/d1 = IEEEDPSin(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing an angle in radians
Result:			fnum1 = IEEE double-precision floating-point sine of fnum2
-------------------------
IEEEDPSincos
Description:		obtains the sine and cosine of an IEEE double-precision floating-
			point number
Library:		mathieeedoubtrans.library
Offset:			-$0036 (-54)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPSincos(fnum2, fnum3)
C:			double IEEEDPSincos(double, d0uble *)
Machine Language:	d0/d1 = IEEEDPSincos(d0/d1, a0)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
			fnum3 = pointer to an IEEE double-precision floating point num-
			ber to receive the cosine of fnum2
Result:			fnum1 = IEEE double-precision floating-point sine of fnum2 (co-
			sine is returned in fnum3)
-------------------------
IEEEDPSinh
Description:		obtains the hyperbolic sine of an IEEE double-precision floating-
			point number
Library:		mathieeedoubtrans.library
Offset:			-$003C (-60)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPSinh(fnum2)
C:			double IEEEDPSinh(double, d0uble)
Machine Language:	d0/d1 = IEEEDPSinh(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing an angle in radians
Result:			fnum1 = IEEE double-precision floating-point hyperbolic sine of
			fnum2
-------------------------
IEEEDPSqrt
Description:		obtains the square root of an IEEE double-precision floating-point
			number
Library:		mathieeedoubtrans.library
Offset:			-$0060 (-96)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPSqrt(fnum2)
C:			double IEEEDPSqrt(double)
Machine Language:	d0/d1 = IEEEDPSqrt(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
Result:			fnum1 = IEEE double-precision floating-point square root of
			fnum2
-------------------------
IEEEDPSub
Description:		subtracts one IEEE double-precision floating-point number from
			another
Library:		mathieeedoubbas.library
Offset:			-$0048 (-72)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPSub(fnum2, fnum3)
C:			double IEEEDPSub(double, d0uble)
Machine Language:	d0/d1 = IEEEDPSub(d0/d1, d2/d3)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
			fnum3 = IEEE double-precision floating-point number
Result:			fnum1 = fnum2 minus fnum3 in IEEE double-precision floating-
			point format
-------------------------
IEEEDPTan
Description:		obtains the tangent of an IEEE double-precision floating-point
			number
Library:		mathieeedoubtrans.library
Offset:			-$0030 (-48)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPTan(fnum2)
C:			double IEEEDPTan(double, d0uble)
Machine Language:	d0/d1 = IEEEDPTan(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing an angle in radians
Result:			fnum1 = IEEE double-precision floating-point tangent of fnum2
-------------------------
IEEEDPTanh
Description:		obtains the hyperbolic tangent of an IEEE double-precision
			floating-point number
Library:		mathieeedoubtrans.library
Offset:			-$0048 (-72)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPTanh(fnum2)
C:			double IEEEDPTanh(double, d0uble)
Machine Language:	d0/d1 = IEEEDPTanh(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing an angle in radians
Result:			fnum1 = IEEE double-precision floating-point hyperbolic tangent
			of fnum2
------------------------- 
IEEEDPTIeee
Description:		converts an IEEE double-precision floating-point number to an
			IEEE single-precision floating-point number
Library:		mathieeedoubtrans.library
Offset:			-$0066 (-102)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPTieee(fnum2)
C:			float IEEEDPTieee(double)
Machine Language:	d0 = IEEEDPTieee(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
Result:			fnum1 = IEEE single-precision floating-point equivalent to fnum2
-------------------------
IEEEDPTst
Description:		compares an IEEE double-precision floating-point number with
			zero
Library:		mathieeedoubbas.library
Offset:			-$0030 (-48)
Modula-2 Module:	none
Syntax:			flag = IEEEDPTst(fnum)
C:			long IEEEDPTst(double)
Machine Language:	d0 = IEEEDPTst(d0/d1)
Modula-2:		not available
Arguments:		fnum = IEEE double-precision floating-point number
Result:			flag = -1 if fnum <0; +1 if fnum >0; 0 if fnum=0
-------------------------
IncrCLMark
Description:		increments character list mark to the next position
Library:		clist.library
Offset:			-$007E (-126)
Modula-2 Module:	none
Syntax:			error = IncrCLMark(cList)
C:			long IncrCLMark(long)
Machine Language:	d0 = IncrCLMark(a0)
Modula-2:      		not available
Arguments:		cList = character list descriptor
Result:			error = 0 if successful; nonzero if next offset is not in the charac-
			ter list
-------------------------
Info
Description:		returns information about a disk or disk file
Library:		dos.library
Offset:			-$0072 (-114)
Modula-2 Module:	DOS
Syntax:			success = Info(lock, infoData)
C:		        long Info(BPTR, struct InfoData *)
Machine Language:	d0 = Info(d1, d2)
Modula-2:		Info(lock: FileLock; infoData: InfoDataPtr): BOOLEAN
Arguments:		lock = BCPL pointer to a lock
			infoData = InfoData structure to be filled
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
InitArea
Description:		initializes vector collection matrix
Library:		graphics.library
Offset:			-$011A (-282)
Modula-2 Module:	Areas
Syntax:			InitArea(areaInfo, buffer, maxVectors)
C:		        long InitArea(struct AreaInfo *, short *, long)
Machine Language:	InitArea(a0, a1, d0)
Modula-2:		InitArea(areaInfo: AreaInfoPtr; buffer: ADDRESS; maxVectors:
			INTEGER)
Arguments:		areaInfo = AreaInfo structure
			buffer = pointer to memory block where vectors will be stored-
			must start on word boundary and should be 5*maxVectors bytes
			long
			maxVectors = maximum number of vectors
Result:			none
-------------------------
InitBitMap
Description:		initializes a BitMap structure
Library:		graphics.library
Offset:			-$0186 (-390)
Modula-2 Module:	Graphics
Syntax:			InitBitMap(bitMap, depth, width, height)
C:			void InitBitMap(struct Bitmap *, long, long, long)
Machine Language:	InitBitMap(a0, d0, d1, d2)
Modula-2:		InitBitMap(bitMap: BitMapPtr; depth, width, height: INTEGER)
Arguments:		bitMap = BitMap structure
			depth = number of bit planes to be used
			width = width of each bit plane in bits
			height = height of each bit plane in lines
Result:			none
-------------------------
InitCLPool
Description:		initializes a character list pool
Library:		clist.library
Offset:			-$001E (-30)
Modula-2 Module:	none
Syntax:			error = InitCLPool(cLPool, size)
C:			long InitCLPool(long, long)
Machine Language:	d0 = InitCLPool(a0, d0)
Modula-2:		not available
Arguments:		cLPool = data area to be used as character list pool
			size = size of pool in bytes
Result:			error = 0 if successful; nonzero if pool size is too small
-------------------------
InitCode
Description:		initializes resident modules with a startup class value and version
			number
Library:		exec.library
Offset:			-$0048 (-72)
Modula-2 Module: 	Resident
Syntax:			InitCode(startClass, version)
C:			void InitCode(long, long)
Machine Language:	InitCode(d0, d1)
Modula-2:		InitCode(startClass, version: LONGCARD)
Arguments:		startClass = startup class of resident module-COLDSTART,
			COOLSTART, or WARMSTART
			version = version number of resident module
Result:			none
-------------------------
InitGels
Description:		initializes a GEL list
Library:		graphics.library
Offset:			-$0078 (-120)
Modula-2 Module:	Gels
Syntax:			InitGels(head, tail, gelsInfo)
C:			void InitGels(struct VSprite *, struct VSprite *, struct GelsInfo *)
Machine Language:	InitGels(a0, a1, a2)
Modula-2:		InitGels(head, tail: VSpritePtr; gelsInfo: GelsInfoPtr)
Arguments:		head = VSprite structure to be used as head of GEL list
			tail = VSprite structure to be used as tail of GEL list
			gelsInfo = GelsInfo structure to be initialized
Result:			none
-------------------------
InitGMasks
Description:		initializes all masks of an AnimOb structure
Library:		graphics.library
Offset:			-$00AE (-174)
Modula-2 Module:	Gels
Syntax:			InitGMasks(animOb)
C:			void InitGMasks(struct AnimOb *)
Machine Language:	InitGMasks(a0)
Modula-2:		InitGMasks(animOb: AnimObPtr)
Arguments:		animOb = AnimOb structure containing masks to initialize
Result:			none
-------------------------
InitLayers
Description:		initializes a Layer_Info structure
Library:		layers.library
Offset:			-$001E (-30)
Modula-2 Module:	none
Syntax:			InitLayers(layerInfo)
C:			void InitLayers(struct Layer_Info *)
Machine Language:	InitLayers(a0)
Modula-2:		not available
Arguments:		layerInfo = Layer_Info structure to initialize
Result:			none
-------------------------
InitMasks
Description:		initializes the BorderLine and CollMask values used by a VSprite
			structure
Library:		graphics.library
Offset:			-$007E (-126)
Modula-2 Module:	Gels
Syntax:			InitMasks(vSprite)
C:			void InitMasks(struct VSprite *)
Machine Language:	InitMasks(a0)
Modula-2:		InitMasks(vSprite: VSpritePtr)
Arguments:		vSprite = VSprite structure containing BorderLine and CollMask
			values to initialize
Result:			none
-------------------------
InitRastPort
Description:		initializes a RastPort structure
Library:		graphics.library
Offset:			-$00C6 (-198)
Modula-2 Module:	Rasters
Syntax:			InitRastPort(rastPort)
C:			void InitRastPort(struct RastPort *)
Machine Language:	InitRastPort(a1)
Modula-2:		InitRastPort(rastPort: RastPortPtr)
Arguments:		rastPort = RastPort structure to initialize
Result:			none
-------------------------
InitRequester
Description:		initializes a Requester structure
Library:		intuition.library
Offset:			-$008A (-138)
Modula-2 Module:	Intuition
Syntax:			InitRequester(requester)
C:			void InitRequester(struct Requester *)
Machine Language:	InitRequester(a0)
Modula-2:		InitRequester(requester: RequesterPtr)
Arguments:		requester = Requester structure to initialize
Result:			none
-------------------------
InitResident
Description:		initializes a resident module
Library:		exec.library
Offset:			-$0066 (-102)
Modula-2 Module:	Resident
Syntax:			InitResident(resident, segList)
C:			void InitResident(struct Resident *, char *)

Machine Language:	InitResident(a1, d1)
Modula-2:		InitResident(resident: ResidentPtr; segList: ADDRESS)
Arguments:		resident = Resident structure representing resident module to
			initialize
			segList = a segment list
Result:			none
-------------------------
InitSemaphore
Description:		initializes a SignalSemaphore structure
Library:		exec.library
Offset:			-$022E (-558)
Modula-2 Module:	Semaphores
Syntax:			InitSemaphore(signalSemaphore)
C:			void InitSemaphore(struct SignalSemaphore *)
Machine Language:	InitSemaphore(a0)
Modula-2:		InitSemaphore(signalSemaphore: SignalSemaphorePtr)
Arguments:		signalSemaphore = SignalSemaphore structure to initialize
Result:			none
-------------------------
InitStruct
Description:		clears an area of memory following rules defined by a table
Library:		exec.library
Offset:			-$004E (-78)
Modula-2 Module:	Memory
Syntax:			InitStruct(initTable, memBlock, size)
C:			void InitStruct(char *, char *, long)
Machine Language:	InitStruct(a1, a2, d0)
Modula-2:		InitStruct(initTable, memBlock: ADDRESS; size: CARDINAL)
Arguments:		initTable = pointer to the commands and data used to initialize
			memory
			memBlock = pointer to memory to be initialized
			size = size of memory to clear before it is initialized with
			initTable; 0 for no initial clearing of memory
Result:			none
-------------------------
InitTmpRas
Description:		initializes chip RAM for use by area-fill, flood-fill, and text
			functions
Library:		graphics.library
Offset:			-$01D4 (-468)
Modula-2 Module:	Rasters
Syntax:			InitTmpRas(tmpRas, buffer, size)
C:			void InitTmpRas(struct TmpRas *, char *, long)
Machine Language:	InitTmpRas(a0, a1, d0)
Modula-2:		InitTmpRas(tmpRas: TmpRasPtr; buffer: PlanePtr; size:
			LONGCARD)
Arguments:		tmpRas = TmpRas structure to be linked into a RastPort
			buffer = pointer to chip RAM memory
			size = size of buffer in bytes
Result:			none
-------------------------
InitView
Description:		initializes a View structure
Library:		graphics.library
Offset:			-$0168 (-360)
Modula-2 Module:	Views
Syntax:			InitView(view)
C:			void InitView(struct View *)
Machine Language:	InitView(a1)
Modula-2:		InitView(view: ViewPtr)
Arguments:		view = View structure to initialize
Result:			none
-------------------------
InitVPort
Description:		initializes a ViewPort structure
Library:		graphics.library
Offset:			-$00CC (-204)
Modula-2 Module:	Views
Syntax:			InitVPort(viewPort)
C:			void InitVPort(struct ViewPort *)
Machine Language:	InitVPort(a0)
Modula-2:      		InitVPort(viewPort: ViewPortPtr)
Arguments:		viewPort = ViewPort structure to initialize
Result:			none
-------------------------  
Input
Description:		gets the initial input file handle assigned to a program
Library:		dos.library
Offset:			-$0036 (-54)
Modula-2 Module:	DOS
Syntax:			file = Input( )
C:			BPTR Input(void)
Machine Language:	d0 = Input( )
Modula-2:		Input( ): FileHandle
Arguments:		none
Result:			file = BCPL pointer to a file handle
-------------------------
Insert
Description:		inserts a Node structure into a doubly-linked list
Library:		exec.library
Offset:			-$00EA (-234)
Modula-2 Module:	Lists
Syntax:			Insert(list, node, listNode)
C:			void Insert(struct List *, struct Node *, struct Node *)
Machine Language:	Insert(a0, a1, a2)
Modula-2:		Insert(list: ListPtr; node, listNode: NodePtr)
Arguments:		list = target List header
			node = Node structure to insert
			listNode = node after which to insert; NULL to insert at head
Result:			none
-------------------------
InstallClipRegion
Description:		installs a clip region into a layer
Library:		layers.library
Offset:			-$00AE (-174)
Modula-2 Module:	Layers
Syntax:			oldClipRegion = InstallClipRegion(layer, region)
C:			struct Region *InstallClipRegion(struct Layer *, struct Region *)
Machine Language:	d0 = InstallClipRegion(a0, a1)
Modula-2:		InstallClipRegion(layer: LayerPtr; region: RegionPtr): RegionPtr
Arguments:		layer = Layer structure to which region will be added
			region = Region structure to be added to layer
Result:			oldClipRegion = previous clip region that was installed; NULL if
			no previous clip region
------------------------- 
IntuiTextLength
Description:		returns the pixel width of an IntuiText string
Library:		intuition.library
Offset:			-$014A (-330)
Modula-2 Module:	Intuition
Syntax:			length = IntuiTextLength(intuiText)
C:			long IntuiTextLength(struct IntuiText *)
Machine Language:	d0 = IntuiTextLength(a0)
Modula-2:		IntuiTextLength(intuiText: IntuiTextPtr): CARDINAL
Arguments:		intuiText = IntuiText structure
Result:			length = pixel width of text
-------------------------
Intuition
Description:		sets Intuition's main entry point, where input events arrive and
			are dispatched
Library:		intuition.library
Offset:			-$0024 (-36)
Modula-2 Module:	Intuition
Syntax:			Intuition(inputEvent)
C:			void Intuition(struct InputEvent *)
Machine Language:	Intuition(a0)
Modula-2:		Intuition(inputEvent: InputEventPtr)
Arguments:		inputEvent = first input event in a linked list of InputEvent
			structures
Result:			none
-------------------------
IoErr
Description:		gets extra information from the system
Library:		dos.library
Offset:			-$0084 (-132)
Modula-2 Module:	DOS
Syntax:			error = IoErr( )
C:			long IoErr(void)
Machine Language:	d0 = IoErr( )
Modula-2:		IoErr( ): LONGINT
Arguments:		none
Result:			error = error code or other error information
------------------------- 
IsInteractive
Description:		finds out whether a file is connected to a virtual terminal
Library:		dos.library
Offset:			-$00D8 (-216)
Modula-2 Module:	DOS
Syntax:			status = IsInteractive(file)
C:			long IsInteractive(BPTR)
Machine Language:	d0 = IsInteractive(d1)
Modula-2:		IsInteractive(file: FileHandle): BOOLEAN
Arguments:		file = BCPL pointer to a file handle
Result:			status = TRUE if file is connected to a virtual terminal; FALSE if
			not
-------------------------
ItemAddress
Description:		returns address of specified MenuItem
Library:		intuition.library
Offset:			-$0090 (-144)
Modula-2 Module:	Intuition
Syntax:			address = ItemAddress(menuStrip, menuNumber)
C:			struct MenuItem *ItemAddress(struct Menu *, long)
Machine Language:	d0 = ItemAddress(a0, d0)
Modula-2:		ItemAddress(menuStrip: MenuPtr; menuNumber: CARDINAL):
			MenuItemPtr
Arguments:		menuStrip = first menu in your menu strip
			menuNumber = value with packed data that specifies the menu
			and item (and optionally subitem)
Result:			address = pointer to specified MenuItem; NULL if menuNumber
			equals NULL
-------------------------
ITEMNUM (macro)
Description:		extracts the menu item number from a value
C Include File:		include/intuition/intuition.h
ML Include File:	none
Modula-2 Module:	Intuition
Syntax:			itemNumber = ITEMNUM(menuValue)
C:			long ITEMNUM(long)
Machine Language:	not available
Modula-2:		ITEMNUM(menuValue: CARDINAL): CARDINAL
Arguments:		menuValue = 16-bit packed number representing the menu num-
			ber, item number, and subitem number
Result:			itemNumber = item number (0-63); equals NOITEM if no menu
			was selected
-------------------------
LoadRGB4
Description:		loads color register values from a data table
Library:		graphics.library
Offset:			-$00C0 (-192)
Modula-2 Module:	Views
Syntax:			LoadRGB4(viewPort, colormap, pens)
C:			void LoadRGB4(struct ViewPort *, short *, long)
Machine Language:	LoadRGB4(a0, a1, d0)
Modula-2:		LoadRGB4(viewPort: ViewPortPtr; colormap: ADDRESS; pens:
			INTEGER)
Arguments:		viewPort = ViewPort whose colors you want to change
			colormap = pointer to array of 16-bit color values, where the firs
			four bits are zero, the second contains red, the third green, and
			the fourth blue
			pens = number of consecutive color registers to load
Result:			none
-------------------------
LoadSeg
Description:		loads an AmigaDOS load module into memory
Library:		dos.library
Offset:			-$0096 (-150)
Modula-2 Module:	DOSLoader
Syntax:			segment = LoadSeg(name)
C:			BPTR LoadSeg(char *)
Machine Language:	d0 = LoadSeg(d1)
Modula-2:		LoadSeg(name: STRPTR): BPTR
Arguments:		name = NULL terminated string that specifies the filename of
			load module
Result:			segment = BCPL pointer to a segment; 0 if unsuccessful
-------------------------
LoadView
Description:		creates a display using a new copper list
Library:		graphics.library
Offset:			-$00DE (-222)
Modula-2 Module:	Views
Syntax:			LoadView(view)
C:			void LoadView(struct View *)
Machine Language:	LoadView(a1)
Modula-2:		LoadView(view: ViewPtr)
Arguments:		view = View structure with pointer to copper list
Result:			none
-------------------------
Lock
Description:		locks a directory or file
Library:		dos.library
Offset:			-$0054 (-84)
Modula-2 Module:	DOS
Syntax:			lock = Lock(name, accessMode)
C:			BPTR Lock(char *, long)
Machine Language:	d0 = Lock(d1, d2)
Modula-2:		Lock(name: STRPTR; accessMode: LONGINT): FileLock
Arguments:		name = NULL terminated string that specifies name of file or
			directory
			accessMode = type of lock-ACCESS_READ (shared) or
			ACCESS_WRITE (exclusive)
Result:			lock = BCPL pointer to a lock
-------------------------
LockIBase
Description:		locks IntuitionBase to keep other tasks (or the system) from
			changing it
Library:		intuition.library
Offset:			-$019E (-414)
Modula-2 Module:	IntuitionBase
Syntax:			lockValue = LockIBase(lockNumber)
C:			long LockIBase(long)
Machine Language:	d0 = LockIBase(d0)
Modula-2:		LockIBase(lockNumber: LONGCARD): LONGCARD
Arguments:		lockNumber = Intuition lock desired (should be zero)
Result:			lockValue = value to use to unlock IntuitionBase via
			UnlockIBase( )
-------------------------
LockLayer
Description:		locks a layer to protect it from graphics output
Library:		layers.library
Offset:			-$0060 (-96)
Modula-2 Module:	Layers
Syntax:			LockLayer(dummy, layer)
C:			void LockLayer(struct Layer_Info *, struct Layer *)
Machine Language:	LockLayer(a0, a1)
Modula-2:		LockLayer(layer: LayerPtr)
Arguments:		dummy = unused
			layer = Layer structure
Result:			none
-------------------------
LockLayerInfo
Description:		locks a Layer_Info structure to keep other tasks from changing it
Library:		layers.library
Offset:			-$0078 (-120)
Modula-2 Module:	Layers
Syntax:			LockLayerInfo(layerInfo)
C:			void LockLayerInfo(struct Layer_Info *)
Machine Language:	LockLayerInfo(a0, a1)
Modula-2:		LockLayerInfo(layerInfo: LayerInfoPtr)
Arguments:		layerInfo = Layerlnfo structure to lock
Result:			none
-------------------------
LockLayerRom
Description:		locks a Layer structure to keep other tasks from changing it
Library:		layers.library
Offset:			-$01B0 (-432)
Modula-2 Module:	Clip
Syntax:			LockLayerRom(layer)
C:			void LockLayerRom(struct Layer *)
Machine Language:	LockLayerRom(a5)
Modula-2:      		LockLayerRom(layer: LayerPtr)
Arguments:		layer = Layer structure to lock
Result:			none
-------------------------
LockLayers
Description:		stops graphic output to all layers in a Layer_Info structure
Library:		layers.library
Offset:			-$006C (-108)
Modula-2 Module:	Layers
Syntax:			LockLayers(layerInfo)
C:		        void LockLayers(struct Layer_Info *)
Machine Language:	LockLayers(a0)
Modula-2:		LockLayers(layerInfo: LayerInfoPtr)
Arguments:		layerlnfo = Layerlnfo structure with list of layers to lock
Result:			none
-------------------------
MakeDosNode
Description:		initializes the DeviceNode structure required to enter a DOS disk
			device into the system
Library:		expansion.library
Offset:			-$0090 (-144)
Modula-2 Module:	Expansion
Syntax:			deviceNode = MakeDosNode(parameterPacket)
C:           		struct DeviceNode *MakeDosNode(long *)
Machine Language:	d0 = MakeDosNode(a0)
Modula-2:		MakeDosNode(parameterPacket: ADDRESS): DeviceNodePtr
Arguments:		parameterPacket = array of long words containing the DOS han-
			dler name, exec device name, unit number (for OpenDevice( )),
			flags (for OpenDevice( )), number of long words used to describe
			the handler environment, and the file handler environment, in
			that order.
Result:			deviceNode = pointer to initialized DeviceNode structure; NULL
			if not enough memory
-------------------------
MakeFunctions
Description:		constructs a jump table of the type used by resources, libraries,
			and devices
Library:		exec.library
Offset:			-$005A (-90)
Modula-2 Module:	Libraries
Syntax:			size = MakeFunctions(destination, funcArray, funcDispBase)
C:			void MakeFunctions(char *, long *, long)
Machine Language:	d0 = MakeFunctions(a0, a1, a2)
Modula-2:		MakeFunctions(destination, funcArray, funcDispBase: ADDRESS):
			LONGCARD
Arguments:		destination = target address for function jump table
			funcArray = pointer to array of function pointers or
			displacements
			funcDispBase = pointer to base about which all function displace-
			ments are relative; 0 if functionArray contains absolute pointers
Result:			size = size of new table in bytes (Modula-2 only)
-------------------------
MakeLibrary
Description:		constructs a library vector and data area
Library:		exec.library
Offset:			-$0054 (-84)
Modula-2 Module:	Libraries
Syntax:			library = MakeLibrary(vectors, structure, init, dataSize, segList)
C:			struct Library *MakeLibrary(long *, char *, _fptr, long, char *)
Machine Language:	d0 = MakeLibrary(a0, a1, a2, d0, d1)
Modula-2:		MakeLibrary(vectors, structure: ADDRESS; init: MAKELIBPROC;
			dataSize: LONGCARD; segList: ADDRESS): LibraryPtr
Arguments:		vectors = pointer to an array of function displacements-if first
			word is -1 array contains relative word displacements; otherwise
			array contains absolute function pointers
			structure = pointer to an InitStruct data region; can be NULL
			init = entry point that will be called before adding the library;
			can be NULL
			dataSize = size of library data area, including the standard library
			node data
			segList = pointer to a memory segment list (used by DOS)
Result:			library = reference address of library
-------------------------
MakeScreen
Description:		executes an Intuition-integrated MakeVPort( ) of a custom screen
Library:		intuition.library
Offset:			-$017A (-378)
Modula-2 Module:	Intuition
Syntax:			MakeScreen(screen)
C:			void MakeScreen(struct Screen *)
Machine Language:	MakeScreen(a0)
Modula-2:		MakeScreen(screen: ScreenPtr)
Arguments:		screen = custom screen
Result:			none
-------------------------
MakeVPort
Description:		constructs intermediate copper list for a ViewPort
Library:		graphics.library
Offset:			-$00D8 (-216)
Modula-2 Module:	Views
Syntax:			MakeVPort(view, viewPort)
C:			void MakeVPort(struct View *, struct ViewPort *)
Machine Language:	MakeVPort(a0, a1)
Modula-2:		MakeVPort(view: ViewPtr; viewPort: ViewPortPtr)
Arguments:		view = View structure
			viewPort = ViewPort structure
Result:			none
-------------------------
MarkCList
Description:		marks a position in a character list
Library:		clist.library
Offset:			-$0078 (-120)
Modula-2 Module:	none
Syntax:			error = MarkCList(cList, offset)
C:			long MarkCList(long, long)
Machine Language:	d0 = MarkCList(a0, a1)
Modula-2:		not available
Arguments:		cList = CList descriptor
			offset = byte offset into character list of position to mark
Result:			error = 0 if successful; nonzero if offset not in character list
-------------------------
MatchToolValue
Description:		checks a tool type variable for a particular value
Library:		icon.library
Offset:			-$0066 (-102)
Modula-2 Module:	Icon
Syntax:			result = MatchToolValue(typeString, value)
C:			long MatchToolValue(char *, char *)
Machine Language:	d0 = MatchToolValue(a0, a1)
Modula-2:		MatchToolValue(typeString, value: STRPTR): BOOLEAN
Arguments:		typeString = a ToolType value, as returned by FindToolType(
			value = value you are looking for
Result:			result = 0 if successful; nonzero if unsuccessful
------------------------- 
MENUNUM (macro)
Description:		extracts the menu number from a value
C Include File: 	include/intuition/intuition.h
ML Include File: 	none
Modula-2 Module:	Intuition
Syntax:			menuNumber = MENUNUM(menuValue)
C:			long MENUNUM(long)
Machine Language:	not available
Modula-2:		MENUNUM(menuValue: CARDINAL): CARDINAL
Arguments:		menuValue = 16-bit packed number representing the menu num-
			ber, item number, and subitem number
Result:			menuNumber = menu number (0-31); equals NOMENU if no
			menu was selected
-------------------------
