ModifyIDCMP
Description:		modifies the state of a window's IDCMP
Library:		intuition.library
Offset:			-$0096 (-150)
Modula-2 Module:	Intuition
Syntax:			ModifyIDCMP(window, flags)
C:			void ModifyIDCMP(struct Window *, long)
Machine Language:	ModifyIDCMP(a0, d0)
Modula-2:		ModifyIDCMP(window: WindowPtr; flags: IDCMPFlagsSet)
Arguments:		window = window containing IDCMP
			flags = IDCMP flags
Result:			none
-------------------------
ModifyProp
Description:		modifies current state of proportional gadgets (see
			NewModifyProp)
Library:		intuition.library
Offset:			-$009C (-156)
Modula-2 Module:	Intuition
Syntax:			ModifyProp(propGadget, window, requester, flags, horizPot,
			vertPot, horizBody, vertBody)
C:			void ModifyProp(struct Gadget *, struct Window *, struct Request-
			er *, long, long, long, long, long)
Machine Language:	ModifyProp(a0, a1, a2, d0, d1, d2, d3, d4)
Modula-2:		ModifyProp(propGadget: GadgetPtr; window: WindowPtr; re-
			quester: RequesterPtr; flags: PropFlagSet; horizPot, vertPot,
			horizBody, vertBody: CARDINAL)
Arguments:		propGadget = proportional gadget to modify
			window = window containing proportional gadget
			requester = Requester structure; NULL if gadget is not part of a
			requester
			flags = new flags value
			horizPot = new horizontal pot value (position)
			vertPot = new vertical pot value (position)
			horizBody = new horizontal body value (size of slider)
			vertBody = new vertical body value (size of slider)
Result:			none
-------------------------
Move
Description:		moves the drawing pen to the specified position without drawing
			anything
Library:		layers.library
Offset:			-$00F0 (-240)
Modula-2 Module:	Drawing
Syntax:			Move(rastPort, x, y)
C:			void Move(struct RastPort *, long, long)
Machine Language:	Move(a0, d0, d1)
Modula-2:		Move(rastPort: RastPortPtr; x, y: INTEGER)
Arguments:		rastPort = RastPort structure
			x = new horizontal coordinate
			y = new vertical coordinate
Result:			none
-------------------------
MoveLayer
Description:		moves a nonbackdrop layer to a new position in the bitmap
Library:		layers.library
Offset:			-$003C (-60)
Modula-2 Module:	Layers
Syntax:			success = MoveLayer(dummy, layer, dx, dy)
C:			long MoveLayer(struct Layerlnfo *, struct Layer *, long, long)
Machine Language:	d0 = MoveLayer(a0, a1, d0, d1)
Modula-2:		MoveLayer(layer: LayerPtr; dx, dy: LONGINT): BOOLEAN
Arguments:		dummy = unused
			layer = nonbackdrop Layer structure
			dx = offset by which to move layer horizontally
			dy = offset by which to move layer vertically
Result:			success = TRUE is successful; FALSE if unsuccessful
-------------------------
MoveLayerInFrontOf
Description:		moves a layer in front of another layer
Library:		layers.library
Offset:			-$00A8 (-168)
Modula-2 Module:	Layers
Syntax:			success = MoveLayerInFrontOf(layer, target)
C:			long MoveLayerInFrontOf(struct Layer *, struct Layer *)
Machine Language:	d0 = MoveLayerInFrontOf(d0, a1)
Modula-2:		MoveLayerInFrontOf(layer, target: LayerPtr): BOOLEAN
Arguments:		layer = layer to move
			target = layer to have another layer placed on top of
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
MoveScreen
Description:		moves a screen vertically
Library:		intuition.library
Offset:			-$00A2 (-162)
Modula-2 Module:	Intuition
Syntax:			MoveScreen(screen, dx, dy)
C:			void MoveScreen(struct Screen *, long, long)
Machine Language:	MoveScreen(a0, d0, a1)
Modula-2:		MoveScreen(screen: ScreenPtr; dx, dy: INTEGER)
Arguments:		screen = screen to move
			dx = offset by which to move screen horizontally
			dy = offset by which to move screen vertically (not implemented
			as of system version 1.3)
Result:			none
-------------------------
MoveSprite
Description:		moves a sprite to specified location
Library:		graphics.library
Offset:			-$01AA (-426)
Modula-2 Module:	Sprites
Syntax:			MoveSprite(viewPort, sprite, x, y)
C:			long MoveSprite(struct ViewPort *, struct SimpleSprite *, long,
			long)
Machine Language:	MoveSprite(a0, a1, d0, d1)
Modula-2:		MoveSprite(viewPort: ViewPortPtr; sprite: SimpleSpritePtr; x, y:
			INTEGER)
Arguments:		viewPort = ViewPort structure
			sprite = SimpleSprite structure
			x = new horizontal position of sprite
			y = new vertical position of sprite
Result:			none
-------------------------
MoveWindow
Description:		moves a window
Library:		intuition.library
Offset:			-$00A8 (-168)
Modula-2 Module:	Intuition
Syntax:			MoveWindow(window, dx, dy)
C:			void MoveWindow(struct Window *, long, long)
Machine Language:	MoveWindow(a0, d0, a1)
Modula-2:		MoveWindow(window: WindowPtr; dx, dy: INTEGER)
Arguments:		window = window to move
			dx = offset by which to move window horizontally
			dy = offset by which to move window vertically
Result:			none
-------------------------
MrgCop
Description:		merges coprocessor instructions to form one instruction list
Library:		graphics.library
Offset:			-$00D2 (-210)
Modula-2 Module:	Views
Syntax:			MrgCop(view)
C:			void MrgCop(struct View *)
Machine Language:	MrgCop(a1)
Modula-2:		MrgCop(view: ViewPtr)
Arguments:		view = View structure
Result:			none
-------------------------
NewFontContents
Description:		creates an array of FontContents entries describing all fonts asso-
			ciated with specified font name
Library:		diskfont.library
Offset:			-$002A (-42)
Modula-2 Module:	none
Syntax:			fontContentsHeader = NewFontContents(fontsLock, fontName)
C:			struct FontContentsHeader *NewFontContents(BPTR, char *)
Machine Language:	d0 = NewFontContents(a0, a1)
Modula-2:		not available
Arguments:		fontsLock = BCPL pointer to a lock on the directory containing
			the fonts contents file (usually FONTS: directory)
			fontName = filename of font contents file (for example,
			"Diamond.font")
Result:			fontContentsHeader = pointer to a FontContentsHeader
-------------------------
NewLayerInfo
Description:		creates a Layer_Info structure
Library:		layers.library
Offset:			-$0090 (-144)
Modula-2 Module:	Layers
Syntax:			layerInfo = NewLayerInfo( )
C:			struct Layer_Info *NewLayerInfo(void)
Machine Language:	d0 = NewLayerInfo( )
Modula-2:		NewLayerInfo( ): LayerInfoPtr
Arguments:		none
Result:			layerInfo = pointer to initialized Layer_Info structure; NULL if
			unsuccessful
-------------------------
NewList
Description:		initializes a list header
Library:		amiga.lib (linked library)
ML Include File:	none
Modula-2 Module:	Lists
Syntax:			NewList(list)
C:			void NewList(struct List *)
Machine Language:	not available
Modula-2:		NewList(VAR list: List)
Arguments:		list = List structure
Result:			none
-------------------------
NewModifyProp
Description:		modifies current state of proportional gadgets, with selective gad-
			get refresh
Library:		intuition.library
Offset:			-$01D4 (-468)
Modula-2 Module:	Intuition
Syntax:			NewModifyProp(propGadget, window, requester, flags, horizPot, 
			vertPot, horizBody, vertBody, gadgetNumber)
C:		        void NewModifyProp(struct Gadget *, struct Window *, struct Re-
			quester *, long, long, long, long, long, long)
Machine Language:	NewModifyProp(a0, a1, a2, d0, d1, d2, d3, d4, d5)
Modula-2:		NewModifyProp(propGadget: GadgetPtr; window: WindowPtr; re-
			quester: RequesterPtr; flags: PropFlagSet; horizPot, vertPot,
			horizBody, vertBody: CARDINAL; gadgetNumber: INTEGER)
Arguments:		propGadget = proportional gadget to modify
			window = window containing proportional gadget
			requester = Requester structure; NULL if gadget is not part of a
			requester
			flags = new flags value
			horizPot = new horizontal pot value (position)
			vertPot = new vertical pot value (position)
			horizBody = new horizontal body value (size of slider)
			vertBody = new vertical body value (size of slider)
			gadgetNumber = number of gadgets to refresh after gadget modi-
			fication; -1 to refresh all gadgets to the end of gadget list
Result:			none
-------------------------
NewRegion
Description:		creates an empty Region structure
Library:		graphics.library
Offset:			-$0204 (-516)
Modula-2 Module:	Regions
Syntax:			region = NewRegion( )
C:		        struct Region *NewRegion(void)
Modula-2:		NewRegion(VAR list: List)
			NewRegion( ): RegionPrt
Arguments:		none
Result:			region = pointer to initialized Region structure; NULL if not
			enough memory
-------------------------
ObtainConfigBinding 
Description:		attempts to get permission to bind drivers 
Library:		expansion.library 
Offset:			-$0078 (-120) 
Modula-2 Module:	none
Syntax:			ObtainConfigBinding( )
C:			void ObtainConfigBinding(void)
Machine Language:	ObtainConfigBinding( )
Modula-2:		not available
Arguments:		none
Result:			none
------------------------
ObtainSemaphore
Description:		obtains exclusive use of a signal semaphore
Library:		exec.library
Offset:			-$0234 (-564)
Modula-2 Module:	Semaphores
Syntax:			ObtainSemaphore(signalSemaphore)
C:			void ObtainSemaphore(struct SignalSemaphore *)
Machine Language:	ObtainSemaphore(a0)
Modula-2:      		ObtainSemaphore(signalSemaphore: SignalSemaphorePtr)
Arguments:		signalSemaphore = initialized SignalSemaphore structure
Result:			none
-------------------------
ObtainSemaphoreList
Description:		obtains exclusive use of a list of signal semaphores
Library:		exec.library
Offset:			-$0246 (-582)
Modula-2 Module:	Semaphores
Syntax:			ObtainSemaphoreList(list)
C:			void ObtainSemaphoreList(struct List *)
Machine Language:	ObtainSemaphoreList(a0)
Modula-2:		ObtainSemaphoreList(list: SignalSemaphorePtr)
Arguments:		list = List structure representing a list of signal semaphores
Result:			none
-------------------------
OFFDISPLAY (macro)
Description:		clears the display DMA bit in the DMA control register
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module:	CustomHardware
Syntax:			OFF_DISPLAY( )
C:			void OFF_DISPLAY(void)
Machine Language:	not available
Modula-2:		OFFDISPLAY( )
Arguments:		none
Result:			none
-------------------------
OffGadget
Description:		disables a gadget
Library:		intuition.library
Offset:			-$00AE (-174)
Modula-2 Module:	Intuition
Syntax:			OffGadget(gadget, window, requester)
C:			void OffGadget(struct Gadget , struct Window *, struct Requester *)
Machine Language:	OffGadget(a0, a1, a2)
Modula-2:		OffGadget(gadget: GadgetPtr; window: WindowPtr; requester:
			RequesterPtr)
Arguments:		gadget = gadget to disable
			window = window containing gadget
			requester = Requester structure; NULL if gadget is not part of a
			requester
Result:			none
-------------------------
OffMenu
Description:		disables a menu or menu item
Library:		intuition.library
Offset:			-$00B4 (-180)
Modula-2 Module:	Intuition
Syntax:			OffMenu(window, menuNumber)
C:			void OffMenu(struct Window *, long)
Machine Language:	OffMenu(a0, d0)
Modula-2:		OffMenu(window: WindowPtr; menuNumber: CARDINAL)
Arguments:		window = window containing menu or menu item
			menuNumber = number specifying menu or menu item to dis-
			able-bits 0-4 specify menu number, bits 5-10 specify menu
			item, and bits 11-15 specify menu subitems
Result:			none
-------------------------
OFF_SPRITE (macro)
Description:		clears the sprite DMA bit in the DMA control register
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module:	CustomHardware
Syntax:			OFF_SPRITE( )
C:			void OFF_SPRITE(void)
Machine Language:	not available
Modula-2:		OFFSPRITE( )
Arguments:		none
Result:			none
-------------------------
OFF_VBLANK (macro) 
Description:		clears the vertical blanking interrupt (bit 5) in the interrupt control 
			register 
C Include File: 	include/graphics/gfxmacros.h 
ML Include File: 	none 
Modula-2 Module:	none 
Syntax:			OFF_VBLANK( ) 
C:			void OFF_VBLANK(void) 
Machine Language:	not available
Modula-2:		not available
Arguments:		none
Result:			none
-------------------------
OldOpenLibrary
Description:		obsolete version of the OpenLibrary( ) function which gains access
			to a library without requiring a version number; do not use this
			function-use OpenLibrary( ) instead
Library:		exec.library
Offset:			-$0198 (-408)
Modula-2 Module:	none
Syntax:			library = Old0penLibrary(name)
C:			struct Library *Old0penLibrary(char *)
Machine Language:	d0 = Old0penLibrary(a1)
Modula-2:		not available
Arguments:		name = name of desired library
Result:			library = base pointer to desired library; NULL if library cannot
			be found
-------------------------
ON_DISPLAY (macro)
Description:		sets the display DMA bit in the DMA control register
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module:	CustomHardware
Syntax:			ON_DISPLAY( )
C:			void ON_DISPLAY(void)
Machine Language:	not available
Modula-2:		ONDISPLAY( )
Arguments:		none
Result:			none
-------------------------
OnGadget
Description:		enables a gadget
Library:		intuition.library
Offset:			-$00BA (-186)
Modula-2 Module:	Intuition
Syntax:			OnGadget(gadget, window, requester)
C:			void OnGadget(struct Gadget *, struct Window *, struct Requester *)
Machine Language:	OnGadget(a0, a1, a2)
Modula-2:		OnGadget(gadget: GadgetPtr; window: WindowPtr; requester:
			RequesterPtr)
Arguments:		gadget = gadget to enable
			window = window containing gadget
requester = Requester structure; NULL if gadget is not part of a
			requester
Result:			none
-------------------------
OnMenu
Description:		enables a menu or menu item
Library:		intuition.library
Offset:			-$00C0 (-192)
Modula-2 Module:	Intuition
Syntax:			OnMenu(window, menuNumber)
C:			void OnMenu(struct Window *, long)
Machine Language:	OnMenu(a0, d0)
Modula-2:		OnMenu(window: WindowPtr; menuNumber: CARDINAL)
Arguments:		window = window containing menu or menu item
			menuNumber = number specifying menu or menu item to en-
			able-bits 0-4 specify menu number, bits 5-10 specify menu
			item, and bits 11-15 specify menu subitems
Result:			none	
-------------------------  
ON_SPRITE (macro)
Description:		sets the sprite DMA bit in the DMA control register
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module:	CustomHardware
Syntax:			ON_SPRITE( )
C:			void ON_SPRITE(void)
Machine Language:	ON_SPRITE( )
Modula-2:		ONSPRITE( )
Arguments:		none
Result:			none
-------------------------
ON_VBLANK (macro) 
Description:		sets the vertical blanking interrupt (bit 5) in the interrupt control 
			register 
C Include File: 	include/graphics/gfxmacros.h 
ML Include File: 	none 
Modula-2 Module:	none 
Syntax:			ON_VBLANK( ) 
C:			void ON_VBLANK(void) 
Machine Language:	ON_VBLANK( )
Modula-2:		not available
Arguments:		none
Result:			none
-------------------------
Open
Description:		opens a file for input or output
Library:		dos.library
Offset:			-$001E (-30)
Modula-2 Module:	DOS
Syntax:			file = Open(name, accessMode)
C:			BPTR Open(char *, long)
Machine Language:	d0 = Open(d1, d2)
Modula-2:		Open(name: STRPTR; accessMode: LONGINT): FileHandle
Arguments:		name = NULL terminated string specifying filename
			accessMode = type of file access desired-MODE_OLDFILE for
			reading, MODE_NEWFILE for writing
Result:			file = BCPL pointer to file handle; NULL if unsuccessful
-------------------------
OpenDevice
Description:		provides access to a device and initializes an IO request block for
			access to the device
Library:		exec.library
Offset:			-$01BC (-444)
Modula-2 Module:	Devices
Syntax:			error = OpenDevice(name, unitNumber, ioRequest, flags)
C:			long OpenDevice(char *, long, struct IORequest *, long)
Machine Language:	d0 = OpenDevice(a0, d0, a1, d2)
Modula-2:		OpenDevice(name: STRPTR; unitNumber: LONGCARD;
			ioRequest: ADDRESS; flags: LONGBITSET): INTEGER
Arguments:		name = NULL terminated string specifying device name
			unitNumber = desired unit number for device (device specific)
			ioRequest = IORequest block to initialize
			flags = additional device information (device specific)
Result:			error = 0 if successful; nonzero if unsuccessful
-------------------------
OpenDiskFont
Description:		gains access to a disk-resident font
Library:		diskfont.library
Offset:			-$001E (-30)
Modula-2 Module:	DiskFont
Syntax:			font = OpenDiskFont(textAttr)
C:			struct TextFont *OpenDiskFont(struct TextAttr *)
Machine Language:	d0 = OpenDiskFont(a0)
Modula-2:		OpenDiskFont(textAttr: TextAttrPtr): TextFontPtr
Arguments:		textAttr = TextAttr structure that describes the desired font
Result:			font = pointer to desired TextFont structure; 0 if unsuccessful
-------------------------
OpenFont
Description:		gains access to a memory-resident font
Library:		graphics.library
Offset:			-$0048 (-72)
Modula-2 Module:	Text
Syntax:			font = OpenFont(textAttr)
C:			struct TextFont *OpenFont(struct TextAttr *)
Machine Language:	d0 = OpenFont(a0)
Modula-2:		OpenFont(textAttr: TextAttrPtr): TextFontPtr
Arguments:		textAttr = TextAttr structure that describes the desired font
Result:			font = pointer to desired TextFont structure; 0 if unsuccessful
------------------------- 
OpenLibrary
Description:		gains access to a library
Library:		exec.library
Offset:			-$0228 (-552)
Modula-2 Module:	Libraries
Syntax:			library = OpenLibrary(name, version)
C:			struct Library *OpenLibrary(char *, long)
Machine Language:	d0 = OpenLibrary(a1, d0)
Modula-2:		OpenLibrary(name: STRPTR; version: LONGCARD): LibraryPtr
Arguments:		name = name of desired library
			version = lowest acceptable library version number; 0 if you
			don't care
Result:			library = base pointer to desired library; NULL if library cannot
			be found
-------------------------
OpenResource
Description:		gains access to a resource
Library:		exec.library
Offset:			-$01F2 (-498)
Modula-2 Module:	Resources
Syntax:			resource = OpenResource(name)
C:			struct Resource *OpenResource(char *)
Machine Language:	d0 = OpenResource(a1)
Modula-2:		OpenResource(name: STRPTR): ResourcePtr
Arguments:		name = name of desired resource
Result:			resource = pointer to resource; NULL if unsuccessful
-------------------------
OpenScreen
Description:		opens an Intuition screen
Library:		intuition.library
Offset:			-$00C6 (-198)
Modula-2 Module:	Intuition
Syntax:			screen = OpenScreen(newScreen)
C:			struct Screen *OpenScreen(struct NewScreen *)
Machine Language:	d0 = OpenScreen(a0)
Modula-2:		OpenScreen(newScreen: NewScreenPtr): ScreenPtr
Arguments:		newScreen = NewScreen structure that describes screen to open
Result:			screen = pointer to Screen structure; NULL if unsuccessful
------------------------- 
OpenWindow
Description:		opens an Intuition window
Library:		intuition.library
Offset:			-$00CC (-204)
Modula-2 Module:	Intuition
Syntax:			window = OpenWindow(newWindow)
C:			struct Window *OpenWindow(struct NewWindow *)
Machine Language:	d0 = OpenWindow(a0)
Modula-2:		OpenWindow(newWindow: NewWindowPtr): WindowPtr
Arguments:		newWindow = NewWindow structure that describes window to
			open
Result:			window = pointer to Window structure; NULL if unsuccessful
-------------------------
OpenWorkBench
Description:		opens the Workbench screen
Library:		intuition.library
Offset:			-$00D2 (-210)
Modula-2 Module:	Intuition
Syntax:			success = OpenWorkBench( )
C:			long OpenWorkBench(void)
Machine Language:	d0 = OpenWorkBench( )
Modula-2:		OpenWorkBench( ): BOOLEAN
Arguments:		none
Result:			success = TRUE if successful (value represents pointer to Work-
			Bench screen-this may change in system versions greater than
			1.3); FALSE (NULL) if unsuccessful
-------------------------
OrRectRegion
Description:		performs a two-dimensional OR operation of a rectangle with a
			region, leaving the result in the region
Library:		graphics.library
Offset:			-$01FE (-510)
Modula-2 Module:	Regions
Syntax:			success = OrRectRegion(region, rectangle)
C:			long OrRectRegion(struct Region *, struct Rectangle *)
Machine Language:	d0 = OrRectRegion(a0, a1)
Modula-2:		OrRectRegion(region: RegionPtr; rectangle: RectanglePtr):
			BOOLEAN
Arguments:		region = Region structure
			rectangle = Rectangle structure
Result:			success = TRUE if successful; FALSE if unsuccessful
------------------------- 
OrRegionRegion
Description:		performs a two-dimensional OR operation of one region with a
			second region, leaving the result in second region
Library:		graphics.library
Offset:			-$0264 (-612)
Modula-2 Module:	Regions
Syntax:			success = OrRegionRegion(region1, region2)
C:			long OrRegionRegion(struct Region *, struct Region *)
Machine Language:	d0 = OrRegionRegion(a0, a1)
Modula-2:		OrRegionRegion(region1, region2: RegionPtr): BOOLEAN
Arguments:		region1 = Region structure
			region2 = Region structure
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
Output
Description:		gets the initial output file handle assigned to a program
Library:		dos.library
Offset:			-$003C (-60)
Modula-2 Module:	DOS
Syntax:			file = Output( )
C:			BPTR Output(void)
Machine Language:	d0 = Output( )
Modula-2:		Output( ): FileHandle
Arguments:		none
Result:			file = BCPL pointer to a file handle
-------------------------
OwnBlitter
Description:		reserves the blitter for private use
Library:		graphics.library
Offset:			-$01C8 (-456)
Modula-2 Module:	Blitter
Syntax:			OwnBlitter( )
C:			void OwnBlitter(void)
Machine Language:	OwnBlitter( )
Modula-2:		OwnBlitter( )
Arguments:		none
Result:			none
------------------------- 
ParentDir
Description:		obtains the parent directory of a file or directory
Library:		dos.library
Offset:			-$00D2 (-210)
Modula-2 Module:	DOS
Syntax:			lock = ParentDir(lock)
C:			BPTR ParentDir(BPTR)
Machine Language:	d0 = ParentDir(d1)
Modula-2:		ParentDir(lock: FileLock): FileLock
Arguments:		lock = BCPL pointer to lock associated with child file or directory
Result:			lock = BCPL pointer to lock associated with parent directory
-------------------------
PeekCLMark
Description:		gets byte located in mark position of a character list
Library:		clist.library
Offset:			-$0084 (-132)
Modula-2 Module:	none
Syntax:			byte = PeekCLMark(cList)
C:			long PeekCLMark(long)
Machine Language:	d0 = PeekCLMark(a0)
Modula-2:		not available
Arguments:		cList = character list descriptor
Result:			byte = byte located in mark position of character list
-------------------------
Permit
Description:		permits task rescheduling halted by Forbid( )
Library:		exec.library
Offset:			-$008A (-138)
Modula-2 Module:	Interrupts
Syntax:			Permit( )
C:			void Permit(void)
Machine Language:	Permit( )
Modula-2:		Permit( )
Arguments:		none
Result:			none
-------------------------
PolyDraw
Description:		draws a series of connected lines from current pen position to
			points specified by a table of (x,y) coordinates
Library:		graphics.library
Offset:			-$0150 (-336)
Modula-2 Module:	Pens
Syntax:			PolyDraw(rastPort, count, array)
C:			long PolyDraw(struct RastPort *, long, short *)
Machine Language:	PolyDraw(al, d0, a0)
Modula-2:		PolyDraw(rastPort: RastPortPtr; count: INTEGER; array:
			ADDRESS)
Arguments:		rastPort = RastPort to draw lines in
			count = number of coordinates in array
			array = pointer to array of coordinates
Result:			none
-------------------------
printf
Description:		prints a formatted string to the standard output (Lattice and Manx
			users: if you link with lc.lib or c.lib, this is not the function you're
			calling)
Library:		amiga.lib (linked library)
Modula-2 Module:	none
Syntax:			printf(string, values...)
C:			void printf(char *, long...)
Machine Language:	move.l #value,-(sp) ;may have several values 
			pea string 
			jsr _printf 
			add.l #8,sp ;(2 arguments * 4 bytes = 8)
Modula-2:		not available
Arguments:		string = string containing optional C formatting commands (%); if
			you're passing longword values on the stack (as shown above) be
			sure to follow the percent symbol with a lowercase L
			values = values or addresses of strings to print; this routine
			knows how many values are on the stack by checking the number
			of formatting commands in the string argument
Result:			none
-------------------------
PrintIText
Description:		prints text according to its IntuiText specifications
Library:		intuition.library
Offset:			-$00D8 (-216)
Modula-2 Module:	Intuition
Syntax:			PrintIText(rastPort, intuiText, leftEdge, topEdge)
C:		        void PrintIText(struct RastPort *, struct IntuiText *, long, long)
Machine Language:	PrintIText(a0, a1, d0, d1)
Modula-2:		PrintIText(rastPort: RastPortPtr; intuiText: IntuiTextPtr; leftEdge,
			topEdge: INTEGER)
Arguments:		rastPort = RastPort structure to receive text
			intuiText = IntuiText structure containing text
			leftEdge = horizontal position of text within RastPort
			topEdge = vertical position of text within RastPort
Result:			none
-------------------------
Procure
Description:		obtains a message-based semaphore
Library:		exec.library
Offset:			-$021C (-540)
Modula-2 Module:	Semaphores
Syntax:			success = Procure(semaphore, message)
C:		        long Procure(struct Semaphore *, struct Message *)
Machine Language:	d0 = Procure(a0, a1)
Modula-2:		Procure(semaphore: SemaphorePtr; message: MessagePtr):
 			BOOLEAN
Arguments:		semaphore = Semaphore structure
			message = Message structure to be used if desired semaphore is
			unavailable
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
PutCLBuf
Description:		converts contiguous data into a character list
Library:		clist.library
Offset:			-$006C (-108)
Modula-2 Module:	none
Syntax:			error = PutCLBuf(cList, buffer, length)
C:		        long PutCLBuf(long, char *, long)
Machine Language:	d0 = PutCLBuf(a0, a1, d1)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
			buffer = buffer containing data to be converted
			length = size of buffer in bytes
Result:			error = 0 if successful; nonzero if unsuccessful
-------------------------
PutCLChar
Description:		adds a byte to the end of a character list
Library:		clist.library
Offset:			-$003C (-60)
Modula-2 Module:	none
Syntax:			error = PutCLChar(cList, byte)
C:			long PutCLChar(long, long)
Machine Language:	d0 = PutCLChar(a0, d0)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
			byte = byte to be added to end of character list
Result:			error = 0 if successful; nonzero if unsuccessful
-------------------------
PutCLWord
Description:		adds a word to the end of a character list
Library:		clist.library
Offset:			-$0054 (-84)
Modula-2 Module:	none
Syntax:			error = PutCLWord(cList, word)
C:			long PutCLWord(long)
Machine Language:	d0 = PutCLWord(a0, d0)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
			word = word to be added to end of character list
Result:			error = 0 if successful; nonzero if unsuccessful
-------------------------
PutDiskObject
Description:		writes a Workbench DiskObject to disk as an .info file
Library:		icon.library
Offset:			-$0054 (-84)
Modula-2 Module:	Icon
Syntax:			success = PutDiskObject(name, diskObj)
C:			long PutDiskObject(char *, struct DiskObject *)
Machine Language:	d0 = PutDiskObject(a0, a1)
Modula-2:		PutDiskObject(name: STRPTR; diskObj: DiskObjectPtr): BOOLEAN
Arguments:		name = name of object
			diskObj = DiskObject structure (.info file)
Result:			success = nonzero if successful
-------------------------
PutIcon
Description:		writes a DiskObject to disk as an .info file
Library:		icon.library
Offset:			-$0030 (-48)
Modula-2 Module:	none
Syntax:			success = PutIcon(name, icon)
C:           long PutIcon(char *, struct DiskObject *)
Machine Language:	d0 = PutIcon(a0, a1)
Modula-2:		not available
Arguments:		name = name of icon (.info file)
			icon = DiskObject structure
Result:			success = nonzero if successful
-------------------------
PutMsg
Description:		gets next message from a message port
Library:		exec.library
Offset:			-$016E (-366)
Modula-2 Module:	Ports
Syntax:			PutMsg(port, message)
C:		        void PutMsg(struct MsgPort *, struct Message *)
Machine Language:	PutMsg(a0, a1)
Modula-2:		PutMsg(port: MsgPortPtr; message: ADDRESS)
Arguments:		port = message port to receive message
			message = Message structure containing message to send
Result:			none
-------------------------
PutWBObject
Description:		writes a WBObject to disk as an .info file
Library:		icon.library
Offset:			-$0024 (-36)
Modula-2 Module:	none
Syntax:			success = PutWBObject(name, object)
C:			long PutWBObject(char *, struct WBObject *)
Machine Language:	d0 = PutWBObject(a0, a1)
Modula-2:		not available
Arguments:		name = name of WBObject (.info file)
			object = WBObject structure
Result:			success = nonzero if successful
------------------------- 
QBlit
Description:		queues up a blitter request
Library:		graphics.library
Offset:			-$0114 (-276)
Modula-2 Module:	Blitter
Syntax:			QBlit(blitNode)
C:			void QBlit(struct BlitNode *)
Machine Language:	QBlit(a1)
Modula-2:		QBlit(blitNode: bltnodePtr)
Arguments:		blitNode = BlitNode structure containing link information and
			address of your blitter routine
Result:			none
-------------------------
QBSlit
Description:		queues and synchronizes a blitter request with the video beam
Library:		graphics.library
Offset:			-$0126 (-294)
Modula-2 Module:	Blitter
Syntax:			QBSlit(blitNode)
C:			void QBSlit(struct BlitNode *)
Machine Language:	QBSlit(a1)
Modula-2:		QBSlit(blitNode: bltnodePtr)
Arguments:		blitNode = BlitNode structure containing link information and
			address of your blitter routine
Result:			none
-------------------------
RangeRand
Description:		generates a random integer within a specified range
Library:		amiga.lib (linked library)
Modula-2 Module:	none
Syntax:			rnd = RangeRand(range)
C:			long RangeRand(long)
Machine Language:	move.l range,-(sp)
			jsr _RangRand ;rnd returned in d0
			addq.l #4,sp
Modula-2:		not available
Arguments:		range = highest integer acceptable
Result:			rnd = random number between 0 and value of range argument
-------------------------
RASSIZE (macro)
Description:		calculates the memory requirements for a raster bitmap of the
			specified with and height
C Include File:		include/graphics/gfx.h
ML Include File:	none
Modula-2 Module:	Graphics
Syntax:			bytes = RASSIZE(width, height)
C:			long RASSIZE(long, long)
Machine Language:	not available
Modula-2:		RASSIZE(width, height: LONGCARD)
Arguments:		width = width of hypothetical bitmap in pixels
			height = height of hypothetical bitmap in pixels
Result:			bytes = number of bytes required to contain raster bitmap
-------------------------
RawDoFmt
Description:		formats data into a character stream using C formatting
			commands (%)
Library:		exec.library
Offset:			-$020A (-522)
Modula-2 Module:	Exec
Syntax:			RawDoFmt(formatString, dataStream, putChProc, putChData)
C:			void RawDoFmt(char *, APTR, void (*)(), APTR)
Machine Language:	RawDoFmt(a0, a1, a2, a3)
Modula-2:		RawDoFmt(formatString, dataStream: ADDRESS; putChProc:
			PROC; putChData: ADDRESS)
Arguments:		formatString = string with optional C formatting commands (%)
			dataStream = stream of data that is interpreted according to the
			formatString
			putChProc = address of procedure to call with each character to
			be output, where procedure is called as PutChProc(char,
			putChData)
			putChData = value to pass to PutChProc
Result:			none
-------------------------
Read
Description:		reads data from a file
Library:		dos.library
Offset:			-$002A (-42)
Modula-2 Module:	DOS
Syntax:			actualLength = Read(file, buffer, length)
C:			long Read(BPTR, char *, long)
Machine Language:	d0 = Read(d1, d2, d3)
Modula-2:		Read(file: FileHandle; buffer: ADDRESS; length: LONGINT):
			LONGINT
Arguments:		file = BCPL pointer to a file handle
			buffer = address of memory block to receive data
			length = number of bytes to read (must not exceed buffer size)
Result:			actualLength = actual number of bytes received
-------------------------
ReadExpansionByte
Description:		reads a byte nybble-by-nybble from a new-style expansion board
Library:		expansion.library
Offset:			-$0060 (-96)
Modula-2 Module:	Expansion
Syntax:			byte = ReadExpansionByte(board, offset)
C:			long ReadExpansionByte(long, long)
Machine Language:	d0 = ReadExpansionByte(a0, d0)
Modula-2:		ReadExpansionByte(board: ADDRESS; offset: LONGCARD):
			INTEGER	
Arguments:		board = base address of expansion board
			offset = logical offset from board base
Result:			byte = data received; -1 if an error occurred
-------------------------
ReadExpansionRom
Description:		reads a new-style expansion board's configuration ROM space
Library:		expansion.library
Offset:			-$0066 (-102)
Modula-2 Module:	Expansion
Syntax:			error = ReadExpansionRom(board, configDev)
C:			long ReadExpansionRom(long, long)
Machine Language:	d0 = ReadExpansionRom(a0, a1)
Modula-2:		ReadExpansionRom(board: ADDRESS; configDev: ADDRESS):
			BOOLEAN
Arguments:		board = base address of expansion board
			configDev = ConfigDev structure to receive ROM data
Result:			error = 0 if successful; nonzero if an error occurred
-------------------------
ReadPixel
Description:		finds the color register (pen) used to color a specific pixel
Library:		graphics.library
Offset:			-$013E (-318)
Modula-2 Module:	Pens
Syntax:			pen = ReadPixel(rastPort, x, y)
C:			long ReadPixel(struct RastPort *, long, long)
Machine Language:	d0 = ReadPixel(a0, d0, d1)
Modula-2:		ReadPixel(rastPort: RastPortPtr; x, y: INTEGER): INTEGER
Arguments:		rastPort = RastPort structure
			x = horizontal coordinate of pixel
			y = vertical coordinate of pixel
Result:			pen = pen number; -1 if pixel lies outside boundaries of rastport
-------------------------
RectFill
Description:		fills a rectangular area using the current pen color, outline color,
			secondary color, and pattern
Library:		graphics.library
Offset:			-$0132 (-306)
Modula-2 Module:	Pens
Syntax:			RectFill(rastPort, xmin, ymin, xmax, ymax)
C:			void RectFill(struct RastPort *, long, long, long, long)
Machine Language:	RectFill(a0, d0, d1, d2, d3)
Modula-2:		RectFill(rastPortPtr: RastPort; xmin, ymin, xmax, ymax: INTEGER)
Arguments:		rastPort = RastPort structure
			xmin = horizontal coordinate rectangle's upper left corner
			ymin = vertical coordinate rectangle's upper left corner
			xmax = horizontal coordinate rectangle's lower right corner
			ymax = vertical coordinate rectangle's lower right corner
Result:			none
-------------------------
RefreshGadgets
Description:		redraws a gadget and all following gadgets in gadget list
Library:		intuition.library
Offset:			-$00DE (-222)
Modula-2 Module:	Intuition
Syntax:			RefreshGadgets(gadgets, window, requester)
C:			void RefreshGadgets(struct Gadget *, struct Window *, struct Re-
			quester *)

Machine Language:	RefreshGadgets(a0, a1, a2)
Modula-2:		RefreshGadgets(gadgets: GadgetPtr; window: WindowPtr; request-
			er: RequesterPtr)
Arguments:		gadgets = first gadget in list of gadgets to refresh
			window = window containing gadgets
			requester = requester containing gadget; NULL if gadget is not
			part of a requester
Result:			none
-------------------------
RefreshGList
Description:		redraws a gadget and specified number of following gadgets in
			gadget list
Library:		intuition.library
Offset:			-$01BO (-432)
Modula-2 Module:	Intuition
Syntax:			RefreshGList(gadgets, window, requester, numGadgets)
C:			void RefreshGList(struct Gadget *, struct Window *, struct Re-
			quester *, long)
Machine Language:	RefreshGList(a0, a1, a2, d0)
Modula-2:		RefreshGList(gadgets: GadgetPtr; window: WindowPtr; requester:
			RequesterPtr; numGadgets: INTEGER)
Arguments:		gadgets = first gadget in list of gadgets to refresh
			window = window containing gadgets
			requester = requester containing gadget; NULL if gadget is not
			part of a requester
			numGadgets = number of gadgets to refresh; -1 to refresh to
			end of gadget list
Result:			none
-------------------------
RefreshWindowFrame
Description:		redraws a window's border, title bar, and gadgets
Library:		intuition.library
Offset:			-$01C8 (-456)
Modula-2 Module:	Intuition
Syntax:			RefreshWindowFrame(window)
C:			void RefreshWindowFrame(struct Window *)
Machine Language:	RefreshWindowFrame(a0)
Modula-2:		RefreshWindowFrame(window: WindowPtr)
Arguments:		window = window to refresh
Result:			none
------------------------- 
ReleaseConfigBinding
Description:		allows others to bind drivers
Library:		expansion.library
Offset:			-$007E (-126)
Modula-2 Module:	none
Syntax:			ReleaseConfigBinding( )
C:			void ReleaseConfigBinding(void)
Machine Language:	ReleaseConfigBinding( )
Modula-2:		not available
Arguments:		none
Result:			none
-------------------------
ReleaseSemaphore
Description:		releases a signal semaphore for use by other tasks
Library:		exec.library
Offset:			-$023A (-5 70)
Modula-2 Module:	Semaphores
Syntax:			ReleaseSemaphore(signalSemaphore)
C:			void ReleaseSemaphore(struct SignalSemaphore *)
Machine Language:	ReleaseSemaphore(a0)
Modula-2:		ReleaseSemaphore(signalSemaphore: SignalSemaphorePtr)
Arguments:		signalSemaphore = initialized SignalSemaphore structure
Result:			none
-------------------------
ReleaseSemaphoreList
Description:		releases a list of signal semaphores for other tasks
Library:		exec.library
Offset:			-$024C (-588)
Modula-2 Module:	Semaphores
Syntax:			ReleaseSemaphoreList(list)
C:			void ReleaseSemaphoreList(struct List *)
Machine Language:	ReleaseSemaphoreList(a0)
Modula-2:		ReleaseSemaphoreList(list: SignalSemaphorePtr)
Arguments:		list = List structure representing a list of signal semaphores
Result:			none
-------------------------
RemakeDisplay
Description:		redraws every intuition screen
Library:		intuition.library
Offset:			-$0180 (-384)
Modula-2 Module:	Intuition
Syntax:			RemakeDisplay( )
C:			void RemakeDisplay(void)
Machine Language:	RemakeDisplay( )
Modula-2:		RemakeDisplay( )
Arguments:		none
Result:			none
-------------------------
RemBob (macro)
Description:		removes a Bob from current GEL list
C Include File:		include/graphics/gels.h
ML Include File:	graphics/gels.i
Modula-2 Module:	none
Syntax:			RemBob(bob, rastPort)
C:			void RemBob(struct Bob *, struct RastPort *)
Machine Language:	RemBob(a0)
Modula-2:		not available
Arguments:		bob = Bob structure to remove
			rastPort = controlling RastPort structure (not needed in
			Modula-2)
Result:			none
-------------------------
RemConfigDev
Description:		removes a ConfigDev structure from the system
Library:		expansion.library
Offset:			-$006C (-108)
Modula-2 Module:	ConfigVars
Syntax:			RemConfigDev(configDev)
C:			void RemConfigDev(long)
Machine Language:	RemConfigDev(a0)
Modula-2:		RemConfigDev(configDev: ConfigDevPtr)
Arguments:		configDev = ConfigDev structure
Result:			none
------------------------- 
RemDevice
Description:		removes a device from the system
Library:		exec.library
Offset:			-$01B6 (-438)
Modula-2 Module:	Devices
Syntax:			error= RemDevice(device)
C:			long RemDevice(struct Device *)
Machine Language:	d0 = RemDevice(a1)
Modula-2:		RemDevice(device: DevicePtr)
Arguments:		device = device node
Result:			error = 0 if successful; nonzero if unsuccessful
-------------------------
RemFont
Description:		removes a font from the system
Library:		graphics.library
Offset:			-$01E6 (-486)
Modula-2 Module:	Text
Syntax:			error = RemFont(textFont)
C:			long RemFont(struct TextFont *)
Machine Language:	d0 = RemFont(a1)
Modula-2:		RemFont(textFont: TextFontPtr)
Arguments:		textFont = TextFont structure to remove
Result:			error = 0 if successful; nonzero if unsuccessful (no value returned
			by Modula-2)
-------------------------
RemHead
Description:		removes a node from the head of a list
Library:		exec.library
Offset:			-$0102 (-258)
Modula-2 Module:	Lists
Syntax:			node = RemHead(list)
C:			struct Node *RemHead(struct List *)
Machine Language:	d0 = RemHead(a0)
Modula-2:		RemHead(list: ListPtr): NodePtr
Arguments:		list = list header
Result:			node = node removed; NULL if list is was already empty
------------------------- 
RemIBob
Description:		immediately removes a Bob from the GEL list and erases it from
			the RastPort display
Library:		graphics.library
Offset:			-$0084 (-132)
Modula-2 Module:	Gels
Syntax:			RemIBob(bob, rastPort, viewPort)
C:			void RemIBob(struct Bob *, struct RastPort *, struct ViewPort *)
Machine Language:	RemIBob(a0, a1, a2)
Modula-2:		RemIBob(bob: BobPtr; rastPort: RastPortPtr; viewPort:
			ViewPortPtr)
Arguments:		bob = Bob structure to remove from GEL list
			rastPort = RastPort structure
			viewPort = ViewPort structure
Result:			none
-------------------------
RemIntServer
Description:		removes an interrupt server from the system
Library:		exec.library
Offset:			-$00AE (-174)
Modula-2 Module:	Interrupts/
Syntax:			RemIntServer(intNum, interrupt)
C:			void RemIntServer(long, struct Interrupt *)
Machine Language:	RemIntServer(d0, a1)
Modula-2:		RemIntServer(intNum: CARDINAL; interrupt: InterruptPtr)
Arguments:		intNum = portia interrupt bit (0-4)
			interrupt = interrupt server node
Result:			none
-------------------------
RemLibrary
Description:		removes a library from the system
Library:		exec.library
Offset:			-$0192 (-402)
Modula-2 Module:	Libraries
Syntax:			error= RemLibrary(library)
C:			long RemLibrary(struct Library *)
Machine Language:	d0 = RemLibrary(a1)
Modula-2:		RemLibrary(Library: LibraryPtr)
Arguments:		library = Library structure to remove
Result:			error = 0 if successful; nonzero if unsuccessful
-------------------------
Remove
Description:		removes a node from a list
Library:		exec.library
Offset:			-$00FC (-252)
Modula-2 Module:	Lists
Syntax:			Remove(node)
C:			void Remove(struct Node *)
Machine Language:	Remove(a1)
Modula-2:		Remove(node: NodePtr)
Arguments:		node = node to remove
Result:			none
-------------------------
RemoveGadget	  
Description:		removes gadget from a window
Library:		intuition.library
Offset:			-$00E4 (-228)
Modula-2 Module:	Intuition
Syntax:			position = RemoveGadget(window, gadget)
C:			long RemoveGadget(struct Window *, struct Gadget *)
Machine Language:	d0 = RemoveGadget(a0, a1)
Modula-2:		RemoveGadget(window: WindowPtr; gadget: GadgetPtr):
			INTEGER
Arguments:		window = window that contains gadget
			gadget = gadget to remove
Result:			position = position in gadget list where gadget was located; -1 if
			gadget was not found
-------------------------
RemoveGList
Description:		removes a series of gadgets from a gadget list
Library:		intuition.library
Offset:			-$01BC (-444)
Modula-2 Module:	Intuition
Syntax:			position = RemoveGList(window, gadget, numGadgets)
C:			long RemoveGList(struct Window *, Gadget *, long)
Machine Language:	d0 = RemoveGList(a0, a1, d0)

Modula-2:		RemoveGList(window: WindowPtr; gadget: GadgetPtr;
			numGadgets: INTEGER): INTEGER
Arguments:		window = window containing gadgets
			gadget = first gadget in gadget list to remove
			numGadgets = number of gadgets to remove
Result:			position = position of removed gadget list; -1 if gadget was not
			found
-------------------------
RemPort
Description:		removes a message port from the system
Library:		exec.library
Offset:			-$0168 (-360)
Modula-2 Module:	Ports
Syntax:			RemPort(port)
C:			void RemPort(struct MsgPort *)
Machine Language:	RemPort(a1)
Modula-2:		RemPort(port: MsgPortPtr)
Arguments:		port = message port to remove
Result:			none
-------------------------
RemResource
Description:		removes a resource from the system
Library:		exec.library
Offset:			-$01EC (-492)
Modula-2 Module:	Resources
Syntax:			RemResource(resource)
C:			void RemResource(struct Resource *)
Machine Language:	RemResource(a1)
Modula-2:		RemResource(resource: ResourcePtr)
Arguments:		resource = resource to remove
Result:			none
-------------------------
RemSemaphore
Description:		removes signal semaphore from the system
Library:		exec.library
Offset:			-$025E (-606)
Modula-2 Module:	Semaphores
Syntax:			RemSemaphore(signalSemaphore)
C:			void RemSemaphore(struct SignalSemaphore *)
Machine Language:	RemSemaphore(a1)
Modula-2:		RemSemaphore(signalSemaphore: SignalSemaphorePtr)
Arguments:		signalSemaphore = signal semaphore to remove
Result:			none
-------------------------
RemTail
Description:		removes node from the tail of a list
Library:		exec.library
Offset:			-$0108 (-264)
Modula-2 Module:	Lists
Syntax:			node = RemTail(list)
C:			struct Node *RemTail(struct List *)
Machine Language:	d0 = RemTail(a0)
Modula-2:		RemTail(list: ListPtr): NodePtr
Arguments:		list = list header
Result:			node = pointer to removed node; NULL if list is already empty
-------------------------
RemTask
Description:		removes a task from the system
Library:		exec.library
Offset:			-$0120 (-288)
Modula-2 Module:	Tasks
Syntax:			RemTask(task)
C:			void RemTask(struct Task *)
Machine Language:	RemTask(a1)
Modula-2:		RemTask(task: TaskPtr)
Arguments:		task = task to remove
Result:			none
-------------------------
RemTOF
Description:		removes a task from the TopOfFrame (vertical-blanking interval)
			interrupt server chain
Library:		amiga.lib (linked library)
Modula-2 Module:	none
Syntax:			RemTOF(i)
C:			void RemTOF(struct Isrvstr *)
Machine Language:	pea i
			jsr _RemTOF
			addq.l #4,sp
Modula-2:		not available
Arguments:		i = Isrvstr structure
Result:			none
-------------------------
RemVSprite
Description:		removes a VSprite from the GEL list
Library:		graphics.library
Offset:			-$008A (-138)
Modula-2 Module:	Gels
Syntax:			RemVSprite(vSprite)
C:			void RemVSprite(struct VSprite *)
Machine Language:	RemVSprite(a0)
Modula-2:		RemVSprite(vSprite: VSpritePtr)
Arguments:		vSprite = VSprite to remove
Result:			none
-------------------------
Rename
Description:		renames a directory or file
Library:		dos.library
Offset:			-$004E (-78)
Modula-2 Module:	DOS
Syntax:			success = Rename(oldName, newName)
C:			long Rename(char *, char *)
Machine Language:	d0 = Rename(d1, d2)
Modula-2:		Rename(oldName, newName: STRPTR): BOOLEAN
Arguments:		oldName = current name of file/directory (can include
			drive/directory path)
			newName = new name for file (can include drive/directory path)
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
ReplyMsg
Description:		replies to a message
Library:		exec.library
Offset:			-$017A (-378)
Modula-2 Module:	Ports
Syntax:			ReplyMsg(message)
C:			void ReplyMsg(struct MsgPort *)
Machine Language:	ReplyMsg(a1)
Modula-2:		ReplyMsg(message: ADDRESS)
Arguments:		message = message to reply to
Result:			none
-------------------------
ReportMouse
Description:		tells intuition whether or not to report the mouse movements as-
			sociated with a window
Library:		intuition.library
Offset:			-$00EA (-234)
Modula-2 Module:	Intuition
Syntax:			ReportMouse(window, flag)
C:			void ReportMouse(struct Window *, long)
Machine Language:	ReportMouse(a0, d0)
Modula-2:		ReportMouse(window: WindowPtr; flag: BOOLEAN)
Arguments:		window = window to be affected
			flag = TRUE to activate mouse movement reports; FALSE to stop
			mouse movement reports
Result:			none
-------------------------
Request
Description:		activates a requester
Library:		intuition.library
Offset:			-$00F0 (-240)
Modula-2 Module:	Intuition
Syntax:			success = Request(requester, window)
C:			long Request(struct Requester, struct Window *)
Machine Language:	d0 = Request(a0, a1)
Modula-2:		Request(requester: RequesterPtr; window: WindowPtr): BOOLEAN
Arguments:		requester = requester to display
			window = window in which requester will appear in
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
RethinkDisplay
Description:		performs a complete overhaul on the Intuition display-screens,
			ViewPorts, everything
Library:		intuition.library
Offset:			-$0186 (-390)
Modula-2 Module:	Intuition
Syntax:			RethinkDisplay( )
C:			void RethinkDisplay(void)
Machine Language:	RethinkDisplay( )
Modula-2:		RethinkDisplay( )
Arguments:		none
Result:			none
-------------------------
ScreenToBack
Description:		moves specified screen to back of the display
Library:		intuition.library
Offset:			-$00F6 (-246)
Modula-2 Module:	Intuition
Syntax:			ScreenToBack(screen)
C:			void ScreenToBack(struct Screen *)
Machine Language:	ScreenToBack(a0)
Modula-2:		ScreenToBack(screen: ScreenPtr)
Arguments:		screen = screen to move
Result:			none
-------------------------
ScreenToFront
Description:		moves specified screen to front of the display
Library:		intuition.library
Offset:			-$00FC (-252)
Modula-2 Module:	Intuition
Syntax:			ScreenToFront(screen)
C:			void ScreenToFront(struct Screen *)
Machine Language:	ScreenToFront(a0)
Modula-2:		ScreenToFront(screen: ScreenPtr)
Arguments:		screen = screen to move
Result:			none
-------------------------
ScrollLayer
Description:		copies data from a SuperBitMap to a layer so as to reposition the
			display over the bitmap
Library:		layers.library
Offset:			-$0048 (-72)
Modula-2 Module:	Layers
Syntax:			ScrollLayer(dummy, layer, dx, dy)
C:			void ScrollLayer(struct Layer_Info *, struct Layer *, long, long)
Machine Language:	ScrollLayer(a0, a1, d0, d1)
Modula-2:		ScrollLayer(layer: LayerPtr; dx, dy: LONGINT)
Arguments:		dummy = unused
			layer = Layer structure
			dx = offset by which to move layer horizontally
			dy = offset by which to move layer vertically
Result:			none
-------------------------
ScrollRaster
Description:		scrolls the contents of a rectangular area of a RastPort
Library:		graphics.library
Offset:			-$018C (-396)
Modula-2 Module:	Rasters
Syntax:			ScrollRaster(rastPort, dx, dy, x1, y1, x2, y2)
C:			void ScrollRaster(struct RastPort *, long, long, long, long, long, 
			long)
Machine Language:	ScrollRaster(a0, d0, d1, d2, d3, d4, d5)
Modula-2:		ScrollRaster(rastPort: RastPortPtr; dx, dy: INTEGER; x1, y1, x2,
			y2: INTEGER)
Arguments:		rastPort = RastPort structure
			dx = offset by which to scroll the rectangle
			dy = offset by which to scroll the rectangle
			x1 = horizontal position of the left edge of the rectangle
			y1 = vertical position of the top edge of the rectangle
			x2 = horizontal position of the right edge of the rectangle
			y2 = vertical position of the bottom edge of the rectangle
Result:			none
-------------------------
ScrollVPort
Description:		scrolls the contents of a rectangular area of a ViewPort by reinter-
			preting the RasInfo information in a ViewPort
Library:		graphics.library
Offset:			-$024C (-588)
Modula-2 Module:	Views
Syntax:			ScrollVPort(viewPort)
C:			void ScrollVPort(struct ViewPort *)
Machine Language:	ScrollVPort(a0)
Modula-2:		ScrollVPort(viewPort: ViewPortPtr)
Arguments:		viewPort = ViewPort structure to update
Result:			none
-------------------------
Seek
Description:		moves the file pointer to a specified position in a file
Library:		dos.library
Offset:			-$0042 (-66)
Modula-2 Module:	DOS
Syntax:			oldPosition = Seek(file, position, mode)
C:			long Seek(BPTR, long, long)
Machine Language:	d0 = Seek(d1, d2, d3)
Modula-2:		Seek(file: FileHandle; position: LONGINT; mode: LONGINT):
			LONGINT
Arguments:		file = BCPL pointer to a file handle
			position = offset by which to move file pointer
			mode = flag specifying how to interpret position offset-
			OFFSET_BEGINNING (-1), OFFSET_CURRENT (0), or
			OFFSET_END (1)
Result:			oldPosition = old file position; -1 if unsuccessful
-------------------------
SendIO
Description:		sends an IO request
Library:		exec.library
Offset:			-$01CE (-462)
Modula-2 Module:	IO
Syntax:			SendIO(ioRequest)
C:			void SendIO(struct IORequest *)
Machine Language:	SendIO(a1)
Modula-2:		SendIO(ioRequest: ADDRESS)
Arguments:		IORequest = an initialized IORequest structure
Result:			none
-------------------------
SetAfPt (macro)
Description:		sets area fill pattern
C Include File:		include/graphics/gfxmacros.h
ML Include File:	none
Modula-2 Module:	Pens
Syntax:			SetAfPt(rastPort, pattern, size)
C:			void SetAfPt(struct RastPort *, char *, long)
Machine Language:	not available
Modula-2:      		SetAfPat(rastPort: RastPortPtr; pattern: ADDRESS; size:
			CARDINAL)
Arguments:		rastPort = RastPort structure
			pattern = pointer to the first word in an area-fill pattern
			size = size of area pattern (size to the power of two equals the
			number of words in pattern)
Result:			none
-------------------------
SetAPen
Description:		sets the primary pen color
Library:		graphics.library
Offset:			-0156 (-342)
Modula-2 Module:	Pens
Syntax:			SetAPen(rastPort, pen)
C:			void SetAPen(struct RastPort *, long)
Machine Language:	SetAPen(a1, d0)
Modula-2:		SetAPen(rastPort: RastPortPtr; pen: CARDINAL)
Arguments:		rastPort = RastPort structure
			pen = pen number (0-255)
Result:			none
-------------------------
SetBPen
Description:		sets the secondary pen color
Library:		graphics.library
Offset:			-015C (-348)
Modula-2 Module:	Drawing
Syntax:			SetBPen(rastPort, pen)
C:			void SetBPen(struct RastPort *, long)
Machine Language:	SetBPen(al, d0)
Modula-2:		SetBPen(rastPort: RastPortPtr; pen: CARDINAL)
Arguments:		rastPort = RastPort structure
			pen = pen number (0-255)
Result:			none
-------------------------
SetCollision
Description:		sets a collision vector to point to a user-written routine
Library:		graphics.library
Offset:			-0090 (-144)
Modula-2 Module:	Gels
Syntax:			SetCollision(number, routine, gelsInfo)
C:			void SetCollision(long, _fgptr, struct GelsInfo *)
Machine Language:	SetCollision(d0, a0, a1)
Modula-2:		SetCollision(number: LONGCARD; routine: PROC; gelsInfo:
			GelsInfoPtr)
Arguments:		number = collision vector number
			routine = pointer to user's collision routine
			gelsInfo = GelsInfo structure
Result:			none
-------------------------
SetComment
Description:		adds a comment to a file
Library:		dos.library
Offset:			-00B4 (-180)
Modula-2 Module:	DOS
Syntax:			success = SetComment(name, comment)
C:			long SetComment(char *, char *)
Machine Language:	d0 = SetComment(d1, d2)
Modula-2:		SetComment(name, comment: STRPTR): BOOLEAN
Arguments:		name = filename of file to comment
			comment = comment to add to file
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
SetCurrentBinding
Description:		sets static board configuration area
Library:		expansion.library
Offset:			-$0084 (-132)
Modula-2 Module:	none
Syntax:			SetCurrentBinding(currentBinding, size)
C:			void SetCurrentBinding(long, long)
Machine Language:	SetCurrentBinding(a0, d0)
Modula-2:      		not available
Arguments:		currentBinding = CurrentBinding structure
			size = size of user's BindDriver structure
Result:			none
-------------------------
SetDMRequest
Description:		attaches a DMRequester (a requester activated when the mouse's
			menu button is double clicked) to a window
Library:		intuition.library
Offset:			-0102 (-258)
Modula-2 Module:	Intuition
Syntax:			success = SetDMRequest(window, dmRequester)
C:			long SetDMRequest(struct Window *, struct Requester *)
Machine Language:	d0 = SetDMRequest(a0, a1)
Modula-2:		SetDMRequest(window: WindowPtr; dmRequester: RequesterPtr)
Arguments:		window = window to which the requester will be added
			dmRequester = requester to attach
Result:			success = TRUE if successful; FALSE if unsuccessful (nothing re-
			turned by Modula-2)
-------------------------
SetDrMd
Description:		sets a drawing mode for drawing routines
Library:		graphics.library
Offset:			-0162 (-354)
Modula-2 Module:	Pens
Syntax:			SetDrMd(rastPort, mode)
C:			void SetDrMd(struct RastPort *, long)
Machine Language:	SetDrMd(a1, d0)
Modula-2:		SetDrMd(rastPort: RastPortPtr; mode: DrawingModeSet)
Arguments:		rastPort = RastPort structure
			mode = drawing mode JAM1, JAM2, COMPLEMENT,
			INVERSVID)
Result:			none
-------------------------
SetDrPt (macro)
Description:		sets a pattern to use for line drawing
C Include File:		include/graphics/gfxmacros.h
ML Include File:	none
Modula-2 Module:	Pens
Syntax:			SetDrPt(rastPort, pattern)
C:			void SetDrPt(struct RastPort *, long)
Machine Language:	not available
Modula-2:		SetDrPt(rastPort: RastPortPtr; pattern: BITSET)
Arguments:		rastPort = RastPort structure
			pattern = 16-bit drawing pattern
Result:			none
-------------------------
SetExcept
Description:		defines which signals cause an exception
Library:		exec.library
Offset:			-0138 (-312)
Modula-2 Module:	Tasks
Syntax:			oldSignals = SetExcept(newSignals, signalMask)
C:			long SetExcept(long, long)
Machine Language:	d0 = SetExcept(d0, d1)
Modula-2:		SetExcept(newSignals, signalMask: SignalSet): SignalSet
Arguments:		newSignals = new values for signals specified in signalMask
			signalMask = set of signals to be affected
Result:			oldSignals = prior exception signals
-------------------------
SetFont
Description:		sets the font to be used for drawing text in a rastport
Library:		graphics.library
Offset:			-0042 (-66)
Modula-2 Module:	Text
Syntax:			SetFont(rastPort, font)
C:			void SetFont(struct RastPort *, struct TextFont *)
Machine Language:	SetFont(a1/ a0)
Modula-2:		SetFont(rastPort: RastPortPtr; font: TextFontPtr)
Arguments:		rastPort = RastPort structure
			font = font descriptor obtained from OpenFont( ) function
Result:			none
-------------------------
SetFunction
Description:		changes a function vector in a library
Library:		exec.library
Offset:			-01A4 (-420)
Modula-2 Module:	Libraries
Syntax:			oldFunc = SetFunction(library, offset, newFunc)
C:			_fptr SetFunction(struct Library *, long,_fptr)
Machine Language:	d0 = SetFunction(a1, a0, d0)
Modula-2:		SetFunction(library: LibraryPtr; offset: INTEGER; newFunc:
			PROC): PROC
Arguments:		library = library to change
			offset = offset of function vector to change
			newFunc = address of new function
Result:			oldFunc = address of old function
-------------------------
SetIntVector
Description:		changes a system interrupt vector
Library:		exec.library
Offset:			-00A2 (-162)
Modula-2 Module:	Interrupts
Syntax:			oldInt = SetIntVector(intNum, newInt)
C:			struct Interrupt *SetIntVector(long, struct Interrupt *)
Machine Language:	d0 = SetIntVector(d0, a1)
Modula-2:		SetIntVector(intNum: CARDINAL; newInt: InterruptPtr):
			InterruptPtr
Arguments:		intNum = Portia interrupt bit number (0-14)
			newInt = initialized Interrupt structure
Result:			oldInt = old Interrupt structure
-------------------------
SetMenuStrip
Description:		attaches a menu strip to a window
Library:		intuition.library
Offset:			-0108 (-264)
Modula-2 Module:	Intuition
Syntax:			SetMenuStrip(window, menu)
C:			void SetMenuStrip(struct Window *, struct Menu *)
Machine Language:	SetMenuStrip(a0, a1)
Modula-2:		SetMenuStrip(window: WindowPtr; menu: MenuPtr)
Arguments:		window = window to receive menu strip
			menu = first menu in menu strip
Result:			none
-------------------------
SetOPen (macro)
Description:		sets the color of the pen used for outlining figures and tums on
			outlining
C Include File:		include/graphics/gfxmacros.h
ML Include File:	none
Modula-2 Module:	Pens
Syntax:			SetOPen(rastPort, pen)
C:			void SetOPen(struct RastPort *, long)
Machine Language:	not available
Modula-2:		SetOPen(rastPort: RastPortPtr; pen: CARDINAL)
Arguments:		rastPort = RastPort structure
			pen = pen number (0-255)
Result:			none
-------------------------
SetPointer
Description:		sets the shape of a window's sprite mouse pointer
Library:		intuition.library
Offset:			-010E (-270)
Modula-2 Module:	Intuition
Syntax:			SetPointer(window, pointer, height, width, xOffset, yOffset)
C:			void SetPointer(struct Window *, short *, long, long, long, long)
Machine Language:	SetPointer(a0, a1, d0, d1, d2, d3)
Modula-2:		SetPointer(window: WindowPtr; pointer: ADDRESS; height,
			width: CARDINAL; xOffset, y: INTEGER)
Arguments:		window = window to receive new pointer
			pointer = sprite data defining new shape
			height = height of sprite in lines
			width = width of sprite in pixels (less than or equal to 16)
			xOffset = horizontal offset of pointer hot spot
			yOffset = vertical offset of pointer hot spot
Result:			none
-------------------------
SetPrefs
Description:		changes Preferences' current settings
Library:		intuition.library
Offset:			-$0144 (-324)
Modula-2 Module:	Preferences
Syntax:			prefBuffer = SetPrefs(prefBuffer, size, inform)
C:			struct Preferences *SetPrefs(struct Preferences *, long, long)
Machine Language:	d0 = SetPrefs(a0, d0, d1)
Modula-2:		SetPrefs(prefBuffer: ADDRESS; size: INTEGER; inform:
			BOOLEAN)
Arguments:		prefBuffer = buffer which contains your desired Preferences
			settings
			size = size of buffer in bytes
			inform = TRUE if you want to send a NEWPREFS message to all
			interested windows
Result:			prefBuffer = pointer to your prefBuffer
------------------------- 
SetProtection
Description:		sets a file or directories protection bits
Library:		dos.library
Offset:			-00BA (-186)
Modula-2 Module:	DOS
Syntax:			success = SetProtection(name, mask)
C:			long SetProtection(char *, long)
Machine Language:	d0 = SetProtection(d1, d2)
Modula-2:		SetProtection(name: STRPTR; mask: ProtectionSet): BOOLEAN
Arguments:		name = file or directory name
			mask = protection bits to set
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
SetRast
Description:		sets the entire rastport to a specified color
Library:		graphics.library
Offset:			-00EA (-234)
Modula-2 Module:	Rasters
Syntax:			SetRast(rastPort, pen)
C:			void SetRast(struct RastPort *, long)
Machine Language:	SetRast(a1, d0)
Modula-2:		SetRast(rastPort: RastPortPtr; pen: CARDINAL)
Arguments:		rastPort = RastPort structure
			pen = color register used to color the rastport (0-31)
Result:			none
-------------------------
SetRGB4
Description:		sets the red, green, and blue values for a viewport's color register
Library:		graphics.library
Offset:			-0120 (-288)
Modula-2 Module:	Views
Syntax:			SetRGB4(viewPort, pen, red, green, blue)
C:			void SetRGB4(struct ViewPort *, long, long, long, long)
Machine Language:	SetRGB4(a0, d0, d1, d2, d3)
Modula-2:		SetRGB4(viewPort: ViewPortPtr; pen: INTEGER; red, green, blue:
			CARDINAL)
Arguments:		viewPort = ViewPort structure
			pen = color register to set (0-31)
			red = red color level (0-15)
			green = green color level (0-15)
			blue = blue color level (0-15)
Result:			none
-------------------------
SetRGB4CM
Description:		sets the red, green, and blue values for a colormap's color register
Library:		graphics.library
Offset:			-0276 (-630)
Modula-2 Module:	Views
Syntax:			SetRGB4CM(colorMap, pen, red, green, blue)
C:			void SetRGB4CM(struct ColorMap *, long, long, long, long)
Machine Language:	SetRGB4CM(a0, d0, d1, d2, d3)
Modula-2:		SetRGB4CM(colorMap: ColorMapPtr; pen: INTEGER; red, green,
			blue: CARDINAL)
Arguments:		colorMap = ColorMap structure
			pen = color register to set (0-31)
			red = red color level (0-15)
			green = green color level (0-15)
			blue = blue color level (0-15)
Result:			none
-------------------------
SetSignal
Description:		defines the state of a task's signals
Library:		exec.library
Offset:			-0132 (-306)
Modula-2 Module:	Tasks
Syntax:			oldSignals = SetSignal(newSignals, signalMask)
C:			long SetSignal(long, long)
Machine Language:	d0 = SetSignal(d0, d1)
Modula-2:		SetSignal(newSignals, signalMask: SignalSet): SignalSet
Arguments:		newSignals = new values for signals specified in signalMask
			signalMask = set of signals to be affected
Result:			oldSignals = prior values for signals
------------------------- 
SetSoftStyle
Description:		sets the style for the current font
Library:		graphics.library
Offset:			-005A (-90)
Modula-2 Module:	Text
Syntax:			newStyle = SetSoftStyle(rastPort, style, enable)
C:			long SetSoftStyle(struct RastPort *, long, long)
Machine Language:	d0 = SetSoftStyle(a1, d0, d1, a6)
Modula-2:		SetSoftStyle(rastPort: RastPortPtr; style, enable: FontStyleSet):
			FontStyleSet
Arguments:		rastPort = RastPort structure
			style = new font style
			enable = mask that determines which style bit can be changed;
			can be derived from AskSoftStyle( ) function
Result:			newStyle = resulting font style
-------------------------
SetSR
Description:		gets and/or sets the processor's status register
Library:		exec.library
Offset:			-0090 (-144)
Modula-2 Module:	Exec
Syntax:			oldSR = SetSR(newSR, mask)
C:			long SetSR(long, long)
Machine Language:	d0 = SetSR(d0, d1)
Modula-2:		SetSR(newSR: BITSET; mask: BITSET): BITSET
Arguments:		newSR = new value for bits specified in mask
			mask = bits to be affected
Result:			oldSR = prior value of status register
-------------------------
SetTaskPri
Description:		gets and sets the priority of a task
Library:		exec.library
Offset:			-012C (-300)
Modula-2 Module:	Tasks
Syntax:			oldPriority = SetTaskPri(task, newPriority)
C:			long SetTaskPri(struct Task *, long)
Machine Language:	d0 = SetTaskPri(a1, d0)
Modula-2:		SetTaskPri(task: TaskPtr; newPriority: INTEGER): INTEGER
Arguments:		task = task to be affected
			newPriority = new priority value (0-8)
Result:			oldPriority = old task priority (0-8)
-------------------------
SetWindowTitles
Description:		sets the titles for both a window and its screen
Library:		intuition.library
Offset:			-0114 (-276)
Modula-2 Module:	Intuition
Syntax:			SetWindowTitles(window, windowTitle, screenTitle)
C:			void SetWindowTitles(struct Window *, char *, char *)
Machine Language:	SetWindowTitles(a0, a1, a2)
Modula-2:		SetWindowTitles(window: WindowPtr; windowTitle, screenTitle:
			STRPTR)
Arguments:		window = window to be affected
			windowTitle = new window title (-1 to keep as-is)
			screenTitle = new screen title (-1 to keep as-is)
Result:			none
-------------------------
SetWrMsk (macro)
Description:		sets the write mask for a rastport (locks and unlocks bitplanes)
C Include File:	include/graphics/gfxmacros.h
ML Include File:	none
Modula-2 Module:	Pens
Syntax:			SetWrMsk(rastPort, mask)
C:			void SetWrMsk(struct RastPort *, long)
Arguments:		cList = character list containing substring
			index = starting position of substring
			length = number of bytes to copy
Result:			cList = new character list that contains the substring; -1 if there
			is not enough memory
-------------------------
SHIFTITEM (macro)
Description:		shifts a menu value to define a new value for the menu item
			number
C Include File:		include/intuition/intuition.h
ML Include File:	none
Modula-2 Module:	none
Syntax:			newValue = SHIFTITEM(menuValue)
C:			long SHIFTITEM(long)
Machine Language:	not available
Modula-2:		not available
Arguments:		menuValue = 16-bit packed number representing the menu num-
			ber, item number, and subitem number
Result:			newValue = the menuValue ANDed with $3F and shifted to the
			left five times-((menuValue & 0x3F) << 5)
-------------------------
SHIFTMENU (macro)
Description:		extracts the menu number from a value (identical to MENUNUM 
			macro)
C Include File: 	include/intuition/intuition.h
ML Include File: 	none
Modula-2 Module:	none
Syntax:			menuNumber= SHIFTMENU(menuValue)
C:			long SHIFTMENU(long)
Machine Language:	not available
Modula-2:		not available
Arguments:		menuValue = 16-bit packed number representing the menu num-
			ber, item number, and subitem number
Result:			menuNumber = menu number (0-31); equals NOMENU if no
			menu was selected
-------------------------
SHIFTSUB (macro)
Description:		shifts a menu value to define a new value for the menu subitem
			number
C Include File:		include/intuition/intuition.h
ML Include File:	none
Modula-2 Module:	none
Syntax:			newValue = SHIFTSUB(menuValue)
C:			long SHIFTSUB(long)
Machine Language:	not available
Modula-2:		not available
Arguments:		menuValue = 16-bit packed number representing the menu num-
			ber, item number, and subitem number
Result:			newValue = the menuValue ANDed with $1F and shifted to the
			left 11 times-((menuValue & 0x1F) << 11)
-------------------------
ShowTitle
Description:		determines whether the screen title bar will be displayed in front
			of a backdrop window
Library:		intuition.library
Offset:			-011A (-282) 
Modula-2 Module:	Intuition
Syntax:			ShowTitle(screen, showIt)
C:			void ShowTitle(struct Screen *, long)
Machine Language:	ShowTitle(a0, d0)
Modula-2:		ShowTitle(screen: ScreenPtr; showIt: BOOLEAN)
Arguments:		screen = screen to be affected
			showIt = flag that indicates whether or not to display the screen's
			title bar in front of a backdrop window (TRUE means show the
			title bar; FALSE means hide it)
Result:			none
-------------------------
Signal
Description:		signals a task with specified signals
Library:		exec.library
Offset:			-0144 (-324)
Modula-2 Module:	Tasks
Syntax:			Signal(task, signals)
C:			void Signal(struct Task *, long)
Machine Language:	Signal(d0, d1)
Modula-2:		Signal(task: TaskPtr; signals: SignalSet)
Arguments:		task = task to be signaled
			signals = signals to send
Result:			none
-------------------------
SizeCList
Description:		gets the size of a character list in bytes
Library:		clist.library
Offset:			-0036 (-54)
Modula-2 Module:	none
Syntax:			size = SizeCList(cList)
C:			long SizeCList(long)
Machine Language:	d0 = SizeCList(a0)
Modula-2:      		not available
Arguments:		cList = character list in question
Result:			size = number of bytes in character list
-------------------------
SizeLayer
Description:		changes the size of a nonbackdrop layer
Library:		layers.library
Offset:			-0042 (-66)
Modula-2 Module:	Layers
Syntax:			SizeLayer(dummy, layer, dx, dy)
C:			long SizeLayer(struct Layer_Info *, struct Layer *, long, long)
Machine Language:	d0 = SizeLayer(a0, a1, d0, d1)
Modula-2:		SizeLayer(layer: LayerPtr; dx, dy: LONGINT): BOOLEAN
Arguments:		dummy = unused
			layer = a nonbackdrop Layer structure
			dx = amount to add to layer's horizontal size (may be negative)
			dy = amount to add to layer's vertical size (may be negative)
Result:			TRUE if successful; FALSE if unsuccessful
-------------------------
SizeWindow
Description:		resizes a window
Library:		intuition.library
Offset:			-0120 (-288)
Modula-2 Module:	Intuition
Syntax:			SizeWindow(window, dx, dy)
C:			void SizeWindow(struct Window *, long, long)
Machine Language:	SizeWindow(a0, d0, d1)
Modula-2:		SizeWindow(window: WindowPtr; dx, dy: INTEGER)
Arguments:		window = window to be resized
			dx = amount to add to window's horizontal size (may be
			negative)
			dy = amount to add to window's vertical size (may be negative)
Result:			none
-------------------------
SortGList
Description:		sorts the GEL list by vertical position of each element, prior to
			displaying the GELs
Library:		graphics.library
Offset:			-0096 (-150)
Modula-2 Module:	Gels
Syntax:			SortGList(rastPort)
C:			void SortGList(struct RastPort *)
Machine Language:	SortGList(a1)
Modula-2:		SortGList(rastPort: RastPortPtr)
Arguments:		rastPort = RastPort structure containing the GelsInfo
Result:			none
-------------------------
SPAbs
Description:		obtains the absolute value of a floating-point number
Library:		mathffp.library
Offset:			-$0036 (-54)
Modula-2 Module:	none
Syntax:			fnum1 = SPAbs(fnum2)
C:			float SPAbs(float)
Machine Language:	d0 = SPAbs(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
Result:			fnum1 = absolute value of fnum2 in floating-point format
-------------------------
SPAcos
Description:		obtains the arcosine of a floating-point number
Library:		mathtrans.library
Offset:			-$0078 (-120)
Modula-2 Module:	none
Syntax:			fnum1 = SPAcos(fnum2)
C:			float SPAcos(float)
Machine Language:	d0 = SPAcos(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number representing the cosine of an
			angle
Result:			fnum1 = floating-point value of fnum2 angle in radians
-------------------------
SPAdd
Description:		adds two floating-point numbers
Library:		mathffp.library
Offset:			-$0042 (-66)
Modula-2 Module:	none
Syntax:			fnum1 = SPAdd(fnum2, fnum3)
C:			float SPAdd(float, float)
Machine Language:	d0 = SPAdd(d1, d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
			fnum3 = floating-point number
Result:			fnum1 = fnum2 plus fnum3 in floating-point format
-------------------------
SPAsin
Description:		obtains the arcsine of a floating-point number
Library:		mathtrans.library
Offset:			-$0072 (-114)
Modula-2 Module:	none
Syntax:			fnum1 = SPAsin(fnum2)
C:			float SPAsin(float)
Machine Language:	d0 = SPAsin(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number representing the sine of an angle
Result:			fnum1 = floating-point value of fnum2 angle in radians
-------------------------
SPAtan
Description:		obtains the arctangent of a floating-point number
Library:		mathtrans.library
Offset:			-$0030 (-48)
Modula-2 Module:	none
Syntax:			fnum1 = SPAtan(fnum2)
C:			float SPAtan(float)
Machine Language:	d0 = SPAtan(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number representing the tangent of an
			angle
Result:			fnum1 = floating-point value of fnum2 angle in radians
-------------------------
SPCmp
Description:		compares two floating-point numbers
Library:		mathffp.library
Offset:			-$002A (-42)
Modula-2 Module:	none
Syntax:			flag = SPCmp(fnum1, fnum2)
C:			long SPCmp(float, float)
Machine Language:	d0 = SPCmp(d1, d0)
Modula-2:		not available
Arguments:		fnum1 = floating-point number
			fnum2 = floating-point number
Result:			flag = -1 if fnum1<fnum2; +1 if fnum1>fnum2; 0 if
			fnum1 = fnum2
-------------------------
SPCos
Description:		obtains the cosine of a floating-point number
Library:		mathtrans.library
Offset:			-$002A (-42)
Modula-2 Module:	none
Syntax:			fnum1 = SPCos(fnum2)
C:			float SPCos(float)
Machine Language:	d0 = SPCos(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number representing an angle in radians
Result:			fnum1 = floating-point cosine of fnum2
-------------------------
SPCosh
Description:		obtains the hyperbolic cosine of a floating-point number
Library:		mathtrans.library
Offset:			-$0042 (-66)
Modula-2 Module:	none
Syntax:			fnum1 = SPCosh(fnum2)
C:			float SPCosh(float)
Machine Language:	d0 = SPCosh(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number representing an angle in radians
Result:			fnum1 = floating-point hyperbolic cosine of fnum2
-------------------------
SPDiv
Description:		divides one floating-point number by another
Library:		mathffp.library
Offset:			-$0054 (-84)
Modula-2 Module:	none
Syntax:			fnum1 = SPDiv(fnum2, fnum3)
C:			float SPDiv(float, float)
Machine Language:	d0 = SPDiv(d1, d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point dividend
			fnum3 = floating-point divisor
Result:			fnum1 = floating-point format results of fnum2 divided by fnum3
-------------------------
SPExp
Description:		obtains the exponent of a floating-point number
Library:		mathtrans.library
Offset:			-$004E (-78)
Modula-2 Module:	none
Syntax:			fnum1 = SPExp(fnum2)
C:			float SPExp(float)
Machine Language:	d0 = SPExp(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
Result:			fnum1 = floating-point value representing e (approx. 2.71728)
			raised to the power of fnum2
-------------------------
SPFieee
Description:		converts a single-precision IEEE number to a Motorola fast float-
			ing point number
Library:		mathtrans.library
Offset:			-$006C (-108)
Modula-2 Module:	none
Syntax:			fnum = SPFieee(ieeenum)
C:			float SPFieee(long)
Machine Language:	d0 = SPFieee(d0)
Modula-2:		not available
Arguments:		ieeenum = single-precision floating-point number
Result:			fnum = Motorola fast floating point equivalent to fnum
-------------------------
SPFlt
Description:		converts an integer to floating-point number
Library:		mathffp.library
Offset:			-$0024 (-36)
Modula-2 Module:	none
Syntax:			fnum = SPFlt(inum)
C:			float SPFlt(long)
Machine Language:	d0 = SPFlt(d0)
Modula-2:		not available
Arguments:		inum = signed integer to be converted
Result:			fnum = floating-point equivalent to inum
-------------------------
SplitCList
Description:		splits a character list in two, breaking it at the mark (obtained via
			the MarkList( ) function)
Library:		clist.library
Offset:			-008A (-138)
Modula-2 Module:	none
Syntax:			tailCList = SplitCList(cList)
C:			long SplitCList(long)
Machine Language:	d0 = SplitCList(a0)
Modula-2:		not available
Arguments:		cList = character list to split
Result:			tailCList = new character list that contains the tail end of the
			original character list; -1 if there is not enough memory
-------------------------
SPLog
Description:		obtains the natural logarithm of a floating-point number
Library:		mathtrans.library
Offset:			-$0054 (-84)
Modula-2 Module:	none
Syntax:			fnum1 = SPLog(fnum2)
C:			float SPLog(float)
Machine Language:	d0 = SPLog(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
Result:			fnum1 = floating-point natural logarithm (base e) of fnum2
-------------------------
SPLog10
Description:		obtains the naparian logarithm (base 10) of a floating-point number
Library:		mathtrans.library
Offset:			-$007E (-126)
Modula-2 Module:	none
Syntax:			fnum1 = SPLog10(fnum2)
C:			float SPLoglO(float)
Machine Language:	d0 = SPLog10(d0)
Modula-2:      not available
Arguments:		fnum2 = floating-point number
Result:			fnum1 = floating-point naparian logarithm (base 10) of fnum2
-------------------------
SPMul
Description:		multiplies one floating-point number by another
Library:		mathffp.library
Offset:			-$004E (-78)
Modula-2 Module:	none
Syntax:			fnum1 = SPMul(fnum2, fnum3)
C            float SPMul(float, float)
Machine Language:	d0 = SPMul(d1, d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
			fnum3 = floating-point number
Result:			fnum1 = product of fnum2 and fnum3 in floating-point format
-------------------------
SPNeg
Description:		negates the value of a floating-point number
Library:		mathffp.library
Offset:			-$003C (-60)
Modula-2 Module:	none
Syntax:			fnum1 = SPNeg(fnum2)
C:			float SPNeg(float)
Machine Language:	d0 = SPNeg(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number to negate
Result:			fnum1 = negative fnum2 in floating-point format
-------------------------
SPPow
Description:		obtains the exponentiation of two floating-point numbers
Library:		mathtrans.library
Offset:			-$005A (-90)
Modula-2 Module:	none
Syntax:			fnum1 = SPPow(fnum2, fnum3)
C:			float SPPow(float, float)
Machine Language:	d0 = SPPow(d1, d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
			fnum3 = floating-point number
Result:			fnum1 = floating-point value of fnum2 raised to the power of
			fnum3
-------------------------
sprintf
Description:		outputs a formatted string into a string (Lattice and Manx users: if 
			you link with lc.lib or c.lib, this is not the function you're calling)
Library:		amiga.lib (linked library)
Modula-2 Module:	none
Syntax:			sprintf(destinationString, formatString, values...)
C:			void sprintf(char *, char *, long...)
Machine Language:	move.l #value,-(sp) ;may have several values 
			pea formatString 
			pea destinationString 
			jsr _printf 
			add.l #8,sp ;(2 arguments * 4 bytes = 8)
Modula-2:		not available

Arguments:		destinationString = address of string to receive output
			 formatString = string containing optional C formatting commands
			 (%); if you're passing longword values on the stack (as shown
			 above) be sure to follow the percent symbol with a lowercase L
			 values = values or addresses of strings to print; this routine
			 knows how many values are on the stack by checking the number
			 of formatting commands in formatString argument
Result:			 none
-------------------------
SPSin
Description:		 obtains the sine of a floating-point number
Library:		 mathtrans.library
Offset:			 -$0024 (-36)
Modula-2 Module:	none
Syntax:			fnum1 = SPSin(fnum2)
C:			float SPSin(float, float)
Machine Language:	d0 = SPSin(d0)
Modula-2:		 not available
Arguments:		fnum2 = floating-point number representing an angle in radians
Result:			fnum1 = floating-point sine of fnum2
-------------------------
SPSincos
Description:		 obtains the sine and cosine of a floating-point number
Library:		 mathtrans.library
Offset:			 -$0036 (-54)
Modula-2 Module:	none
Syntax:			fnum1 = SPSincos(fnum2, fnum3)
C:			float SPSincos(float, float *)
Machine Language:	d0 = SPSincos(d1, d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
			fnum3 = pointer to floating point number to receive the cosine of
			fnum2
Result:			fnum1 = floating-point sine of fnum2 (cosine is returned in
			fnum3)
-------------------------
SPSinh
Description:		obtains the hyperbolic sine of a floating-point number
Library:		mathtrans.library
Offset:			-$003C (-60)
Modula-2 Module:	none
Syntax:			fnum1 = SPSinh(fnum2)
C:			float SPSinh(float, float)
Machine Language:	d0 = SPSinh(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number representing an angle in radians
Result:			fnum1 = floating-point hyperbolic sine of fnum2
-------------------------
SPSqrt
Description:		obtains the square root of a floating-point number
Library:		mathtrans.library
Offset:			-$0060 (-96)
Modula-2 Module:	none
Syntax:			fnum1 = SPSqrt(fnum2)
C:			float SPSqrt(float)
Machine Language:	d0 = SPSqrt(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
Result:			fnum1 = floating-point square root of fnum2
-------------------------
SPSub
Description:		subtracts one floating-point number from another
Library:		mathffp.library
Offset:			-$0048 (-72)
Modula-2 Module:	none
Syntax:			fnum1 = SPSub(fnum2, fnum3)
C:			float SPSub(float, float)
Machine Language:	d0 = SPSub(d1, d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
			fnum3 = floating-point number
Result:			fnum1 = fnum2 minus fnum3 in floating-point format
-------------------------
SPTan
Description:		obtains the tangent of a floating-point number
Library:		mathtrans.library
Offset:			-$0030 (-48)
Modula-2 Module:	none
Syntax:			fnum1 = SPTan(fnum2)
C:			float SPTan(float, float)
Machine Language:	d0 = SPTan(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number representing an angle in radians
Result:			fnum1 = floating-point tangent of fnum2
-------------------------
SPTanh
Description:		obtains the hyperbolic tangent of a floating-point number
Library:		mathtrans.library
Offset:			-$0048 (-72)
Modula-2 Module:	none
Syntax:			fnum1 = SPTanh(fnum2)
C:			float SPTanh(float, float)
Machine Language:	d0 = SPTanh(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number representing an angle in radians
Result:			fnum1 = floating-point hyperbolic tangent of fnum2
-------------------------
SPTieee
Description:		converts a Motorola fast floating point number to a single-
			precision IEEE number
Library:		mathtrans.library
Offset:			-$0066 (-102)
Modula-2 Module:	none
Syntax:			ieeenum = SPTieee(fnum)
C:			float SPTieee(float)
Machine Language:	d0 = SPTieee(d0)
Modula-2:		not available
Arguments:		fnum = Motorola fast floating point number
Result:			ieeenum = single-precision floating-point equivalent to fnum
-------------------------
SPTst
Description:		compares a floating-point number with zero
Library:		mathffp.library
Offset:			-$0030 (-48)
Modula-2 Module:	none
Syntax:			flag = SPTst(fnum)
C:			long SPTst(float)
Machine Language:	d0 = SPTst(d0)
Modula-2:		not available
Arguments:		fnum = floating-point number
Result:			flag = -1 if fnum<0; +1 if fnum>0; 0 if fnum=0
-------------------------
SubCList
Description:		copies a substring from a character list
Library:		clist.library
Offset:			-0096 (-150)
Modula-2 Module:	none
Syntax:			cList = SubCList(cList, index, length)
C:			long SubCList(long, long, long)
Machine Language:	d0 = SubCList(a0, d0, d1)
Modula-2:		not available
Arguments:		cList = character list containing substring
			index = starting position of substring
			length = number of bytes to copy
Result:			cList = new character list that contains the substring; -1 if there
			is not enough memory
-------------------------
SUBNUM (macro)
Description:		extracts the menu subitem number from a value
C Include File:		include/intuition/intuition.h
ML Include File:	none
Modula-2 Module:	Intuition
Syntax:			subNumber= SUBNUM(menuValue)
C:			long SUBNUM(long)
Machine Language:	not available
Modula-2:		SUBNUM(menuValue: CARDINAL): CARDINAL
Arguments:		menuValue = 16-bit packed number representing the menu num-
			ber, item number, and subitem number
Result:			itemNumber = item number (0-31); equals NOSUB if no menu
			was selected
-------------------------
SumKickData
Description:		computes the checksum for a Kickstart delta list
Library:		exec.library
Offset:			-0264 (-612)
Modula-2 Module:	Resident
Syntax:			SumKickData( )
C:			void SumKickData(void)
Machine Language:	SumKickData( )
Modula-2:		SumKickData( )
Arguments:		none
Result:			none
-------------------------
SumLibrary
Description:		verifies a library's checksum; alerts user if checksum is incorrect
Library:		exec.library
Offset:			-01AA (-426)
Modula-2 Module:	Libraries
Syntax:			SumLibrary(library)
C:			void SumLibrary(struct Library *)
Machine Language:	SumLibrary(a1)
Modula-2:		SumLibrary(
Library:		LibraryPtr)
Arguments:		library = library to verify
Result:			none
-------------------------
SuperState
Description:		engage supervisor mode using user-defined stack
Library:		exec.library
Offset:			-$0096 (-150)
Modula-2 Module:	Interrupts
Syntax:			sysStack = SuperState( )
C:			long SuperState(void)
Machine Language:	d0 = SuperState( ) 
Modula-2:		SuperState( ): ADDRESS 
Arguments:		none 
Result:			sysStack = pointer to system stack; NULL if already in supervisor 
			mode
-------------------------
SwapBitsRastPortClipRect
Description:		engage supervisor mode using user-defined stack
Library:		layers.library
Offset:			-007E (-126)
Modula-2 Module:	Layers
Syntax:			SwapBitsRastPortClipRect(rastPort, clipRect)
C:			void SwapBitsRastPortClipRect(struct RastPort *, struct ClipRect *)
Machine Language:	SwapBitsRastPortClipRect(a0, a1)
Modula-2:		SwapBitsRastPortClipRect(rastPort: RastPortPtr; clipRect:
			ClipRectPtr)
Arguments:		rastPort = RastPort structure
			clipRect = ClipRect to swap bits with
Result:			none
-------------------------
SyncSBitMap
Description:		copies all bits from a layer's ClipRects into the SuperBitMap
Library:		layers.library
Offset:			-01BC (-444)
Modula-2 Module:	Clip
Syntax:			SyncSBitMap(layer)
C:			void SyncSBitMap(struct Layer *)
Machine Language:	SyncSBitMap(a0)
Modula-2:		SyncSBitMap(layer: LayerPtr)
Arguments:		layer = a locked layer that contains a SuperBitMap
Result:			none
-------------------------
Text
Description:		prints text in a RastPort using the current font
Library:		graphics.library
Offset:			-$003C (-60)
Modula-2 Module:	Text
Syntax:			Text(rastPort, string, length)
C:			void Text(struct RastPort *, char *, long)
Machine Language:	Text(a1, a0, d0)
Modula-2:		Text(rastPort: RastPortPtr; string: STRPTR; length: CARDINAL)
Arguments:		rastPort = RastPort where text is to be output
			string = text to print
			length = number of characters in string
Result:			none
-------------------------
Textlength
Description:		finds the length (in bits) that a string of characters would occupy
			if printed to a RastPort using the current text font
Library:		graphics.library
Offset:			-$0036 (-54)
Modula-2 Module:	Text
Syntax:			size = TextLength(rastPort, string, length)
C:			long TextLength(struct RastPort *, char *, long)
Machine Language:	d0 = TextLength(a1, a0, d0)
Modula-2:		TextLength(rastPort: RastPortPtr; string: STRPTR; length: CARDI-
			NAL): CARDINAL
Arguments:		rastPort = RastPort where text would be output
			string = text to print
			length = number of characters in string
Result:			size = number of pixels (horizontally) required to print the speci-
			fied text
-------------------------
ThinLayerInfo
Description:		converts a 1.1 LayerInfo structure into a 1.0 LayerInfo structure,
			thus returning the extra memory allocate by FattenLayerInfo (this
			is an obsolete function)
Library:		layers.library
Offset:			-$00A2 (-162)
Modula-2 Module:	none
Syntax:			ThinLayerInfo(layerInfo)
C:			void ThinLayerInfo(struct Layer_Info *)
Machine Language:	ThinLayerInfo(a0)
Modula-2:		not available
Arguments:		layerInfo = LayerInfo structure to convert
Result:			none
------------------------- 
Translate
Description:		converts an English string into phonetics
Library:		translator.library
Offset:			-$001E (-30)
Modula-2 Module:	Translator
Syntax:			error = Translate(instring, inlen, outbuf, outlen)
C:			long Translate(char *, long, char *, long)
Machine Language:	d0 = Translate(a1, d0, a1, d1)
Modula-2:		Translate(instring: STRPTR; inlen: LONGCARD; outbuf: STRPTR;
			outlen: LONGCARD): LONGINT
Arguments:		instring = English string to convert
			inlen = number of characters in instring
			outbuf = buffer to hold phonetic codes
			outlen = size of outbuf in bytes
Result:			error = 0 if successful; negative number representing position in
			instring where function was forced to stop because the output
			buffer overflowed
-------------------------
TypeOfMem
Description:		determines the attributes of a given memory address
Library:		exec.library
Offset:			-$0216 (-534)
Modula-2 Module:	Memory
Syntax:			attributes = TypeOfMem(address)
C:			long TypeOfMem(void *)
Machine Language:	d0 = TypeOfMem(a0)
Modula-2:		TypeOfMem(address: ADDRESS): MemReqSet
Arguments:		address = memory address
Result:			attributes = type of memory-MEMF_CHIP, MEMF_FAST,
			MEMF_PUBLIC
-------------------------
UnGetCLChar
Description:		adds a byte to the beginning of a character list
Library:		clist.library
Offset:			-$0048 (-72)
Modula-2 Module:	none
Syntax:			error = UnGetCLChar(cList, byte)
C:			long UnGetCLChar(long, long)
Machine Language:	d0 = UnGetCLChar(a0, d0)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
			byte = byte to add to beginning of character list
Result:			error = 0 if successful
-------------------------
UnGetCLWord
Description:		adds a word to the beginning of a character list
Library:		clist.library
Offset:			-$0060 (-96)
Modula-2 Module:	none
Syntax:			error = UnGetCLWord(cList, word)
C:			long UnGetCLWord(long, long)
Machine Language:	d0 = UnGetCLWord(a0, d0)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
			word = word to add to beginning of character list
Result:			error = 0 if successful; 1 if unsuccessful
-------------------------
UnLoadSeg
Description:		removes a segment from memory
Library:		dos.library
Offset:			-$009C (-156)
Modula-2 Module:	DOSLoader
Syntax:			UnLoadSeg(segment)
C:			void UnLoadSeg(BPTR)
Machine Language:	UnLoadSeg(d1)
Modula-2:		UnLoadSeg(segment: BPTR): BOOLEAN
Arguments:		segment = BCPL pointer to a segment as returned by LoadSeg( )
Result:			none
-------------------------
UnLock
Description:		unlocks a directory or file
Library:		dos.library
Offset:			-$005A (-90)
Modula-2 Module:	DOS
Syntax:			UnLock(lock)
C:			void UnLock(BPTR)
Machine Language:	UnLock(d1)
Modula-2:		UnLock(lock: FileLock)
Arguments:		lock = BCPL pointer to a lock
Result:			none
-------------------------
UnlockIBase
Description:		releases the lock on IntuitionBase so Intuition can change the
			structure as it pleases
Library:		intuition.library
Offset:			-$01A4 (-420)
Modula-2 Module:	IntuitionBase
Syntax:			UnLockIBase(lockNumber)
C:			void UnLockIBase(long)
Machine Language:	UnLockIBase(a0)
Modula-2:		UnLockIBase(lockNumber: LONGCARD)
Arguments:		lockNumber = Intuition lock value as returned by LockIBase( )
Result:			none
-------------------------
UnlockLayer
Description:		unlocks a Layer so the graphics routines can use it
Library:		layers.library
Offset:			-$0066 (-102)
Modula-2 Module:	Layers
Syntax:			UnLockLayer(layer)
C:			void UnLockLayer(struct Layer *)
Machine Language:	UnLockLayer(a0)
Modula-2:		UnLockLayer(layer: LayerPtr)
Arguments:		layer = Layer structure to unlock
Result:			none
-------------------------
UnlockLayerInfo
Description:		unlocks a Layer_Info structure
Library:		layers.library
Offset:			-$008A (-138)
Modula-2 Module:	Layers
Syntax:			UnlockLayerInfo(layerlnfo)
C:			void UnlockLayerInfo(struct Layer_Info *)
Machine Language:	UnlockLayerInfo(a0, a1)
Modula-2:		UnlockLayerInfo(layerlnfo: LayerlnfoPtr)
Arguments:		layerlnfo = Layer_Info structure to unlock
Result:			none
-------------------------
UnlockLayerRom
Description:		unlocks a Layer so the graphics routines can use it (this function
			uses ROM code as opposed to LockLayerRom( )'s RAM-based
			code)
Library:		graphics.library
Offset:			-$01B6 (-438)
Modula-2 Module:	RomLayers
Syntax:			UnLockLayerRom(layer)
C:			void UnLockLayerRom(struct Layer *)
Machine Language:	UnLockLayerRom(a5)
Modula-2:		UnLockLayerRom(layer: LayerPtr)
Arguments:		layer = Layer structure to unlock
Result:			none
-------------------------
UnlockLayers
Description:		unlocks all layers so the graphics routines can use them
Library:		layers.library
Offset:			-$0072 (-114)
Modula-2 Module:	Layers
Syntax:			UnLockLayers(layerInfo)
C:			void UnLockLayers(struct Layer_Info *)
Machine Language:	UnLockLayers(a0)
Modula-2:		UnLockLayers(layerInfo: LayerInfoPtr)
Arguments:		layerInfo = Layer_Info structure
Result:			none
-------------------------
UnPutCLChar
Description:		gets a byte from the end of a character list
Library:		clist.library
Offset:			-$0048 (-72)
Modula-2 Module:	none
Syntax:			byte= UnPutCLChar(cList)
C:			long UnPutCLChar(long)
Machine Language:	d0 = UnPutCLChar(a0)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
Result:			byte = byte from end of character list; -1 no data
-------------------------
UnPutCLWord
Description:		gets a word from the end of a character list
Library:		clist.library
Offset:			-$0066 (-102)
Modula-2 Module:	none
Syntax:			word = UnPutCLWord(cList)
C:			long UnPutCLWord(long)
Machine Language:	d0 = UnPutCLWord(a0)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
Result:			word = word from end of character list; -1 if no data
-------------------------
UpFrontLayer
Description:		moves a layer in front of all other layers
Library:		layers.library
Offset:			-$0030 (-48)
Modula-2 Module:	Layers
Syntax:			success = UpFrontLayer(dummy, layer)
C:			long UpFrontLayer(struct Layer_Info *, struct Layer *)
Machine Language:	d0 = UpFrontLayer(a0, a1)
Modula-2:		UpfrontLayer(layer: LayerPtr): BOOLEAN
Arguments:		dummy = unused
			layer = pointer to Layer to move behind other layers
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
UserState
Description:		return to user state and system stack (do NOT call if computer is
			already in user state)
Library:		exec.library
Offset:			-009C (-156)
Modula-2 Module:	Interrupts
Syntax:			UserState(sysStack)
C:			void UserState(char *)
Machine Language:	UserState(d0)
Modula-2:		UserState(sysStack: ADDRESS)
Arguments:		sysStack = system stack pointer as returned by SuperState( )
Result:			none
-------------------------
Vacate
Description:		releases a semaphore locked by Procure( )
Library:		exec.library
Offset:			-$0222 (-546)
Modula-2 Module:	Semaphores
Syntax:			Vacate(semaphore)
C:			void Vacate(struct Semaphore *)
Machine Language:	Vacate(a0)
Modula-2:		Vacate(semaphore: SemaphorePtr)
Arguments:		semaphore = Semaphore structure to release
Result:			none
-------------------------
VBeamPos
Description:		returns the current position of the vertical video beam
Library:		graphics.library
Offset:			-$0180 (-384)
Modula-2 Module:	Views
Syntax:			pos = VBeamPos( )
C:			long VBeamPos(void)
Machine Language:	d0 = VBeamPos( )
Modula-2:		VBeamPos( ): CARDINAL
Arguments:		none
Result:			pos = current beam position (0-511)
-------------------------
ViewAddress
Description:		returns the address of Intuition's View structure
Library:		intuition.library
Offset:			-$0126 (-294)
Modula-2 Module:	Intuition
Syntax:			view = ViewAddress( )
C:			struct View *ViewAddress(void)
Machine Language:	d0 = ViewAddress( )
Modula-2:		ViewAddress( ): ViewPtr
Arguments:		none
Result:			view = address of the Intuition View structure
------------------------- 
ViewPortAddress
Description:		returns the address of a window's ViewPort structure
Library:		intuition.library
Offset:			-$012C (-300)
Modula-2 Module:	Intuition
Syntax:			viewPort = ViewPortAddress(window)
C:			struct ViewPort *ViewPortAddress(struct Window *)
Machine Language:	d0 = ViewPortAddress(a0)
Modula-2:		ViewPortAddress(window: WindowPtr): ViewPortPtr
Arguments:		window = Window structure
Result:			viewPort = address of window's ViewPort structure
-------------------------
Wait
Description:		waits for one or more signals
Library:		exec.library
Offset:			-$013E (-318)
Modula-2 Module:	Tasks
Syntax:			signals = Wait(signalSet)
C:			long Wait(long)
Machine Language:	d0 = Wait(d0)
Modula-2:		Wait(signalSet: SignalSet): SignalSet
Arguments:		signalSet = set of signals to wait for
Result:			signals = signals that have occurred
-------------------------
WaitBlit
Description:		waits for the blitter to finish what it's doing
Library:		graphics.library
Offset:			-$00E4 (-228)
Modula-2 Module:	Blitter
Syntax:			WaitBlit( )
C:			void WaitBlit(void)
Machine Language:	WaitBlit( )
Modula-2:		WaitBlit( )
Arguments:		none
Result:			none
------------------------- 
WaitBOVP
Description:		waits for the vertical beam to reach the bottom of a ViewPort
Library:		graphics.library
Offset:			-$0192 (-402)
Modula-2 Module:	Views
Syntax:			WaitBOVP(viewPort)
C:			void WaitBOVP(struct ViewPort *)
Machine Language:	WaitBOVP(a0)
Modula-2:		WaitBOVP(viewPort: ViewPortPtr)
Arguments:		viewPort = ViewPort structure
Result:			none
-------------------------
WaitForChar
Description:		waits a specified amount of time for a character to become avail-
			able from a virtual terminal
Library:		dos.library
Offset:			-$00CC (-204)
Modula-2 Module:	DOS
Syntax:			avail = WaitForChar(file, timeout)
C:			long WaitForChar(BPTR, long)
Machine Language:	d0 = WaitForChar(d1, d2)
Modula-2:		WaitForChar(file: FileHandle; timeout: LONGINT): BOOLEAN
Arguments:		file = BCPL pointer to a file handle
			timeout = number of microseconds to wait for character
Result:			avail = TRUE if a character is available
-------------------------
WaitIO
Description:		waits for an I/O request to be executed
Library:		exec.library
Offset:			-$01DA (-474)
Modula-2 Module:	IO
Syntax:			error = WaitIO(ioRequest)
C:			long WaitIO(struct IORequest *)
Machine Language:	d0 = WaitIO(a1)
Modula-2:		WaitIO(ioRequest: ADDRESS): INTEGER
Arguments:		ioRequest = IORequest block
Result:			error = 0 if successful
-------------------------
WaitPort
Description:		waits for a message
Library:		exec.library
Offset:			-$0180 (-384)
Modula-2 Module:	Ports
Syntax:			message = WaitPort(port)
C:			struct Message *WaitPort(struct MsgPort *)
Machine Language:	d0 = WaitPort(a0)
Modula-2:		WaitPort(port: MsgPortPtr): ADDRESS
Arguments:		port = message port to receive message
Result:			message = pointer to first available message
-------------------------
WaitTOF
Description:		waits for the next vertical blank
Library:		graphics.library
Offset:			-$010E (-270)
Modula-2 Module:	Views
Syntax:			WaitTOF( )
C:			void WaitTOF(void)
Machine Language:	WaitTOF( )
Modula-2:		WaitTOF( )
Arguments:		none
Result:			none
-------------------------
WBenchToBack
Description:		moves the Workbench screen behind all other screens
Library:		intuition.library
Offset:			-$0150 (-336)
Modula-2 Module:	Intuition
Syntax:			success = WBenchToBack( )
C:			long WBenchToBack(void)
Machine Language:	d0 = WBenchToBack( )
Modula-2:		WBenchToBack( ): BOOLEAN
Arguments:		none
Result:			success = TRUE if Workbench screen is open
-------------------------
WBenchToFront
Description:		moves the Workbench screen in front of all other screens
Library:		intuition.library
Offset:			-$0156 (-342)
Modula-2 Module:	Intuition
Syntax:			success = WBenchToFront( )
C:			long WBenchToFront(void)
Machine Language:	d0 = WBenchToFront( )
Modula-2:		WBenchToFront( ): BOOLEAN
Arguments:		none
Result:			success = TRUE if Workbench screen is open
-------------------------
WhichLayer
Description:		finds the layer which contains the specified point
Library:		layers.library
Offset:			-$0084 (-132)
Modula-2 Module:	Layers
Syntax:			layer = WhichLayer(layerlnfo, x, y)
C:			struct Layer *WhichLayer(struct Layer_Info *, long, long)
Machine Language:	d0 = WhichLayer(a0, d0, d1)
Modula-2:		WhichLayer(layerlnfo: LayerlnfoPtr; x, y: LONGCARD): LayerPtr
Arguments:		layerlnfo = Layerlnfo structure
			x = horizontal coordinate of point
			y = vertical coordinate of point
Result:			layer = pointer to top-most layer containing this point; NULL if
			point is not in a layer
-------------------------
WindowLimits
Description:		sets the minimum and maximum size of a window
Library:		intuition.library
Offset:			-$013E (-318)
Modula-2 Module:	Intuition
Syntax:			success = WindowLimits(window, minWidth, minHeight,
			maxWidth, minHeight)
C:			long WindowLimits(struct Window *, long, long, long, long)
Machine Language:	d0 = WindowLimits(a0, d0, d1, d2, d3)
Modula-2:		WindowLimits(window: WindowPtr; minWidth, minHeight,
			maxWidth, maxHeight: LONGINT): BOOLEAN
Arguments:		window = window to set size limits for
			minWidth = window's new minimum width
			minHeight = window's new minimum height
			maxWidth = window's new maximum width
			maxHeight = window's new minimum height
Result:			success = TRUE if all limits are set; FALSE if any of the limits are
			out of range, in which case only the legal limits are set
-------------------------
WindowToBack
Description:		moves a window to the back of all other windows
Library:		intuition.library
Offset:			-$0132 (-306)
Modula-2 Module:	Intuition
Syntax:			WindowToBack(window)
C:			void WindowToBack(struct Window *)
Machine Language:	WindowToBack(a0)
Modula-2:		WindowToBack(window: WindowPtr)
Arguments:		window = window to move to back of display
Result:			none
-------------------------
WindowToFront
Description:		moves a window in front of all other windows
Library:		intuition.library
Offset:			-$0138 (-312)
Modula-2 Module:	Intuition
Syntax:			WindowToFront(window)
C:			void WindowToFront(struct Window *)
Machine Language:	WindowToFront(a0)
Modula-2:		WindowToFront(window: WindowPtr)
Arguments:		window = window to move to front of display
Result:			none
-------------------------
Write
Description:		writes bytes of data to a file
Library:		dos.library
Offset:			-$0030 (-48)
Modula-2 Module:	DOS
Syntax:			length = Write(file, buffer, length)
C:			long Write(BPTR, char *, long)
Machine Language:	d0 = Write(d1, d2, d3)
Modula-2:		Write(file: FileHandle; buffer: ADDRESS; length: LONGINT):
			LONGINT
Arguments:		file = BCPL pointer to a file handle
			buffer = pointer to start of buffer containing data to write
			length = number of bytes to write
Result:			length = number of bytes successfully written; -1 if error
			occurred
-------------------------
WriteExpansionByte
Description:		writes a byte to a new-style memory expansion board-nybble by
			nybble
Library:		expansion.library
Offset:			-$0072 (-114)
Modula-2 Module:	Expansion
Syntax:			error = WriteExpansionByte(board, offset, byte)
C:			long WriteExpansionByte(long, long, long)
Machine Language:	d0 = WriteExpansionByte(a0, d0, d1)
Modula-2:		WriteExpansionByte(board: ADDRESS; offset: LONGCARD; byte:
			BYTE): BOOLEAN
Arguments:		board = base of a new-style expansion board
			offset = logical offset from the configdev base
			byte = byte to write to board
Result:			error = 0 if successful
-------------------------
WritePixel
Description:		colors a single pixel with the current foreground drawing pen
Library:		graphics.library
Offset:			-$0144 (-324)
Modula-2 Module:	Pens
Syntax:			error = WritePixel(rastPort, x, y)
C:			long WritePixel(struct RastPort *, long, long)
Machine Language:	d0 = WritePixel(a1, d0, d1 )
Modula-2:		WritePixel(rastPort: RastPortPtr; x, y: INTEGER): INTEGER
Arguments:		rastPort = RastPort structure containing pixel to color
			x = horizontal coordinate of pixel
			y = vertical coordinate of pixel
Result:			error = 0 if successful; -1 if pixel is outside specified RastPort
-------------------------
XorRectRegion
Description:		performs a 2d XOR operation of a rectangle with a region, leaving
			the results in the region
Library:		graphics.library
Offset:			-$022E (-558)
Modula-2 Module:	Regions
Syntax:			status = XorRectRegion(region, rectangle)
C:			long XorRectRegion(struct Region *, struct Rectangle *)
Machine Language:	d0 = XorRectRegion(a0, a1)
Modula-2:		XorRectRegion(region: RegionPtr; rectangle: RectanglePtr):
			BOOLEAN
Arguments:		region = Region structure
			rectangle = Rectangle structure
Result:			status = TRUE if successful; FALSE if out of memory
-------------------------
XorRegionRegion
Description:		performs a 2d XOR operation of one region with a second region,
			leaving the results in the second region
Library:		graphics.library
Offset:			-$026A (-618)
Modula-2 Module:	Regions
Syntax:			status = XorRegionRegion(region1, region2)
C:			long XorRegionRegion(struct Region *, struct Region *)
Machine Language:	d0 = XorRegionRegion(a0, a1)
Modula-2:		XorRegionRegion(region1, region2: RegionPtr): BOOLEAN
Arguments:		region1 = Region structure
			region2 = Region structure
Result:			status = TRUE if successful; FALSE if out of memory
-------------------------
Amiga Hardware Registers

The Amiga's hardware is accessed via registers- locations within a chip
that control it's operation or return status information about the chip.  A
register is accessed by R/W operations just like RAM.

Warning: You should never attempt to read a write-only register.  Doing so
will place a random value in that register and possibly cause a lockup.  For
the same reason, never use BCLR or BSET on a write-only register as these
two instructions perform a read prior to clearing or setting the specified
bit.  Write-only registers will be annotated with a (*W), and read-only
registers with a (*R) in the Status header.  A third type of register is a
Strobe register.  These are used by the Amiga to signify that an event has
occurred.  You should NEVER READ OR WRITE to a strobe register as the
operation may falsely trigger the strobe and confuse the Amiga.

SET/CLR Bit: Some registers contain a bit labeled "SET/CLR".  This is a
special bit that allows you to set or clear the register's other bits
without using AND or OR.  SET/CLR will always be bit 15.  What happens to a
register that contains a SET/CLR bit depends on the way you set this bit.
If it is set to zero, any other bit that is written to with a one will be
cleared.  If bit 15 is set to one, any other bit that is written to with a
one will be set to one.  All bits written to with a zero remain unaffected.
So, to clear all the bits, use $7FFF.  To set all bits, use $FFFF.  The
SET/CLR bit is useful ONLY on write-only registers.  On read only registers,
this bit always returns a value of zero.

Now that you realize how the bit operations work, here are the custon chip
register addresses and explanations:

----------------------------------------------------------------------------
$DFF000 BLTDDAT      Blitter Destination Data (early read dummy address)
Status: DMA Only     Agnus
                     Just before a word of data is moved into RAM by the
                     blitter, it's stored here.  This register cannot be
                     accessed by the 68K or the copper.  It's used
                     exclusively by the blitter DMA.  Writing to it does
                     nothing.  Reading returns a seemingly random number
----------------------------------------------------------------------------
$DFF002 DMACONR      DMA Enable Read
Status: *R           Agnus/Paula
                     0  AUD0EN   1 = Audio channel 0 DMA enabled
                     1  AUD1EN
                     2  AUD2EN
                     3  AUD3EN
                     4  DSKEN    1 = Disk DMA enabled
                     5  SPREN    1 = Sprite DMA enabled
                     6  BLTEN    1 = Blitter DMA enabled
                     7  COPEN    1 = Copper DMA enabled
                     8  BPLEN    1 = Bit-plane DMA enabled
                     9  DMAEN    0 = DMA for all channels disabled
                     10 BLTPRI   1 = Blitter has full priority over 68K
                                 0 = Blitter has partial priority
                     11 UNUSED
                     12 UNUSED
                     13 BZERO    1 = If the last blitter operation output 
                                     zeroes only.  No bits were set in
                                     destination RAM.
                     14 BBUSY    1 = Blitter is busy ("blitting") See note
                     15 SETCLR   UNUSED

Note: Because of timing problems with 68020/68030 processors, you must wait
a short while before testing BBUSY.  A "btst #14,DMACONR" before the test
will provide the appropriate delay.  (i.e.: BTST twice)
----------------------------------------------------------------------------
$DFF004 VPOSR        Vertical Beam Position Read
Status: *R           Agnus
                     0  V8       The high bit of the vertical beam position
                                 (1 = pos > 255)
                  1-14  UNUSED
                    15  LOF      Interlace Long Frame Flag (1 = a long frame
                                 is being drawn (even), 0 = a short frame
                                 (odd))

----------------------------------------------------------------------------
$DFF006 VHPOSR       Vertical/Horizontal Beam Position Read
Status: *R           Agnus
                   0-7  H1-H8    Video beam's horizontal position in
                                 increments of two lo-res pixels
                  8-15  V0-V7    Low 8 bits of video beam's horizontal pos

Note: If bit 3 in register BPLCON0 ($DFF100) is set, the Amiga returns the
light pen position and NOT the raster position!  Also, the location and size
of the visible screen area changes accordingly with the DIWSTRT and DIWSTOP
(Display Window Start/Stop @ $DFF08E / $DFF090).  These registers are
changed by Preferences each time you adjust the display-centering gadget.
Normal Visible Screen area is - horizontal : $40 - $E0
                                  vertical : $2C - $F4
----------------------------------------------------------------------------
$DFF008 DSKDATR      Disk Data Read (early read dummy address -Disk DMA)
                     SEE $DFF000 (BLTDDAT) for explanation.
----------------------------------------------------------------------------
$DFF00A JOY0DAT      Joystick/Mouse Port 0 Data
$DFF00C JOY1DAT                     Port 1 Data
Status: *R          Denise
                     For Mouse Use:
                   0-7           Horizontal Position Counter
                  8-15           Vertical Position Counter
                     For Joystick Use:
                     0 EOR BIT 1 Down (1 = stick down)
                     1           Right(1 = stick right)
                     8 EOR BIT 9 Up   (1 = stick up)
                     9           Left (1 = stick left)
                     For Paddle Use:
                     1           Right paddle fire button (1 = fire)
                     9           Left paddle fire button  (1 = fire)
----------------------------------------------------------------------------
$DFF00E CLXDAT       Collision Data
Status: *R           Denise
if set to one...     0  Even bit plane collided with odd bit plane
                     1  Odd plane collided with sprite 0 or 1
                     2                     with sprite 2 or 3
                     3                                 4 or 5
                     4                                 6 or 7
                     5  Even plane collide with sprite 0 or 1
                     6                                 2 or 3
                     7                                 4 or 5
                     8                                 6 or 7
                     9  Sprite 0 or 1 collide with 2 or 3
                    10         0 or 1              4 or 5
                    11         0 or 1              6 or 7
                    12         2 or 3              4 or 5
                    13         2 or 3              6 or 7
                    14         4 or 5              6 or 7
                    15  UNUSED

Note: When you read this register, all bits are cleared, so be sure to save
it if you need it's contents if you want to check for more than one type of
collision.  Bitplane collisions are extremely flexible.  See CLXCON
($DFF098) for more info.D
----------------------------------------------------------------------------
$DFF010 ADKCONR      Audio/Disk Control Read
Status: *R           Paula
                     0 ATVOL0 1 = Audio channel 0 modulates channel 1 volume
                     1 ATVOL1 1 =               1                   2
                     2 ATVOL2 1 =               2                   3
                     3 ATVOL3 1 = Output of audio channel 3 disabled
                     4 ATPER0 1 = Audio channel 0 modulates channel 1 period
                     5 ATPER1 1 =               1                   2
                     6 ATPER2 1 =               2                   3
                     7 ATPER3 1 = Output of audio channel 3 disabled
                     8 FAST   1 = MFM:2 us per bit disk operation (normDOS)
                              0 = GCR:4 us per bit disk op (double density)
                     9 MSBSYNC    1 = GCR-format synchronization for disk
                                      operations enabled (not used by DOS)
                    10 WORDSYNC   1 = Disk Controller is synchronizing on
                                      the data word found in the DSKSYNC
                                      register ($DFF07E) typically set to
                                      $4489 for MFM.
                    11 UARTBRK    1 = RS232 break-signal is occuring on the
                                      serial TxD line.
                    12 MFMPREC    1 = MFM selected
                                  0 = GCR selected
                 13-14 PRECOMP    Disk precompensation time (00=none,
                                  01=140 nsec, 10=280 nsec, 11=560 nsec)
                    15 SETCLR     UNUSED

Note: ADKCONR is a read version of ADKCON ($DFF09E).  See that register for
a complete explanation of each bit.
----------------------------------------------------------------------------
$DFF012 POT0DAT      Pot (Paddle/Proportional Joystick) Port 0/1 Data Read
$DFF014 POT1DAT 
Status: *R           Paula
                       For Paddle Use:
                   0-7 Left Paddle Counter (0 = completely CCW)
                  8-15 Right Paddle Counter(0 = completely CCW)
                       For Proportional Joystick Use:
                   0-7 Horizontal Counter (0 = stick pushed left)
                  8-15 Vertical Counter   (0 = stick pushed down)
----------------------------------------------------------------------------
$DFF016 POTGOR       Pot Port Data Read
Status: *R           Paula
                     0 START  Trigger bit for starting pot counters
                              (always reads zero)
                   1-7 UNUSED Reserved for Chip ID
                     8 DATLX  Current state of pin 9 on game port 1 (0/1)
                     9 OUTLX  Output enable for pin 9 on game port 1 (zero)
                    10 DATLY  Current state of pin 5 on game port 1 (0/1)
                    11 OUTLY  Output enable for pin 5 on game port 1 (zero)
                    12 DTARX  Current state of pin 9 on game port 0 (0/1)
                    13 OUTRX  Output enable for pin 9 on game port 0 (zero)
                    14 DATRY  Current state of pin 5 on game port 0 (0/1)
                    15 OUTRY  Output enable for pin 5 on game port 0 (zero)

Notes: This is the read address for the POTGO register ($DFF034).  Most of
the bits in this register are write-only and always return a zero when read.
Only bits 8, 10, 12, and 14 return valid data.  The remaining bits are
controlled via the POTGO register.  (See for more info on these bits)
   The Amiga's game ports are quite versatile.  Pins 5 and 9 of either port
can be programmed to receive and send digital data.  This register allows
you to read the current high-low state of these pins.
   Simply read the desired pin's DATxx bit to determine its status.  (0 =
0v, 1 = +5v)  The positive voltage sent to these pins should never exceed 5
volts or 400 mA.  ONLY THE VOLTAGE FROM PIN 7 SHOULD BE CONNECTED TO PIN 5
OR 9.  PIN 7 CARRIES +5 VOLTS FROM THE AMIGA'S OWN POWER SUPPLY.
   The right mouse button is wired to game port pins 8 and 9.  When the
button is pressed, these two pins connect.  Pin 8 is grounded, so any
voltage that 9 carries gets shorted to ground.
   To sense whether the right mouse button is being pressed on a mouse
plugged into game port 0, you must first set pin 9 to output.  (i.e.:
OUTLY = 1 or write $0C00 to POTGO.  For a mouse plugged into port 1, use
OUTRY and DATRY instead.)  Finally, wait about 300 msec for the voltage to
reach the game port - and then read the status of pin 9 via the DATLY bit in
POTGOR.  If this bit equals one, the pin is not grounded, thus the button is
not pressed.  If it equals zero, the pin is grounded, and the button has
been pressed.
   Because Intuition automatically handles game port 0 mouse events, you'll
have to turn off multitasking if you wish to control this port directly via
the hardware.  Even accessing port 1 may cause problems since any
manipulation of POTGO affects all of the bits.  Such confusion usually
results in the Amiga thinking that the right mouse button is being clicked
when it really isn't.
   Rather than calculate a 300 msec delay, you may write a #$C000 to POTGO
and wait for one vertical blanking period with the following:
            WaitVertB:
               move.l VPOSR,d0
               and.l  #$0001FF00,d0
               bne    WaitVertB
               rts
----------------------------------------------------------------------------
$DFF018 SERDATR      Serial Data Input and Status Read
Status: *R           Paula
                   0-7 DB0-DB7   Byte of data read from serial port
                     8 DB8/STP   Ninth data bit or stop bit
                     9 STP       Stop bit if set up for 9 data bits
                    10 UNUSED
                    11 RxD       Current status of serial port's RxD line
                    12 TSRE      Transmit shift register empty (if 1)
                    13 TBE       Transmit buffer empty (if 1)
                    14 RBF       Receive buffer is full(if 1)
                    15 OVRUN     Receive buffer overrun (if 1)
----------------------------------------------------------------------------
$DFF01A DSKBYTR      Disk Data Byte and Disk Status Read
Status: *R           Paula
                   0-7 DATA      Byte of data read from disk
                  8-11 UNUSED
                    12 WORDEQUAL Disk Sync pattern found (if 1)
                    13 DISKWRITE Disk controller writing (if 1)
                                 Disk controller reading (if 0)
                    14 DMAOEN    Disk DMA is active (if 1)
                    15 BYTEREADY Bits 0-7 of this register will hold new
                                 data if bit 15 is set.

Notes: Considering the fact that disk data can be transferred to and from
memory automatically through DMA, it is neither necessary nor recommended
that you read data one byte at a time via 0-7, and 15.
   Bit 12: WORDEQUAL holds a one for only 2 usec!  (The time for one MFM bit
to pass under the head.)  AmigaDos uses $4489 for the sync.
----------------------------------------------------------------------------
$DFF01C INTENAR      Interrupt Enable Read
Status: *R           Paula
                     0 TBE    1 = Serial transmit buffer empty interrupt
                                  enabled (level 1)
                     1 DSKBLK 1 = Disk block done int enabled (level 1)
                     2 SOFT   1 = Software interrupts enabled (level 1)
                     3 PORTS  1 = CIA-A and expansion port interrupts
                                  enabled (level 2)
                     4 COPER  1 = Copper interrupt enabled (level 3)
                     5 VERTB  1 = Vertical Blank Int enabled (level 3)
                     6 BLIT   1 = Blitter ready int enabled (level 4)
                     7 AUD0   1 = Audio channel 1 int enabled (level 4)
                     8 AUD1                     2
                     9 AUD2                     3
                    10 AUD3                     4
                    11 DBF    1 = Serial receive buffer full interrupt
                                  enabled (level 5)
                    12 DSKSYN 1 = Disk sync pattern found int enab (lev 5)
                    13 EXTER  1 = CIA-B and expansion port int enab(lev 6)
                    14 INTEN      Master interrupt off switch  (0 = All
                                  ints listed above disabled)
                    15 SETCLR UNUSED by INTENAR

Notes: The Amiga's hardware is capable of generating 14 interrupts on seven
levels.  Level 1-6 are maskable, and level 7 is an NMI.  This register tells
you which ints are enabled or disabled.  To enable or disable an interrupt,
use this register's write address, INTENA ($DFF09A).  To force an interrupt
to take place, use register INTREQ ($DFF09C).  To actually find out what
type of interrupt is taking place, read INTREQR at $DFF01E.
   When the uP receives an interrupt signal, it takes the level number,
multiplies it by two, and adds $FFFFF1 to the result.  This calculation
produces the address of a byte long memory offset contained in ROM.  The
memory offset is then multiplied by four to obtain the address of the
interrupt's auto vector - a location that contains the pointer to the
corresponding interrupt processing routine.  Under the current version of
ROM, these four byte pointers are stored in locations $64, $68, $6C, $70,
$74, $78, and $7C, for the level 1-7 interrupts respectively.
   To prioritize interrupts that share the same level number, Exec has
assigned each interrupt a pseudo priority number.  Again, the higher this
number, the higher the priority:
      Interrupt               680x0 Level    Pseudo-Priority
      ---------                  -----            -----
      Software                     1                1
      Disk Block Done              1                2
      Transmit Buffer Empty        1                3
      CIA-A (exp bus pin 19)       2                1
      Copper                       3                1
      Vertical Blank               3                2
      Blitter Done                 3                3
      Audio Channel 2              4                1
      Audio Channel 0              4                2
      Audio Channel 3              4                3
      Audio Channel 1              4                4
      Read Buffer Full             5                1
      Disk Sync Pattern Found      5                2
      CIA-B (exp bus pin 22)       6                1

   If you plan on handling interrupts completely on your own, note that
interrupt processing routines are always executed in SUPERVISOR mode.  As a
minimum, your routine should clear the corresponding bit in the INTREQ
register to clear that interrupt.  Use the 680x0 instruction RTE to return
from an interrupt.
   To cause a raster interrupt to occur, simply make the copper wait for the
desired line, then store #$8010 in INTREQ:
      wait 0,100         ; wait for line 100
      move #$8010,INTREQ ; trigger interrupt
----------------------------------------------------------------------------
$DFF01E INTREQR      Interrupt Request
Status: *R           Paula
                     The bit by bit explanations are exactly the same
                     except that "enabled" is replaced with "requested".
                     See INTENAR ($DFF01C) for details.
----------------------------------------------------------------------------
$DFF020 DSKPTH       Disk Pointer
$DFF022 DSKPTL
Status: *W           Agnus
                     This is where you store the starting address of your
                     disk data prior to activating disk DMA.  DSKPT is
                     broken into a High and Low portion.  Note that if your
                     Amiga does not have a 1MB Agnus, you cannot specify
                     an address above $7FFFF.  Otherwise, it is $FFFFF.
                     The low bit is always interpreted as zero, so the
                     data must begin at an even location.
----------------------------------------------------------------------------
$DFF024 DSKLEN       Disk Data Length
Status: *W           Paula
                  0-13 LENGTH Number of words to read or write
                    14 WRITE  1 = Activate write mode  0 = read mode
                    15 DMAENA 1 = Enable Disk DMA  0 = Disable Disk DMA

Notes: You must write the same value TWICE in a row in order for the value
to take effect.  This double write rule was incorporated to safeguard
against accidental disk activity - programs that lose control and start
trashing memory can't just shove a number into this register and initiate
potentially harmful disk activity.
   Since the length must be stored in 14 bits, the data cannot be longer
than 32766 bytes.  The DMA hardware uses this length value as a counter.
Every time a word of data is transferred to or from disk, this counter is
decremented, and the address in the DSKPT register incremented.  Transfer
stops when this value reaches zero.
   Because of a bug in the Amiga Hardware, the last three bits of data are
missing.  To remedy this, save one more word than necessary.
   Before and after doing any disk operations, set this register to #$0000
to enable read mode and disable disk DMA.
   Bit 15: Setting this bit initiates disk DMA.  It will not start, however,
until the DMAENA bit in the ADKCON register ($DFF09E) is also set.  You'll
have to set both of these bits in order to perform any DMA-controlled disk
operations.  NEVER start disk DMA unless a previous operation is complete or
you may wind up trashing the data on the disk!  To find out when a read or
write operation is complete, use the disk block done interrupt, which can be
detected through the use of the DSKBLK bit (1) in the INTEQR register at
$DFF01E.
----------------------------------------------------------------------------
$DFF026 DSKDAT       Disk DMA Write
Status: *W           Paula
                     This is the data buffer used by the disk DMA when
                     transferring data.  It is the write address of the
                     DSKDATR register ($DFF008).
----------------------------------------------------------------------------
$DFF028 REFPTR       Refresh Pointer
Status: *W           Agnus
                     The Amiga uses this register as a RAM refresh address
                     register.  Do not modify the value there or you may
                     corrupt the contents of RAM!  It is for diagnostic
                     purposes only.
----------------------------------------------------------------------------
$DFF02A VPOSW        Vertical Beam Position Write
Status: *W           Agnus
                     This is the write address of the VPOSR register
                     located at $DFF004.  Note the warnings that apply for
                     the refresh pointer as they also apply.
----------------------------------------------------------------------------
$DFF02C VHPOSW       Vertical/Horizontal Beam Position Write
Status: *W           Agnus
                     This is the write address of the VHPOSR register
                     located at $DFF006.  Note the warnings that apply for
                     the refresh pointer as they also apply.

----------------------------------------------------------------------------
$DFF02E COPCON       Coprocessor Control
Status: *W           Agnus
                     0 UNUSED
                     1 CDANG  Copper Danger Bit (1 = Copper can access
                              blitter registers  0 = Copper cannot.)
                  2-15 UNUSED

Notes: A one value allows access to $DFF040+, and a zero value $DFF080+.
For instructions on the copper and its instruction set, see locations
$DFF080-$DFF08C.
----------------------------------------------------------------------------
$DFF030 SERDAT       Serial Data Output
Status: *W           Paula
                   0-7 DB0-DB7   Byte of data to be output
                     8 DB8/STP   Ninth data bit or stop bit
                     9 STP       Stop Bit if sending nine data bits
                 10-15 UNUSED    (See below)

Notes: To send data out the serial port, simply store it here.  Upon
receiving a nonzero value, the contents of the register are shifted out the
serial port - low bit first, high bit last until its contents are empty
(equal zero).  Since the start bit is sent automatically, DO NOT include it
as part of your data.  Because you must send at least one stop bit, SERDAT
should never equal zero.
   By convention, only 8 or 9 data bits should be stored in this register at
any on time.  However, because this is a true 16 bit register, up to 15 data
bits and one stop bit can be output in just one shot - an interesting, if
questionably useful feature.
----------------------------------------------------------------------------
$DFF032 SERPER       Serial Period (Transfer Rate) and Data Bit Control
Status: *W           Paula
                  0-14 RATE   Bit transfer rate specified in increments of
                              279.4 nsec.
                    15 LONG   Number of data bits to expect when receiving
                              data (1 = nine  0 = eight data bits)

Notes: The value stored in bits 0-14 determine how many bus cycles occur
between each bit sent or received through the serial port.  So, if one bit
is to be sent every X bus cycles, use X-1.  Serial transfer rates are
usually specified in baud rates, not bus cycles.  Use this formula to
translate the baud rate into the period value this regiester expects:
      Period = (3579546 / Baudrate) - 1
   The period value for the six most common baud rates are:
         Baud Rate   Period
         ---------   ------
            300       11931
            600       5965
           1200       2982
           2400       1490
           4800        745
           9600        372
   Bit 15: Affects incoming, not outgoing data length.
----------------------------------------------------------------------------
$DFF034 POTGO        Pot Port Data
Status: *W           Paula
                     See POTGOR at $DFF016 for an explanation on how this
                     write register works.
----------------------------------------------------------------------------
$DFF036 JOYTEST      JOY0DAT and JOY1DAT Write
Status: *W           Denise
                     This register allows you to set the contents of the
                     JOY0DAT and JOY1DAT registers at $DFF00A / $DFF00C.
                     The value stored here affects both registers,
                     allowing you to reset the mouse position counters for
                     both ports with just one instruction.
----------------------------------------------------------------------------
$DFF038 STREQU       Short Frame Vertical Blank Strobe
$DFF03A STRVBL       Normal Vertical Blank Strobe
$DFF03C STRHOR       Horizontal Sync Strobe
$DFF03E STRLONG      Long Raster Strobe
Status: Strobe       Denise (Denise/Paula on STRHOR)
                     Do not read to or write from any of these registers.
                     Doing so would falsely trigger the strobe and confuse
                     the Amiga.
----------------------------------------------------------------------------
Location Range: $DFF040-$DFF074  The Blitter Registers

   The blitter takes care of almost all of the Amiga's bitmapped graphics
manipulation, from drawing lines to moving objects and filling outlined
areas.  Intuition, for example, uses the blitter for such things as drawing
gadgets and printing text.  And one of the best things about the blitter is
that it executes independently, allowing the Amiga to animate objects while
the uP is hard at work executing program instructions.

   Copy Mode: The blitter's main task is to copy data from one area of
memory to another.  This operation is specified as a blit.  The blitter was
specifically designed to copy bitmap data, however, you can use the blitter
to copy whatever type of data you choose.
   Data to be copied may come from up to three different locations in
memory, but you can have only one destination address.  The blitter refers
to the source addresses as A, B, and C.  The destination area is called D.
   When using more than one source address, the blitter must combine the
data from the different sources before it can be written back out.  To do
this, it performs any combination of eight different logic operations called
miniterms.  Miniterms allow you to combine the bits from A, B, and C in 256
different ways before they reach their destination.  This provides the
programmer with great flexibility when copying bitmapped images.  Shapes can
be inverted, merged, "cookie cut", and so on.  Bits 0-7 in the BLTCON0
register at $DFF040 control the miniterm settings.
   The most common use for the blitter is to move rectangular areas of a
bitmapped screen.  Because of the way screen bitmaps are laid out, it would
be impractical if all you could do was to copy consecutive bytes in memory.
Instead, you must be able to skip several bytes between each horizontal
screen line.  That way, you don't have to copy objects that take up the
entire width of the screen.
   The BLTAMOD-BLTDMOD registers ($DFF060-$DFF066) allow you to specify the
difference between the width of the object being copied and the width of the
bitmap.  The BLTSIZE register at $DFF058 defines width and height of the
source and destination area.  Together these registers allow the blitter to
copy any rectangular area of a bitmap.
   The memory addresses of A, B, and C go in registers BLTAPT, BLTBPT, and
BLTCPT ($DFF050, $DFF04C, and $DFF048) respectively, and the D address goes
in register BLTDPT ($DFF054).  When specifying A, B, C, or D, you must
provide the blitter with an even, word aligned address.
   Because bitmapped objects don't always begin on a word aligned address,
and their width isn't always an even multiple of 16 (16 bits = 1 word), the
blitter can mask out certain bits in the first and last word of each
horizontal line copied from source A.  This way, you can copy an area that
starts at any pixel location and is of any pixel width you desire.  The
first word mask for source A goes in register BLTAFWM ($DFF044).  The last
word mask goes in register BLTALWM ($DFF046).  In effect, the first word of
each line is ANDed with BLTAFWM and the last word of each line is ANDed with
BLTALWM before they are written to destination RAM.
   To move bitmapped images horizontally with pixel accuracy, it is
necessary to shift the image's data one bit at a time.  Using bits 12-15 in
the BLTCON0 and BLTCON1 registers ($DFF040 and $DFF042), you can tell the
blitter to shift source A and/or source B data right 0-15 bits before it's
transferred to it's destination.  The shifting takes place within the
blitter so it does not affect the area of memory actually being copied.
   Shifting is not restricted by word boundaries; a word's low bit is
shifted into the high bit of the following word.  If there is no previous
word of data being copied (i.e. if the current word is the very first word
of data being copied), zeroes are shifted into the word's high bits.
   What happens when you need to shift something left, say a pixel?  Well,
simply shift it right (16-x) times.  The only difference is that your data
is one word further to the right.  Optionaly, you could also run the blitter
in descending mode.  In this mode, data is shifted left by the value stored
in bits 12-15 of the BLTCON0 and BLTCON1 registers.  Here's another reason
for operating the blitter in descending mode:
   The blitter is usually called upon to move objects around the screen.
Generally, a programmer will do this by copying an object's data from a
special buffer area in memory to the screen's bitmap.  (Since the blitter
can only copy to one destination area at a time, you'll have to do a blitter
operation for each bit plane.)  Next, a copy of the screen's background is
copied to the screen to erase the object.  Finally, the object is copied to
a different location on the screen, thus making in move.
   In the previous example, data was copied from two separate areas of
memory.  Sometimes it's desirable to copy to and from areas that overlap.
However, this may cause problems because the blitter may copy a piece of
data into a memory location that hasn't been read yet, thus destroying it.
(i.e. If the destination and source overlap, and the destination is higher
in memory, bye-bye data!)
   To avoid the problem of overlapping data, the blitter can be run in two
modes: ascending and descending.  When should you use descendong mode?
Well, if the end of the source overlaps the start of the destination, use
descending mode.  If the start of the source overlaps the end of the
destination, use ascending mode.  If the source and destination don't
overlap, it doesn't matter what you use.  The DESC bit (1) in the BLTCON1
register at $DFF042 determines the blitter's current mode.
   To initiate a blitter copy operation, you should first select the blitter
copy mode by NOT setting the LINE bit (0) in the BLTCON1 register at
$DFF042.  Second, tell the computer the address of your source data using
the BLTAPT, BLTBPT, BLTCPT, and the destination data at BLTDPT.  (These
addresses should specify the starting or ending addresses of the data
depending on whether the blitter is running in ascending or descending mode,
respectively.)  Third, use BLTCON0 to select the desired miniterms and tell
the computer which sources you're using (A, B, and/or C) and enable the
blitter's D destination channel.  (If you don't enable D, data isn't going
anywhere!)  Fourth, set up any other options you want such as shifting or
masking of data.  Finally, write the width and height of the area to be
copied into the BLTSIZE register at $DFF058.  Writing to BLTSIZE
automatically starts the blitter, so it SHOULD BE THE VERY LAST THING YOU
SET!  During the blitter operation, the BBUSY bit (14) in the DMACONR
register is set equal to one.  When the blitter is finished, this bit is
cleared.
   The following happens during a blitter copy operation: Data is copied one
word at a time from the memory address specified by the BLTxPT registers to
the address found in BLTDPT.  Every time a word is copied, the BLTxPT
registers are incremented (or decremented if in descending mode).  When the
number of words to b copied matches the width in the BLTSIZE register, the
modulation value found in the BLTxMOD registers is added to the BLTxPT
registers and the copying continues on the next line.  When the number of
lines copied equals the height in BLTSIZE, the operation is complete and the
blitter stops.

   Fill Mode: The blitter offers a crude area-fill option that works in
tandem with the data-copy operation described above.  Fill mode is activated
by BLTCON1's IFE (Inclusive Fill Enable) bit or EFE (Exclusive Fill Enable)
bit prior to turning on the blitter.  After the blitter reads data from
memory and manipulates it according to the miniterm settings, the specified
fill operation is performed on the data before it is written to destination
memory.  Fill operations work IN DESCENDING MODE ONLY!  The figure below
illustrates the effect of each type of fill operation has on data:

                           After:
            Before   FCI = 0   FCI = 1

           00011000  00011000  11111111
           00100100  00111100  11100111
           01000010  01111110  11000011
Fill       01000010  01111110  11000011
           00100100  00111100  11100111
           00011000  00011000  11111111

           00011000  00001000  11110111
           00100100  00011100  11100011
Exclusive  01000010  00111110  11000001
Fill       01000010  00111110  11000001
           00100100  00011100  11100011
           00011000  00001000  11110111

   In all fills, the blitter evaluates data one bit at a time, starting at
the rightmost edge and moving to the left.  Before the fill begins, however,
the blitter takes note of the FCI bit (2) of the BLTCON1 register.  The
value of this bit becomes the initial fill value of the blitter's fill bit.
For the sake of clarity, let's assume FCI starts at zero.
   Here's how inclusive fill works: As the blitter moves left, it changes
all zero bits to zero, because zero is the current value of the fill bit.
When the blitter encounters a 1 bit, it toggles the fill bit, changing it to
a one.  Now the blitter changes the following 0 bits to 1, because that is
the current value of the fill bit.  Every time the blitter encounters a 1
bit in the data, the fill bit changes value.  The figure above illustrates
the difference between fills that start with FCI = 0 or FCI = 1.
   Exclusive fills take one extra step when they encounter a 1 bot.  In
addition to toggling the fill bit, the blitter replaces that 1 bit with the
new fill-bit value.
   Both types of fills expect borders to be defined by a single 1 bit - one
bit to tell the blitter that it's inside an area, and the other to tell it
that it's outside.  When the blitter encounters two one bits in a row, it
assumes that there is no space to be filled since there is no zero bit
between pixels.  If the blitter encounters three 1 bits in a row, the
blitter assumes that it has gone in, out, then back in to an area to be
filled.  (The fill bit has been toggled three times.)  This happens when the
blitter runs across an odd number of adjacent bits.
   To execute a fill operation, simply set up the blitter registers for a
standard copy operation, set either the IFE or EFE bit, set the FCI bit to
the desired value, set the DESC to put the blitter in descending mode, then
start the blitter by writing the area size to the BLTSIZE register.  By
setting the blitter's source address equal to the destination address, you
can fill an area without having to copy data from one separate location to
another.

   Line Mode: Besides copying data and filling areas, the blitter has one
more talent: drawing lines.  In line mode, almost all of the blitter
registers change their functions.
   The blitter draws lines at incredible speeds, much faster than the 68000.
Unfortunately, you can't just give the blitter two points and then tell it
to connect the dots.  You need to perform some calculations first.
   Let's say that you want to draw a line from point (x1,y1) to (x2,y2).
From these coordinates you need to figure out the horizontal and vertical
distance between the line's two end points.  This is easily calculated using
the following two formulae:
      dx = abs(x1-x2)
      dy = abs(y1-y2)
   Now you're ready to give the BLTCON1 register at $DFF042 some information
about the physical orientation of the line.
      If (dx >= dy) and (x1 >= x2) set bit 2.
      If (dx < dy)  and (y1 >= y2) set bit 2.
      If (dx >= dy) and (y1 >= y2) set bit 3.
      If (dx < dy)  and (x1 >= x2) set bit 3.
      If (dx >=dy)                 set bit 4.
   Together, these bits define the octant (position relative to the line's
starting position) in which the line will appear.  The following shows how
the Amiga divides the screen into octants:

             \    |    /      * = x1,y1
              \ 3 | 1 /       Note: The numbers shown in this figure
             7 \  |  / 6      represent the combined value of BLTCON1's
                \ | /         bits 2-4.  If the line appears on the border
             -----*-----      of two octants, it does not matter which of
                / | \         the two octants you select.
             5 /  |  \ 4
              / 2 | 0 \
             /    |    \

   Next, you need to determine which value is larger: dx or dy.  Let dmax
equal the greater value, and dmin the lesser value.  Now use these values to
set the following registers:
      dmax = max(dx,dy)
      dmin = min(dx,dy)
         BLTBMOD = 4* dmin
         BLTAMOD = 4 * (dmax-dmin)
         BLTAPTL = (4 * dmin) - (2 * dmax)
   These formulae define the line's slope.  If the result of the last
calculation BLTAPTL is negative, you must store a 1 in the SIGN bit (6) of
the BLTCON1 register.
   Besides holding the line's octant number and the negative/positive status
of the line's slope, BLTCON1 affects the line's physical appearance.  If
you're drawing lines to enclose an area that you plan to fill later using
blitter fill mode, you should set the ONEDOT bit (1) equal to one.  This
tells the blitter to draw lines using only one pixel per raster, thus
providing a single pixel border for your object.
   To create textured lines, BLTCON1's bits 12-15 work in conjunction with
the BLTBDAT register ($DFF072).  The bit pattern found in BLTBDAT defines
the pixel pattern used to draw lines.  For normal solid lines, set all of
BLTBDAT's bits to one.  (i.e. $FFFF)  Other values create dotted or dashed
lines.  Bits 12-15 in BLTCON1 allow you to specify which bit in BLTBDAT,
0-15, defines the status of the first pixel in the line.  For most practical
purposes, BLTCON1's bits 12-15 should be set equal to the value of x1's
lower 4 bits.  (i.e. x1 AND $0F)  This informs the blitter to start the line
off with the value found in BLTBDAT's MSB (15).  IMPORTANT: ALWAYS SET
BLTCON1 PRIOR TO BLTBDAT!
   BLTCON1's bit 5 should always be set to zero, as should bits 7 through
11.  To tell the blitter that you want to draw lines instead of copy data,
the LINE bit (0) must be set to 1.
   The Amiga needs certain information about the size and location of the
screen's bitmap before it can draw a line.  First, store the byte-width
(number of pixels divided by 8) of the bitmap in the BLTCMOD and BLTDMOD
registers ($DFF060 and $DFF066).  Next, you must put the address of the word
containing the starting point of the line into the BLTCPT and BLTDPT
registers.  ($DFF048 and $DFF054)
   Only one bitplane can be written to during a single blitter operation.
So, to draw a line of a particular color on a multiple bitplane screen, it
may be necessary to perform two or more line blits.  In these cases, you set
the registers up for the first bitplane as usual, and perform the blit; then
for subsequent bitplanes, you simply reinitialize the registers with the
same values EXCEPT for the registers BLTCPT and BLTDPT, which must contain
the address of the line's starting point within the new bitplane.
   As with blitter copy mode, you must set bits 0-7 in the BLTCON0 register
($DFF040) to choose a miniterm.  Usually, you should store $CA here, but if
you prefer to XOR your line onto the screen (invert all the pixels found on
the line), store a $4A here.
   BLTCON0's bits 8-11 should be set equal to $B.  (This activates blitter
source A and C, and destination D.)  Store x1's lower four bits (x1 AND $0F)
into BLTCON0's bits 12-15.  The blitter uses this value to determine the bit
position of the line's starting point within the bitplane memory location
specified by registers BLTCPT and BLTDPT.
   Now, set BLTADAT ($DFF074) equal to $8000.  (Set this register only AFTER
you've set BLTCON0)  Only two more registers must be set before you can
activate the blitter: BLTAFWM and BLTALWM.  ($DFF044 and $DFF046)  Store a
$FFFF into both.
   Finally, you're ready to start the blitter by writing to the BLTSIZE
register ($DFF058).  Use the following formula to determine the value that
you should store into this register:
      BLTSIZE = (dmax * 64) + 66
   Because writing to BLTSIZE turns on the blitter, this should be the last
register that you set.

   General Guidelines: When programming the blitter at the hardware level
with multitasking turned on, you must be sure to grab the blitter for your
own exclusive use so other programs don't try to use it.  Using the library
function call OwnBlitter() you can reserve the blitter for your own
personal use.  The function call DisownBlitter() frees the blitter so other
programs can use it.
   Before writing to any of the blitter registers, you must be sure the
blitter isn't currently in operation, even after a call to OwnBlitter().  To
ensure the blitter's dormancy, you can use the function call WaitBlit(), or
you can read the status of the BBUSY bit found in the DMACONR register at
$DFF002.
   Under normal operation conditions, the Amiga's microprocessor has
priority over the blitter when it comes to accessing chip RAM.  Because of
the way memory cycles are allocated, memory conflicts rarely occur between
the blitter and the 68000.  However, if time is a critical factor, you can
give the blitter a higher priority than the 68000 by setting the BLTPRI bit
in the DMACON register ($DFF096).
   The blitter can perform so many special operations on a word of data that
it's important to know the order in which these operations take place.
Masking via the BLTAFWM and BLTALWM register takes effect first (assuming
the data was obtained from A and is either the first or last word of a
horizontal line.); next the data is shifter, if a shift was specified my the
source's shift bits (ASHx or BSHx); the miniterm operations are performed
next; and finally, the data is filled according to the status of BLTCON1's
EFE, IFE, and FCI bits.  Only after all this does the data reach its
destination.
   As a general rule, you should always write zeroes to any unused bits in
a blitter register.  On future versions of the Amiga blitter, these bits may
be used to perform new functions - functions that could freak your program
if mistakingly activated!
   In the following register explanations, a lowercase letter (i.e.: a, b,
c) will be used to specify a normal miniterm descriptor, and a capital
letter it's NOTted equivalent.  (i.e. A, B, C = NOT a, NOT b, NOT c)  This
is for the miniterm descriptors only!
----------------------------------------------------------------------------
$DFF040 BLTCON0      Blitter Control Register 0
Status: *W           Agnus
                     0 LF0    1 = Selects miniterm ABC
                     1 LF1    1 = Selects miniterm ABc
                     2 LF2    1 = Selects miniterm AbC
                     3 LF3    1 = Selects miniterm Abc
                     4 LF4    1 = Selects miniterm aBC
                     5 LF5    1 = Selects miniterm aBc
                     6 LF6    1 = Selects miniterm abC
                     7 LF7    1 = Selects miniterm abc
                     8 USED   1 = Enable DMA for D
                     9 USEC   1 = Enable DMA for C
                    10 USEB   1 = Enable DMA for B
                    11 USEA   1 = Enable DMA for A
                 12-15 ASH0-3 Preshift value for A
                     For Line Mode:
                   0-7 LF0-LF7   Miniterm value, usually $CA
                     8 USED      Set to 1
                     9 USEC      Set to 1
                    10 USEB      Set to 0
                    11 USEA      Set to 1
                 12-15 START0-3  Set to (x1 and #$0F)

   Here's how BLTCON0's bits operate in normal copy mode:
   Bits 0-7: Each of these bits controls a particular miniterm - a logical
operation performed on blitter source data before it reaches its
destination.  To activate a miniterm, simply set its bit equal to one.  You
may select as many or as few as you want.
   Using miniterms, you can slice and dice data in a variety of ways.
Suppose you set bit zero equal to one.  In this case, the miniterm is ABC.
What that means is that a one bit will be output to D only when:
      A=0, B=0, and C=0!  Any other combination results in a zero output.
Conversely, miniterm abc will output a one only when A, B, and C are equal
to one.
   For more complex results, it's possible to activate more than one
miniterm at once.  The resulting miniterms are added together (OR'ed) and
simplified.  Thus:  aBC + aBc can be simplified to aB.  (If the values are
different as in the case of the C's, they cancel out.)  You may expand aB in
the same way to aBC + aBc.
   To fill an area of memory with zeroes, don't select any miniterms.
Consequently, you can fill memory with #$FF's by selecting all of the
miniterms.  The following table contains the miniterm settings avaliable to
graphics.library function calls:
      Miniterm Val   Miniterm Logic    Result of Most Useful Settings
      ------------   --------------    ------------------------------
          #$00       always zero       Clear Destination
          #$10       aBC
          #$20       aBc
          #$30       aB                Copy inverted source to destination
          #$40       abC
          #$50       aC                Invert Destination
          #$60       aBc + abC         Merge (cookie cut) source with dest.
          #$70       aB + aC
          #$80       ABC               Write 1s only where source & dest
                                       overlap
          #$90       abc + aBC
          #$A0       ac
          #$B0       ac + aB
          #$C0       ab                Direct copy of source to destination
          #$D0       ab + aC
          #$E0       ac + ab           Combine (mix) source with destination
          #$F0       always one        Fill Destination

Note: Even if you try to set the lower four bits of a graphics.library
miniterm, the system will zero them out before actually writing this value
to the register's LFx bits.
      If you set the blitter's sources the same way that the
graphics.library does - A points to a mask (usually $FFFF), B points to the
source data, and C points to the Destination data - you can use this table
to determine the miniterm settings for your own blitter routines.
   When blitting with only one or two sources active, choose miniterms that
aren't affected by the value of the unused source(s).

   Bit 8: This bit determines whether the blitter's destination DMA is
enabled.  Seting this bit to one enabled the DMA, and 0 Disables it.  If
destination DMA is disabled, nothing can be written during a blit.  This
seemingly useless feature turns out to be quite useful feature for detecting
collisions between two images.  Simply set up the blitter for sources A and
B to point to the two images, select miniterm logic ab ($C0), activate the
blitter, wait for the blitter to finish, and then check the BZERO bit (13)
of the DMACON register at $DFF002.  If BZERO = 0, the images touch.  Because
the BZERO bit is valid even if the data isn't written to memory, you don't
need to activate destination D for this type of collision detection to work.

   Bits 9-10: These bits determine which of the blitter's sources: A, B,
and/or C are active during a blitter operation.  Writing a one to any of
these bits turns on the DMA for the corresponding source.  When the blitter
is turned on, data is read from the memory specified by the active source's
BLTxDAT register.  For this reason, it is important to PREINITIALIZE the
BLTxDAT register of all unused sources before performing a blit.  If you
don't want inactive sources to affect the results of a blit, choose
miniterms that ignore the values of such sources.

   Bits 12-15: Prior to applying the value of source A to the selected
miniterm operation, the blitter shifts the value the number of times
specified in these bits.  (If the blitter is in ascending mode, the data is
shifted right, otherwise, it is shifted left.)  Obviously, shifting does not
occur if all of these bits are set to zero.
   Whenever you tell the blitter to shift the data in source A, you must
store a modulo value that's one less than normal in the BLTAMOD and BLTDMOD
registers.

   Line Mode - Here's how the register functions in line mode:
   Bits 0-7: These bits control the miniterm setting used to combine the
line's bits (obtained from A) with the bits in the destination bitplane
(obtained from source C).  Source B is used as a mask for generating
patterned lines.  For normal lines, use a miniterm setting of #$CA.  To draw
a line of inverted pixels, use miniterm value #$4A.
   Bits 8-11: The blitter draws lines using source A as a point generator, B
as the static mask, and C for reading the current status of the destination
bitplane, and D for outputting the pixels.  Because we don't want the mask
in source B to change, source B's DMA should be inactive.  All of the
blitter's other channels must be active however.  As a result, you should
always set these bits equal to #$B when using the blitter to draw lines.
   Bits 12-15: These bits must equal the lower four bits of horizontal
coordinate x1.  Although these are referred to as the START bits in line
mode, their contents still specify a shift value, as they do in copy mode.
Here's how it works: In line mode, you must initialize source A's data
register (BLTADAT) with a $8000.  This puts a 1 bit in the leftmost position
in the word.  The value stored in these START bits specifies how far that
data is to be shifted to the right.  By shifting that bit right by the value
found in x1's lower 4 bits, you move the bit into the pixel position of the
line's starting point.

   Now the cheat: Here's a quick and easy formula for calculating the value
that you must store in BLTCON0 when drawing lines:
      3018 + ((x1 and #$0F) * 4096)

   This specifies the miniterm value for a normal line and provides the
blitter with the bit position of x1 within the memory location found in
registers BLTCPT and BLTDPT.  ($DFF048 and $DFF054)  To XOR a line onto the
screen (invert any of the bits located within the line), subtract 128 from
the result of the above calculation.
----------------------------------------------------------------------------
$DFF042 BLTCON1      Blitter Control Register 1
Status: *W           Agnus
                     For Blitter Moves and Fills:
                     0 LINE   1 = activate line draw mode, 0 = normal copy
                     1 DESC   1 = descending operation, 1 = ascending op.
                     2 FCI    Starting bit for fill mode
                     3 IFE    Enables inclusive fill mode
                     4 EFE    Enables exclusive fill mode
                  5-11 UNUSED Always set to zero.
                 12-15 BSH0-3 Preshift value for source B

                     For Line Mode:
                     0 LINE   Set to one
                     1 ONEDOT 1 = Draw lines with only a single pixel per
                                  raster
                     2 AUL    Set if ((dx>=dy)and(x1>=x2) or
                                     ((dx<dy) and(y1>=y2))
                     3 SUD    Set if ((dx>=dy)and(y1>=y2) or
                                     ((dx<dy) and(x1>=x2))
                     4 SUL    Set if dx>=dy
                     5 UNUSED Always set to zero
                     6 SIGN   Set if (4*dmin)<(2*dmax)
                  7-11 UNUSED Always set to zero
                 12-15 TEXTURE0-3 Set to (x1 and #$0F)

   Here's how BLTCON1's bits operate in normal copy mode:
   Bit 0: This bit activates line mode.  It must be set to zero for copy
operations.
   Bit 1: Storing a one here puts the blitter in descending mode.  Do that
whenever your source and destination overlap and the destination data has a
higher address than the source.  You should also use descending mode if you
plan on shifting data left.  You MUST use descending mode for a blitter fill
operation.  When descending mode is active, the BLTAPT, BLTBPT, and BLTCPT
registers ($DFF050, $DFF04C, and $DFF048) must point to the last word in the
memory area to be written to.  Normally, in ascending mode, these registers
point to the start of the memory area.
   Bit 2: The value of this bit determines the initial fill value used by
the blitter in fill mode.  Fill mode is activated by setting either of the
following two bits.
   Bit 3: Activates inclusive fill mode (See above)
   Bit 4: Activates exclusive fill mode (See above)  For normal copy
operations, both this bit and bit 3 should be set to zero.  Fills are
performed on data only after it has been run through the selected miniterm.
   Bits 12-15: Prior to applying the value of source B to the selected
miniterm operation, the blitter shifts the value the number of times
specified in these bits.  (If the blitter's in ascending mode, data's shifted
right.  If the blitter is in descending mode, the data is shifted left.)
Shifting does not occur if you write a zero to these bits.
   Whenever you tell the blitter to shift the data in source B, you must
store a modulo value that is one less than normal in the BLTBMOD and BLTDMOD
registers.

   Line Mode: To activate line mode, set bit zero of this register equal to
one.  Setting the ONEDOT bit (1) tells the blitter to draw lines that have
only one pixel on each horizontal row.  For clear, clean lines, you should
set this bit equal to zero.  But if you are drawing objects that you plan to
fill later using the blitter fill operation, this bit should be set to one.
This way, the area to be filled in will be enclosed by single pixel walls,
just as the blitter expects them to be.  Bit 5, and bits 7-11 should be set
to zero.  The value of the remaining bits depends on the line's coordinates.
   You might be interested to know that this register's TEXTURE bits are
actually used as a shift value, as they are in blitter copy mode.  You see,
blitter source B is used as a mask for creating textured lines.  Because a
line may start at any pixel position, it is necessary to shift the mask
found in BLTBDAT to align its high bit with the line's starting point.  As
with bits 12-15 in the BLTCON0 register, the shift value for source B is
calculated from the lower four bits of x1.
----------------------------------------------------------------------------
$DFF044 BLTAFWM      Source A First Word Mask
Status: *W           Agnus
   This register allows you to mask out the bits found on the left edge of
the bitplane area specified for blitter source A.  The first word of each
horizontal line is ANDed with the value stored in this register before it is
shifted, applied to the miniterm, and copied to memory.  For example, to
ensure that the two leftmost pixels of an area are always set to zero, store
a $3FFF in this register.  In descending mode, this and the following
register swap functions.
   Line Mode: In line mode, you should always store a $FFFF here.
Otherwise, your line may appear broken.
----------------------------------------------------------------------------
$DFF046 BLTALWM      Source A Last Word Mask
Status: *W           Agnus
   This register allows you to mask out the bits found on the right edge of
the bitplane area specified for blitter source A.  The last word of each
horizontal line is ANDed with the value stored in this register before it is
shifted, applied to the miniterm, and copied to memory.  For example, to
ensure that the two rightmost pixels of an are are always set to zero, store
a $FFFC in this register.  In descending mode, this and the previous
register swap functions.
   Line mode: In line mode, you should always store a $FFFF here.
Otherwise, your line may appear broken.
----------------------------------------------------------------------------
$DFF048 BLTCPTH      Blitter Source C Pointer
$DFF04A BLTCPTL
Status: *W           Agnus
   This is where you store the address of source C's bitmap data prior to
activating the blitter.  If you're blitting in ascending order, this address
should specify the starting address of your data.  If you're blitting in
descending order, this address should specify the ending address of your
data - the address of the last word of data.
   The low bit of this 32 bit register is always interpreted as zero, so
blitter bitmap data must begin on an even word boundary address.  (Using
BLTxFWM and BLTxLWM mask registers, however, you can specify bitmapped areas
with pixel accuracy.)  And, unless your Amiga has a 1MB Agnus, your data
cannot be located above $7FFF.  (1MB Agnus, use $FFFFF)
   Line mode: This register, as well as the BLTDPT register ($DFF054), must
contain the starting address of the line to be drawn.  (i.e. the address of
the word that contains the first point of the line.)  Using standard (x1,y1)
coordinates where (0,0) is the upper left corner of the bitplane, you can
calculate this address using the following formula:
   Address = Bitplane + (y1 * BytesPerLine) + (2 * (x1/16))
where Bitplane is the starting address of the destination bitplane and Bytes
Per Line is the width of the bitplane in bytes (number of pixels divided by
eight).  So, to draw a line in a 320 x 200 pixel bitplane found in memory at
16384 starting at coordinate (10,20), you would store a 17185 into this
register because 16384+(20*(320/8))+(2*(10/16)) equals 17185.
----------------------------------------------------------------------------
$DFF04C BLTBPTH      Blitter Source B Pointer
$DFF04E BLTBPTL
Status: *W           Agnus
   This is where you store the source B's bitmap data prior to activating
the blitter.  See register BLTCPT ($DFF048) for details.
   Line Mode: This register is not used in blitter line mode.
----------------------------------------------------------------------------
$DFF050 BLTAPTH      Blitter Source A Pointer
$DFF052 BLTAPTL
Status: *W           Agnus
   This is where you store the address of source A's bitmap data prior to
activating the blitter.  See register BLTCPT ($DFF048) for details.
   Line Mode: Only the low word of this register, BLTAPTL, us used in line
mode.  Its value determines the slope of the line.  Use the following
formula to calculate the value of this register:
      BLTAPTL = (4 * dmin) - (2 * dmax)
where dmin equals min(abs(x1-x2),abs(y1-y2)) and dmax equals
max(abs(x1-x2),abs(y1-y2)).  If this formula produces a negative number, you
must write a 1 to the SIGN bit (6) of the BLTCON1 register at $DFF042.
----------------------------------------------------------------------------
$DFF054 BLTDPTH      Blitter Destination Pointer
$DFF056 BLTDPTL
Status: *W           Agnus
   This is where you store the address of the chip RAM you're blitting into
(usually, this is a location within a bitmap).  If you're blitting in
ascending order, this address should reflect the starting address of your
data.  If you're blitting in descending order, it should reflect the ending
address of the destination data.  This register has the same limitations as
the BLTAPT-BLTCPT registers.  See location $DFF048 for details.
   Line Draw Mode: This register, as well as the BLTCPT register at $DFF048
must contain the starting address of the line to be drawn - that is, the
address of the word that contains the first point in the line.  See $DFF048
for more information.
----------------------------------------------------------------------------
$DFF058 BLTSIZE      Blitter Start and Size
Status: *W           Agnus
                     For Blitter Moves and Fills:
                   0-5 W0-W5  Width of destination area in words
                  6-15 H0-H9  Height of destination area in pixels

                     For Line Mode:
                     0        Set to 0
                     1        Set to 1
                   2-5        Set to 0
                  6-15        Set to (dmax+1)

   The value stored in this register tells the blitter how large your
destination area is.  The lower six bits specify the width of this area in
words - pixels divided by 16.  If these bits are set to zero, the blitter
assumes a width of 64 words, or 1024 pixels.  The height of the area in
pixels goes into the upper nine bits.  A 0 specifies a height of 1024
pixels.  You can use the following formula to calculate the value of this
register:
      BLTSIZE = (Height * 64) + (Pixelwidth / 16)
   The maximum width or height is 1024 pixels.  The minimum width is 16
pixels and the minimum height is one pixel.
   Writing to this register activates the blitter.  As a result, it should
be the last blitter register that you write to.
   If you are shifting source A or source B data, you must specify a
horizontal width that is one greater than normal.

   Line Mode: In line mode, the lower six bits must hold the value 2 while
the upper 9 bits must hold the value of dmax + 1.  Use the following formula
to determine the value that you should store in this register:
      BLTSIZE = (dmax * 64) + 66
where dmax equals max(abs(x1-x2),abs(y1-y2)).
   Because writing to BLTSIZE turns on the blitter, it should be the last
register that you set.
----------------------------------------------------------------------------
$DFF05A - $DFF05E    Currently Unused
----------------------------------------------------------------------------
$DFF060 BLTCMOD      Blitter Source C Modulo
Status: *W           Agnus
   Whenever the blitter finishes writing data to the last word in a
horizontal line, the contents of this register are added to the BLTCPT
register so that it points to the start of the next line.  This allows the
blitter to copy areas within a bitmap that are smaller than the width of the
bitmap itself.  If you're copying an area that is the same width of the
bitplane it is contained in or if you're copying consecutive bytes in
memory, simply write a zero to this register.  Otherwise, this register
should contain the difference between the byte width of the bitplane
containing the area to be copied and the byte width of the area.  Here's a
formula for determining the value that should be stored in this register:
      BLTCMOD = (BitMapWidth / 8) - (2 * (AreaWidth / 16))
where BitMapWidth and AreaWidth are the pixel widths of the source bitmap
and the area to be copied respectively.  Note that this register specifies
width in bytes whereas the BLTSIZE register specifies width in words.  Also,
although this register reflects the bitmap's width in bytes, its low bit is
ignored, so the value here must specify an even number of bytes.
   With a separate BLTxMOD register for each source, it's possible to
combine the data from three bitmaps of different widths.

   Line Mode: For drawing lines, store the byte width (pixel width divided
by 8) of your bitmap in this register.
----------------------------------------------------------------------------
$DFF062 BLTBMOD      Blitter Source B Modulo
Status: *W           Agnus
   Copy Mode: See BLTCMOD above.

   Line Mode: This register should contain the value 4 * dmin, where dmin
equals min(abs(x1-x2),abs(y1-y2)).
----------------------------------------------------------------------------
$DFF064 BLTAMOD      Blitter Source A Modulo
Status: *W           Agnus
   Copy mode: See BLTCMOD above.

   Line Mode: This register should contain the value 4 * (dmin - dmax) with
dmin and dmax defined as above.
----------------------------------------------------------------------------
$DFF066 BLTDMOD      Blitter Destination Modulo
Status: *W           Agnus
   Copy mode: See BLTCMOD above.

   Line Mode: For drawing lines, store the byte width (pixel width divided
by 8) of your bitmap in this register.  This is the same value you must
store in the BLTCMOD register.
----------------------------------------------------------------------------
$DFF068 - $DFF06E    Currently Unused
----------------------------------------------------------------------------
$DFF070 BLTCDAT      Blitter C Source Data
Status: *W           Agnus
   The blitter uses this register as the data register for blitter source C

   Line Mode: This register is not used in line mode.

   Blitter Data Register Notes: The blitter uses these registers as a
temporary holding place for data that is read from memory.  If a source's
DMA is enabled for a blitter operation, words are read from memory and then
stored in the corresponding BLTxDAT register.  Here the data is manipulated
according to the mask registers, the shift bits, the miniterm operation, and
then it is written to destination RAM.
   If a source's DMA is disabled, the data is not read from memory, but the
value found in the source's data register is still used to form the
blitter's output.  For this reason, it's a good idea to initialize the data
register of an unused source prior to starting the blitter.
   You can use the data registers to fill an area of memory with any word
long value.  Simply set up the blitter so that none of the data registers
have DMA enabled, select a miniterm of A, write the desired value into the
BLTADAT register, set up the remaining registers as usual, and activate the
blitter.
   If you plan to shift source A or B during a blitter operation, you must
be sure to initialize the shift bits prior to writing to the source's data
register.  Otherwise, the number written to this register will be shifteed
according to the old shift value.
----------------------------------------------------------------------------
$DFF072 BLTBDAT      Blitter Source B Data
Status: *W           Agnus
   This is the data register for blitter source B.

   Line Mode: Store the bit pattern with which you wish you5r line to be
drawn in this register.  For normal solid lines, store a $FFFF here.  Other
values produce dotter or dashed lines.
----------------------------------------------------------------------------
$DFF074 BLTADAT      Blitter Source A Data
Status: *W           Agnus
   This is the data register for blitter source A.

   Line Mode: This register should be initialized with the value of $8000
for line mode.
----------------------------------------------------------------------------
$DFF076 - $DFF07C    Currently Unused
----------------------------------------------------------------------------
$DFF07E DSKSYNC      Disk Sync Pattern
Status: *W           Paula
   Before reading data from a disk, it's often necessary to sync the
drive's heads on a particular bit pattern.  This register allows you to do
just that.
   When the WORDSYNC bit (10) in the ADKCON register ($DFF09E) is set, the
disk controller's DMA is enabled and the controller prepares to search the
disk for the sync pattern found in this register.  The disk controller
doesn't start searching until this register is written to.  When the sync
pattern is found, it is set to one for two or four usec (Depending on the
format selected: MFM or GCR) as soon as the sync pattern is located.
This event can also be used to trigger a level 6 interrupt.
   In MFM format (the disk format used by AmigaDos), the sync pattern should
be a value that is impossible to create using MFM data coding.  This way, it
can't be confused with actual data.  AmigaDos uses the number $4489 as its
sync pattern.  Here's how you might initiate the search for this value using
machine language:

   ADKCON equ $DFF09E
  DSKSYNC equ $DFF07E
   move.w #$8400,ADKCON
   move.w #$4489,DSKSYNC

   For more information on low-level disk access, see the CIA-B's PRB
register at $BFD100.
----------------------------------------------------------------------------
Copper Registers:

   The copper is designed to free the 680x0 from display tasks.  It has
three instructions: WAIT, MOVE, and SKIP.  It doesn't seem like you can do
much with only three instructions, but by using a variety of tricks and
subterfuges, a copper list can perform loops, take over the blitter, and
even generate an interrupt for the 68000.

   WAIT.  Wait mimics a loop structure which waits for a certain condition
to occur.  Specifically, Wait waits for the x,y coordinates of the raster to
meet or exceed the coordinates you specify.  Thus, wait allows you to
synchronize actions with the video.  (i.e.: Color changes, raster
interrupts, etc.)  Since a typical copper list executes every time the
screen is drawn, the color change will be rock steady.
   The x,y coordinates are not simple pixel coordinates, but beam position
coordinates.  See the descriptions of VPOSR ($DFF004), VHPOSR ($DF006),
VPOSW ($DFF02a), and VHPOSW ($DFF02C).
   Here is what a Wait instruction looks like:
    0  Always set to 0
  1-7  horizontal compare enable bits
 8-14  vertical compare enable bits
   15  the blitter finished disable bit (usually 1)
   16  Always set to 1
17-23  horizontal beam position
24-31  vertical beam position

   Bits 1-7 describe which bits of the horizontal beam counter will be
compared with an x position for which you choose to wait.  Normally, you
should set all of these bits to one.
   Bits 8-14 describe the same for the y position.
   Bit 15 should normally be set to one.  If you set it to zero, the copper
Wait instruction will wait until the beam position meets or exceeds the
given position and the blitter has finished its operation.
   Bits 17-23 indicate the horizontal beam position for which the wait is
waiting.  Note that bits 1-7 are used to decide which bits are actually used
for the comparison.
   Bits 24-31 indicate the same for the vertical - uses 8-14.

   Because the horizontal beam position is maintained to a resolution of two
low resolution pixels, and because the LSB of that position is not used in
wait comparison, WAIT has a resolution of four lo-res or 8 hi-res pixels.
   One potential problem with wait is that you cannot directly wait for a
line greater than 255.  To do this, wait for 255.  Then, wait for line
number x-255.
   A version of the wait command is used to end copper lists.  The command
code is $FFFFFFFE.  (i.e. wait for y=255, x=254)  The loop seems to be
infinite, and in fact is, however note that the copper list is reset DURING
EVERY VERTICAL BLANKING PERIOD!

   MOVE.  The Move instruction transfers data to a hardware register.  The
instruction can store data into any register with an address of $80 or more.
 Note that the register base of $DFF000 is implicit - it is not included in
the instruction.  If the copper danger bit, CDANG is set ($DFF02E bit 1),
the instruction can store data into any register with an address of $40 or
more.  Unless you need the copper to write to the blitter registers, you
should keep CDANG set to zero.
   With the Move instruction, you can set up bitplane pointers, sprite
pointers, color registers, and so on.  A complete, useful copper list will
have MANY move instructions because there are several DMA registers that
have to be reset every frame.  For example, the bitplane registers must be
reset to keep them from continuing where they left off.  Otherwise, you'd
see all of chip RAM rushing through the screen at great speed.
   Keep in mind that Move is not instantaneous.  Two Move instructions will
be separated by four low resolution pixels.
   Here is the format for the Move command:
 0-15 Data
   16 Set to Zero
17-24 Register address
25-31 Unused - set to zero

   Bits 0-15 are a word of data that you wish to transfer to the hardware
register.  If you want to transfer a long word, you must use 2 move
instructions.
   Bits 17-24 specify the offset from $DFF000 which you would like to
modify.  The CDANG bit of the COPCON register determines which values are
considered legal by the copper.

   SKIP.  Most copper lists are composed only of WAIT and MOVE instructions.
The Skip command allows for conditional branching.  It is a command that has
quite a bit of potential that has rarely been tapped.
   Skip is a close relative of WAIT.  As is the case with Wait, Skip decides
what to do based on the position of the video beam.  Instead of waiting for
a beam position though, it alters copper list program flow based on the beam
position.
   The Skip instruction looks like this:
    0 Set to 1
  1-7 horizontal compare enable bits
 8-14 vertical compare enable bits
   15 blitter-finished-disable bit
   16 set to 1
17-23 horizontal beam position
24-31 vertical position

   The Skip command skips the instruction that immediately follows it if the
beam counter meets or exceeds the value you specify.  The instruction that
follows skip is typically a strobe to the COPJMP1 or COPJMP2 registers.
Writing to these registers causes a jump to the address in the COP1LC or
COP2LC registers, respectively.

----------------------------------------------------------------------------
$DFF080 COP1LCH      Copper Program Counter 1
$DFF082 COP1LCL
$DFF084 COP2LCH      Copper Program Counter 2
$DFF086 COP2LCL
Status: *W           Agnus
   The above registers are the copper location registers.  COP1LC is the
default copper PC.  Either of the above are loaded when the COPJMP registers
are strobed.
----------------------------------------------------------------------------
$DFF088 COPJMP1      Copper Jump Strobes
$DFF08A COPJMP2
Status: Strobe       Agnus
   These locations, when written to, cause the respective copper PC (1 or 2)
to be loaded into the copper program counter.  The operation system strobes
COPJMP1 during a vertical blank interrupt.
----------------------------------------------------------------------------
$DFF08C COPINS       Copper Instruction Identity
Status: *W           Agnus
   This location is of questionable use to the programmer.  It is written to
by the hardware and is used to identify the current copper instruction.
----------------------------------------------------------------------------
Location Range: $DFF08E - $DFF094   Position of the screen display
   These four registers define the position of the Amiga's screen.  DIWSTRT
(Display Window Start) defines the screen's upper left corner while DIWSTOP
(Display Window Stop) defines the window's lower right corner.  Anything
outside of this area is considered border area.
   Before explaining how the next two registers, DDFSTRT and DDFSTOP, affect
the display, a brief explanation of bitplane DMA is in order.  Bitplane data
describes what to draw, but it's the responsibility of bitplane DMA to grab
that data from chip RAM and give it to the video hardware via registers
BPL1DAT - BPL6DAT ($DFF110 - $DFF11A).  Shortly after the video hardware
receives new data, it draws that data at the cirrent video beam position.
So where graphics appear onscreen is determined by when bitplane DMA gives
the video hardware its information.  (Anytime bitplane DMA is inactive and
the BPLxDAT registers are empty, the Amiga displays the color specified by
the COLOR00 register.)
   Vertically, bitplane DMA starts the moment it reaches the Y coordinate
found in DIWSTOP.  Horizontal start and stop locations are a bit more
complicated, however, as the computer needs some more time before it can
display fetched data.  On a lo-res display, it takes 8.5 color clocks.  (A
color clock is equal to one memory access cycle, ehich is approximately 280
nsec in duration.  The Amiga can output two lo-res pixels per color clock.)
   Each horizontal line on the computer screen can be thought of as a time
line.  Where along this line bitplane DMA is allowed to start is determined
by the DDFSTRT (Display Data Fetch Start) register.  The DDFSTOP (Display
Data Fetch Stop) register tells the Amiga when the bitplane DMA should stop.
 As you can imagine, unless these registers correspond with the horizontal
coordinates found in the DIW registers, your display will appear cropped
and/or garbled.
   Finding the proper value for the DDFSTRT based on the horizontal
coordinate found in DIWSTRT is easy.  Because the DIWSTRT register specifies
coordinates in lo-res pixels, and the DDFSTRT register is accurate to only
two lo-res pixels, you must first divide DIWSTRT's horizontal coordinate by
two; then, simply subtract the number of color clocks that you need - 4.5
for hi-res, and 8,5 for lo-res.  Here oare the formulae you should use to
calculate the correct value for the DDFSTRT register:
      DDFSTRT = HSTART / 2 - 4.5  for hi-res screens, and
      DDFSTRT = HSTART / 2 - 8.5  for lo-res.
HSTART refers to bits 0-7 of the DIWSTRT register (its horizontal
coordinate).
   Since the default value for HSTART is $81, DDFSTRT defaults to $3C for
hi-res, and $38 for lo-res.
   Calculating the value for DDFSTOP is also easy.  Its value depends on the
screen's width:
      DDFSTOP = DDFSTRT + (4 * ((Width / 16) - 1))  for hi-res screens, and
      DDFSTOP = DDFSTRT + (* * ((Width / 16) - 1))  for lo-res.
Width is the width of the screen in pixels.  So, on a standard 640 pixel
hi-res screen, where DDFSTRT equals $3C, DDFSTOP should be set to $D4.
----------------------------------------------------------------------------
$DFF08E DIWSTRT      Display Window Start
Status: *W           Agnus
                   0-7 HSTART Horizontal coord. of upper left corner
                  8-15 VSTART Vertical coordinate of lower right corner
Notes: Bits 0-7 default to $81, and 8-15 default to $2C.
----------------------------------------------------------------------------
$DFF090 DIWSTOP      Display Window Stop
Status: *W           Agnus
                   0-7 HSTOP  Horizontal coord. of lower right corner
                  8-15 VSTOP  Vertical coord. of lower right corner.
Notes: For bits 0-7, the minimum HSTOP position in $100, which is 1/3 across
the screen.  The value stored here represents an offset from this position.
So, the actual horizontal coordinate of the lower right corner of the screen
is $100 PLUS HSTOP!  You can think of HSTOP as being a nine bit register
with bit 8 always set.  The Default is $C1, which specifies a value of $1C1.
   For bits 8-15, these bits hold the vertical coordinate of the lower right
corner of the screen.  The minimum VSTOP position in $80.  If the value here
is less than $80, VSTOP equals $100 PLUS your VSTOP value.  Simply put,
whatever the state of bit 8 is, bit nine will be opposite!  The default for
NTSC is $F4, and the PAL default is $2C which actually is $12C.  VSTOP
always specifies the vertical position in noninterlace lines, no matter what
mode the computer is in.
----------------------------------------------------------------------------
$DFF092 DDFSTRT      Display Data Fetch Start
Status: *W           Agnus
   This register specifies the horizontal position that the video beam must
reach in order for bitplane DMA to start.  It's value depends on your screen
resolution, and what you store in the HSTART bits (0-7) in the DIWSTRT
register at $DFF09E.
   In hi-res, only bits 2-7 are active.  (specifies an even multiple of 4)
In lo-res, only bits 3-7 are active (an even multiple of 8).  Because of
certain hardware limitations, do not use DDFSTRT values less than $18.  Ans,
because sprite DMA relies on color clocks that occur during raster positions
$16-$34, using DDFSTRT values below $38 will disable certain sprites.  The
lower the number, the more sprites are disabled.  Higher numbered sprites
will be disabled first.
----------------------------------------------------------------------------
$DFF094 DDFSTOP      Display Data Fetch Stop
Status: *W           Agnus
   This register specifies the horizontal position the video beam must reach
in order for bitplane DMA to stop.  The bits used are the same as for
DDFSTRT.  Because of certain hardware limitations, do not use values greater
than $D8.
----------------------------------------------------------------------------
$DFF096 DMACON       DMA Control
Status: *W           Angus/Denise/Paula
   This is the write register for DMACONR.  The only difference is that
SET/CLR is active.  Note that activating audio channel DMA starts the sound
on the specified channel.  (See DMACONR at $DFF002)
----------------------------------------------------------------------------
$DFF098 CLXCON       Collision Control
Status: *W           Denise
                     0 MVP1   Match value for bitplane 1 collisions
                     1 MVP2                            2
                     2 MVP3                            3
                     3 MVP4                            4
                     4 MVP5                            5
                     5 MVP6                            6
                     6 ENBP1  Enable collision detection for bitplane 1
                     7 ENBP2                                          2
                     8 ENBP3                                          3
                     9 ENBP4                                          4
                    10 ENBP5                                          5
                    11 ENBP6                                          6
                    12 ENSP1  Enable collision detection for sprite 1
                    13 ENSP3                                        3
                    14 ENSP5                                        5
                    15 ENSP7                                        7

   The Amiga can detect three types of graphic collisions: sprite - sprite,
sprite - bitplane, and bitplane - bitplane.  The match value in bits 0-5
determine exactly what constitutes a collision: either a 0 or 1.
   Through creative use of 0-5 and 6-11, you can specify that collision
takes place with only a certain color or within a range of colors.
   Bits 6-11.  These bits determine which bit planes are used in collision
detection.  Oddly, the Amiga always seems to think that a bitplane collision
is taking place when all of these bits are set to zero.
   Bits 12-15.  Setting these bits allows you to check for collisions
between the specified sprite, and the next lower one.
----------------------------------------------------------------------------
$DFF09A INTENA       Interrupt Enable
Status: *W           Paula
   This is the write register for INTENAR at $DFF01C.  Note that SET/CLR is
active, and that you must CLEAR the appropriate bit after servicing the
interrupt!
----------------------------------------------------------------------------
Location Range: $DFF09E - $DFF0DE   Audio Registers
   Once you have a waveform sample loaded into chip RAM, turning that data
into sound is relatively simple.  Just tell the computer where is, the
length in words, how fast to play the sound, set the volume, and then signal
that DMA for the desired sound.  The Amiga will continue to play and repeat
your sound until you tell it to stop.
----------------------------------------------------------------------------
$DFF09E ADKCON       Audio/Disk Control (see ADKCONR at $DFF010)
Status: *W           Paula
   Notes on bit 12: MFM vs. GCR formatting:
   Briefing put, MFM format inserts clock bits between each data bit written
to disk.  If two consecutive data bits are zero, a 1 clock bit is inserted
between them.  If either of two consecutive bits is a 1, a 0 clock pulse in
put between them.  Using this coding method, the amount of data written to a
disk is doubled, but the accuracy of reading the data is increased.  You
see, the disk controller has an easier time synchronizing on data that
changes states rather than data that repeats such as a long string of 1's or
0's.
   GCR format handles synchronization problems by encoding every four bits
od data into five bits.  The result is a binary number with no more than two
adjacent 0 bits and no more than eight adjacent 1 bits.  (This format is
used on the Commodore 1541 drives on the C64.)  The following table shows
the 5 bit GCR equivalents of the binary numbers 0000-1111.
      Binary   GCR
      ------   ---
       0000   01010     Note that with GCR, no more than 8 on bits or
       0001   01011     2 off bits are possible.
       0010   10010
       0011   10011
       0100   01110
       0101   01111
       0110   10110
       0111   10111
       1000   01001
       1001   11001
       1010   11010
       1011   11011
       1100   01101
       1101   11101
       1110   11110
       1111   10101

   Notes on bit 13: These set the disk disk controller's precompensation
time, which directly affects the density of the data written to disk.  The
faster the precompensation time, the higher the density.  With AmigaDos,
density is highest on the inside tracks, probably due to the fact that these
is less physical space for these tracks.
----------------------------------------------------------------------------
$DFF0A0 AUD0LCH      Channel 0 Waveform Address
$DFF0A2 AUD0LCL
Status: *W           Agnus
   The low byte of this register is always interpreted as zero, so your data
must begin on a word boundary.  For a 512K Agnus, max address is $7FFFF, and
for a 1MB Agnus, it is $FFFFF.
----------------------------------------------------------------------------
$DFF0A4 AUD0LEN      Channel 0 Waveform Length
Status: *W           Paula
   The length of your data in words is stored here.  So, your data must be
an even number of bytes, and may not exceed 131,070 bytes.  (i.e. 65536
times two.)
   However, it is possible to play waveforms longer than 131,070 bytes due
to the fact that the Amiga buffers the contents of the AUDxLC and AUDxLEN
registers by using backup registers.  So, you may change the AUDxLC and
AUDxLEN registers while the Amiga is playing a sound, and when it is
finished, it will start with the new data!  Any of the Amiga's audio
channels can cause a level 4 interrupt just before your sound starts a new
waveform cycle.  When this interrupt occurs, you know it's safe to change
the registers.  One warning however: Interrupts caused by high-frequency
waveforms can occur quite rapidly.  Even more rapidly than the operating
system can keep up!  It's best to leave the audio interrupts alone, unless
you actually need them.  Just wait a little while before changing the AUDxLC
and AUDxLEN registers and all will work fine.
----------------------------------------------------------------------------
$DFF0A6 AUD0PER      Channel 0 Period
Status: *W           Paula
   A sound's frequency is determined by the value stored here.  The lowest
value you should use is 124, since this is about as fast as the Amiga can
go.  The highest value is 65535.
   How you determine the period depends on how you get your waveform data.
If you use a digitizer and the frequency is in Samples-per-second, use this
equation:  AUDxPER = 3579546 / Samples-per-second
   If you have a group of data that you want played as an "instrument", use
this:      AUDxPER = 3579546 / (Bytes-Length * Frequency to be played)
   Of course, the frequency for a given note may be calculated by the old
standby:   Frequency = Base * 2 ^ (1/12)
   Which calculates the frequency for the next note once given a frequency.
Middle C comes in at 261.4 Hz.
   If you don't want your sound to repeat, you should consider one more
thing: when to stop the sound.  You see, the faster you play the sound, the
faster its going to finish.  To figure out how long to let it play, use the
following equation:
           uSec = .279365 * Period * Length
Where uSec, is of course, the time in microseconds it takes to play your
sound once.
----------------------------------------------------------------------------
$DFF0A8 AUD0VAL      Channel 0 Volume
Status: *W           Paula
   This volume register can accept values between 0 and 64, where 0 is the
lowest setting (at -infinity dB), and 64 is loudest (at -0 dB).
----------------------------------------------------------------------------
$DFF0AA AUD0DAT      Channel 0 Data
Status: *W           Paula
   This is the data buffer used by channel 0.  It's purpose is to output
sounds at a rate higher than the DMA can.  To use it, you must disable
channel 0 DMA and shove the data in onw word at a time.
----------------------------------------------------------------------------
Location Range: $DFF0AC - $DFF0AE   Unused
   The Amiga reserves enough space for eight word-long addresses for each
channel, but uses only six.  The remaining addresses are unused.
----------------------------------------------------------------------------
$DFF0B0/2   AUD1LCH/L    These registers function exactly the same as
$DFF0B4     AUD1LEN      channel 0's.  To Find channel 2's, add $20 to
$DFF0B6     AUD1PER      the AUD0xxx value, and $30 for channel 3.
$DFF0B8     AUD1VOL
$DFF0BA     AUD1DAT
$DFF0BC/E   UNUSED
----------------------------------------------------------------------------
Location Range: $DFF0E0 - $DFF0F6   Bitplane pointer registers
Status: *W      Agnus
   These registers point to the current word of data that is being displayed
from each bitplane.  They are set up by the programmer, but increment as
each word of data is fetched from memory.  Therefore, these registers must
be reset for each screen.  This is usually done by the copper list, but may
also be written directly to by the programmer during the vertical blank
interrupt.  The initial value stored here should be the starting address of
the bitplane.  The value stored here must begin on a word boundary, and all
notes about 512K / 1MB Agnus chips apply here.

$DFF0E0 BPL1PTH/L Bitplane pointers for bitplanes 1-6... 32 bits long
$DFF0E4 BPL2PTH/L with bit zero ignored.
$DFF0E8 BPL3PTH/L
$DFF0EC BPL4PTH/L
$DFF0F0 BPL5PTH/L
$DFF0F4 BLT6PTH/L
----------------------------------------------------------------------------
Location Range: $DFF0F8 - $DFF0FE   Currently Unused.
----------------------------------------------------------------------------
Location Range: $DFF100 - $DFF104   Bitplane Control Registers
   These three register control the modes of the Amiga video display.
Within the bits of these registers are the means of creating just about any
Amiga screen possible.  BPLCON0 ($DFF100) controls how the pixels are
displayed.  Genlocking, interlace, dual playfield mode, HAM, Extra Half
Brite, and Hi-Res are all among its domain.  BPLCON1 ($DFF102) controls the
hardware smooth scrolling of the Amiga.  BPLCON2 ($DFF104) is the priority
register which determines how the playfield and sprites will interact.  A
few terms will be described to facilitate the discussion of these registers:

   Dual Playfield Mode: In this mode, the odd numbered bitplanes are grouped
into one playfield (1), and the even numbered bitplanes into the other. (2)
One playfield has priority over the other, which means that the backgroup's
playfield shows through only when the foreground's pixels color is 0.
   Extra HalfBrite: In EHB, pixels may have any value in the range of 0-63.
Pixels in the range of 0-31 use the normal 32 color registers.  Pixels 32-63
use the lower 32 color registers with the RGB values each shifter one bit
right.  Thus, 32-63 are half as bright.
   Genlock: This is a method of combining computer graphics with an external
video source.  The external source shows through where pixel color 0 is.
   Hold and Modify (HAM): In HAM mode, 16 color registers (4 bits) are used
normally.  In 5 bitplane HAM mode, a bit set in the 5th bitplane signifies
that the pixel should use the color of the pixel immediately to the left,
but with the blue value corresponding to the value of the lower four
bitplanes.  In 6 bitplane mode, the bits in the 5th and 6th bitplanes are
used to specify whether the lower sixteen color registers should be used
normally, or whether the pixel should be based on the pixel immediately to
the left, with the red, green, or blue intensity altered.  HAM images are
the most photographic available on the Amiga.  Six bitplane HAM is typical,
with five bitplane HAM a rarity.
   Interlace: This is a method of doubling vertical resolution by displaying
alternating lines on alternating scans.  See VPOSR at $DFF004.
   Playfield: This is the name for the non-sprite graphics that appear on
the screen as a result of bitplane DMA.  The name is a carryover from the
old Atari VCS.  (gasp!)
----------------------------------------------------------------------------
$DFF100 BPLCON0      Bitplane Control Register 0
Status: *W           Agnus/Denise
                     0 UNUSED
                     1 ERSY   External sync.  (1 = external, genlocked
                              0 = internal, normal)
                     2 LACE   1 = interlace enable
                     3 LPEN   1 = light pen enable
                   4-7 UNUSED
                     8 GAUD   1 = Genlock audio enable
                     9 COLOR  1 = Composite color enable on Amiga 1000,
                              0 = Monochrome display.
                    10 DBLPF  1 = Double (dual) playfield mode
                    11 HOMOD  1 = HAM active
                 12-14 BPU    Number of bitplanes used.  Zero = no bitplanes
                              You cannot use more than 4 for hi-res, and six
                              activates EHB mode.
                    15 HIRES  1 = Hi-res mode  0 = Lo-res mode.

Notes on bit 8: It has been alleged that audio data can be multiplexed on
the BKGD pen during vertical blanking, and bit 8 enables this feature.  In
reality, however, this bit simply goes out on the pixel switch ZD during
blanking periods.
----------------------------------------------------------------------------
$DFF102 BPLCON1      Bitplane Control Register 1
Status: *W           Denise
                   0-3 PF1H   Playfield 1 horizontal scroll
                   4-7 PF2H   Playfield 2 horizontal scroll
   This register allows you to fine scroll the screen horizontally.
Vertical scrolling is trivial.  Simply increment or decrement the starting
address of each bitplane by the width of a screen line in bytes.  Horizontal
scrolling is trickier.  You can perform a coarse 16 pixel scroll by simply
incrementing or decrementing the starting address of the bitplane pointers
by one word, but to scroll at the pixel level, use this register.
   In lo-res, the scrolling is in one pixel increments, and in hi-res, it is
two pixels.  To set up a screen for horizontal scrolling, the screen must be
one word wider than normal.  Do, you must add 2 to DDFSTRT's ($DFF030)
normal value.  You must set the modulo registers (BPLxMOD $DFF108) to the
number of "extra" bytes in each line (those that would not exist if you
weren't doing horizontal scrolling) minus two.  For example, if you're
displaying 40 bytes of an 80 byte wide screen, place the number 38 into the
appropriate BPLxMOD register.
----------------------------------------------------------------------------
$DFF104 BPLCON2      Bitplane Control Register 2
Status: *W           Denise
   This register allows you to determine priorities between the graphic
elements that make up an Amiga screen, namely the eight sprites and two
playfields.

   0-2 PF1P    Playfield 1 vs. sprite priority
   3-5 PF2P    Playfield 2 vs. sprite priority
     6 PF2PRI  Playfield 1 vs. playfield 2 priority (1 = 2 in front,
               0 = 1 in front.)

Notes: Bits 0-5 allow you to specify whether sprites should pass in front of
or behind a given set of bitplanes.  The table below shows the allowable
values.

   bit 2    bit 1    bit 0    (for playfield 1)
   bit 5    bit 4    bit 3    (for playfield 2)
     0        0        0      Playfield has top priority
     0        0        1      Playfield appears behind sprites 0-1
     0        1        0      Playfield appears behind sprites 0-3
     0        1        1      Playfield appears behind sprites 0-5
     1        0        0      Playfield appears behind all sprites
----------------------------------------------------------------------------
$DFF106              Zilch - Unused
----------------------------------------------------------------------------
$DFF108 BPL1MOD      Bitplane Modulo 1
$DFF10A BPL2MOD      Bitplane Modulo 2
Status: *W           Agnus
   These registers control how many bytes are added to the bitplane pointers
at the end of a video line.  Normally, the value is zero.  When the number
is greater than zero, you have an undisplayed segment of the screen to the
right of the visible area.  You can bring this area into view by
incrementing the bitplane pointers, and modifying the smooth scroll
register BPLCON1 at $DFF102.
   As an example, suppose the virtual screen you have is 80 bytes wide, by
the visible screen is 40.  You'll need to specify 40 as the modulo.
   There are two modulo registers, one for each playfield.  Unless you are
using dual playfield mode, both of these registers should be set to the same
value.  Note that the lowest bit is ignored, thus these registers must be
set to an even value.
----------------------------------------------------------------------------
Location Range $DFF10C - $DFF10E    Currently Unused.
----------------------------------------------------------------------------
Location Range $DFF110 - $DFF11A    Bitplane Data Registers
   The Amiga hardware is currently able to display six bitplanes.  If you
look carefully, however, there are gaps that would allow two extra bitplanes
to be inserted.  These registers are typically written to by the bitplane
DMA, but they may also be written to by the programmer directly.  The
parallel data from the six bitplanes is shifted out the left and converted
to a color.  BPL1DAT is the trigger register.  That means that you should
write to BPL2DAT - BPL6DAT first, then write to BPL1DAT to trigger the
serial conversion.

$DFF110 BPL1DAT   Bitplane DMA trigger.  Color Weight = 1
$DFF112 BPL2DAT   Weight = 2
$DFF114 BPL3DAT   Weight = 4
$DFF116 BPL4DAT   Weight = 8
$DFF118 BPL5DAT   Weight = 16
$DFF11A BPL6DAT   Weight = 32 (i.e. HAM / EHB)
----------------------------------------------------------------------------
Location Range $DFF11C - $DFF11E    Currently Unused.
----------------------------------------------------------------------------
Location Range $DFF120 - $DFF17E    Sprite Registers
   The Amiga is known for the animation capabilities of the blitter, but it
also has powerful sprite hardware.  Sprites have some advantages over the
blitter.  Whereas the blitter must render its images to display memory,
sprites are rendered in a separate area of memory.
   There are eight sprites.  Each sprite is 16 pixels wide and an arbitrary
size high.  The pixels are lo-res, even when displayed in hi-res or
interlaced mode.  Each pixels can be one of three colors or transparent.
   Sprites 0 and 1 share color registers 17 - 19.  Sprites 2 and 3 share
21-23, 4 and 5 share 25-27, and 6 and 7 share 29 through 31.  If your screen
uses 4 bitplanes or less, you won't have to worry about sprites sharing the
color registers with the playfield.  Otherwise... you'll have to plan colors
carefully.
   Note that the lower the sprite number, the higher its priority on the
screen.  Sprite priorities relative to the playfield can be assigned.  See
the bitplane control registers $DFF100 - $DFF106.
----------------------------------------------------------------------------
$DFF120 SPR0PTH         Sprite Pointer 0
$DFF122 SPR0PTL
Status: *W              Agnus
   This register holds the address of the Sprite 0 DMA data.  The address
must be in chip RAM.  This register acts as a DMA counter, so you must
initialize it during every vertical blank via the copper list or within a
vertical blank interrupt server.
   The address which you set to this register should contain valid sprite
data in chip RAM.  Use this format (each value is 32 bits):

      Sprite Control Value
      Image data for line 1
      Image data for line 2
      .....................
      Image data for last line

   Repeat this format for each occurrance of the sprite on the screen.  For
instance, you might have the same sprite engine used in three different
vertical areas of the screen.  In this case, you'd have the above format
three times.  At the end of the data, store a $00000000.
   Here is a sample adapted from the Amiga Hardware Reference Manual:
      SPRITE:
         DC.L  $6D607200   ; VSTART, HSTART, and VSTOP
         DC.L  $099007E0   ; Sprite data... $6D
         DC.L  $13C80FF0   ;                $6E
         DC.L  $23C41FF8   ;                $70
         DC.L  $13C80FF0   ;                $71
         DC.L  $099007E0   ;                $72
         DC.L  $00000000   ; End of structure.

   The Amiga is often said to have reusable sprite engines.  This means that
the Amiga can display the same sprite in several different places.  There is
one significant limitation to this ability: You must ensure that there is at
least one blank line vertically between the two instances of the same
sprite.  For example, if you have a sprite that stops displaying on line 25,
you may display a second one on line 27 or greater.
----------------------------------------------------------------------------
$DFF124 SPR1PTH/L Sprite Pointers 1-7
$DFF128 SPR2PTH/L
$DFF12C SPR3PTH/L
$DFF130 SPR4PTH/L
$DFF134 SPR5PTH/L
$DFF138 SPR6PTH/L
$DFF13C SPR7PTH/L
----------------------------------------------------------------------------
$DFF140 SPR0POS         Sprite Position 0 & Control 0
$DFF142 SPR0CTL
Status: *W              Agnus/Denise
   These two 16-bit registers can be thought of as a single 32 bit register
which holds information about how sprite 0 is to be displayed.  Info
included is vertical and horizontal starting locations, vertical stopping
location, and whether the sprite should be attached to its companion (0 and
1, 2 and 3, 4 and 5, 6 and 7).
   The sprite control value consists of the following bits, the number of
which should be stored in the:
                        0 HSTART       lowest bit
                        1 VSTOP        highest bit
                        2 VSTART       highest bit
                      3-6 Always 0
                        7 ATTACHMENT   1 = attached, 0 = not
                     8-15 VSTOP        lowest 8 bits
                    16-23 HSTART       highest 8 bits
                    24-31 VSTART       lowest 8 bits

   The HSTART value is your sprite's intended horizontal position.
Typically, the horizontal position 0 is 64 pixels to the left of the screen.
 This number can change depending on your preferences settings.  Suppose
that you want to position a sprite at the horizontal position which
corresponds to pixel 10.  In this case, add 10 + 64, to get 74.  Place 74 in
HSTART.  If you're setting up your own copper list, you'll know the value to
add to your desired offset.  If you're using a screen set up by the screen,
you can find the offset in the View structure.
   The VSTART value is your sprite's intended vertical position.  Typically,
the vertical position is 0-44 pixels above the top line of the screen.  This
number can change depending on your preferences settings.  Suppose you want
to position a sprite at the vertical position that corresponds with pixel
position 12.  Simply add 12 + 44 to get 56.  Place 56 in VSTART.
   The VSTOP value is the line on which you want your sprite to stop
displaying.  Simply add the height of the sprite to VSTART to get this
value.
   The register's attachment bit (7) is ingored in even numbered sprites.
When you attach two sprites, set HSTART, VSTART, and VSTOP of the two
sprites to the same values.
   Keep in mind that to modify this from within the copper, you will need to
use two Move instructions.  This location is usually not written to by the
programmer.  Instead, it is written to by sprite DMA.
----------------------------------------------------------------------------
$DFF144 SPR0DATA        Sprite Data Register 0
$DFF146 SPR0DATB
Status: *W              Denise
   This location is usually not written to by the programmer.  Instead, it
is written to by the sprite DMA.  If you write to it directly, write to
SPR0DATB (high bit of 4 colors) first then to SPR0DATA.  The data will then
be displayed on every line at the horizontal position specified in SPR0POS
and SPR0CTL until you write to SPR0DATA again.  SPR0DATA acts as a switch to
turn the sprite on.  SPR0CTL acts as the corresponding off switch.  The
weight of the bits for color are as follows:
      SPR0DATA 1
      SPR0DATB 2
      SPR1DATA 4 (if attached)
      SPR1DATB 8 (if attached)
----------------------------------------------------------------------------
Note: Sprites 0,1 share colors as do 2,3; 4,5; and 6,7

$DFF148 SPR1POS      (PIXEL VALUE 0 = TRANSPARENT
$DFF14A SPR1CTL                   1 = COLOR REGISTER 17
$DFF14C SPR1DATA                  2 = COLOR REGISTER 18
$DFF14E SPR1DATB                  3 = COLOR REGISTER 19)
$DFF150 SPR2POS      (SHARES 3'S COLOR REGISTERS...)
$DFF152 SPR2CTL
$DFF154 SPR2DATA
$DFF156 SPR2DATB
$DFF158 SPR3POS      (PIXEL VALUE 0 = TRANSPARENT
$DFF15A SPR3CTL                   1 = COLOR REGISTER 21
$DFF15C SPR3DATA                  2 = COLOR REGISTER 22
$DFF15E SPR3DATB                  3 = COLOR REGISTER 23)
$DFF160 SPR4POS      (SHARES 5'S COLOR REGISTERS...)
$DFF162 SPR4CTL
$DFF164 SPR4DATA
$DFF166 SPR4DATB
$DFF168 SPR5POS      (PIXEL VALUE 0 = TRANSPARENT
$DFF16A SPR5CTL                   1 = COLOR REGISTER 25
$DFF16C SPR5DATA                  2 = COLOR REGISTER 26
$DFF16E SPR5DATB                  3 = COLOR REGISTER 27)
$DFF170 SPR6POS      (SHARES 7'S COLOR REGISTERS...)
$DFF172 SPR6CTL
$DFF174 SPR6DATA
$DFF176 SPR6DATB
$DFF178 SPR7POS      (PIXEL VALUE 0 = TRANSPARENT
$DFF17A SPR7CTL                   1 = COLOR REGISTER 29
$DFF17C SPR7DATA                  2 = COLOR REGISTER 30
$DFF17E SPR7DATB                  3 = COLOR REGISTER 31)
----------------------------------------------------------------------------
Location Range $DFF180 - $DFF1BE    Color Registers
   Each color register contains 12 bits of information, for a total of 4096
colors.  The registers are set up as follows:
      0-3 Blue intensity (0 = no blue, 15 = full blue)
      4-7 Green intensity
     8-11 Red intensity
    12-15 Unused

   There are seven colors which can be represented in 16 intensities.  Those
colors are, along with their hexadecimal values:

Gray     Red      Green    Blue     Yellow      Magenta     Cyan
----     ---      -----    ----     ------      -------     ----
FFF      F00      0F0      00F      FF0         F0F         0FF

   Here is a table of common colors:

Black - 000       Blue - 00F        Green - 0F0       Cyan - 0FF
Red   - 0F0       Purple-F0F        Orange- E70       Yellow-FF0
White - FFF       LtGray-CCC        MdGray- 888       DkGray-444
----------------------------------------------------------------------------
$DFF182 COLOR01   $DFF184 COLOR02   $DFF186 COLOR03   $DFF188 COLOR04
$DFF18A COLOR05   $DFF18C COLOR06   $DFF18E COLOR07   $DFF190 COLOR08
$DFF192 COLOR09   $DFF194 COLOR10   $DFF196 COLOR11   $DFF198 COLOR12
$DFF19A COLOR13   $DFF19C COLOR14   $DFF19E COLOR15   $DFF1A0 COLOR16
$DFF1A2 COLOR17   $DFF1A4 COLOR18   $DFF1A6 COLOR19   $DDD1A8 COLOR20
$DFF1AA COLOR21   $DFF1AC COLOR22   $DFF1AE COLOR23   $DFF1B0 COLOR24
$DFF1B2 COLOR25   $DFF1B4 COLOR26   $DFF1B6 COLOR27   $DFF1B8 COLOR28
$DFF1BA COLOR29   $DFF1BC COLOR30   $DFF1BE COLOR31
----------------------------------------------------------------------------
8520 CIA Chips - Location Range $BFD000-$BFDF00
CIA-B
   Locations $BFD000-$BFDF00 are used to address the Amiga's second Complex
Interface Adaptor (CIA-B).  Since the chip itself is identical to the CIA-A,
which is addressed at $BFE001, the discussion here will be limited to the
use the Amiga makes of this particular chip.  For more general information
on the chip registers, see the corresponding entries for CIA-A.  Unlike the
custom chip registers, the CIA registers are all one byte long and can be
both read from and written to.
----------------------------------------------------------------------------
$BFD000 PRA          Peripheral Data Register for Data Port A
Status: R/W          CIA-B
                     0 BUSY   Centronics busy (parallel port pin 11)
                     1 POUT   Centronics paper out (pin 12)
                     2 SEL    Centronics select (pin 13)
                     3 DSR    RS232 data set ready (serial port pin 6)
                     4 CTS    RS232 clear to send (pin 5)
                     5 DCD    RS232 carrier detect (pin 8)
                     6 RTS    RS232 request to send (pin 4)
                     7 DTR    RS232 data terminal ready (pin 20)
----------------------------------------------------------------------------
$BFD100 PRB          Peripheral Data Register for Data Port B
Status: R/W          CIA-B
                     0 STEP   Move drive head by one track in direction
                              specified by the DIR bit (set to 1, 0,
                              then 1 again to move head.)
                     1 DIR    Direction to move drive head (1 = out to 0,
                              0 = in to track 79+)
                     2 SIDE   Select drive head (1 = bottom, 0 = top)
                     3 SEL0   0 = Select DF0:  1 = not selected
                     4 SEL1   0 = Select DF1:
                     5 SEL2   0 = Select DF2:
                     6 SEL3   0 = Select DF3:
                     7 MTR    Motor on/off status (1 = motor off,
                              0 = motor on)

   Notes:
      Bit 0: After moving the drive's head, it is important that you wait 3
microseconds before performing any other disk activities.  Since software
timing loops will be shorter on accelerated Amigas, use the CIA timers.
      Bit 1: You can check if the drive head of a selected drive is on track
0 by reading bit 4 of the CIA-A chip's PRA register located at $BFE001.
      Bit 2: When you select the head, the value of this bit affects only
the currently selected drives.
      Bits 3-6: You may select more than one drive at a time.  Thus, you can
move the heads on more than one drive simultaneously.
      Bit 7: This bit turns the motors on and off.  The drive LED is
directly wired to the motor power.  This bit should be set before you select
a drive.  If a drive is already selected and you wish to change the state of
its motor, deselect the drive, set this bit, and then reselect the desired
drive.
      When turning on the motor, you must wait for the motor to reach its
full rotation speed before performing any other disk activities.  Bit 5 of
the CIA-A's PRA ($BFE001) is set equal to 0 whenever the drive has reached
full speed and is ready to receive another command.
      Note that all of this assumes that you have disabled multitasking and
have taken full control of the computer.
----------------------------------------------------------------------------
$BFD200 DDRA            Data Direction Register A
Status: R/W             CIA-B
   A bit set in this register causes the corresponding bit in PRA to be
defined as output.  A bit clear causes it to be defined as input.  Note that
bits 0-5 are normally clear, and bits 6-7 are set.
----------------------------------------------------------------------------
$BFD300 DDRB            Data Direction Register B
Status: R/W             CIA-B
   This register controls the I/O of PRB.  All bits MUST be set to 1.
----------------------------------------------------------------------------
Location Range: $BFD400 - $BFD700   CIA-B Timers A & B L/H Bytes
   According to some early Commodore-Amiga manuals, Timer A is reserved for
Commodore 8-bit serial bus communications - the bus system used by the C64
to talk to the 1541, 1571, 1581, as well as C64 compatible printers.  For
all practical purposes, the Amiga has no use for these timers.  Timer B is
also unused by the operating system.  Feel free to use them yourself.  For
more details, see the entry for the CIA-A Timer A & B registers at $BFE401
through $BFE701.

$BFD400 TALO   Timer A Low Byte.  R/W
$BFD500 TAHI   Timer A High Byte. R/W
$BFD600 TBLO   Timer B Low Byte.  R/W
$BFD700 TBHI   Timer B High Byte. R/W
----------------------------------------------------------------------------
Location Range: $BFD800-$BFDB00     CIA-B TOD Counters
   This 24 bit timer serves as a horizontal blank counter for the
graphics.library , and is used to synchronize the output of graphics with
the position of the video beam.
   The CIA-B chip's TICK line is connected to the Agnus chip's _HSYNC line,
so the TOD clock's counter is incremented once every horizontal blank, or
31500 times per second.

$BFD800 TODLO  TOD counter low byte    R/W   CIA-B (0-7)
$BFD900 TODMID TOD counter mid byte    R/W   CIA-B (8-15)
$BFDA00 TODHI  TOD counter high byte   R/W   CIA-B (16-23)
$BFDB00 TODHR  UNUSED - Not connected to the Amiga
-----------------------------------------------------------------------------
$BFDC00 SDR          Serial Data Register
Status: R/W          CIA-B
   The CIA chip has an on-chip serial port, which allows you to send or
receive a byte of data one bit at a time, with the MSB (7) shifted out
first.
   The CIA-B's SP line, which carries bits to the Serial Data Register, is
connected to bit 0 of this chip's data port A, and in turn, to pin 11 of the
parallel port.  The chip's CNT line, which carries the bits that are output
by the Serial Data Register, is connected to bit 1 of this chip's Data Port
A, and in turn, to pin 12 of the parallel port.
   For more information about the use of this register, see the entry for
location $BFEC01.  The Amiga's operating system does not use this register.
----------------------------------------------------------------------------
$BFDD00 ICR          Interrupt Control Register
Status: R/W          CIA-B
            0 R - did Timer A count down to zero? (1 = yes)
              W - enable or disable Timer A IRQ (1 = enabled  0 = disabled)
            1 R - did Timer B count down to zero? (1 = yes)
              W - enable or disable Timer B IRQ (1 = enabled  0 = disabled)
            2 R - did TOD clock reach alarm time? (1 = yes)
              W - enable or disable TOD alarm IRQ (1 = en  0 = dis)
            3 R - did the serial data register finish a byte? (1 = yes)
              W - enable or disable serial data register IRQ (1/0 = en/dis)
            4 R - was a signal sent on the FLAG line? (1 = yes)
              W - enable/disable flag IRQ (1/0 = en/dis)
            5     UNUSED - always returns a zero
            6     UNUSED - always returns a zero
            7 R - did any CIA-A source cause an interrupt? (1 = yes)
              W - set or clear bits of this register.  (1 = bits written to
                  with a 1 will be set, 0 = bits written with a 1 will be
                  cleared.)

   This register is used to control the 5 interrupt sources on the 8520 CIA
chip.  For details on its operation, see $BFED01.
   The main difference between the two CIA chips pertaining to this register
is that on CIA-B, the FLAG line is connected to the disk controller's
DSKINDEX line.  And in order for the Amiga to recognize a CIA-B chip
interrupt, bit 13 or the INTENA register must be set to 1.  See registers
INTENA and INTENAR at $DFF09A and $DFF01C for more information on Amiga
interrupts.
----------------------------------------------------------------------------
Location Range $BFDE00 - $BFDF00    CIA Control Registers A & B
See locations $BFEE01 and $BFEF01 for details.
----------------------------------------------------------------------------
$BFDE00 CRA          Control Register A
Status: R/W          CIA-B
            0 START   Start Timer A (1 = start, 0 = stop)
            1 PBON    Select Timer A output on Data Port B (1 = Timer B
                      output appears on bit 6 for Data Port B)
            2 OUTMODE Data Port B output mode (1 = toggle bit 6, 0 = pulse
                      bit 6 every 10 microprocessor cycles)
            3 RUNMODE Timer A run mode (1 = one shot, 0 = continuous)
            4 LOAD    Force latched value to be loaded to Timer A counter
                      (1 = force load strobe)
            5 INMODE  Timer A input mode (1 = count signals on CNT line at
                      pin 1 of keyboard port, 0 = count every 10 uP cycles)
            6 SPMODE  Serial Port ($BFEC01) mode (1 = output, 0 = input)
            7 UNUSED
----------------------------------------------------------------------------
$BFDF00 CRB          Control Register B
Status: R/W          CIA-B
            0 START   Start Timer B (1 = start, 0 = stop)
            1 PBON    Select Timer B output on Data Port B (1 = Timer B
                      output appears on bit 7 for Data Port B)
            2 OUTMODE Data Port B output mode (1 = toggle bit 7, 0 = pulse
                      bit 7 every 10 microprocesor cycles(
            3 RUNMODE Timer B run mode (1 = one shot, 0 = continuous)
            4 LOAD    Force latched value to be loaded to Timer B counter
                      (1 = force load strobe)
          5-6 INMODE  Timer B input mode
                      00 = count every 10 uP cycles
                      01 Count cycles on CNT line at pin 1 of keyboard port
                      10 Count each time that Timer A counts down to 0.
                      11 Count Timer A 0's when CNT pulses are present
            7 ALARM   Select TOD write status (1 = writing to TOD registers
                      sets counter, 0 = writing to TOD registers sets alarm)
----------------------------------------------------------------------------
Location Range $BFE001-$BFE301   CIA Data Ports A and B
   These registers allow the Amiga to communicate with the outside world.
Bits of data written to the PRA and PRB registers ($BFE001 and $BFE101) can
be sent to external devices, while bits of data those devices send can be
read here.
   A bit can be set up for only input or output, not both at once.  To
define the I/O status of a bit, you use the Data Direction Registers.
Register DDRA ($BFE201) controls data port A, and register DDRB ($BFE301)
controls data port B.  1 = output mode, and 0 = input mode.  Note that DDRA
is preset by the Amiga on power up.  Modifying the contents may cause the
computer to lock up.
----------------------------------------------------------------------------
$BFE001 PRA          Peripheral Data Register for Data Port A
Status: R/W          CIA-A
                     0 OVL    Memory overlay bit (Dont change! Keep 0)
                     1 LED    Power LED/Cutoff filter (1 = LED dimmed and
                              cutoff filter inactive, 0 = LED/filter normal)
                     2 CHNG   Disk Change (1 = no change, 0 = disk has
                              been removed)
                     3 WPRO   1 = Disk Write Protected  0 = Unprotected
                     4 TK0    1 = head not on trk 0, 0 = head on track 0.
                     5 RDY    1 = currently selected drive is ready for
                              commands, 0 = not ready.
                     6 FIR0   Fire button on port 1, pin 6 (0 = pressed)
                     7 FIR1   Fire button on port 2, pin 6 (0 = pressed)

   Notes: On bits 6-7, you may also output data  through pin 6 on either
game port.  Simply set bit 6 or 7 (depending on which port you wish to
output data o) in the DDRA register to 1 for output and then toggle the same
bit in the PRA register.  Setting the PRA bit to one outputs approximately 5
volts on that line.  Setting the PRA bit equal to zero oulls the line low to
zero volts.  It is common courtesy to set the data direction registers back
to their original value after using them.
----------------------------------------------------------------------------
$BFE101 PRB          Peripheral Data Register for Data Port B
Status: R/W          CIA-A
                     0 D0  Parallel port pin 2
                     1 D1  Parallel port pin 3
                     2 D2  Parallel port pin 4
                     3 D3  Parallel port pin 5
                     4 D4  Parallel port pin 6
                     5 D5  Parallel port pin 7
                     6 D6  Parallel port pin 8
                     7 D7  Parallel port pin 9

   Notes: This register is used exclusively by the Amiga's parallel port.
It controls the port's data lines, and is therefore responsible for all
parallel port transmissions.
   For example, whenever the Amiga sends a character to a printer that's
connected to the parallel port, it uses this register.  It just sets all the
bits in the DDRB equal to one and writes the byte of data to be output here.
----------------------------------------------------------------------------
$BFE201 DDRA         Data Direction Register A
Status: R/W          CIA-A
                     0 Select bit 0 PRA I/O (Must be 1 = Output)
                     1            1                  1
                     2            2                  0 = Input
                     3            3                  0
                     4            4                  0
                     5            5                  0
                     6            6         (Normally 0)
                     7            7         (Normally 0)
----------------------------------------------------------------------------
$BFE301 DDRB         Data Direction Register B
Status: R/W          CIA-A
   A bit set or clear here makes the corresponding bit in the PRB set for
output or input, respectively.
----------------------------------------------------------------------------
Location Range $BFE401 - $BFE701    CIA Timers A & B L/H Bytes
   These four timer registers (two for each timer) have different functions
depending on whether you are reading from or writing to them.  When you read
from these registers, you get the present value of the Timer Counter (which
counts down from its initial value to zero).  When you write to these
registers, the value is stored in the Timer Latch, and from there it can be
used to load the Timer Counter using the LOAD bit of the CRA or CRB
registers (see $BFEE01 and $BFEF01).
   These interval timers can hold a 16 bit value from 0 to 65535, in low
byte - high byte format.  Once the Timer Counter is set to an initial value
and the timer is started, the timer will decrement every 10 uP cycles.
Since the clock speed of an NTSC Amiga is 7.159090 MHz, using every count
takes approximatels a millionth of a second.  (10 / 7159090 =
0.0000013968256).  The formula for calculating the amount of time it will
take for the timer to count down from its latch value to zero is:
      Time = Latch Value / Count Speed
where Latch Value is the value written to the low and high timer registers,
and Count Speed is 715909 for NTSC, and 709379 for PAL.
   When Timer A or B reaches 0, it will set bit 0 or 1 in the Interrupt
Control Register at $BFED01.  If the timer interrupt has been enabled, an
interrupt will take place, and the high bit of the Interrupt Control
Register will be set to one.  Alternately, if the PBON bit is set, the timer
will wirte data to bit 6 or 7 on Port B.  After the timer gets to zero, it
will reload the Timer Latch value and either stop or count down again,
depending on whether it is in one-shot or continuous mode (determined by bit
3 of the Control Register).
   Although usually a timer will be used to count every 10 uP cycles, Timer
A can also count external pulses on the CNT line, which is connected to the
Amiga's keyboard.
   Timer B is even more versatile.  In addition to these two sources, Timer
B can count the number of times that Timer A goes to zero.  By setting Timer
A to count the uP clock, and Timer B to count the number of times Times A
reaches 0, you effectively link the two into one 32 bit timer that can count
for more than an hour before resetting.
   In the Amiga, CIA-A Timer A is used to time the transfer of keyboard
data.  Timer B is used by Exec (the core of the Amiga's multitasking
operating system) to synchronize task switching; it also serves as the
timer.device's UNIT_MICROHZ timer.  As a result, neither Timer A or B is
available for general use.
----------------------------------------------------------------------------
$BFE401 TALO            Timer A Low Byte
$BFE501 TAHI            Timer A High Byte
$BFE601 TBLO            Timer B Low Byte
$BFE701 TBHI            Timer B High Byte
Status: R/W             CIA-A
----------------------------------------------------------------------------
Location Range $BFE801 - $BFEB01    CIA-A TOD Counters
   In addition to two general purpose timers, the 8520 CIA has a special
purpose 24-bit counter that can count up to 16777215 ($FFFFFF).  Unlike the
chip's other two timers, the TOD clock counts up, and when the TOD clock
reaches its maximum value, starts over at zero and continues counting.  The
TOD clock can also be set to generate an interrupt whenever it reaches a
determined value.
   The TOD clock increments its counter approximately 60 times per second
(50 for PAL) - the same frequency as the computer's power line tick.
   The TOD registers can be used for two purposes, depending on whether you
are reading from or writing to them.  If you are reading from them, you will
always be reading the timer's current value.  There is a latching feature
associated with the high byte register that freezes the other two bytes
until you read the low byte.  This is to keep inaccurate readings from
occurring.  (Note that the timer will not continue to count until you read
the low byte!)
   Writing to these registers sets either the counter or alarm time
depending on the setting of bit 7 of Control Register B (CRB, $BFEF01).  If
that bit is set to 1, writing to the TOD registers sets the alarm.  If the
bit is set to zero, writing to the TOD registers sets the clock.  In either
case, as with reading the registers, there is a latch function.  This
function stops the clock from updating when you write to the high byte
register.  The clock will not start again until you write to the low byte
register.
   The CIA-A's TOD clock serves as the timer.device's UNIT_VBLANK timer.
Unlike the Timer A driven UNIT_MICROHZ clock (which is also used by Exec),
UNIT_VBLANK is not slowed down if the computer is running several programs
at once.
----------------------------------------------------------------------------
$BFE801 TODLO        TOD Counter Low Byte
$BFE901 TODMID       TOD Counter Mid Byte
$BFEA01 TODHI        TOD Counter High Byte
$BFEB01 TODHR        UNUSED - Not connected to the Amiga
Status: R/W          CIA-A
----------------------------------------------------------------------------
$BFEC01 SDR          Serial Data Register
Status: R/W          CIA-A
   The CIA chip has a built in serial port, which allows you to send or
receive a byte of data one bit at a time, with the MSB (7) shifted out
first.  Control Register A at $BFEE01 allows you to choose input or output
modes.  In input mode, a bit of data is read from the chip's SP line
whenever a signal on the CNT line appears.  After 8 bits are received, and
the data has been placed in the SDR, an interrupt is generated to let you
know that the register should be read.
   In output mode, you write data to the SDR, and it is sent out over the SP
line using Timer A for the baud rate generator.  Whenever a byte of data is
written to using this register, transmission will start as long as Timer A
is running in continuous mode.  Data is sent at half the Timer A rate, and
an output will appear on the CNT line whenever a bit is sent.  After all 8
bits have been sent, an interrupt is generated to indicate that it is time
to load the next byte to send into the Serial Data Register.
   The Amiga usus this register to receive data from the keyboard's KDAT
line (via pin 2 of the keyboard port), and the CNT line is connected to the
keyboard's KCLK line (via pin 1 of the keyboard port).  Data is never sent
to the keyboard, so this register is always operating in input mode.
   By reading this register directly, you can find the RAWKEY value of the
current key being pressed.  A rawkey value specified the physical location
of the key on the keyboard.  Normally, the Amiga's operating system reads
the value from the SDR and uses the computer's current keyboard map table
(such as USA1) to convert it to ASCII.  Keymap tables are important because
different countries use different keyboard layouts.  There are at least 15
different Amiga keyboard configurations in existance.
   The number returned does not have the high bit (7) set during the key
press.  However, when the key is released, bit 7 is set.  Thus, a key's
release value is 128 greater than its depress value.
   You should know the shift or control keys do not modify the rawkey
values.  Instead, the shift or control keys send their own rawkey codes.
   There are six special codes that can be sent via the SDR:
      $78 - Control/Amiga/Amiga
      $F9 - Ignore last character: transmission error
      $FA - 10 character keyboard buffer is full
      $FC - Keyboard self test failed
      $FD - Header: Any following codes were keys pressed on power up
      $FE - Termination code after the keys pressed on power up.
            (i.e.: $FD xx xx ... $FE)
   Using the console.device's RawKeyConvert() functiom, you can convert a
rawkey code to normal ASCII.

----------------------------------------------------------------------------
$BFED01 ICR          Interrupt Control Register
Status: R/W          CIA-A
   Notes: Bit layout is the same as the ICR at $BFDD00.  This register is
used to control the five interrupt sources on the 8520 CIA chip.  These
sources are Timer A, Timer B, the TOD clock, the SDR, and the chip's FLAG
line.  Timer's A & B cause an interrupt when they count down to zero.  The
TOD clock generates an alarm when it reaches the alarm time.  The SDR
generates an interrupt when it compiles 8 bits of input or output.  An
external signal pulling the CIA chip's FLAG line low will also cause an
interrupt (on CIA-A, the FLAG line is connected to the ACK line - pin 10 of
the parallel port).
   Even if the conditions for an interrupt are satisfied, the interrupt must
still be enabled for the interrupt to occur.  This is done by writing to the
ICR.  What happens when you write to this register depends on the way you
set bit 7.  If it is set to 0, any bit you write to with a 1 is cleared.  If
it is set to a 1, any bit that you write to with a 1 is set, and the
corresponding interrupt is enabled.  In either case, any bits written to
with a zero will be unaffected.
   For example, to disable all interrupts from machine language, you could
MOVE.B #$7F,$BFED01.  Don't try this with multitasking turned on, as it will
turn off Timer B, which handles task switching.
   To turn on a Timer B interrupt, a program could MOVE.B #$82,$BFED01.  Bit
7 is set to 1, and so is bit 1, so the interrupt which corresponds with bit
1 (Timer B) is enabled.
   When you read this register, you can tell if any of the conditions for a
CIA interrupt were satisfied because the corresponding bit will be set to a
one.  For example, if Timer A counter down to zero, you would read a #$01
from this register.  If in addition the enable bit that corresponds to that
interrupt source is set to 1 and an interrupt occurs, bit 7 will also be
set.  This allows a multi-interrupt system to read one bit and see if the
source of a particular interrupt is CIA-A.  You should note, however, that
reading this register clears it, so you should preserve its contents if you
want to test more than one bit.  In order for the Amiga to recognize a CIA-A
chip interrupt, bit 3 of the INTENA register must be set to 1.  See
registers INTENA and INTENAR ($DFF09A, $DFF01C) for more information.
----------------------------------------------------------------------------
$BFEE01 CRA          Control Register A
$BFEF01 CRB          Control Register B
Status: R/W          CIA-A
   See $BFDE00 and $BFDF00 for information on the bit layout.
----------------------------------------------------------------------------
This completes "Mapping the Amiga" from Compute! Books.  For information
on system structures, examine your C and assembler Include files.  They
have much better information than the book.
Slates from Bansai
