




                        NOTE: README.

         DUE TO THE FACT THAT THE IFF FILES THAT WAS WITH THE 
         ORIGANAL RELEASE BY DUAL CREW SHINING CAME TO A TOTAL
         OF 3MEG+ CRUNCHED. SO IN ORDER TO DISPLAY ALL FILES
         I WOULD HAVE HAD TO RELEASE A 4 DISK LSD DOCS DISK.
         THEREFORE I HAVE OMITTED THE IFF GRAPHIC IN ORDER TO 
         RELEASE THE REAL 3D V2.0 FULL DOCS ONTO ONE DISK.....
              HOWEVER, IF YOU ARE INTERESTED IN HAVING THE FULL
         3MEGS+ OF IFF GRAPHICS, LEAVE MAIL FOR CYGNUS ON 
         DIABOLICAL SABOTAGE.
              THANX TO DIRTYBRUSH FOR DOING A GREAT JOB ON THE
         REAL 3D V2.0 DOCS...
                                 CYGNUS





                          REAL 3D V2 - FULL DOCS
                          ----------------------

          By: DIRTYBUSH (aka: SNUSKIS) of DUAL CREW SHINING (DCS)
          -------------------------------------------------------

				PART 1


CONTENTS
INTRODUCTION

Chapter 1 FEATURES OF REAL 3D V.2

Chapter 2 INSTALLATION

2.1 HARDWARE REQUIREMENTS

2.2 INSTALLING THE SYSTEM

Chapter 3 USING THE MANUAL

3.1 WELCOME TO THE WORLD OF REAL 3D V.2

3.2 SUGGESTED METHOD OF READING

     3 2.1 All Users
     3.2.2 As a New User
     3.2.3 As a User with Previous 3D Graphics Experience
     3 2.4 Real-1.X User

3.3 MAJOR DEVELOPMENTS SINCE v1.42

     3 3.1 System Integration & Configurable Interface
     3.3.2 Multi.Selection Support
         3.3.2.1 Multi-selecting Objects
         3.3.2.2 Multi-selecting Functions
     3.3.3 Hierarchy
         3 3.3.1 Animation System
         3.3.3.2 Materials
         3.3.3.3 Boolean Operations
         3.3.3.4 Hierarchy References and Order
     3.3.4 Freeform Curves and Surfaces
     3.3.5 Built in Programming Language

Chapter 4 GETTING STARTED

4.1 OPENING THE PROGRAM

     4.2 FAMILIARIZE YOURSELF WITH THE MENUS & TOOLS
     4.2 1 Menus
     4 2.2 Tool Icons
     4.2.3 Hot keys
     4.2.4 Conclusion

                             - CONTENTS 1.1 -

4.3 INTRODUCTION PROJECT

     4.3.1 Loading the Project
     4.3.2 Refreshing and Rendering
     4.3.3 Animating
         4.3.3.1 "Jump To/Play To" and the Time Slider
         4.3.3.2 "Wireframe/Ray Trace" Gadget
     4.3.4 Rendering Revisited

4.4 END OF THE BEGINNING

TUTORIAL
--------

Chapter 1 OBJECT CREATION & MODIFICATION


1.1 STARTING THE PROGRAM
1.2 THE WINDOWS
1.3 THE MOUSE
1.4 BASIC TERMINOLOGY
1.5 TUTORIAL EXAMPLE 1:
    SELECT WINDOWS AND HIERARCHY

     1.5.1 The Current Level
     1.5.2 Object Multiselection

1.6 TUTORIAL EXAMPLE 2: 3D MODELLING
1.7 MODIFYING
1.8 SAVING AND LOADING
1.9 VISIBLES

     1.9.1 Polygon/Polyhedron/Polymids
     1.9.2 Sector Visibles

1.10 COMPOUND TOOLS

     1.10.1 Lathe
     1.10.2 Tube tools
     1.10.3 Rounded Polygons and Polyhedrons
     1.10.4 Object-Pixel Tool

                             - CONTENTS 1.2 -

1.11 LIGHTSOURCES

     1.11.1 The Brightness of Light Sources

1.12 MACROS

Chapter 2 THE ENVIRONMENT

2.1 ASYNCHRONOUS ACTION

2.2 SCREENS

2.3 VIEW WINDOWS

     2.3.1 Projection Types
     2.3.2 Input&Output Planes
     2.3.3 View Coordinates & Cameras
     2.3.4 booming and Positioning the View

2.4 WIREFRAME DRAWING SPEED

     2.4.1 Bounding Boxes
     2.4.2 Refresh Modes
     2.4.3 The Visible Range of the Objects
     2.4.4 Other Methods

2.5 THE MEASURING WINDOW

2.6 GRIDS

2.7 THE UNDO FUNCTION

     2.7.1 Undo and Memory Management

2.8 VECTOR STACK

Chapter 3 MATERIALS

3.1 USING MATERIALS

     3.1.1 General Information
     3.1.2 Tutorial Project
     3.1.3 Optical Properties

                             - CONTENTS 1.3 -

3.2 TEXTURE MAPPING

     3.2.1 General Information
     3.2.2 Textures
     3.2.3 Texture Mapped Materials
     3.2.4 Mappings
     3.2.5 Sector Mappings
     3.2.6 Spline Mapping
     3.2.7 Index Format String
     3.2.8 Animated Textures

3.3 ADVANCED MATERIAL FEATURES

     3.3.1 Multiple Materials
     3.3.2 Procedural Handlers
     3.3.3 Nonhomogeneous Materials
     3.3.4 Mappings and Hierarchy
     3.3.5 Some Material Morphing Examples

Chapter 4 MODELING

4.1 FREEFORM MODELLING AND POINT EDITING

     4.1.1 Curves
         4.1.1.1 Special Curve Shapes
         4.1.1.2 Multiple Control Points
     4.1.2 Selecting Points
     4.1.3 Freeforms as Levels
     4.1.4 Freeform Surfaces
         4.1.4.1 Example: Creating a Simple Mesh
         4.1.4.2 Coplanar Sweeping
         4.1.4.3 Orthogonal Sweeping
         4.1.4.4 Rotate - Creating a Wine Glass
         4.1.4.5 Swinging
         4.1.4.6 Cross-sectional Surface Construction
         4.1.4.7 Mesh-Pixel Tool
     4.1.5 Modifying Curves and Meshes
     4.1.6 Bending Functions
     4.1.7 Example: Creating a B-Spline Head

4.2 BOOLEAN OPERATIONS

     4.2.1 Wireframes of Booleans

4.3 OBJECT ATTRIBUTES

     4.3.1 Infinite Primitives

                             - CONTENTS 1.4 -

4.4 SPECIAL FUNCTIONS

     4.4.1 Use of Animation Methods for Creation
     4.4.2 COG Modifications


Chapter 5 RENDERING

5.1 LIGHTING SETTINGS
5.2 COLOR/IMAGE SETTINGS
5.3 RENDERING QUALITY SETTINGS
5.4 RAY TRACING QUALITY SETTINGS
5.5 RENDERING MODES
5.6 DITHERING
5.7 SPECIAL SETTINGS
5.8 HIERARCHY AND RENDERING
5.9 RENDERING A WIREFRAME PREVIEW OF AN ANIMATION
5.10 RENDERING AN ANIMATION
5.11 RENDERING TO A FILE
5.12 CONTINUING A CANCELLED RENDERING PROCESS
5.13 RENDERING TO AN EXTERNAL SCREEN

     5.13.1 Rendering an Animation Using External Screen
     5.13.2 External Screen Aspect Ratio
     5.13.3 Other Information

5.14 BOXES
5.15 OBJECT ATTRIBUTES AND RENDERING

     5.15.1 Scene gadget
     5.15.2 Backdrop and Matte Objects

                             - CONTENTS 1.5 -

5.16 OPTIMIZATIONS

     5.16.1 Rendering Mode
     5.16.2 Resolution
     5.16.3 Recursion
     5.16.4 Re-interpreting B-splines
     5.16.5 Reflections & Not Reflected.
     5.16.6 Shadows
     5.16.7 Other Optimizations

5.17 USING ALPHA CHANNEL
5.18 RENDERING FIELDS
5.19 MOTION BLUR
5.20 TROUBLESHOOTING

     5.20.1 Not Enough Memory
     5.20.2 Disappearing objects

Chapter 6 ANIMATION

6.1 PATH

     6.1.1 Move Object along a Path
     6.1.2 Move Objects along a Path Like a Snake
     6.1.3 Bouncing Sphere
     6.1.4 Hierarchical Animations and Bouncing Sphere
     6.1.5 Move Elastic B-Spline Mesh along a Path
     6.1.6 Talking Head
     6.1.7 Moving Objects along a B-Spline Mesh
     6.1.8 Customized Paths

6.2 ROTATION

     6.2.1 Rotating Objects Around an Axis
     6.2.2 Rotating with Different Speeds and Directions
     6.2.3 Hierarchical Rotations
     6.2.4 Tornado

6.3 SWEEP

     6.3.1 Walking Legs
     6.3.2 Tracking Guns

                             - CONTENTS 1.6 -

6.4 SIZE

     6.4.1 Beating Spheres
     6.4.2 Bubbles

6.5 STRETCH

     6.5.1 Elastic Cube
     6.5.2 Bouncing Elastic Sphere

6.6 DIRECTION

     6.6.1 Move a Logo Text along a Direction Path
     6.6.2 Swimming Fish

6.7 MOVE&DIR

     6.7.1 Rocking Logo Moving along a Straight Line
     6.7.2 The Rally Driver

6.8 CONTROL CURVES

     6.8.1 Beating and Moving Slime Ball
     6.8.2 Elastic Flying Carpet
     6.8.3 Flying Viewpoint

6.9 SIMPLE SKELETON

     6.9.1 A SIMPLE SKELETON and a Logo Text
     6.9.2 Rotate a Simple Skeleton around an Axis
     6.9.3 Elastic Skeleton and Logo Text
     6.9.4 Moving Objects along a Skeleton
     6.9.5 Rocking Spheres
     6.9.6 A Hydrogen Atom and its Electron Orbit

6.10 SKELETON

     6.10.1 Another Logo Text Animation
     6.10.2 Rotating Skin around Bones

6.11 INVERSE KINEMATICS

     6.11.1 Curl a Finger
     6.11.2 Push a Button with the Finger-tip
     6.11.3 Interactively Controlled Hierarchical Skeletons
     6.11.4 An Animated Robot Arm

                             - CONTENTS 1.7 -

6.12 MORPHING

     6.12.1 Second Talking Head
     6.12.2 Singing Heads
     6.12.3 Sing the Same Song Ten Times
     6.12.4 Morphing Hierarchical Objects
     6.12.5 Morphing Texture Maps and Materials
     6.12.6 Camera Flight Animation

6.13 TRANSFORM

     6.13.1 Piston
     6.13.2 Hesitating Piston
     6.13.3 Three Dimensional Time

6.14 RADIAL FORCE

     6.14.1 Gravity
     6.14.2 The Simplest Possible Particle Animation
     6.14.3 Customized Radial Force

6.15 DIRECTED FORCE

     6.15.1 Turbulence
     6.15.2 Snow in the Wind

6.16 TANGENT FORCE

     6.16.1 Centrifugal Force

6.17 INTERACTIVE COLLISION DETECTION

     6.17.1 Colliding Spheres
     6.17.2 Multiple Collisions
     6.17.3 Bowling Alley
     6.17.4 Drop a Ball to a Tube
     6.17.5 A Rolling Ball

6.18 NON-INTERACTIVE COLLISION DETECTION

     6.18.1 A Planet and Meteorites

6.19 FRICTION

     6.19.1 Friction and Spheres with Different Sizes
     6.19.2 Customized Friction

                             - CONTENTS 1.8 -

6.20 CREATION

     6.20.1 A Sphere Tube
     6.20.2 Boiling Water
     6.20.3 A Wriggling Snake

6.21 PROCESSOR

6.22 RPL

     6.22.1 An Easy Way to Write a RPL Procedure

6.23 WAVE

     6.23.1 Waving Sea
     6.23.2 A Water Drop
     6.23.3 Parallel Waves
     6.23.4 Waves and Ripples
     6.23.5 Waving Particles

Chapter 7 RPL

7.1 INTRODUCTION

     7.1.1 Basic Concepts

7.2 TUTORIAL

     7.2.1 Getting Started
     7.2.2 Stacks
     7.2.3 Reverse Polish Notation
     7.2.4 Parameter Stack
     7.2.5 Data Types
         7.2.5.1 Integers
         7.2.5.2 Floating-points
         7.2.5.3 Strings
     7.2.6 Stack Manipulation Words
     7.2.7 Compiling New Words
     7.2.8 Constants and Variables
     7.2.8.1 Constants
     7.2.8.2 Variables

                             - CONTENTS 1.9 -

     7.2.9 Flow Control
     7.2.10 Conditional Execution
         7.2.10.1 Comparisons
         7.2.10.2 IF.ENDIF Structure
         7.2.10.3 IF.ELSE.ENDIF Structure
         7.2.10.4 Inverting Flags
         7.2.10.5 Nesting Conditionals
     7.2.11 Loops
         7.2.11.1 Definite Loops
         7.2.11.2 Indefinite Loops
         7.2.11.3 Nested Loops
     7.2.12 Words and the Vocabulary
     7.2.13 Loading a File
     7.2.14 Using RPL Windows

7.3 USING RPL FOR CUSTOMIZING EDITOR

     7.3.1 Communicating with RPL Programs
     7.3.2 "Master" ENVIRONMENT
     7.3.3 Binding Macros to Keys
     7.3.4 Binding Macros to Icons

7.4 CREATING ANIMATIONS USING RPL

     7.4.1 Modifying Objects Directly
     7.4.2 Creating New Methods
         7.4.2.1 Do Nothing Method
         7.4.2.2 Move Absolutely Along a Path
         7.4.2.3 Chain

7.5 USING EVAL

7.6 OBJECTS

     7.6.1 Object Creation
     7.6.2 Object Instances
     7.6.3 Grouping Objects Together
     7.6.4 SphereMan

                             - CONTENTS 1.10 -

REFERENCE

Chapter 1 MENU FUNCTIONS

1.1 PROJECT
1.2 CREATE
1.3 MODIFY
1.4 VIEW
1.5 ANIMATE
1.6 EXTRAS
1.7 SETTINGS
1.8 TOOLS

Chapter 2 ANIMATION METHOD SYNTAX

2.1 PRINCIPLES

     2.1.1 General Information
     2.1.2 Built-in Methods
     2.1.3 User Defined Methods
     2.1.4 Evaluating Parameters
     2.1.5 Animation Oriented Tags
     2.1.6 Particle System Principles
         2.1.6.1 Converting Motion Properties into Real Motion
         2.1.6.2 Forces in the Particle System
         2.1.6.3 Real Time and Particle Motion
         2.1.6.4 Side-effects of Particle Animations
     2.1.7 Creating New Methods

2.2 ANIMATION METHODS

     2.2.1 PATH
     2.2.2 ROTATION
     2.2.3 SWEEP
     2.2.4 SIZE
     2.2.5 STRETCH
     2.2.6 DIRECTION
     2.2.7 MOVE & DIR
     2.2.8 CONTROL CURVES

                             - CONTENTS 1.11 -

     2.2.9 SIMPLE SKELETON
     2.2.10 SKELETON
     2.2.11 INV KINEMATIC
     2.2.12 MORPHING OPEN & CLOSED
     2.2.13 TRANSFORM
     2.2.14 WAVE
     2.2.15 RADIAL FORCE
     2.2.16 DIRECTED FORCE
     2.2.17 TANGENT FORCE
     2.2.18 COLLISION
     2.2.19 INT COLLISION
     2.2.20 FRICTION
     2.2.21 CREATION
     2.2.22 PROCESSOR
     2.2.23 RPL

Chapter 3 RPL SYNTAX

3.1 KERNEL WORDS
3.2 OBJECT CREATION WORDS

     3.2.1 Geometry
         3.2.1.1 fStAngle & fEnAngle
         3.2.1.2 wGeomFlags
         3.2.1.3 wFreeType
     3.2.2 iColor
     3.2.3 Attributes
         3.2.3.1 Name
         3.2.3.2 Object Flags
     3.2.4 Tags
     3.2.5 Return Value
     3.2.6 Word Definitions

3.3 MODIFICATION WORDS

     3.3.1 Modify Flags
     3.3.2 Locking Object Data
     3.3.3 Word Definitions

3.4 OBJECT WORDS

     3.4.1 Return Value
     3.4.2 Locking Data Structure
     3.4.3 Word Definitions

                             - CONTENTS 1.12 -

3.5 ANIMATION WORDS
3.6 I/O WORDS
3.7 MATERIAL WORDS
3.8 MISCELLANEOUS WORDS
3.9 USER INTERFACE WORDS
3.10 AREXXWORDS
3.11 VECTOR OPERATIONS

Chapter 4 GEOMETRIC OBJECT PROPERTIES


4.1 GEOMETRIC PROPERTIES

     4.1.1 Surface Definition
     4.1.2 COG
     4.1.3 Direction
     4.1.4 Size

4.2 DEFAULT GEOMETRIC PROPERTIES

Chapter 5 TAGS

5.1 TAG IDENTIFIERS
5.2 RESERVED TAG IDENTIFIERS

Chapter 6 AREXX INTERFACE OF REAL 3D

6.1 GENERAL
6.2 AREXX VS. RPL
6.3 SENDING AREXX COMMANDS TO THE PORT OF REAL 3D
6.4 RETURN VALUES


                             - CONTENTS 1.13 -

6.5 RESULT STRING
6.6 CLIP LIST
6.7 SENDING AREXX COMMANDS FROM REAL 3D
6.8 RETURN VALUES FROM OTHER APPLICATIONS
6.9 RESULT STRINGS FROM OTHER APPLICATIONS

APPENDICES

Appendix A PREDEFINED ICONS

Appendix B HOT KEYS AND MENUS

Appendix C UTILITY SOFTWARE

C.1 CONVERSION SOFTWARE

     C.1.1 RealConvert
     C.1.2 DxfToRPL

C.2 IMAGE & ANIMATION DISPLAY

     C.2.1 Display
     C.2.2 DeltaConvert
     C.2.3 DeltaPlay

GLOSSARY

INDEX

                             - CONTENTS 1.14 -

INTRODUCTION
------------

Chapter 1 FEATURES OF REAL 3D V.2
---------------------------------


Program Description

REAL 3D V.2 is a design and animation program for producing high quality
realistic images of three-dimensional objects.
3D Desktop animators, creative computer artists, product designers,
teachers and everyone interested in compiler generated imagery will find
REAL 3D V.2 a very useful and unique tool.
This new version introduces a large collection of state-of-art features,
making REAL 3D V.2 one of the most powerful 3D packages available to
desktop computer platforms.

Integrated Environment

The mode-less design principles of REAL 3D V.2 mean that the user can
directly access most functions of the program simultaneously.
F or example: it is possible to modify a material and immediately see how
the modification affects the rendered image.

Configurable Environment Expendability

The REAL 3D user interface is fully configurable. You easily are able to
design different working environments to meet requirements of different
applications.
For example: REAL 3D V.2 can be used as a single view editor, a tri-view
editor or perhaps a 9-view editor. It is possible to expand the program
by defining new functions and binding them to icons and keys.

Zero Wait State Design

The asynchronous software design, implemented using the latest techniques
of object-oriented programming, takes extensive advantage of multi-tasking
operating systems. In this way maximum convenience and productivity are
achieved when modelling. The user never has to wait until some function
has finished; instead, he can continue with new actions while old ones
execute as background tasks.

Hierarchical Object-Oriented Construction of Objects

With REAL 3D V2, objects can be created with hierarchical structure. This
means that the objects are made of sub-objects, and these sub-objects may
have their own sub-structure and so on. This kind of tree structure is
well known in the context of disk operating systems in which directories
are created inside other directories.
In REAL 3D the counterparts of these directories combine objects into
logical groups. This approach makes, for example, object modifications
extremely easy because it is possible to perform operations to each
logical entity separately or collectively. When copying a DOS directory,
it is not necessary to take care of the individual files and directories
inside it. In the same manner , a complex object can be stretched in
REAL 3D as easily as one part of it.

Ray Tracing

The ray tracing calculations of REAL 3D are strongly based on the optical
properties of materials in the real world. REAL 3D produces images by
simulating the laws of optics, and consequently they represent reality
with astonishing accuracy.

Speed

Innovative methods and new ray tracing algorithms make REAL 3D extremely
fast. Ray tracing in REAL 3D V.2 is so incredibly fast that it is usable
as a primary re-drawing method instead of wire-frames during the
interactive modelling process.

                           - INTRODUCTION 1.1 -

Rendering Techniques

As well as the ultra fast wire-frame refreshing, REAL 3D V.2 includes
six different rendering techniques: hidden-line wire-frames, high speed
basic surface rendering, simple ray tracing with non-interactive
environment-mapped reflections, single light-source ray tracing,
rendering without shadows, and full featured ray tracing.

Light-sources

it is possible to use an unlimited number of light-sources with any
desired color and intensity. Smooth edged shadows can be produced using
diffuse light-sources.

Anti-aliasing

REAL 3D V.2 includes adjustable anti-aliasing.
There are 9 different degrees of anti-aliasing, from which the user can
select a suitable level. The most accurate level uses 256 * 256 adaptive
over-sampling, which is enough for any application!

Depth-of-Field

Using a highly optimized algorithm, depth-of-field can be used even for
very complex scenes. There is no significant impact on rendering time.

Motion Blur

The Rendering Engine also supports a sophisticated motion blur evaluation
system that can be applied to whole scenes or individual objects
selectively. The use of adaptive over-sampling makes this evaluation
faster than other software on equivalent platforms.

Draft rendering

For drafting purposes it is possible to render with low resolutions to
produce images faster. Rectangular areas of an image can be individually
selected and rendered with any desired techniques: resolution,
anti-aliasing level, etc.

True Solid Modeling

REAL 3D V.2 includes CSG (Constructive Solid Geometry) modelling.
Solid modelling is the most sophisticated way to represent three
dimensional objects. For example, solid modelling offers general boolean
operations and makes it possible to simulate optical devices, like lenses,
correctly.

Mathematical Surfaces

In addition to polygonal surfaces, REAL 3D V.2 includes several curved
surfaces such as: ellipsoids, cylinders, cones and hyperboloids.
The surface descriptions of these surfaces are defined mathematically.
This means that no matter how much a sphere created by REAL 3D V.2 is
enlarged, no edges, corners, or other artifacts become visible on its
surface. This makes the program much faster, and most importantly, the
resultant images are of very high quality.

Boolean Operations

Using boolean operations between objects, you can for example, split an
object into two pieces and move the pieces apart so that the inner
structure of the object is revealed. Operations can alter the properties
of the material of the target object using the properties of the tool.
By using a shiny cylinder, a shiny hole can be drilled into a matt object.
These operations are a powerful way to create and modify objects.
When modelling technical objects these boolean operations are especially
indispensable.

                           - INTRODUCTION 1.2 -

Compound Tools

Complex shapes constructed by automatically combining basic primitive
objects.

Polygonal Surfaces

Conventional polygonal surfaces with optional Phong Shading are included.

B-spline Surfaces

Uniform cubic B-spline surfaces provide the user with a very powerful way
of representing curved free-form surfaces and organic shapes.
The quality of shaded B-spline surfaces is far superior to polygonal
surfaces with Phong Shading.

Free-form Construction

A large collection of free-form surface construction functions are
provided including: co-planar and orthogonal sweeps, rotation, cross-
sectional building, etc.

Linear Modifications

All the necessary functions for modifying the basic shape and properties
of objects are included.

Non-linear Transformations

Nearly one hundred non-linear transformations and bending functions are
available for altering the shape of free-form surfaces.

Fractal Generators

Two fractal generators are included for constructing "landscapes" and
"trees".

Material Properties

Using the hierarchical structure it is possible to construct objects
from different materials having suitable physical properties. All material
properties can be adjusted without any restrictions. Even the refractive
index of light is freely adjustable so that it is possible to create
optical devices from glass lenses. These devices act as their real-world
counterparts: a magnifying glass in REAL 3D really magnifies!

Texture Mapping

The texture mapping properties of REAL 3D V.2 are not restricted to any
fixed patterns. Any image file can be used to paint objects.
Pictures created with any paint program, video digitizer, or scanner can
all be used to color the surface of an object. For example, by digitizing
a wood-grain pattern, it is easy to create wooden objects that look very
realistic. In REAL 3D V.2 textures are treated as objects and are a part
of the object hierarchy which means that textures can be modified and
animated just as easily as any other object.

B-spline Mapping

Textures and images can be mapped over the surface of a B-spline mesh so
that they exactly follow the curvature of the mesh object. The B-spline
object can be modified or animated and its texture will move with it like
a skin.

Procedural Textures

As well as using image files to define material properties, an unlimited
number of mathematical handlers can be used. The user can write arbitrary
formulas defining the color, bump-mapping, and other material properties.
Many built in procedural handlers are included.

                           - INTRODUCTION 1.3 -

Multiple Textures

Objects can have multiple textures and materials. Furthermore, the
materials can be faded and mixed.

Animation Support

The new version introduces a revolutionary animation system which extends
the object-orientation principles to the process of defining the animation
methods for each object. In the new animation system, the motion
description is a natural part of the object structure. The built-in
animation methods include such features as: basic motion and shape
modification, morphing and skeletonal control using inverse kinematics.

Particle Animation

There is also one of the most powerful particle animation systems
available integrated into the animation system. Using these animation
methods objects are treated as particles that can have various physical
properties like: velocity , spin, mass, and surface-friction.
They can then be made to collide and interact just like objects in the
real world.

Interactive Replay

REAL 3D also includes software for showing rendered animations
interactively.

Macro Functions

it is possible to combine REAL 3D functions to form macros either by
recording the mouse and keyboard actions, or by creating the descriptive
text using the built in programming language. With macros the user can
easily create complex symmetrical forms or produce animation effects.
Macros can be saved, loaded, and bound to keys and icons.

RPL Language

REAL 3D contains a fully featured programming language called RPL.
The language offers the most powerful interface to the software and can
even be used for accessing operating system functions. RPL is used for:

- expanding the program features
- macro recording
- scene description and saving
- particle and procedural animation methods
- procedural material properties

Two formats are available: a binary and an ASCII format. The binary format
offers efficient and fast way of storing a scene description, whereas the
ASCII format, based on RPL programming language, is machine independent.

Tag Expansion

Object and material data structures can be expanded using tags. Tags are
also used in particle animations where the tag data attached to an object
can determine the behavior of the object.

AutoCAD Interface

REAL 3D supports importing AutoCAD DXF format.

Mattes and Background

The 3D images rendered by REAL 3D are easily integrated with digital
backgrounds. By using other objects to act as "mattes", rendered objects
can be made to "pass behind" parts of the background. When used correctly
with the animation system these techniques allow direct combination of 3D
graphics and "live" action.

                           - INTRODUCTION 1.4 -

Alpha channel

The REAL 3D Rendering Engine provides support for graphics hardware with
an alpha-information channel. By using the alpha-channel as a video key,
ray traced scenes can be combined with video without the need to digitize
it in advance.

image Output

The protocol for output devices is well designed and flexible. This allows
for graphics hardware manufacturers to easily write the software needed
for using their hardware with REAL 3D.

Field Rendering

Rendering of separate fields is also supported by the software.

Chapter 2 INSTALLATION
----------------------

2.1 HARDWARE REQUIREMENTS

REAL 3D V.2 has the following hardware requirements:

- At least 3 megabytes of RAM memory
- A hard disk with at least 5 megabytes of free-space for the software
- MC68020 (or higher, e.g. 68030/68040) processor
- A math coprocessor

For professional users we recommend a configuration with at least 5
megabytes of RAM memory and at least 10 megabytes of hard disk space
reserved for the REAL 3D environment.

The special 68040 optimized program version has been tested to be up
to 8 times faster in rendering than the 68030 version running equal
clock frequency.

2.2 INSTALLING THE SYSTEM

Before you use your REAL 3D disks, make working copies of the originals
by using either Workbench-duplicate operation or some copying program.
This guarantees that if a disk is corrupted accidentally, you will still
have a good copy.

To use the software, you need a hard disk. To install the software to
your hard disk, just double click the InstallHD-icon on the first program
disk and follow the instructions. For successful installation, there must
be at least five megabytes of free hard disk space.

After installation, remember to add "assign R3D2: Partition:R3D2" command
to your startup-sequence (preferably to the s:user-startup file), where
"Partition" refers to the hard disk partition you chose.

For your convenience, REAL 3D maintains information of the DOS directories
that contain the data structures created with the program, for example:
project, material, and object structures. The default directories are the
directories found in the software package.
You can change them by using Settings/Paths function and then by using
Project/Environment/Save function , save the working environment as
"s:real-startup". The directory paths are included in the project file,
and when you next run the program and try to load some data, the relevant
directory is immediately displayed (if it still exists).

The automatic installation procedure creates a directory under which it
copies the contents of the program disks. Furthermore, it adds two files
to the s: directory, real-startup and RPL-startup. Real-startup is a
project file, containing the default user interface. RPL-startup contains
the initial RPL definitions of which the most important are the default
keyboard binding definitions or Hot-Keys.

                           - INTRODUCTION 1.5 -

Chapter 3 USING THE MANUAL
--------------------------

3.1 welcome to the world of REAL 3D V.2

REAL 3D V.2 is an extremely powerful tool for creating realistic computer
graphics images and animations. Once you have grasped a few basic
principles you will find it very interesting to use. This manual is
designed to gently take you through the learning process. Very soon you
will be creating some very cool images and animations that previously
you didn't think possible on a desktop 3D platform.

3.2 Suggested Method of Reading

3.2.1 All Users

The manual contains six different sections:

INTRODUCTION - Introduces you to the program and gets you started.

TUTORIAL - Takes you through all the functions in easy steps with lots of
           examples. There are also text and files in the "Examples"
           directory to help.

REFERENCE - This contains concise descriptions for the menu functions and
            for each gadget on all the requesters.

GLOSSARY - REAL 3D V.2 uses a number of special terms and phrases to
           describe the items you create and how certain functions
           operate. These are all defined in this section.

APPENDICES - All the miscellaneous information: diagrams of icons,
             descriptions of hot-keys, and using the support software
             is contained in this section.

INDEX - A full index.

In Chapter 4, "Getting Started", there is a special project for you to
load with instructions to follow so that you can experiment and get a
quick taste of the power of REAL 3D V.2.

3.2.2 As a New User

If this is the first time you have ever used a 3D graphics program then
using REAL 3D will be a real experience! You should go straight to
Chapter 4 and follow the instructions carefully. Take your time, be
patient, the whole world of Virtual Reality and Computer Generated
Images & Animations lies before you...

You should now go to Chapter 4 "Getting Started".

3.2.3 As a User with Previous 3D Graphics Experience

If you have used 3D graphics packages before, but never any of the
previous versions of REAL 3D then you should pay special attention to the
Tutorial. REAL 3D is on the cutting-edge of 3D graphics software, and
contains many new ideas and principles which make it probably the most
powerful computer graphics development tool available on ANY platform.
It is quite different from other packages; but in this difference lies
its power.

REAL 3D V.2 gives you, the user, a highly flexible editor for creating
the shapes and materials you desire using a working environment you can
configure to your own personal requirements (or even the requirements of
a particular project). This editor is smoothly integrated with a highly
optimized rendering engine that will provide you with ray-traced images
in the minimum of time. If draft rendering is used on a fast workstation
then it is quite practical to edit using shaded surfaces.

The next sub-chapter is directed at users who already have some experience
with REAL 3D from the original version. To get immediately into learning
the new program just go to Chapter 4; but if you are interested in the
history of REAL 3D's development then read on...

                           - INTRODUCTION 1.6 -

3.2.4 Real-1.X User

About 4 man-years of programming effort has been put into developing
version 2.0 from 1.42. Understandably the program has changed
considerably, but the basic principles of creating objects using
primitives, arranged in a hierarchy, remains.

The way that hierarchy is used to control and construct objects has been
expanded. Animation is no longer based upon "exposed' frames or objects
but upon new structures created in the hierarchy to describe how objects
should move and transform.

The whole user-interface has changed radically and many new features have
been added. Once you discover the power behind these new features they
will rapidly become essential tools that you would not want to do without.

Almost all of your old friends are still there, they are just living in
different places! Some functions have been replaced by much more powerful
and flexible tools to cope with the expanded features of the program.

The next sub-chapter is for you. It describes briefly most of the new
developments, but it is not supposed to be a substitute for learning the
new version. By all means experiment with the new features using your
experience of the earlier versions of REAL 3D, but if you don't get the
results you expect then consult the TUTORIAL, it's there to help!

3.3 MAJOR DEVELOPMENTS SINCE v1.42

3.3.1 System integration & Configurable interface

The most immediately obvious change is that there are no longer three
separate parts to the program. In REAL 3D V.2 object creation,
modification, animation, and rendering can all be carried out on ONE
screen. It is possible and often necessary to use more than one screen
but the way in which screens are used can be configured by the user.

This is handled by allowing the user to open screens that suit a
particular requirement and opening one or more windows on that screen.-
These windows do have specific functions depending upon their type,
but each can be configured to meet your needs.

It is also possible to declare one of these screens the default public
screen (OS 2.0 feature). This means that certain OS 2.0 compatible
programs can be integrated into REAL 3D. Conversely it may also be
possible to integrate into those packages that also use public screens.

A particular configuration of screens and windows can be saved as an
"environment" and then loaded at any time.

This configurable environment allows the creation of user-defined tool
gadgets and single-key macros to extend the user interface.

3.3.2 Multi-selection Support

The OS principle of multi-selection has been included in v.2. It is now
possible to select lists of objects or even menu selections or tool icons.

3.3.2.1 Multi-selecting Objects

Multiple objects can be selected from a Select Window using<LMB><SHLFT>
or <DRAG> in the same way as selecting icons on WorkBench. These objects
then form a list which can be used as a target for any of the modification
functions or as operands for some creation functions. This is an essential
technique for those functions which require two or more objects as
operands.

                           - INTRODUCTION 1.7 -

3.3.2.2 Multi-selecting Functions

An Action List is maintained for keeping all functions selected by the
user. As many functions as required can be placed on this list by clicking
<LMB> either on the Tool Icons or on a menu selection. These functions can
then be used consecutively until the list is empty. The list operates on a
First In First Out (FIFO) basis.

3.3.3 Hierarchy

The use of the hierarchy has been substantially expanded by the addition
of many new primitives and the functions to control them.
Probably the most important changes to the hierarchy concern: the
animation system, materials, and boolean operations.

3.3.3.1 Animation System

The animation system is completely new. Animations are no longer based
upon frames and exposed objects. Instead time is now a global value that
controls how objects are animated and there is a special window (the
animation window) for controlling time. Time is continuous and any moment
in time can be selected and the position and state of all animated objects
can be viewed for that time. Moments in time, or frames, only become
animations when they are rendered.
Animation effects (called methods) i.e. PATH, SWEEP, COLLISION, etc.,
are now attached to objects in the hierarchy. These "methods' can effect
all those objects at the same hierarchical level, and some can even effect
other methods. This means it is possible to build the animation of a
complex object up in stages:

- Make a thigh rotate about a hip.
- Make a shin rotate about the knee of the thigh.
- Make the whole leg run along a path.

This whole object can then be positioned anywhere in space and it will
carry out its actions when animated.

All methods can be copied and modified by the modification functions just
like any other object. If their animation effects are controlled by other
objects which have some geometry then their effect will be modified with
them. So the running leg can be duplicated to make a pair and, with a
little bit of modification of size and position, can also become the arms
for a running man. These animated objects can then be saved by the user.

3.3.3.2 Materials

Materials are now associated with objects in the hierarchy in the same way
as methods. These textures also effect objects in the same level.
This means that several material properties can be applied to a visible
(object) to produce extremely complex properties.

For example:

- A "shiny" material with no geometric texture can be used with a cylinder
  to make a metal tin can

- A picture of a label can be used as an image and "wrapped" onto the tin
  with a cylindrical texture.

- A third material can have mathematically defined circular "ridges" bump-
  mapped onto the ends of the can using a procedural handler.

Since the textures can also have a geometrical representation, that is,
a rectangular parallel projection would be represented by a dotted
rectangle on the editor screen, they can be modified just like any other
geometric.

This means they can be re-positioned, sized, and stretched until they are
in precisely the required place. Also a texture is just another object so
of course it can be animated!

                           - INTRODUCTION 1.8 -

3.3.3.3 Boolean Operations

Boolean operations are now applied to all objects at the same level of
hierarchy instead of between just two operand objects. This means that if
a level is turned from boolean type OR (the default) to AND then the
resultant visible will consist of the over-lapping volume of ALL the
objects in that level, including any other booleans.

The AND NOT operation is achieved by applying the "Inverted" attribute to
one or more of the objects in the level. By setting an objects "Paints"
attribute, the "WITH PAINT" effect from the earlier versions is produced.
All these settings are available in the object attributes requester opened
with MODIFY/properties/Attributes, or there are functions under the
CREATE/Boolean menu which use operands selected from the hierarchy with
multi-selection to create the final composite.

3.3.3.4 Hierarchy References and Order

In addition to the old feature of "logical objects" (now called levels),
which allowed new objects to be grouped at different levels of hierarchy,
there are two new objects which alter the evaluation of the hierarchy.
These are groups, which are references to a collections of points on a
free-form, and links, which allow other parts of the hierarchy to be
referenced at the current level.

3.3.4 Free-form Curves and Surfaces

The major new feature is the addition of cubic B-spline curves and
surfaces for the construction of free-form objects. B-splines can be
controlled in a similar way to the original free-form objects in v1.42,
but the quality when rendered is significantly higher even when the
surface is constructed from very few data points.

There are some restrictions about using B-splines and some basic tricks
to learn. Also the calculations involved in rendering them are staggering,
so although the rendering engine has been specially optimized to cope,
they are not as fast as Phong Shaded surfaces.
The quality is well worth the wait though.

3.3.5 Built-in Programming Language

Finally, REAL 3D V.2 has its own programming language, RPL, which allows
any function the user requires to be integrated easily into the software.

Chapter 4 GETTING STARTED
-------------------------


This chapter takes you through the first stages of using REAL 3D V.2.
The main part of this chapter takes you step by step through a REAL 3D
project which has been prepared specially to introduce you to most of the
fundamental principles. It should also show you the potential of this
incredibly powerful computer graphics design tool.

4.1 OPENING THE PROGRAM

You should have already installed the program to your hard-drive, if not
go through the steps in 2.2 above before proceeding.

Now open the drawer where you installed the REAL 3D system and double-
click the icon "Real" using the left mouse button. From now on this will
just be described as double-clicking and the left mouse button will be
abbreviated to <LMB>. The program is quite large and will take a few
moments to load.

                           - INTRODUCTION 1.9 -

When the program first loads you will be presented with your first REAL 3D
working environment.

This initial environment consists of just three windows. The large almost
square window with a thin border is a view window. Through this window you
look into the REAL 3D universe.

The small window in the bottom right corner is a tool window or tool-box.
This contains a number of tool icons.

The third window on the right is a select window. This is used for
selecting objects from the hierarchy which is the special way that REAL 3D
stores all its objects. In some ways this is the most important of all the
windows in the REAL 3D system. Understanding how hierarchy and object
selection works it the key to unlocking the power behind REAL 3D.

This may seem to be a very simple arrangement, but it provides you with
all the basic windows and tools you will need to experiment with the
introduction project. Later you will learn how to re-configure your
environment to suit your own requirements.

4.2 FAMILIARIZE YOURSELF WITH THE MENUS & TOOLS

4.2.1 Menus

Just use the right mouse button (this will be shown as <RMB> from now on)
to browse through the menu lists. Soon you will find that they are very
logically laid out and it is easy to remember where each function lives.

Example 1:
Create a sphere with a menu function.

1. Select the menu function Create Visibles/Sphere.

Note:
This means hold the <RMB> down and slide the pointer along the top menu
strip until you come to the second heading "Create". Then move the pointer
down to the first sub-menu called "Visibles" . Still holding the <RMB>
down move over the sub-menu until the pointer is over the function
"Sphere". Finally release the <RMB>.

The name of the function you selected appears at the top of the view after
the text "Next:". This tells you that the next function on the Action List
will be to create a sphere.

2. Click the <LMB> once somewhere near the middle of the view.

Note:
You must just quickly click the button, don't hold it down otherwise you
will get a <DRAG> box which has a special use. If you do get a <DRAG> box
don't worry, just let go of the <LMB> and REAL 3D will automatically
select the start point for your sphere.

3. Move the pointer.

                           - INTRODUCTION 1.10 -

As you move the pointer you will see the wire-frame representation of the
sphere you are creating drawn with a dark broken line. A wire-frame is
just a very fast way of representing the shape of a three-dimensional
object on the two dimensional surface of your monitor.

4. When the sphere is the size you want just click the <LMB> again to
   complete the creation process.

The wire-frame is drawn with a solid white line, and the name "ellipsoid"
appears in the select window.

4.2.2 tool icons

You can also see a window containing a number of tool icons which provide
single click access to many of the most frequently needed functions.
There are more icons available, only the basic ones are currently in the
tool window. You can find out how to add more icons to your tool box and
even create your own in the TUTORIAL section.

Example 2:
Using the Create/"Sphere" tool icon to create a second sphere.

1. Click on the icon in the tool-box. The icon is second one of the fourth
   icon row.

2. Select the center for the sphere using the <LMB> as you did in step 2
   of Example 1 . Select a point away from your first sphere so that the
   new one will not overlap.

3. Follow steps 3 & 4 above.

You should now have two wire-frames of spheres and the Select Window will
have the names "ellipsoid" and "ellipsoid.1" on the list of objects.

4.2.3 Hot-keys

You might want to see what your spheres look like when shaded so follow
the following example.

Example 3:
Invoking the rendering engine using a hot-key.

1. Press and hold the right Amiga key (<RAM> from now on).

2. Press the "r" key. Pressing the shift key is unnecessary, the hot-keys
   are not case sensitive.

Note:
Make sure you have the view window active. Click on it or check to see if
it is "highlighted".

You have just used the hot-key <RAM>r to start rendering. The rendering
engine will produce a shaded image of your two spheres using its Draft
setting. Your environment was set up with 8 levels of gray, but most other
graphics modes are supported. The rendering engine is the part of the
REAL 3D system that draws your objects as shaded surfaces instead of
wire-frames.

4.2.4 Conclusion

That is how easy it is to create and render objects using REAL 3D.
Obviously it will take some practice to create complex scenes and
animations, but follow the next sub-chapter through and you will begin
to see the potential...

                           - INTRODUCTION 1.11 -

4.3 INTRODUCTION PROJECT

A special set of files have been prepared to accompany this manual, you
will use the first of these now in order to get a brief taste of the
power of REAL 3D V.2. If you are new to REAL 3D and especially if the
whole process of using the Amiga is new to you, take your time and read
the instructions carefully. Everything has been arranged in a concise
and logical fashion to make it easy for you. Just follow the instructions
and the manual will guide you through.

4.3.1 Loading the Project

The first thing you need to do is load the introduction project.
A REAL 3D project contains the information necessary to define a scene
or animation in the REAL 3D universe.

Example 4:
Load a new project.

1. Select the menu function Project/Project/Replace using the same
   process for menu selection as described in Example 1 above.
   A standard file selector is opened.

This is the basic style of requester for loading and saving files.
It shows the files that are available in the current drawer as a
selection list, and a number of other gadgets for controlling which types
of files are shown and for moving to different drawers and partitions of
your disk.

Note:
To select a file, move the pointer over the name of the file in the list
and click <LMB> . The file name will be high-lighted and at the same time
it will appear in the "File" text-gadget box.

2. Select the "Intro.prj" file. Then move the pointer over the OK button-
   gadget and click <LMB>.

REAL 3D has loaded a new set of windows as part of the working environment
for the "Intro" project. You can see a view, a select window, and an
animation window. The animation window contains all the gadgets for
controlling animation playback and recording (much like VCR controls).
You will find out how to use some of these gadgets shortly, the rest are
explained in the TUTORIAL. This window has been opened on its own private
screen. For the moment slide the animation window down out of the way by
following the method :

3. Move the pointer over the dark bar at the top of the Animation Screen,
   press and hold the <LMB> and then move the pointer down to slide the
   screen out of the way. When you can see all the view then release the
   <LMB> to let go of the screen bar.

Now you can begin to investigate the features of the project.

                           - INTRODUCTION 1.12 -

4.3.2 Refreshing and Rendering

Example 5:
Testing refreshing and view projection types.

1. Move the pointer onto the view window, click <LMB> to make it the
   active window, then press the <ENTER> key.

Pressing <ENTER> has refreshed all the windows. Now you can see the
wire-frame representations of the objects in this REAL 3D universe.

Note:
An object is any item like a shape or surface that is stored in the
special structure called the hierarchy. The principle of how objects are
stored in hierarchy is very important to understanding REAL 3D, but for
now just think of the hierarchy as like your hard-drive.
It can contain different types of objects and can have different
"drawers" for putting objects in.

2. To see the wire-frames in perspective select the View/Type menu, and
   click the <LMB> once on the "Perspective" item. A check mark will
   appear on the left to show that this type is now selected.

Note:
Before you clicked on "Perspective" you may have noticed that the View
Projection Type was "Parallel". This type of projection produces the kind
of wire-frame views used by most CAD programs.

3. Now try pressing each of the different cursor keys several times.

You will see that as you press the keys the wireframe image rotates. You
can continue to rotate in any direction until you come right back to the
starting position.

                           - INTRODUCTION 1.13 -

Note:
If you find the direction of the rotation confusing then you should
realize that it is rotating the View about the objects in the same way as
you move a camera or turn your head. If you turn your head to the left
(left cursor key or <LCK>) then what you are looking at moves to the
right.

4. To re-display your starting position use View/Display/Reset or <RAM>e.
   The view returns to its original viewing position and the wireframes
   are re-drawn.

Example 6:
Experimenting with rendering techniques.


1. For the simplest rendering select the function View/Render/Window.
   "Simple Shaded View of Introduction Project"

The wire-frame image is quickly replaced by one showing the objects as
gray shaded surfaces. As it was when you pressed <RAM>r, the view has
been refreshed using the simple shaded surface rendering mode called
"Draft". This is a special very high-speed technique used by the
rendering engine which just gives you the fastest possible truly three
dimensional representation of your visible objects. It is possible, on
a fast workstation, to use this mode as part of your interactive
editing of objects.

2. Select the function View/Render/Settings.

                           - INTRODUCTION 1.14 -

This will open a Render Settings Requester Window with many gadgets that
covers most of the screen.

Note:
These gadgets are easy to learn and will give you complete control of how
the rendering engine converts your scene into an image.

3. Move the pointer up towards the top left hand corner of the render
   settings requester and find the gadget labelled "Mode". You will see
   that the actual button is showing that it is in "Draft" mode. Click
   once on this cycle-gadget and the rendering mode will change to
   "Environment.

4. Now move down to the bottom left corner and select "OK" to confirm the
   change. This will close the window.

5. You should now render the view again.

Note:
You have used the hot-key <RAM>r before, so you can use it from now on
whenever you want the rendering engine to refresh a view.

                           - INTRODUCTION 1.15 -

Remember:
Using <RAM>r ONLY affects view windows, so you must make sure that one is
active by clicking it; otherwise nothing will happen.

The scene is re-drawn, only this time the big sphere is striped and shows
the realsoft Logo, and the base has a chequered pattern.

Note:
"Environment mode is the first rendering mode that uses materials when it
creates the image. If you want to create realistic looking scenes you have
to be able to describe how an object affects the light which falls on it.
This is done by defining a material and applying it to the object.
The TUTORIAL explains all the details of creating and using materials.

6. The image looks a bit "over-exposed" so you should make another small
   adjustment to the render settings. To open the render settings
   requester, you can use the menus, or the hot-key <RAM>s. Now find the
   slider-gadget labelled "Brightness'. (It's on the left, near the
   bottom.) To the right of the slider is a number, currently it shows the
   value of "Brightness' as 100. Move the slider until this value is
   between 70 and 80; then confirm the change with "OK', and render the
   view again.

Note:
To move the slider, just position the pointer over the dark rectangle,
hold the <LMB>, and move the mouse from right to left.

When the rendering engine produces the image this time, the over-all level
of light is reduced so those bright parts of the scene that had become
overexposed are now at a more natural level. This is just like adjusting
the "Contrast' control of your monitor.

7. If you want to see what this scene looks like now in color, select
View/Render/HAM. This will open render settings so you can make any last
minute adjustments before rendering. You can look at one more feature of
the rendering engine by clicking on the check-gadget labeled "Backgr.
gradient". A check mark will appear on the button to show that this
feature is enabled. Everything else should be just perfect so click "OK".

REAL 3D automatically opens a HAM screen with a full-screen window with
no border. This type of window is called a borderless view. The rendering
engine is also started. You will see the scene rendered in color this
time. The background will be shaded from a light to a darker gray.

We will now have a look at some of the features of the animation system.

4.3.3 Animating

Example 6:
Playing an animation.

1. First you should close the HAM screen. Select the function
   Project/Environment/Close - Current.

REAL 3D closes the borderless view and the HAM screen leaving you with
your original environment.

2. Use the same method as you did in Example 4, step 3 to get hold of
   the title bar of the animation screen and drag it so you can see all
   the gadgets as far down as the one on the right showing "Wireframe'.

3. Click the "Play Forwards" gadget labelled with "->|".

This will play a wire-frame pre-view of the animation.

                           - INTRODUCTION 1.16 -

4. When the anImatIon play stops, click the play backwards gadget on the
   Animation Window. "l<-".

5. The wire-frame animation will now play backwards.

You will notice that the small bouncing sphere has not ended up in its
original position. The reasons for this is that its animation is
influenced by "Particle Animation" and it requires some special handling
that will be discussed later in the manual. For now, just remove this
part of the animation:

6. Move the pointer onto the select window and click once on the object
   name "Particle_Sys".
   The name "Particle_Sys" is now high-lighted to show that it is a
   selected object.

7. Now select the function Modify/Structure/Delete.

The object "Particle_Sys" has been deleted. Its name is removed from
the select window and the wire-frame of the bouncing ball is missing
from the view. This is because the Particle_Sys object was actually
several objects, including the visible ones, contained in a single
drawer-like object which is called a level in REAL 3D terminology.

8. Now you can try all the other "VCR-like" button-gadgets on the
   animation window, and the animation will behave exactly as you expect.

Note:
As you play with the gadgets notice what happens with the "knob" on the
"Time" slider gadget and to the numbers in the box to the right of it.
They show the animation time which is always between 0.0 and 1.0.

4.3.3. 1 "Jump To/Play To" and the "Time Slider"

Example 7:
Testing the "Time Slider" controls.

1. Use the <LMB> to hold the "knob" of the slider as you did with the
   "Brightness" control of render settings. Now move it to a new time.

Time goes immediately to the new value, and the view is refreshed showing
the position of "Animation Obj" for that time. If you cannot clearly
determine the position from the wireframes just click on the view and use
<RAM>r to render the image.

Remember:
If "Environment" mode is too slow for your workstation then change it to
"Draft" using render settings.

2. Click on the cycle-gadget which is showing "Jump To". It will change
   to "Play To". Now when you change time with the slider the animation
   is played from the current time to the new value.

4.3.3.2 "Wireframe/Ray Trace" Gadget

There is one last gadget that you should look at while "Getting Started".
This controls how the animation system refreshes your view while it plays
back the animation.

Example 8:
Testing Animation Refresh

1. Use one of the Time controls to set the animation at the start. Now
click on the cycle-gadget showing "Wire frame". It changes to "Ray Trace".

                           - INTRODUCTION 1.17 -

2. Now change time slightly.

The animation system updates the position of the animated objects and
invokes the rendering engine to update the view. The system continues
shading new images until the time value you gave is reached. You can stop
the process by <LMB> clicking the CANCEL button.

4.3.4 Rendering Revisited

Just before you leave the INTRODUCTION to begin the TUTORIAL you might
like to look at the full power of the rendering engine. The following
example does not describe any details of the functions you will use.
It is just here to allow you to see how realistic the images are that
REAL 3D can produce.

Example 9:
Producing an image with soft-shadows and depth-of-field.

1. Use Project/Project/Replace to load a new copy of "Intro.prj".

2. Click on the view and then change the View/Type to "Perspective".
   Then use <RAM>- twice to zoom the display out.

Note:
You may have to press the <SHIFT> key to get the "-" function.

3. Now change the "Jump To" control for the time slider to "Play To" and
   set the time to about half-way through the animation.

Remember:
If you want the bouncing ball to be correct, you can only move
timeforward.

4. To start the rendering, click on the view and select View/Render/HAM
   or use <RAM>h.

5. When render settings opens, change the "Mode" to "Normal", set
   "Brightness" to about 75, and enable "Background gradient" as you did
   before.

6. Now use the two slider gadgets above "Backgr. gradient" to set
   "Antialiasing" to 3 and "Lightsamples" to 1.

7. Finally click the pointer in the numeric-gadget box labelled "DOF
   scale" , then enter the value 1.0. Check the settings, then confirm
   them and start the rendering with "OK".

This will take a few minutes to produce the finished image, as REAL 3D
is having to carry out a phenomenal number of calculations to produce
such a very realistic image.

4.4 END OF THE BEGINNING

Hopefully this introduction has whetted your appetite and demonstrated
a little of the power of REAL 3D V.2. In the TUTORIALS that follow, you
will find that the program is logically arranged and with a little
practice you will very soon be able to create fantastic images and
animations.

                           - INTRODUCTION 1.18 -

TUTORIAL
--------

Chapter 1 OBJECT CREATION & MODIFICATION
----------------------------------------

Before you start to read the tutorials, remember that most tutorial
examples include an example of the finished result. You will be informed
about the presence of this kind of support material in the following way:

Support example:
Examples/.....

This means that you can verify the result of the tutorial example by
replacing your current project (use menu Project/Project/Replace) with the
given file, which you can find in the "Examples" directory of the REAL 3D
drawer.

If you worked through Chapter 4 GETTING STARTED of the INTRODUCTION, then
you have already created some spheres, and you will have seen a few of the
other objects which can be created when you looked at the Intro.prj.
This first chapter of the tutorial is intended to give you an overview of
the user interface of the software. It will familiarize you with the use
of the hierarchy and basic creation and modify functions.

1.1 STARTING THE PROGRAM

REAL 3D can be activated from the Workbench interface by double-clicking
the icon of the program "Real", or from the command line interpreter
(CLI/SHELL) by the command REAL.

If you are going to modify a project that you have created earlier, then
you can start the program by opening the icon for that object as described
in Amiga user interface manuals. The same method is valid for all data
structures created by the program. For example, you may choose to start
the program from different environment files instead of the program icon
itself, depending on what kind of modelling you are planning to do.
If the purpose is to create animations, run the program directly to the
animation environment;

if you are going to do accurate CAD type modelling, pick a tri-view
environment with plenty of grids. The user interface of REAL 3D is
configurable and you may customize it to suit your needs.

The "Environments" drawer of the software package contains some sample
environments.

Note:
If you start the program from CLI, make sure that the stack size is large
enough. We recommend the stack size be at least 40 000 bytes. You can use
the CLI stack command to set a proper stack size.

When studying this chapter, you should use the standard environment, and
therefore start the program from its icon.

1.2 THE WINDOWS

When the program is started from its program icon, it loads the
environment definition stored in the s:real-startup file. The original
environment contains a basic 3 window interface in which all the creation
and modifying functions can be done. The largest window, a view window,
shows the object under construction. By default, it displays the object
from the front as parallel projection.

The construction of objects is done in view windows using the mouse. You
can see a symbol _+_ in the view window. This symbol is the "hot-point",
which displays the latest given coordinate position in space. You can move
the hot-point to a new location by clicking in a desired place.
The third coordinate value for the points, which the user defines with the
mouse, is read from the hot-point position, because a mouse button click
defines only two coordinates at a time.

The top border of the view displays some useful information. First, you
can see a window name identifier. Second, the projection type of the view;
parallel or perspective. Finally, the view border displays two selected
functions, current one and the next one in the FIFO list of the view.
The window in the top right corner of the display is called a selection
window.

                             - TUTORIAL 1.1 -

This window displays the names of the objects you have constructed. You
can select an object by clicking on its name in the select window.
Multi-selection happens by pressing the <SHIFT> key down and clicking the
names, or by dragging with the <LMB> in the select window. The names of
selected objects are highlighted as an indication of the selection.

The select window is very important part of the working environment.
Extensive use of object hierarchy is one of the most important principles
of REAL 3D.

The third window, in the bottom right corner of the screen, is a tool
window. It contains tool icons from which you can activate functions.
It is possible to modify the contents of the tool window and add user-
defined icons.

1.3 THE MOUSE

When using REAL 3D, the mouse is the most important input device, and the
actions the user can do with it can be divided in two categories in the
following way:

- The right button is used for menu selection. In addition to this,
  certain object creation procedures can be cancelled by clicking the
  right mouse button.

- All the other actions are done using the left mouse button, such as
  drawing.

Remember:
Left mouse button is abbreviated as <LMB>, and right one as <RMB>.

Most of the actions in REAL 3D can be performed by menu selection in a
way which is defined by the Workbench user interface: to select a menu
item, press the right mouse button, point to the menu bar, then point to
the desired menu item and release the right button, The highlighted menu
item is the one which is being selected. You can experiment by selecting
Extras/Refresh/Wire-frame. The program replies by redrawing the display.

Also, menu multi-selection is supported: to select several menu items at
the same time, keep the right mouse button down and select the menus with
the left mouse button. The multi-selected actions are executed in First
In First Out order (FIFO).

Note that each window type may have its own menu system which may be
different from other windows menus, and some windows may have part of the
menus inactive. For example, it is not possible to select the function
View/Render/Window when a "select" window is active. You must have a
"view" window active (selected).

In this manual menus are represented in the following way:

- Menu/Item.

- Menu/Item/Sub-item.

For example: Create/Visibles/Sphere.

Instead of using menus, most functions can be activated using keyboard
equivalents (Hot-Keys) or tool window icons.

When using the left mouse button, use sharp clicks instead of keeping the
button down and moving the mouse. Left mouse button dragging is reserved
for certain point selection functions.

For example, when shaping a rectangle, click on the top left corner, and
then release the button. Then you may freely move the mouse, or even
select some menus, or have a cup of coffee. When you are certain of the
position of the bottom right corner of the rectangle, click a second
time in the desired place.

When modelling objects with exact coordinates, it may be difficult to
obtain high enough accuracy using the mouse. In such a situation, you can
replace left mouse button clicks using either the vector stack or a
measuring window. These will be described in detail later.

Left mouse button "dragging", moving the mouse while keeping the left
button pressed, has some special functions in REAL 3D. If you try this in
the view window, you see that a box is shaped according to the mouse
pointer movements.

                             - TUTORIAL 1.2 -

By default, the average is projected to the input plane, which is the
plane in 3D space along which the coordinates run when you move the mouse.

If you want to consider only the points of the selected objects instead of
the whole scene, keep the <Alt> key pressed when dragging.
The other important <key><DRAG> combinations are:

- <SHIFT><DRAG>, which pushes the points inside the drag box onto the
  vector stack. This operation does not project the average into the input
  plane.

- <SHIFT><Ctrl><DRAG>, which creates a point group for point editing of
  freeform objects.

Although the averaging operation is simple, it is very useful. Using this
feature, you can easily lock the mouse coordinates to any existing point
when modifying or creating an object; just drag the box around the one
single point.

The following examples demonstrate how the dragging feature can be used.
Try these examples if you are already familiar with the software. (come
back to these later, once you've learned the basics)

To lengthen a cylinder:

1 . Activate the cylinder and select the Extend function.

2. Drag a box around the points of one end of the cylinder.

3. Drag a box around the other end.

4. Extend the object.

To create a circle precisely in the middle of another circle:

1. Select the circle creation function.

2. Drag a box around the points of the circle; this defines the middle
   point of the new circle.

3. Define the radius.

To move a triangle so its top will be in the middle of an edge of a
rectangle, assuming that the two objects do not lie originally in the
same plane:

1. Activate the triangle and select the Move function.

2. To ensure the operation is done correctly in all three dimensions,
   press <SHIFT> and drag a box around the top point of a triangle; this
   puts the top point to the vector stack.

3. Hit <RAM>. (right-Amiga-period). This pulls the true 3D coordinates
   of the triangle top from the vector stack.

4. <SHIFT> <DRAG> a box containing the two end points of the desired edge
   of the rectangle.

5. Hit<RAM>.

1.4 BASIC TERMINOLOGY

The term "object" in REAL 3D is used to describe all the items which are
stored in the hierarchy. Objects take many different forms, depending
upon their purpose. Not all objects have wire-frames, and some with
wire-frames do not have a visible surface when they are rendered.
Some objects cannot be seen at all, except as a name in a select window.

There is one special class of object, which you need to know about,
called a "primitive". A primitive is the most basic kind of object.

In the REAL 3D universe, a primitive cannot be divided into smaller
sub-objects. They are a bit like the fundamental particles of matter.
Objects can be made from primitives and even other objects. One final
point of terminology; a primitive is an object, but not all objects are
primitives.

                             - TUTORIAL 1.3 -

If no special keys are pressed while dragging, the program calculates an
average of all the points of the scene inside the dragged box, and moves
the hot-point to the average point. There are six main classes of
primitives, but you will only look at the first four in this chapter.
Most of these types also have some sub-types.

visibles - These primitives produce a visible surface when rendered unless
you take some action to alter their basic nature.

structures - These primitives have no wire-frame and do not render, but
despite that, they are in many ways the most important kind of primitive
in the hierarchy. Structures control how other primitives are arranged
and accessed by all the different functions of REAL 3D.

controls - Although these have wire-frames, they do not have any surface
and so do not render. As their name implies, they are used for controlling
the action of various REAL 3D functions.

freeforms - A collection of points describing a free-form line or surface
is called a freeform in REAL 3D terminology.

This may seem a little confusing at first, but as you work through the
tutorial, how, when, and where to use each of these objects will become
clear.

1.5 TUTORIAL EXAMPLE 1: SELECT WINDOWS AND HIERARCHY

All the objects created by REAL 3D consist of so called primitives.
These are the basic components and tools from which you can construct more
complex objects. To create a primitive "rectangle":

1. Choose the menu Create/Visibles/Rectangle.

2. Move the mouse pointer to a desired location and click the left button.

3. Now you can shape the rectangle by moving the pointer.

4. Click the left button, and REAL 3D creates a primitive "rectangle".

Now the view displays a rectangular wireframe. You can look at the
rectangle from different directions using cursor keys, or <RAM>X for
(front view), <RAM>y for (side view), or <RAM>z for (top view). The
rectangle is a plane, and therefore it appears as a line when you look at
it from the side. You can also see a peak perpendicular to the rectangle.
The purpose of this peak is explained in the context of Boolean
operations.

Remember: <RAM>x means that you first press the right Amiga key down, then
you hit "x" key, and then you release right Amiga key.

You can see the logical structure of your object in the select window.
Your scene "Root" consists of one single primitive, "rectangle". If you
now move the pointer on the name "Root" and click the left button, you
can see the name being highlighted on the instruction window as an
indication of the selection.

Figure T1-1: Select Window  (PICTURE: T1.1)

The names "Root" and "rectangle" are printed in different text types in
the select window: "Root" is written with bold typeface, and "rectangle"
is in normal type. The bold or normal gives an indication that the objects
are of different "types" i.e. "Root" is a hierarchical object having a
substructure, whereas rectangle does not have any sub-hierarchy.

                             - TUTORIAL 1.4 -

The object type, which "Root" represents, is called a level in REAL 3D.
REAL 3D uses levels to collect the parts of an object into groups. It is
possible to select and modify very complex levels without having to deal
with their substructures.

For example, if you have grouped all the parts of a robot arm under one
single level "robot arm", then you can rotate the whole arm, and there
is no need to pay any attention to each finger etc.

A well known example of this kind of a hierarchical data management are
disk operating systems: the level "Root" corresponds to a directory in
DOS, and the counterpart of the object "rectangle" is an actual DOS file.

1.5.1 The Current Level

Next we will study some basic functions of the select window. For this,
we need an object hierarchy which is a bit more complex:

1. Select menu Create/Structure/Level.

A new level appears in the select window:

     Root
        rectangle
        level

The new level was inserted after the rectangle, to the same hierarchy
level as the rectangle. This happens because "Root" is the so called
current level. Each select window stores the information of its own
current level, and the program inserts new objects under the current level
of the select window which was used last. This global object insertion
level is called the current level. It is quite simple once you experiment
a little.

To change the current level:

2. Move the mouse pointer on the name "level" on the select window and
   Double-click <LMB>.

The contents of the select window should change to display "level" only.
Now "level" is the current level, which can be seen in the following way:

3. Select menu Create/Visibles/Sphere, click <LMB> once in the middle of
   the view, shape a circle and <LMB> click again.

This adds a new primitive to your hierarchy. The select window displays:

     level
        ellipsoid

This means the sphere was inserted under "level", not immediately under
"Root". The whole hierarchy is:

             +------+
             | Root |
             +------+
              /    \
   +-----------+   +-------+
   | rectangle |   | level |
   +-----------+   +-------+
                      |
                 +----------+
                 |ellipsoid |
                 +----------+

The same structure can be described using indentation:

     Root
        rectangle
        level
          ellipsoid

or graphical presentation:

                +-------+
                | level |---
               /+-------+   \ +-----------+
              /              \| ellipsoid |
     +------+/ +-----------+  +-----------+
     | Root |--| Rectangle |
     +------+  +-----------+

Figure T2-1: Simple Object Hierarchy

                             - TUTORIAL 1.5 -

All three methods are used throughout the manual, depending on which one
is the most convenient.

If you <LMB> double-click name "rectangle", the result of the action is
highlighting the name of the object in the select window. This is because
the object "rectangle" represents the lowest level of the hierarchy, and
there is no substructure to be displayed on the select window.

To change the current level back to "Root":

4. <LMB> double-click the topmost item, "level", on select window.

Now the contents of "Root" level are displayed again. You are now on the
top of the object structure hierarchy, and if you double-click "Root",
nothing happens. If "Root" had been a part of a larger object, then you
could have moved one step upwards in the hierarchy, and REAL 3D would have
revealed all the objects in the same hierarchy level as "Root".

1.5.2 Object Multi-selection

Next we will experiment with modifying an object. But first, since we are
going to consider multi-selection, continue with the previous example by
creating one more primitive (make sure that "Root" is the current level):

1. Select Create/Visibles/Cube and shape a cube just as you created the
   rectangle. The size and position of the cube doesn't matter for this
   example.

So, now you have the following hierarchy:

     Root
        rectangle
        level
          ellipsoid
     cube

To move the cube to another position in space:

1. Select the cube by <LMB> clicking its name on select window.

Note:
After creating the cube, it should be automatically selected, unless
Settings/Creation/Auto _selected feature is switched off. Clicking the
name again to re-select it does no harm.

2. Choose the menu Modify/Linear/Move.

3. Move the mouse pointer, for example, to the middle of the cube and
   click the left mouse button.

4. Move the cube to a new location and <LMB> click.

Note:
Right mouse button cancels the modification.

Now experiment with multi-selection:

5. Move the mouse pointer over "rectangle" on the select window, press
   and keep <LMB> down, move the mouse down until all the three names
  under "Root" are highlighted, and release the <LMB>.

6. Repeat the Move function and verify that all the three objects you
   selected are moving.

Multi-selection can also be accessed in the following manner:

7. Click on select window below all the names in order to deselect all
   objects. Highlighted names now become normal.

8. Press <SHIFT> key down and keep it there.

9. Click the name "Rectangle".

10. Click the name "level".

11. Click the name "cube".

12. Release <SHIFT> key.

                             - TUTORIAL 1.6 -

Again, you multi-selected the same three items, this time one by one.
The next test explains another useful trick:

13. Press <SHIFT> key down and keep it there.

14. Click the name "level".

15. Release <SHIFT> key.

This deselects "level". This way it is possible to deselect individual
objects which you have selected by mistake without starting the whole
selection process from the beginning.

To finish this example, do the following:

16. Multi-select the three objects in "Root" level as you did before.

17. Select Modify/Structure/Delete.

You have deleted the scene of a rectangle, sphere and cube.

Note:
You cannot delete the root object.

Summary: REAL 3D uses a hierarchy tree for describing and managing the
structure of the scene. There are two important concepts related to the
hierarchy tree:

- The Current Level, under which new objects are inserted

- List of Selected Objects, which defines the target of object
  modifications.

1.6 TUTORIAL EXAMPLE 2: 3D MODELLING

In this example, we create a simple table. The example demonstrates how
to use object hierarchy, and especially the principles of 3D modelling.

The table consists of a cover and a base, and the base consists of two
stands and a brace. We will create the table only using cubes. The
following picture illustrates the structure of the table:

Figure T1-3: Table  (PICTURE: T1-3)

You can continue modelling this example from the situation of where the
last example ended, or start from new. You have the standard 3 window
configuration and no objects built yet. You may also select
Project/Project/New or restart the program before commencing.

We start building the table by creating the hierarchy level, which
contains all the parts of the table:

1. Choose Create/Structure/Level.

2. Choose the menu Modify/Properties/Name. A requester is opened.

3. Write the name "table" and hit <RETURN> or select OK.

Figure T1-4: The Name Input Device  (PICTURE: T1-4)

                             - TUTORIAL 1.7 -

To create the cover of the table:

4. Open a palette window: use Project/Windows/Palette or hit <RAM>p.

5. Choose a nice color for the cover by pressing <LMB> down on the color
   bar of the palette window. When a good color is found, release <LMB>
   and click the OK gadget. Then close the window using the standard
   window close gadget.

6. To ensure accurate positioning, select View/Grid/Snap to Grid. From now
   on, mouse coordinates are rounded to suitable intervals, and it becomes
   easy to line up objects.

7. Activate the view window by clicking it and hit <RAM>e. Now you've got
   the standard front view.

8. Hit <RAM>z. Now you've got top view; now click in the middle of the
   view. This moves the hot-point to the middle and guarantees that the
   third coordinate (z-coordinate) will be correct when you do front view
   modelling. (you have defined the z input coordinate).

9. Go back to front view by hitting <RAM>x.

10. Choose Create/Visibles/Cube, and shape a low but wide cube to
    represent the cover as it is seen from the front.

           ----------------

Figure T1-5: Front View of the Cover of the Table.

11. "Cube" is not a good name for the cover of the table, so change it:
    choose the menu Modify/Properties/Name. Enter the name "cover" and
    hit <RETURN>.

Now you have created a table which consists of a cover only. Now lets
create an object "base":

12. Choose Create/Structure/Level.

13. Choose the menu Modify/Properties/Name, enter the name "base" and
    hit RETURN.

Your table now consists of a cover and a base. Next we will start to
build the base, but remember that we have to instruct the program to
insert the new objects under the "base" level:

14. <LMB> double-click the name "base" on the select window.

This changes the current level to "base", and the contents of "base" are
displayed. As it was shown in the previous chapter, as long as the current
level is "base", every new object or primitive you create will become a
part of the base.

Now the hierarchy is:

          +------+
          | Root |
          +------+
           /    \
    +-------+  +------+
    | cover |  | base |
    +-------+  +------+

The base is a hierarchy level, which so far has nothing in it.

To create a stand for the table:

15. Choose Create/Primitives/Cube and shape a narrow, high cube to
    represent a stand, as shown below.

           ----------------
            |
            |
            |
            |
            |
            |

Figure T1-6: Front View After Step 15.

16. Rename the new cube as "stand1" by choosing Modify/Properties/Name.

The stands of the table are identical, therefore you can create the
second stand by using the duplicate function:

                             - TUTORIAL 1.8 -

17. Choose the menu Modify/Structure/Duplicate, having the stand as the
    selected object.

18. Move the copy to the right place by choosing Modify/Linear/Move.

           ----------------
            |            |
            |            |
            |            |
            |            |
            |            |
            |            |

Figure T1-7: Front View After Step 18.

As you have seen, REAL 3D automatically gives names to primitives
according to their types. This is handy when you are making a relatively
small object, and therefore it is easy to identify the different parts of
the object. Anyway, it is usually wise to give a name to each part of the
object which describes its purpose. Therefore:

19. Choose Settings/Creation/Qry Prim. Name.

20. It is best to create the brace of the table using side the view, so
    hit <RAM>y.

21. Shape a narrow, high cube in the middle of the stands (see figure
    below). When REAL 3D asks the name of the primitive, type "brace".

    -----------------
    |               |
    -----------------
    |      | |      |
    |      | |brace |
    |      | |      |
    |      |_|      |
    |               |
    |_______________|

Figure T1-8: Side View After Step 21.

22. Also, the cover of the table should be modified so it becomes wider
    than the stands. The side view you have now is suitable for this:
    change the current level back to root and select the cover.
    Then select menu Modify/Linear/Move and move the cover slightly
    (e.g. 2 grid units) to the left.

23. The cover is too narrow, so select menu Modify/Linear/Extend.
    Then click on the top left corner of the cover and then on the top
    right corner - when you move the mouse, you see that the cover width
    is changing accordingly. Move the mouse e.g. 4 grid units to the right
    from the original top right corner, so that the right edge reaches out
    over the edge of the stands as much as the left edge does.

          -----------------
          |               |
          -----------------
          |      | |      |
          |      | |      |
          |      | |      |
          |      |_|      |
          |               |
          |_______________|


            <------- move
         -----------------
         |               |
         ------------------
          |      | |      |
          |      | |      |
          |      | |      |
          |      |_|      |
          |               |
          |_______________|


           extend ------->
        ---------------------
        |                   |
        ---------------------
          |      | |      |
          |      | |      |
          |      | |      |
          |      |_|      |
          |               |
          |_______________|

Figure T1-9: Modifying the Cover.

Now the side view shows the correct shape. But there are still some
things to do:

24. Hit <RAM>x to get front view again.

                             - TUTORIAL 1.9 -

The brace cube probably doesn't fit between the stands properly. So:

25. Select the brace object again using the select window.

26. Move the brace so its left edge matches the inner side of the left
    stand.

27. Extend the brace just as you extended the cover earlier, until it
    matches the stands (See the figure T1-3).

28. Use the cursor keys to find a good viewing angle and select
    View/Render/Window or hit<RAM>r.

Now the table is ready. The final hierarchical structure of the table
is the following:

                 +------+
                 | Root |
                 +------+
                     |
                 +-------+
                 | table |
                 +-------+
                   /   \
            +-------+ +------+
            | cover | | base |
            +-------+ +------+
                      /    |  \________
                     /     |           \
               +--------+ +--------+ +--------+
               | stand1 | | stand2 | | stand3 |
               +--------+ +--------+ +--------+

Support example:
Examples/Objects/Table.

In the example, we named the objects so that the name of an object
described the purpose of it, to make the identification easier. If your
model includes several objects of the same name, you can identify them
according to the order you created them; the first object you created
is the topmost in the select window.

If you don't remember which one you created first, there is one further
way to select primitives: <SHIFT><DRAG> a box containing the points of
desired primitives. This operation pushes the points included in the drag
box onto the vector stack of REAL 3D. If dragging was successful, you
should see the points marked with a cross symbol. Then press <RAM><Space>,
and selection happens.

You can check which object is the active one by hitting <Help> key. The
wireframe of the selected object will flash.

In the next paragraph, we will modify the table in different ways so you
can get some idea of REAL 3D's powerful hierarchical object oriented
construction method.

1.7 MODIFYING

Now you already know how to use some modification functions. You also know
that modifications are done to the selected objects. You can select any
part of the table and modify it, regardless of the complexity of the
modification.

We can continue to modify the table of the previous example (You can load
the file Project/Project/Replace Examples/Objects/Table).

To move the brace of the table:

1. Select "brace".

2. Choose the menu Modify/Linear/Move and move the brace.

To move the whole base:

3. Select "base".

4. Hit the key "m" (move) which is the default keyboard short-cut for Move
   function and move the base.

If the table seems to be too high:

5. Select the whole "table".

6. Select Modify/Linear/Stretch, <LMB> click on the top left corner of the
   table, then <LMB> click on the bottom right corner of the table. Then
   move the mouse until the shape is desired.

                             - TUTORIAL 1.10 -

You can also rotate the table with the Modify/Linear/Rotate function, or
change the size of it using Modify/Linear/Size function. The Mirror
function inverts the object with respect to an axis defined by you.

If the result of a modification was unexpected:

- Select Extras/Undo or hit <RAM>u key.
- The Undo-function restores the situation to the situation before the
  latest action.

Actually, the depth of undo buffer is 3 by default, so you can undo three
steps backwards. It is possible to change the undo depth to other values
using the Settings/Undo/Set depth function, but remember that the greater
the value, the more memory is required.

You can also relocate the table by choosing Modify/Linear/Move COG. This
function moves the target to a given point using the so called COG point
of the object (COG = Center of Gravity). Every primitive you create has
some default value for COG. For example, the COG of a ball is its middle
point. You can redefine the COG point by the function Modify/Properties/
COG.

To move a stand of the table to the bottom left corner of the window:

1. Select a stand.

2. Choose Modify/Linear/Move COG.

3. Click the view near the desired place.

4. Move the pointer to the desired place and click the left button.

To modify the color of the table cover:

1. Select the cover.

2. Open the palette window (<RAM>p).

3. Select the palette window menu Project/Fetch. The color of the cover
   is read and displayed in the color square above the OK gadget. Also
   the RGB sliders are adjusted accordingly.

4. Modify the red component to 100 by moving the R-slider.

5. Click OK. This changes the current color.

6. Activate the view window and select Modify/Properties/Color. This
   writes the modified color back to the cover.

Move, Rotate, Color and Stretch are functions which affect only the
physical structure of the table. Next we turn to functions which change
the hierarchical structure. In fact, you already know some, namely the
Delete and Duplicate functions.

The hierarchical structure of the table created in the previous example
seems to be quite a logical one. The stands are a part of the base, but
the cover is not. Anyway, you can move the parts of the table in the
hierarchy tree, just as you can move files and directories in DOS to
new directories.

If you want to move the cover to be a part of the base:

1. Select "cover".

2. Choose Modify/Structure/Cut.

3. Double-click the level "base" on select window, so it becomes the
   current level.

4. Choose Modify/Structure/Paste.

You have modified the hierarchy of your table to be as follows:

     Root
        table
        base
          stand1
          stand2
          brace
          cover

                             - TUTORIAL 1.11 -

If you don't want any part of the table to belong to the base:

1. Multi-select stand1, stand2, brace and cover.

2. Choose Modify/Structure/Cut.

3. Double-click the name "base" on top of the select window; the window
   changes the current level to be the parent level, "table".

4. Choose Modify/Structure/Paste.

If you want to move the base now, you won't move any of the parts of the
table. The base is now empty, and the structure of the table is quite
peculiar.

     Root
        table
          stand1
          stand2
          brace
          cover
        base

As a final example of modifying object hierarchy, we consider the use of
two select windows. As it has been mentioned, each select window has its
private current level, which becomes the global current level when you
activate it. You can use this feature in the following way:

1. Open a second select window.

2. Set the current level of the original select window to "base".

3. Set the current level of the new select window to "table".

4. Activate the new select window.

5. Use Create/Visibles/Sphere to create a new primitive. It appears under
   "table" level in hierarchy.

6. Activate original select window and create another sphere. It appears
   under "base" in hierarchy.

7. Drag multi-select the objects under "table" using the new select
   window, which still displays those objects.

8. Select Modify/Hierarchy/Cut.

9. Activate the old select window.

10. Select Modify/Hierarchy/Paste. The objects are pasted under "base".

As you see, you can use multiple select windows to quickly access
different parts of the hierarchy.

1.8 SAVING AND LOADING

An object you have created, or any part of it, can be saved on disk and
later be recalled to be used again.

For example, to save the table you created before to the directory
"Objects" of drawer R3D2:

1. Select "table".

2. Choose Project/Objects/Save.

A device will then appear on the screen. With the file requester, you
can define all the names and paths that REAL 3D needs to load and save
data. In the device, you can see a DOS directory.
Using the mouse, you can select any of the names moving in the directory
tree until you have reached the directory you want. Then you can type the
name to save the object with to the "File" field in the lower part of the
device.

Naturally, you can also select an existing file. In this case, the old
contents of the file will be overwritten. Similarly , you can type any
name in the file field with its directory path regardless of which
directory is shown in the device.

Continue saving with the following actions:

                             - TUTORIAL 1.12 -

3. Click the drawer name "Objects" on the file selector, unless "Objects"
   is already displayed (check the drawer field).

4. REAL 3D already proposes the name "table" in the File field, so choose
   OK.

In the same manner, you may want to insert the name and object "table"
in a scene from the "Objects" directory of r3d2:

1. Make the object in which you want to insert the table (for example a
   garden furniture set) the current level.

2. Choose Project/Objects/Insert.

3. Select the drawer "objects" and the file "table" from the file
   requester and choose OK.

If the object is found, it will become a part of the garden furniture set.
The table is now the active object, so you can modify it in various ways,
for example, move it to an appropriate location.

Note:
If you save on object to an existing file name, REAL 3D gives a warning
to guard against mistaken overwriting, unless the Settings/General/
Confirm_save gadget is deactivated.

The third entry in the Project/Objects menu: Replace, replaces the whole
object hierarchy starting from root with the new one loaded from the disk.
Where as Insert, inserts the loaded object to the old object structure.

Most other IO menus include a similar group of three functions: Insert,
Replace and Save. They work in a similar way: Save is for saving to disk,
Insert adds new data to the current project, and Replace replaces the
current data with the one loaded from disk.

Note:
REAL 3D binary format is an IFF type collection of different data
sections. This means that a file can contain both objects and materials,
but you can only load the objects from it using Objects/Replace or
Insert. When replacing Projects, you can define the sections which you
want replaced from the file.
For example, if you Project/Project/Replace from a file which does not
contain an environment section, you do not lose your current user
interface definition. Also, you can specify which sections you want
replaced by using Project/Project/Replace Sections. When you create
objects, it is advisable to compose them of reasonable sub-objects, which
can be saved to appropriate sub-directories. Although this means more
work in the beginning, it does allow you to create libraries of reusable
objects.

1.9 VISIBLES

The examples presented earlier already have explained how to create some
basic visibles. The main classes of visibles are:

- Flat planar visibles
- Polygonal visibles
- Cylinders
- Cones
- Ellipsoids
- Hyperbolic visibles

REAL 3D includes a variety of tools for creating these visibles. Also,
tools for creating sector versions of most visibles are included. Thirdly,
the so called compound tools combine visibles to obtain more complicated
shapes.

This chapter introduces some new visibles. The rest are described in the
reference section.

                             - TUTORIAL 1.13 -


1.9.1 Polygon/
      Polyhedron/
      Polymids

With the polygon tool, you can create plane polygons. Use it in the
following way:

1. Select Create/Visibles/Polygon.

2. Use the left mouse button to add new edge points when drawing a
   polygon.

3. You may undo the points one by one using <Del> key.

4. Right mouse button ends the function.

5. <Space> key cancels the function. Note that the edge curve of the
   polygon is closed automatically.

Creating a polyhedron (extruded polygon) happens exactly in a similar
way. Polymids are slightly different. A Polymid is a pyramid type of shape
with a sharp top peak.A Cut polymid is the same shape with a cut top. Use
the latter in the following way:

1. Select the menu Create/Visibles/Cut polymid.

2. First define the intersection shape of the object, in other words, the
   shape of the bottom plane of the object. You can do this in the same
   way as with the polygon tool. Use the right mouse button to end the
   shape definition.

3. Click the left mouse button in the position to which you want to place
   the first point of the polygon which forms the top cover of the object.

4. Now you can size the top cover by moving the mouse, and when the size
   is suitable, click the left button.

1.9.2 Sector Visibles

As an example of sector visibles, we will create a cylinder sector, which
is an useful shape for say 3D pie charts.

1. Select Create/Sectors/Cylinder.

2. Click in the center point of the cylinder.

3. Move the mouse until the distance from the center point is correct.
   Also, the line which the function draws defines one side of the sector,
   so direct it accordingly. Then <LMB> click again.

4. Now rotate the mouse counter clockwise until the sector angle is
   desired. Then <LMB> click.

1.10 COMPOUND TOOLS

REAL 3D includes a set of special tools to ease creation of certain types
of objects, such as objects turned in a lathe. Objects which consist of
several primitives can be created fast and easily with these special
tools.

Compound tools have some advantages over freeform based creation methods:

- They perform certain shape constructions very easily and quickly

- They produce memory efficient models

- Compound tool objects are fast to render

- True volume representation is produced

- Excellent rendering quality

The disadvantage is the inherent geometric restrictions, although this is
partly compensated for by the large number of different compound tools
available.

                             - TUTORIAL 1.14 -

In the following, some compound tools are introduced. The rest work in
quite a similar manner. Exact details can be found in the reference
section of the manual.

1.10.1 Lathe

To use the lathe tool:

1. Choose Create/Compound Tools/Lathe.

2. Define the direction of the axis of the lathe by selecting two
   spatial points with the mouse.

3. Then click the starting point and define the direction of the surface
   at that point by drawing a line segment. Click when the direction is
   suitable.

4. Now you can shape a curve. When the shape is suitable, click the left
   mouse button and shape the next curve.

5. If you want to make a sharp edge, use right mouse button to cancel the
   current curve shaping and then define the new direction.

6. Sometimes the smooth profile curve breaks because of precision problems
   in calculations. This can be avoided by defining the shape in shorter
   segments.

7. When the required shape has been defined, turning can be terminated by
   pressing the right mouse button twice.

Figure T1-10: Candlesticks turned in a lathe.  (PICTURE: T1-10)

1.10.2 Tube tools

With the tube tools, you can create a continuous tube. The tools can be
used, for example, for creating 3D fonts.

The tube tools are divided into sub-classes according to the following
properties:

- Rounded edges/sharp edges ("rounded" option)

- Constant radius/varying radius ("Conical" option)

- Circular/rectangular intersection shape ("Circular/"Rectangular")

- Automatic subdivision/no subdivision ("Subdivided" option)

The tube tools use various primitives like cylinders, polyhedrons, and
spheres to create the tube you define.

For example, to use the rounded circular tube tool:

1. Choose Create/Compound Tools/Rounded Circular.

2. Define the diameter of the tube by shaping a circle.

3. Draw the tube in space as long as you want and then cut it with the
   <RMB> button.

As a second example of tube tools, we consider the Conical tube. With
this tool it is possible to create spheres connected with cones. The
result is a tube with a changing radius and rounded joints.

For example, this tool is suitable for creating a robot finger.

1. Select Create/Compound Tools/Conical

2. Shape as many circles as needed. These circles define the joints
   of a finger.

3. End the joint definition by clicking the <RMB> button.

                             - TUTORIAL 1.15 -

If you try the same with Conical Subdivided tube tool, you get more
joints and smoother result. Try the previous example with the subdivision
factor 5, just to see the difference.

Figure T1-11: The Tube Tools.  (PICTURE: T1-11)

Top row: (IN PICTURE)
     Circular Subdivided, Rounded Circular Subdivided,
     Sharp Circular, Rounded Circular.

Second row: (IN PICTURE)
     Conical, Conical Subdivided.

Bottom row: (IN PICTURE)
     Rectangular, Rectangular Subdivided, Rectangular Conical,
     Rectangular Conical Subdivided.

1.10.3 Rounded Polygons and Polyhedrons

Compound tools include functions for creating polygons and polyhedrons
with rounded corners. They are handy for example for logotype creation.

You can use all the four tools in a similar way as when you created the
polygon, but the tool automatically rounds the corners. "Rounded" tools
use fixed maximal rounding radius, whereas "Ellipsed" tools round the
corners all the way to the middle of each edge. The following figure
shows example shapes created with the tools.

Figure T1-12: Rounded Polyhedron (left) and Ellipsed Polyhedron (right).
              (PICTURE: T1-12)

1.10.4 Object-Pixel Tool

The object-pixel tool is a very powerful link between two and three
dimensional computer graphics. The idea is to easily and quickly obtain
complex 3D solid objects by replacing the two dimensional pixels of a
picture with some three dimensional objects, such as spheres.
When using the pixel tool, the user can define which object replaces
the pixels. Only the pixels which have some other color than the
background color (color 0) are replaced, and the colors of objects
created are the same as the colors of the pixels. With 24 bit and HAM
images, all the pixels are replaced.

For example, you can create 3D text using the usual 2D fonts. There is
a wide variety of different fonts available, and furthermore, there are
an infinite number of ways to define the object with which the pixels
are replaced. For the creative user, pixel tool offers an excellent
method to produce 3D pictures and animations. It is especially handy
for producing particle groups for particle animations (text which is
exploding etc.).

                             - TUTORIAL 1.16 -

To create text with the pixel tool:

1. Start a paint program, choose a suitable font, write the word "Real",
   define a brush containing the word and then save the brush for
   example, to the RAM disk.

2. Create, for example, a small sphere in REAL 3D. Make sure that it
   is selected.

3. Choose Create/Compound Tools/Object-Pixel Tool. Now the file selector
   is displayed, and you can select the brush you saved to ram disk.

4. Next, you can define the size and location of the object which will
   be created by shaping a rectangle in a view window.

5. When the object is created, you probably don't need the original
   sphere any longer, so delete it.

Figure T1-13: Text Created with Object-Pixel Tool.  (PICTURE: T1-13)

Note:
Pixel tool tends to create a "heavy" object. For example, in a paint
program a brush of 30 times 30 pixels looks very small, but it includes
900 pixels. A slightly larger brush, say 80 times 80 pixels, includes
6400 pixels already. This may lead to memory problems.

1.11 LIGHT SOURCES

A light source is a primitive which radiates light of its own color.
If the primitive is black, it does not radiate light at all. A white
object radiates all the main components (R,G,B) of light in the same
amounts.

In real life, it is usually very difficult to observe objects in
lighting which has only one wavelength. Also, there is not any
material which would reflect only one wavelength . In REAL 3D, all this
is possible, so you should be careful when selecting the colors of light
sources. For example, a totally red object is not visible at all under
blue lighting, because a red object does not reflect any blue light.
A violet object looks red under yellow lighting.

Usually, it is advisable to create white light sources, so all objects
will be rendered in their "true" colors. Although the number of light
sources is unlimited, they should not be used indiscriminately. The time
taken by rendering is greatly dependent on the number of light sources.

In the next example, we will test different light sources. The example
includes a cylinder floating above a rectangle (floor), and two light
sources casting shadows onto the floor.

1. Reset the view window by activating it and then pressing <RAM>e.

2. Take a top view by hitting <RAM>z.

3. Create a rectangle (Create/Visibles/Rectangle), almost filling the
   whole view.

4. Create a cylinder (Create/Visibles/Cylinder) to the middle of the
   rectangle.

5. Select a suitable current color for the light sources using palette
   window. Pure white (255,255,255) is a good choice.

                             - TUTORIAL 1.17 -

6. Choose Create/Light-sources/Point and click on the left side of the
   cylinder.

7. Choose Create/Light-sources/Wall and shape a small square to the right
   side of the cylinder.

8. Go back to front view by hitting <RAM>x.

9. All the objects lie at the same level. Select the rectangle and move
   it to the bottom, select cylinder and move it above the rectangle.
   Select the light sources and move them well above the cylinder.

10. Hit <RAM>s to get the Render settings requester. When it opens, set
    Mode to Normal and click OK.

11. Adjust the viewing angle with the cursor keys and hit <RAM>r to
    render.

Now you should see the shadows of the cylinder on the floor. The edges
of the shadows from both lights appear both to be sharp. Do this to see
a soft shadow:

12. Open render setting requester again (you can do it while the program
    is still rendering!) and adjust the Lightsamples slider at the right
    side of the requester to the value one. Then hit OK.

13. Hit <RAM>r to re-render the view.

Support example:
Examples/Objects/lightsources

This time, one of the shadows has a smooth edge. Rendering is much slower
(about 4 times), but probably the extra realism is worth the time penalty.

You can adjust the size of the smooth area on the shadow edge by
increasing the size of the wall light source. Nevertheless, you may then
have to increase Lightsamples level respectively, which again slows down
the rendering. So, the smoother the shadows, the more calculations and
rendering time is required.

Figure T1-14: Light Source Test Scene  (PICTURE: T1-14)

1.11.1 The Brightness of Light Sources

When you create light sources, you don't have to worry about their
brightness; the program will scale their intensities to a suitable level,
and fine tuning can be done by settings of the solid model. You can set
the relative brightness of various light sources by giving them suitable
colors. A lamp having lower values for RGB components has a lower light
intensity than a lamp which has higher RGB values.
These differences will be preserved in automatic scaling. The automatic
scaling of light intensities can be thought of as being analogous to the
automatic exposure functions of a camera, where the exposure level is
based on the overall brightness of the picture.

Notice that if you position a light source near an object, there will be
a great difference in light level (in other words contrast is high).
If you illuminate the object from a distance, the light falling on the
object will be much more evenly distributed.

A good example of this phenomenon is the comparison of sunlight and lamp
light. If you place a lamp near an object to act as a spot light, and
another further away to give ambient light, the latter should have much
higher intensity than the former to produce any visible effect.

                             - TUTORIAL 1.18 -

Light sources don't show directly in shaded pictures. So, if you want to
see lamps or reflections of the light source on reflecting surfaces, you
must put a cover made of, say, matt glass around the light source.
This is just like in the real world!

You may find it useful to save some suitable light sources as objects to
disk so light sources can be brought to use as the need arises.
Nevertheless, if you want to produce a ray traced picture of an object,
you don't always have to create light sources. The rendering unit of
REAL 3D includes some fast ray tracing modes in which one light source
is created automatically. For more information, see the chapter on
Rendering.

1.12 MACROS

The macro facility, an important feature of REAL 3D, is very useful when
you must execute the same modifying operations to a large number of
objects. A macro is a series of modification operations which the user
can define to best suit his/her needs. Macros can be stored to hard disk,
bound to keyboard short-cuts, and made into tool window icons. They can
later be executed on any object.

Macro definition is started by the operation Record. The current macro,
usually automatically stored as t:macro.rpl, is deleted. After this, all
these new operations are stored in the t:macro.rpl file. These operations
include all functions of Modify/Linear, Modify/Structure, and Modify/Bend
functions.

When the macro has been fully defined, the recording is stopped by
selecting Record again.

An example of macro definition:

1. Create an object.

2. Choose Project/Macros/Record. A checkmark will appear in the menu
   showing that macro recording is active.

3. Flatten the object with the Stretch function.

4. Rotate the object with the Rotate function.

5. Move the object with the Move function.

6. Choose Projects/Macro/Record again.

Now you have defined a macro which consists of three modifying operations.
To execute the macro:

1. Select the object to modify.

2. Choose Project/Macros/Execute Current.

If you want to execute the macro 20 times:

1. Select the object to modify.

2. Choose Project/Macros/Repeat Current.

3. Type 20 into the requester, then click OK.

This is a very powerful method for creating symmetrical objects. As an
example, let us create a set of ball bearings:

1. Create a sphere with a suitable size and place it near the top of the
   view window.

2. Select menu Project/Macro/Record.

3. Modify/Structure/Duplicate the sphere.

4. Modify/Linear/Rotate the sphere around the center point of the view.

5. Select menu Project/Macros/Record.

6. Select menu Project/Macros/Repeat Current.

7. Estimate the number of spheres needed to form the entire ball bearing
   and enter this value.

                             - TUTORIAL 1.19 -

Figure T1-15: Ball Bearing Macro  (PICTURE: T1-15)

Spread macro is another useful macro feature. It spreads the macro over
the selected objects, incrementing the number of macro repetitions by one
after processing each selected object. Try the following with the spheres
you created in the example above:

1. Multi-select all the spheres.

2. Select Modify/Linear/Move COG, and click twice in the middle of the
   view. The result is that all the spheres are collected to the same
   position.

3. Select Project/Macro/Record.

4. Still having all the spheres multi-selected, move the spheres to the
   right, half the diameter of a sphere.

5. Select Project/Macro/Record to end the macro.

6. Select Project/Macro/Spread Current.

If you repeated the steps correctly, you got a horizontal row of spheres.

You can save the macro by using Project/Macros/Current to Named function
(or by copying/renaming t:macro.rpl with a suitable name). Current macro
is just an ascii file stored in system t: directory. It is a small RPL
program, and you can edit it with any text editor.

You can also pick any RPL program/macro and execute it using the menu
Project/Macro/Execute Named. There is also Named_to_Current function,
which makes a given macro the current one, so you can use it with the
repeat and spread functions.

                             - TUTORIAL 1.20 -

Chapter 2 THE ENVIRONMENT
-------------------------

2.1 ASYNCHRONOUS ACTION

REAL 3D makes extensive use of the Amiga multitasking operating system.
This helps make using the software more comfortable, faster, and
consequently more productive.

The user interface is designed using the "zero wait state" principle:
even if the user starts a time consuming process, the program continues
to monitor the users actions and gives immediate responses. In REAL 3D,
this happens by the asynchronous execution of multiple tasks.

The following test demonstrates this:

1. Use Create/Compound tools/Circular subdivided to create a tube; use
   at least 10 clicks to define the tube shape and use 10 subdivisions.
   This should create a rather complex object.

2. Activate a view and select View/Render/Window. The program starts
   shading the window.

3. Now immediately select another creation function; create a sphere,
   and start shaping it in the view which is still rendering.

It is possible to initiate new tasks even though the program is redrawing
the window. Another useful test can be opening more views and then
selecting Extras/Refresh All/Ray Trace: Views are rendered independently
of each other.

If you try Modify/Linear/Move to move the tube, you will see another zero
wait state feature: even though the wireframe is complex, REAL 3D responds
to your mouse moves easily.

Note that certain functions can momentarily block your actions. For
example, IO functions (saving and loading). Secondly, modal requesters,
such as render and drawing settings block the view where they are opened,
but other windows are still fully available. For example, if you are
defining the render settings for a View window and you need to open the
Palette window, activate a Select window and open the Palette window from
it.

One very useful technique which utilizes asynchronous action is material
editing. When testing materials, you can open a material window, edit a
material, and then activate the rendering of a view without closing the
material editor. While the rendering proceeds, you can edit the material
library and restart the rendering as soon as the changes are made.
Especially useful is the technique using "Box" rendering (see the chapter
"Rendering") where you can very quickly and interactively test critical
materials in their correct environments.

2.2 SCREENS

REAL 3D supports all Amiga display modes for the user interface display.
If you select the menu Project/Environment/Open screen, a requester is
displayed which will include the, display modes which are supported by
your workstation. You can adjust your display with the folloWing options:

The Color gadget slider allows you to select the number of colors to be
used for the screen display. The minimum value 1 allows two colors, and
the current maximum value of 8 allows 256 (or more in HAM) colors.

                             - TUTORIAL 2.1 -

The greater the depth, the more chip memory the display requires. Also
the display updating slows as the screen depth increases, but on the other
hand, shading quality is improved.

Width and Height gadgets define the size of the screen in pixels. When you
select a screen mode, the dimensions are updated automatically to the
system default values, but you can modify them freely. If you specify
larger than default dimensions, a virtual screen is automatically opened.

You can also give a name to the screen you open. The name can be used for
example in the Animation window when rendering animations; you can specify
which screen should be saved using the name.

Furthermore, the HAM gadget and overscan selectors are included. Note that
not all the mode combinations are possible at the same time. You will get
an error message if a mode is incompatible.

REAL 3D can operate on multiple screens simultaneously. The user can
freely create a multiple screen configuration. For example, you can have
a HAM screen open for color shading and a fast four color HIRES screen
for editing, with the ability to easily jump between them.

You can edit the screen palette using the Environment/Screen Palette
function. The palette requester includes two built-in palette options:
grey scale and color scale palettes. They are both optimized for ray
trace rendering, but you can adjust them slightly without loosing shading
quality. Also, you can re-arrange the order of the colors freely. Ray
trace shading with color scale palette on non-HAM screens works properly
only if the screen depth is at least 6 (AGA machines). If you use the
color palette, you have to activate the Render settings/Color shading
menu function in order to get proper results. You can change certain
screen properties using the screen window of REAL 3D; for further
details, see the reference manual.

2.3 VIEW WINDOWS

The main purpose of the View window is visualization (seeing) the
properties and the shapes of the models created by the user. Secondly,
Views input coordinate data from the mouse in an intuitive way, making it
easy to construct and modify objects. The whole modelling process can also
be entered using written instructions in a RPL window, but the approach is
much less intuitive. Using RPL written input can provide you with exact
modelling precision if need be.

REAL 3D supports a variety of different Amiga window types including
borderless and superbitmap windows. Their usage is not restricted; the
environment can be freely configured according to your personal
preferences.

Some suggestions:

- The borderless window, because it fill the whole screen, is often used
  for the final rendering of animations.

- The superbitmap window can be used for rendering selected parts from the
  scene, only the visible part of the window is shaded at once.

- The window borders of normal Views can be removed using Project/Windows/
  No Gadgets function. This gives more work space.

                             - TUTORIAL 2.2 -

2.3.1 Projection Types

For each View window, you can define the so called projection type. This
type defines how the shape of the model is rendered to the window.

If the type is Parallel, the scene is drawn as if it was seen from an
infinite distance. When using this projection, you cannot see any
perspectivity in objects, and visualizing the depth direction (the
direction from your "eyes" toward the objects) can be more difficult than
when using the perspective projection. Nevertheless, accurate modelling
is easier. For example, a front view of a cube in parallel projection is
a rectangle, and it is easy to align other objects with the sides of the
cube regardless of their positions in the depth direction.

If the type is Perspective, the objects can be seen in a natural
perspective way which corresponds to normal cameras. In this projection,
the View window area corresponds to the film in the camera; the film is
perpendicular to the line from the camera to the point of focus of the
camera.

The perspective projection may be more appropriate in intuitive, less
accurate modelling such as creating compositions from the camera view.
It is normally used when the final images are rendered. Note that the
rendering engine supports the rendering of both types of projections;
the parallel projection the faster of the two to render.

2.3.2 Input &Output Planes

The term "output plane" means the image plane to which the rendering
algorithms project the shape of the model. You can consider the
rectangular surface of the View window to be this plane; it is always
perpendicular to the direction you are looking at through the View
window in question. Each View window has its own private output plane
definition, which can be also described as the "internal camera"
definition of the View. This is presented in more detail in the next
chapter 2.3.3.

The term "input plane" means the plane in which the mouse coordinates
run. For example, the input plane can be the XZ plane passing through
the origin (the normal horizontal "ground" surface). When you move the
mouse, the Y coordinate remains zero, and only X and Z vary.
An intuitive way to describe this is: if an object is lying on the ground
and the ground is the input plane (please forget the fact that the earth
is actually spherical), you cannot lift an object above the ground by
applying the Move function. You can just slide the object along the
ground.

The input and output planes can be the same or separate planes. In the
previous "ground surface" example, the input and output planes coincide
when you look at the ground directly from above or from below. But you
can also use a perspective arbitrary view (perhaps the final camera
view) while moving the object along the ground surface.

Normally, both planes are automatically connected to each other so that
when you adjust one (e.g. using cursor keys), the other follows. The
following example shows how to disconnect them.

                             - TUTORIAL 2.3 -

1. Activate the View, hit <RAM>e and click in the middle of the View to
   move the hot-point (set by mouse click) near the origin. The hot-
   point will define the third "depth direction" coordinate of the input
   plane.

2. Select View/Drawing_Set, activate the "Abs Grid" gadget and select OK.
   This shows a grid pattern on the horizontal XZ plane, which is helpful
   when doing perspective modelling.

3. Hit <RAM>z to get the top view. <RAM>x, y, and z hot keys always set
   both planes to the same position.

4. Select Create/Visibles/Cube and create a cube.

5. Select View/Type/Perspective. Then select the View/Type/Separate IO
   menu.

6. Now use the cursor keys to adjust the View angle so that it is no
   longer directly from above. The output plane is rotated but the input
   plane remains unaltered.

7. Select Modify/Linear/Move, grab the cube and move it. The cube moves
   in the XZ plane and you see it growing when it comes nearer to the
   camera position.

Figure T2-1: Separate IO  (PICTURE: T2-1)

The <RAM>x, <RAM>y, and <RAM>z keyboard shortcuts set the input and output
planes parallel to the absolute space axes, regardless if the Separate IO
is selected or not. Cursor keys rotate and move the output plane only when
the Separate IO is used.

As it was already mentioned, the hot-point "+" which you can set by mouse
clicks, also plays a role in the View IO system: the input plane always
goes through that point.

The input plane can be defined using the local coordinate systems of the
objects. This enables you to edit the objects in their natural
orientation. For example, if you want to stretch a cube which has been
rotated several times and you stretch it in the absolute space
orientation, the shape of the cube becomes distorted. To get a controlled
modification, you have to set the input plane parallel to one side of the
cube.

The input plane can be set to the object coordinate system by using the
function View/Input Crd./Obj. Space to View. To get the full advantage of
this feature, it is recommended that you add a reference coordinate system
to objects when originally creating them. Using the default orientation of
the compound or freeform objects may not be accurate enough.

The following example demonstrates this:

1. Create a level called "house" and add a cube (walls) and a triangular
   polyhedron (roof) under the house level to represent a simplified shape
   of a house.

2. Select Create/Controls/Coordsys, click in the middle of the house and
   shape a coordinate system primitive: set the three directions of
   the coordsys primitive parallel to the walls of the cube and press
   <LMB>. If the coordinate system directions do not match the wall
   directions perfectly, adjust the coordsys using Modify/Linear/Rotate.

                             - TUTORIAL 2.4 -

3. Now rotate the whole house to an arbitrary angle using Modify/Linear/
   Rotate. Change the View angle using the cursor keys and rotate it again
   to make its orientation irregular.

4. Go back to the front view using <RAM>x. Now the problem is how to make
   the house higher or wider? The solution is:

5. Select the coordsys primitive and select View/Input Crd./ Obj. Space to
   View. The view orientation is changed so that editing the house becomes
   easy using the e.g. Modify/Linear/Stretch function.

2.3.3 View Coordinates & Cameras

Every View window includes a description of its internal camera system.
This camera information includes the following items:

- The position of the camera (viewpoint)

- The point at which the camera is aimed (aimpoint)

- The camera tilt angle

- The scale factor (the angle of the lens)

- Two depth of field factors.

The View displays the objects according to this information. The depth of
field information becomes relevant only when the scene is rendered
using ray tracing.

The camera information can be stored to the object hierarchy tree by
creating a camera object. This makes it possible to animate the camera as
any other object, for example: morph between key positions and attributes
of the camera.

The camera object can be created using the menu View/Camera/Create Camera.
This function creates a new level, and puts two primitives, an aimpoint
and a viewpoint, under it. They together include all the camera
information, and the currently displayed situation on the view is stored
to them.

The camera object consists of two primitives in order to allow easy
tracking of animated objects. For example, if the viewpoint primitive is
placed in a moving car and the aimpoint primitive is in an airplane, the
camera automatically follows the airplane regardless of the complexity of
the motions involved.

The purpose of the aimpoint is to define where the camera aims. It is very
easy to move the aimpoint to any desired point in the scene and redirect
the camera that way. Secondly, the distance from the viewpoint to the
aimpoint defines the focal length of the camera in the depth of field
rendering effect: objects near the aimpoint (and at a similar distance in
general) are sharper in the image.

The viewpoint primitive contains the rest of the camera information. For
example, by rotating the viewpoint, you can adjust the tilt angle.

As it was mentioned, every View window contains a full camera description
internally. You can use the camera object consisting of the aimpoint and
the viewpoint to store a suitable viewing angle more permanently. The
following example demonstrates this:

1. Hit <RAM>x to get a front view, and use Create/Visibles/Cube to create
   a cube (just something to look at).

2. Use the cursor keys to find a suitable viewing angle.

                             - TUTORIAL 2.5 -

3. Select View/Camera/Create Camera. The carefully selected camera
   position becomes safely stored.

4. Hit <RAM>z to get the top view, and create another cube.

5. Select View/Camera/Camera->View. You see the camera view again.

6. Adjust the view angle slightly using the cursor keys and "record" the
   adjustments to the camera object using View/Camera/View->Camera.

This way, you can take the camera information from a camera object, modify
it in the View and put it back. You can adjust the camera settings
visually and interactively through the View.

It is also possible to create multiple cameras. This feature can be used
in the following ways:

- You can store several "important" camera positions to multiple cameras
  making it possible to quickly check the scene from those critical
  positions during the model creation.

- Multiple cameras are needed when animating the camera using the morphing
  method.

- When designing your animation, it is possible to "take" from one camera
  position to the next similar to directing an actual movie set.

When you want to take a particular camera view and you have multiple
cameras, you can specify which one to use by selecting it and then
selecting the menu View/Camera/Camera->View.

When playing and rendering animations, it is sometimes necessary to
specify, whether a View should follow motions of an animated camera or
not. If you are using a camera object, it is useful to play the animation
from such a point of view that the motions of the camera itself can be
seen. Therefore, automatically taking the camera view during the animation
play is not always appropriate.

You can select the automatic usage of the camera view during animation
play by selecting the toggle menu View/Camera/Camera View function. This
selection is private for each View window: one View can follow the camera,
while another one shows the animation from a fixed position.

If you are using multiple cameras, you can specify which one to use in
each window during an animation play from the camera view by adding the
tag "SWND windowname" to viewpoints and aimpoints. Each window checks
the hierarchy tree and chooses the first view-point and aimpoint it finds.
The SWND tag makes the view or aimpoint window specific.

NOTE:
The Camera View function is used only during the animation play. It does
NOT connect a camera object to the View so that the camera object follows
cursor key adjustments. Instead, use the View->Camera function to store
the adjustments to the camera.

2.3.4 Zooming and Positioning the View

The visible contents of a View window, in addition to the camera position
and orientation, also depend on the scale factor of the View. The scale
defines the "lens angle" of the camera; it is a certain kind of a
magnification factor. The bigger the scale, the bigger the objects appear
on the display and the smaller part you can see of the total scene.
Defining a small scale factor corresponds to using a fish-eye lens: the
camera angle is wide, and a big part of the scene fits into the View even
if the camera is close to the objects under observation.

                             - TUTORIAL 2.6 -

Note that in perspective View windows, the size in which the objects
appear on the display, depends on two factors:

- The scale

- The distance from the camera to the objects

There are no other factors involved. So, if you try to find a good camera
angle in an interior room scene and the objects do not fit well into the
picture, resizing the room does not help. The problem could be best solved
by moving the camera and/or changing the scale. This is the same as real
world situations.

The camera distance does not matter at all on parallel projection Views.
The scale alone defines the object magnification.

To change the scale:

1. If you intend to enlarge an object on a View, choose the operation
   View/Display/Pos&Zoom In.

2. Then move the mouse pointer to that part of the View you want to
   enlarge. When you press the left mouse button, you can draw a rectangle
   on the screen. The region inside the rectangle will be enlarged so that
   it takes up the whole window.

You can reduce the scale by choosing the operation View/Display/Pos&Zoom
Out. Then you can define a rectangle that will, after reduction, contain
that part of the space that is visible on the View when the operation was
started.

A quick way to change the scale is to use the <RAM>- and <RAM>+ keys which
correspond to the Zoom In and Zoom Out functions.

Using the Position operation you can change the position of the windows in
space. You can, for example, observe in detail an object that is on the
edge of the space.

To move a View window in space:

1. Choose menu View/Display/Position.

2. Grab an object and move it to any place you want. Instead of moving the
   object, REAL 3D moves the window so that the object will show in a
   different part of the window.

The auto focus function offers a fast way to position and scale the View
around the selected objects:

1. Select the desired objects.

2. Select View/Display/Auto Focus.

The active View window will be centered around the objects, and the scale
is modified so that the objects fill the window.

If you want to reset the scale and the position of the View to the default
values:

1. Choose View/Display/Reset or hit <RAM>e keys.

                             - TUTORIAL 2.7 -

2.4 WIREFRAME DRAWING SPEED

The asynchronous design of REAL 3D normally means that the user does not
have to pay much attention to wireframe refreshing of the View windows.
In some extreme cases with very complicated wireframes, it may be necessary
to control screen updates in order to obtain more speed.

2.4.1 Bounding Boxes

When modifying objects, it is possible to use the Bounding Box
representation instead of accurate wireframe drawing. You can select this
method using the Modify/Draw mode menu.

When the bounding box representation is selected and you select an object
modification function, as soon as you click on a View, REAL 3D constructs
a box shape around each selected object and uses the boxes to show the
effect of the modification.

The bounding box representation may be suitable e.g. when resizing a
complex object; the new size can be seen immediately from the box shape,
without the possible redrawing delays.

2.4.2 Refresh Modes

You can speed up screen updates by choosing menu Settings/Refresh/Current.
Then the program updates only the active View window.

If the previous technique is not fast enough, select Settings/Refresh/
None. Then the program does not update at all.

Settings/Refresh/All turns the normal automatic updating on.

2.4.3 The Visible Range of the Objects

Often it is unnecessary to have objects drawn on the screen other than the
object you are creating. For example, if you are creating a rocking chair
inside a house, it is of no use to draw the house all the time. The house
should be drawn only when the rocking chair is ready and can be positioned
in the living room. In REAL 3D, you are able to allow only a portion of
the object to be drawn which can be useful when creating complex scenes.

The visible range of an object can be defined in relation to the current
level. You can define the number of the parent levels of the current level
to be drawn using the Settings/Oper. Level/Depth function, and by
selecting Settings/Oper. Level/Active menu.

If the Active toggle is unset, the whole project is drawn to the screen
regardless of which level is the current one.

If the Active toggle is set and the Depth is 0, only objects under the
current level are drawn.

2.4.4 Other Methods

- Using lower screen depth, for example 2 instead of 4, may speed up
screen refreshing considerably.

- Drawing speed of B-Spline objects can be adjusted using the View/
  Drawing_Set function. The lower the Surface and Curve subdivision, the
  faster the updating. Control Polygon representation without Knots and
  Curves is the fastest method.

                             - TUTORIAL 2.8 -

- You can make individual objects invisible using the WF-invisible gadget
  of the Modify/Properties/Attributes function. If it is important to see
  some wireframe, add a visible cube with a suitable size to the same
  level and make it RT-invisible. Then it shows the size and the location
  of the invisible object quickly, but the "cube" is not visible when test
  rendering.

2.5 THE MEASURING WINDOW

The measuring window can be used to substitute for the mouse or for
numerical input when accurate control is required.

The window displays the mouse coordinates of the active View. The
measuring windows input fields can modify the coordinates. The
coordinates can be expressed using the following alternatives:

- Hot-point or absolute space origin related coordinates.

- Input-plane oriented or absolute space oriented coordinate directions.

- Polar or normal 3D coordinates.

Furthermore, the measuring unit can be specified to be meters,
millimetres, inches etc.

The following examples demonstrate how to use the measuring window.
Open a View window and a measuring window:

To create a square rectangle:

1. Activate the View and hit <RAM >e to reset it.

2. Select Create/Visibles/Rectangle.

3. Activate the X gadget of the measuring window, enter 0 and hit
   <RETURN>. Then activate the Y gadget, enter 0 and hit <RETURN>.
   Leave Z as it is.

4. Press the ACCEPT gadget.

5. Activate the X gadget again, enter 0.8 and hit <RETURN>. Then activate
   the Y gadget, enter 0.8 and hit <RETURN>. You should see the rectangle
   on the display.

6. If the size of the rectangle is not suitable, re-enter the X and Y
   values.

7. Press ACCEPT to create the rectangle.

To move the rectangle 0.2 units to the X direction and 0.3 units to the
Z direction:

1. Select the rectangle and select Modify/Linear/Move.

2. Activate the "Hot-P" gadget of the measuring window.

3. Press the ACCEPT gadget to "grab" the rectangle.

4. Enter X = 0.2, Y = 0, Z = 0.3. Every time you enter a new value,
   you see the rectangle moving.

                             - TUTORIAL 2.9 -

5. Press ACCEPT

To create a cylinder sector of 45 degrees:

1. Activate the "Origin" and "Polar" gadgets.

2. Select Create/Sectors/Cylinder.

3. Enter X = 0, Y = 0 , Z = 0, and press ACCEPT.

4. Enter X = 0,Y = 0,Z = 2 and press ACCEPT.

5. Enter X = 45, Y = 0 , Z = 2. By modifying Z and N values, you can
   adjust the size and the depth of the sector. X defines the angle.

6. When the sector is suitable, press ACCEPT.

To rotate the cylinder 1 5 degrees around its center:

1. Activate the "Origin", "I-Plane" and "Polar" gadgets.

2. Select the sector and select Modify/Linear/Rotate.

3. <LMB> click in the center of the cylinder.

4. Press <CTRL> down and click directly to the right of the sector center.
   Keeping the <CTRL> down when pressing <LMB> defines a new coordinate
   but leaves the hot-point unaltered. This is necessary to measure the
   rotation around the sector center

5. Now use the measuring window: enter the angle to the X gadget. When the
   angle is suitable, hit ACCEPT. As you see, it is possible to swap from
   the normal mouse input to the measuring system input. If you want to
   start using the mouse again while executing a function, activate the
   View by clicking its title bar.

2.6 GRIDS

The grid function of REAL 3D rounds the mouse coordinates to a desired
grid. The grid system is based on a set of grids, of which one is the so
called current grid. The current grid can be "activated" so that the
coordinates snap to it, and it can be made visible. The number of grids
is not limited, and the current grid collection can be edited and expanded
freely.

If you do not know the grid function yet, experiment with it in the
following way:

1. Activate a View window and hit <RAM>e to reset it.

2. Select Create/Visibles/Rectangle and shape a rectangle. Observe that
   you can freely control the size of the rectangle.

3. Select the View/Grid/Snap to Grid toggle menu.

4. Create another rectangle. This time the shape of the rectangle can be
   defined only in grid units.

5. Create a third rectangle beside the second one. Observe how easy it is
   to match one edge of the new rectangle with an edge of the second
   rectangle.

                             - TUTORIAL 2.10 -

6. Select View/Grid/Visible. When you create new rectangles, it is easy
   to align them with the previous ones because you can follow the visible
   grid lines.

In the previous example, the internal default grid of 0.1 units was used.
You can specify another grid by using the View/Grid/Select function:
it allows you to pick a grid from the current grid collection. This grid
collection can be loaded, saved, or replaced using the Project/Project/
Load Sections, Save Sections or Replace sections functions and by
selecting the "Grids" gadget in the sections requester.

You can also save a suitable grid collection as a part of your working
environment by using Project/Project/Save Sections (e.g. to
s:real-startup) and by including "Grids" to the selected sections.

You can create a new grid using the menu View/Grid/Create. The most
important definitions are the "Name" and the three "Grid" gadgets, which
Specify the lengths of the grid units. It is good idea to name the grids
according to the grid unit sizes, so that selecting them using the name is
easy.

You can also specify the grid origin. The visible grid plane position,
size, color and line pattern can be controlled. The default pattern 65535
corresponds to a solid line, 21845 gives a dense dotted line and 4369
gives a less dense dotted line.

Grids can be modified using the View/Grid/Modify function and individual
grids can be deleted using the View/Grid/Delete function.

2.7 THE UNDO FUNCTION

The undo function can be used to restore the situation before the latest
action affecting the object structure. The undo depth can be specified
using Settings/Undo depth function; if the depth is greater than one, you
can restore the state of the scene several steps earlier. After restoring
the earliest state included in the undo buffer, the undo function jumps
back to the current situation. This means that you can safely step through
the undo buffer, because it works as a closed loop.

To use the undo feature, select Extras/Undo or hit the <RAM>U keys.
Note that Project/New function clears the undo buffer, thus deleting its
contents permanently. Undo stores only the object data structure.
You cannot undo e.g. window closing or material modifications.

You can use undo to restore an animation to its original state after the
playback. This is handy when creating particle animations, which cannot
be "rewound".

2.7.1 Undo and Memory Management

There are some tricks which can be helpful when meeting memory problems.

If the program does not execute a selected function, but gives a message
"NOT ENOUGH MEMORY", it is recommended that the scene is saved before
further actions.

Deactivating the undo feature using the Settings/Undo/Active menu usually
helps with low memory problems. You may also define a lower undo depth,
for example 1 instead of the default 3 steps.

Note:
If your scene causes memory problems while editing, it is almost certain
that you cannot render shaded images of it.

                             - TUTORIAL 2.11 -

2.8 VECTOR STACK

The Vector stack of REAL 3D is a general purpose storage for 3D vectors.
Many built-in functions use it in their operation, and you can use the
vectors stack for storing and manipulating coordinate data for all kinds
of modelling purposes.

REAL 3D includes a menu based "3D-calculator", which can do vector
subtraction, addition and other useful operations. It uses the vector
stack to store the parameters and results of such operations.

You can store 3D coordinates to the vector stack by entering the
coordinates from the keyboard or by using mouse operations. The
coordinates can be modified and combined using the vector operations and
later when creating or modifying objects, you can pick vectors from the
stack, instead of using <LMB> clicks.

The following example demonstrate using the vector stack.

An example: creating a polygon using information from existing objects

1. Create two objects, a sphere and a rectangle. The purpose is to create
   a triangle from the middle of the sphere to the middle of one side of
   the rectangle and to a given 3D point (1,1,0.5).

2. Press <SHIFT> down and drag a box (keep <LMB> down and move the mouse,
   so that REAL 3D displays a dotted-line rectangle) around the sphere.
   A set of crosses should appear on the View. These crosses show the
   current contents of the vector stack.

3. Select Extras/Vectors/Average All. This operation calculates an average
   of all the vectors in the stack. The vectors are removed from the stack
   and the result (the average) is pushed to the stack. So, only one cross
   is left in the middle of the sphere.

4. <SHIFT><drag> another box around the two points of an edge of the
   rectangle. Two more vectors are pushed to the stack.

5. Select Extras/Vectors/Average. This operation replaces the two topmost
   vectors in the stack with their average. So, the result is that the
   middle point of the rectangle edge is put into the stack.

6. Now the stack contains two vectors, and we enter the third one from the
   keyboard: select Extras/Vectors/Enter and type the coordinates 1, 1 and
   0.5 to the three fields of the numeric requester.

7. Select Create/Visible/Polygon. Instead of using <LMB>, select three
   times Extras/Vectors/Pull (or hit<RAM>.), and then use <RMB> to finish
   the polygon.

If the View window was not active when you selected the Polygon function,
activate it with a click on the title bar, so that the creation is
started. If it is a borderless View, you can activate it with a <LMB>
click and then undo the first point with the <DEL> key. In some cases,
you just have to activate the View first and then select the creation
function.

                             - TUTORIAL 2.12 -

Chapter 3 MATERIALS
-------------------

3.1 USING MATERIALS

3.1.1 General Information

When creating photorealistic images and animations, it is necessary not
only to create complex shapes, but to simulate different real world
material properties. REAL 3D includes excellent tools for this purpose.

REAL 3D represents objects as solids whose physical properties can be
defined using materials. Materials contain information about molecular
surface structure, colouring, and optical properties.

Basic material properties can be adjusted easily using slider gadgets.
More accurate control over properties can be achieved using so called
texture maps, which are bitmap images whose colors can be used to define
object surface colouring and other material properties. Mathematical
textures, which are mathematical formulas that define desired properties,
are also used. Since mathematical textures can be expressed as RPL
programs or user-defined formulas, there are again unlimited possibilities
to enhance and expand the built-in material features of REAL 3D.

Many advanced material features of REAL 3D utilize the solid modelling
principle of the program. Correct light refraction evaluation and non-
homogenous materials, such as gas clouds with a desired spatial density
distribution, are good examples. When working with REAL 3D, you store the
materials you may need in a material library, which is a memory resident
collection of individual materials. A material is a collection of
information which defines the characteristics of a real world material
such as wood, glass, steel, marble, water, etc.

You can manipulate the material library in many different ways: you can
delete materials from it, empty it, load an old library from disk and join
it to the current one, save the library , and last but not least, create
brand new materials using the material editor , and add them to the
library.

When you want to use a material for an object in your scene, you create a
new object in the hierarchy. This new "material" object acts as a
reference to one of the materials in the library, and at the same time,
defines certain geometric properties which are used in the precise
placement of the texture (material object) on the object (target solid
object) when texture mapping. This new material reference object is called
the mapping object. All the objects in the same hierarchy level with the
mapping object are affected by the material to which the mapping refers.

So, the principle is to have a library of materials and to use the
hierarchy tree to combine shapes with materials. For example, to model a
wooden candlestick, you first add the material wood to the material
library, then create a level "Wooden-Stick", and under that level you
place the stick shape object and the wood mapping object. You can
interpret this so that the wooden stick consists of stick and wood, shape
and the material. Natural, isn't it!

     WoodenStick
        Stick
        Wood

Note:
That the hierarchy tree contains references to the materials, not the
materials themselves. This approach has several advantages.
First of all, often you have to adjust the material properties afterwards;
it is sufficient to modify only one material to get the desired change in
all objects which are made of that material. Secondly, a material is very
large collection of information and therefore this method saves a lot of
memory.

                             - TUTORIAL 3.1 -

A real example of using materials will clarify this rather abstract
description. We will experiment with materials in the following tutorial
project.

3.1.2 Tutorial Project

Creating a shiny sphere standing on a marble cube is a suitable exercise
to demonstrate various aspects of using materials. First create a simple
object containing two primitives:

1. Start the program with the standard environment.

2. Create two shapes using Create/Visibles/Cube and Sphere functions.
   The hierarchy tree should look like the following:

     Root
        
cube                                                               
        ellipsoid                                                  
                                                                   
3. Open the material editor using the menu Project/Windows/Material

This opens a new window with many gadgets. Don't worry, most gadgets
contain good default values, and you will only have to define a couple
of things in order to create a material.

4. Type the name of the first material "shiny" to the name field.

The properties of "shiny" can be adjusted using a couple of sliders:

5. Move the Specularity slider to the middle, so that the percentage
   displayed at the right end of the slider becomes approximately 50%.

6. Adjust Brilliance to 80%.

Specularity creates high-lights, which make the object look shiny. The
higher the specularity, the sharper the high-lights. The second
specularity adjustment, specular brightness, defines the brightness of
the high-lights. The default value 25% is suitable, so you do not have
to change it. Brilliance is the "mirror-like" property: the higher the
value, the clearer the reflections you see on the surface of the
material. Brilliancy level 0 produces a matt surface with no reflections,
like unpolished paper.

Now that the properties are defined:

7. Hit APPLY button.

This creates the material "shiny", that is, adds the material to the
material library.

The second material can be created in a similar way.

8. Hit RESET button to remove old material properties.

9. Define the name of the second material, "marble".

10. Select material editor menu Texture/Define.

11. Select the file "r3D2:textures/marble1", using file selector.

12. Activate both Tile gadgets, X and Y

13. Press APPLY.


                           End Of Part 1



