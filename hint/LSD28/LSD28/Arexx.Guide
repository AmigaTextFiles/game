             /~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
             /~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
             /~~\___________________________________________/~~\
             /~~\___________________________________________/~~\
             /~~\__/~~\__________/~~~~~~~~\___/~~~~~~~~~\___/~~\
             /~~\__/~~\_________/~~~~~~~~~~___/~~~~~~~~~~\__/~~\
             /~~\__/~~\_________/~~\__________/~~\____/~~\__/~~\
             /~~\__/~~\_________/~~\__________/~~\____/~~\__/~~\
             /~~\__/~~\_________/~~~~~~~~~\___/~~\____/~~\__/~~\
             /~~\__/~~\__________/~~~~~~~~~\__/~~\____/~~\__/~~\
             /~~\__/~~\_________________/~~\__/~~\____/~~\__/~~\
             /~~\__/~~\_________________/~~\__/~~\____/~~\__/~~\
             /~~\__/~~~~~~~~~\__/~~~~~~~~~~\__/~~~~~~~~~~\__/~~\
             /~~\___/~~~~~~~~\___/~~~~~~~~\___/~~~~~~~~~\___/~~\
             /~~\___________________________________________/~~\
             /~~\________________________________________mUb/~~\
             /~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
             /~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\


                                   present

                               an ARexx Guide

                          ripped to you by mUb/LSD



Flow of control


[I] BREAK     : BREAK
Exit from innermost DO-END block or INTERPRET instruction


[I] DO        : DO
                DO FOREVER
                DO [FOR] count
                DO WHILE/UNTIL test
                DO var=start [TO limit] [BY step]
                DO [FOR] count WHILE/UNTIL test
                DO var=start [TO limit] [BY step] FOR count
                DO var=start [TO limit] [BY step] WHILE/UNTIL test
                DO var=start [TO limit] [BY step] FOR count WHILE/UNTIL test
Begin a block of instructions or a loop


[I] ELSE      : ELSE [;] instruction
Introduce code to be executed when an IF test fails


[I] END       : END [var]
Terminate a block of instructions beginning with DO or SELECT


[I] EXIT      : EXIT [expr]
Terminate a script


[I] IF        : IF test [;] THEN [;] instruction [ELSE [;] instruction]
Introduce code to be executed if test expression is True


[I] INTERPRET : INTERPRET [expr]
Execute ARexx instructions contained in a string


[I] ITERATE   : ITERATE [var]
Skip to the end of the current iterative loop


[I] LEAVE     : LEAVE [var]
Break out of current iterative loop


[I] NOP       : NOP
Do nothing - a dummy instruction


[I] OTHERWISE : OTHERWISE [;] [instruction(s)]
Introduce default case for SELECT control structure


[I] SELECT    : SELECT; WHEN ... [OTHERWISE [;] [instructions]] END
Branch to first case whose controlling condition is met


[I] SIGNAL    : SIGNAL ON type
                SIGNAL OFF type
                SIGNAL [VALUE] label-expression
Turn interrupt type on/off; transfer control to label


[I] THEN      : THEN [;] instruction
Execute dependent instruction if preceding expression was True


[I] WHEN      : WHEN test [;] THEN [;] instruction
In SELECT, introduce code to be executed if test is True



Functions and arguments


[I] ARG       : ARG [template] [,template ...]
Shorthand form of PARSE UPPER ARG


[F] ARG       : numargs = ARG()
                argn    = ARG(num)
                bool    = ARG(num, mode)
Return information about script or function arguments
Modes:   E - Exists          O - Omitted


[I] CALL      : CALL function(arg, arg, arg)
                CALL function arg, arg, arg
Invoke a function but ignore the result


[I] PROCEDURE : PROCEDURE [EXPOSE var [var ...]]
Protect function caller's variables from name collisions


[I] RETURN    : RETURN [expr]
Return control (and optionally a value) to caller



Strings (editing)


[F] COMPRESS  : s = COMPRESS(str, [list])
Remove the characters in list (default=space) from str


[F] DELSTR    : s = DELSTR(str, start, [len])
Delete len (default=rest of str) characters from str, from start


[F] INSERT    : s = insert(istr,str,[start],[len],[pad])
Insert len characters of istr into str at start


[F] OVERLAY   : s = OVERLAY(new, old, [start], [len], [pad])
Overlay len characters of new on old, from start


[F] STRIP     : s = STRIP(str, [mode], [list])
Strip leading and/or trailing characters in list from str
Modes:   B - Both (default)   L - Leading  T - Trailing


[F] SUBSTR    : s = SUBSTR(str, start, [len],[pad])
Extract len (default=rest of str) characters of str, from start


[F] TRANSLATE : s = TRANSLATE(str)
                s = TRANSLATE(str,[output],[input],[pad])
Translate str using input and output character tables


[F] TRIM      : s = TRIM(str)
Remove trailing blanks from str


[I] UPPER     : UPPER var [var ...]
Convert contents of variables to upper case


[F] UPPER     : s = UPPER(str)
Convert str to upper case



Strings (pattern matching)


[F] ABBREV    : bool = ABBREV(str, abbr, [len])
Test if abbr is an abbreviation of str with at least len characters


[F] COMPARE   : n = COMPARE(str1, str2, [pad])
Determine position at which strings differ (0 if identical)


[F] INDEX     : n = INDEX(str,pat,[start])
Return position of pat in str, from 1 or start (0 if not found)


[F] LASTPOS   : n = LASTPOS(pat,str,[start])
Return position of pat in str, searching backwards from end or start


[F] POS       : n = POS(pat,str,[start])
Return position of pat in str, from 1 or start (0 if found)


[F] VERIFY    : n = VERIFY(str,list,[match],[start])
Search str from 1 or start for characters in list; return index or 0
Modes (match) : M - Return index of first list character of str
    Other/default - Return index of first non-list character



Strings (formatting)


[F] CENTER    : s = CENTER(str, width, [pad])
Center str in a field of given width


[F] LEFT      : s = LEFT(str,count,[pad])
Extract leftmost count characters of str, pad on right if needed


[F] REVERSE   : s = REVERSE(str)
Reverse str


[F] RIGHT     : s = RIGHT(str,width,[pad])
Extract rightmost width characters of str, pad on left if needed


[F] SPACE     : s = SPACE(str, [len], [pad])
Set word-breaks in str to len spaces (or pad)



Strings (word-oriented)


[F] DELWORD   : s = DELWORD(str, start, [len])
Delete len words from str, beginning at start word


[F] FIND      : n = FIND(str, phrase)
Return position of word-string phrase in str


[F] SUBWORD   : s = SUBWORD(str, start, [count])
Extract count words (default=rest of str) from str, from start word


[F] WORD      : s = WORD(str,n)
Extract word n from str


[F] WORDINDEX : n = WORDINDEX(str,n)
Determine character position in str of start of word n


[F] WORDLENGTH: n = WORDLENGTH(str,n)
Determine length of word n in str


[F] WORDS     : n = WORDS(str)
Return number of words in str



Strings (miscellaneous)


[F] COPIES    : s = COPIES(str, n)
Concatenate n copies of str


[F] HASH      : n = HASH(str)
Calculate a hash value for str


[F] LENGTH    : n = LENGTH(str)
Return length of str in characters


[I] PARSE       : PARSE [UPPER] source [template] [,template]
      Source name          Source string contents
         ARG                  Arguments to script or function
         EXTERNAL             Input via STDERR file
         NUMERIC              NUMERIC options: digits fuzz form
         PULL                 Input via STDIN file
         SOURCE               type result called resolved ext host
         VALUE expr WITH      Result of expression
         VAR varname          Contents of varname
         VERSION              version cpu mpu video freq
Split input string(s) into substrings


[F] XRANGE      : s = XRANGE([c1],[c2])
Build character string from c1 to c2 with consecutive ASCII values



Numbers


[F] ABS         : absval = ABS(num)
Return absolute value of numeric expression


[F] DIGITS      : n = DIGITS()
Return current NUMERIC DIGITS setting


[F] FORM        : f = FORM()
Return current NUMERIC FORM setting


[F] FUZZ        : f = FUZZ()
Return current NUMERIC FUZZ setting


[F] MAX         : n = MAX(n1, n2 [, n3 ...])
Find the largest of a set of numbers


[F] MIN         : n = MIN(n1, n2 [, n3 ...])
Find the smallest of a set of numbers


[I] NUMERIC     : NUMERIC DIGITS num
                  NUMERIC FUZZ   num
                  NUMERIC FORM SCIENTIFIC
                  NUMERIC FORM ENGINEERING
Set numeric calculation and display options


[F] RANDOM      : n = RANDOM([low],[high],[seed])
Return pseudo-random integer between low and high inclusive


[F] RANDU       : n = RANDU([seed])
Return pseudo-random number between 0 and 1


[F] SIGN        : n = SIGN(num)
Determine the sign of a number, return -1, 0, or 1


[F] TRUNC       : n = TRUNC(number,[places])
Truncate number to places decimal places



Bit manipulation


[F] BITAND      : s = BITAND(str1, [str2], [pad])
Return bit-wise AND of two strings, padded to equal length


[F] BITCHG      : s = BITCHG(str, n)
Invert bit n, counting from right, in str


[F] BITCLR      : s = BITCLR(str, n)
Clear bit n, counting from right, in str


[F] BITCOMP     : n = BITCOMP(str1, str2, [pad])
Return first bit, counting from right, at which str1 ~= str2 (-1 if equal)


[F] BITOR       : s = BITOR(str1, [str2], [pad])
Return bit-wise OR of two strings, padded to equal length


[F] BITSET      : s = BITSET(str, n)
Set bit n, counting from right in str


[F] BITTST      : bool = BITTST(str, n)
Test bit n, counting from right, in str


[F] BITXOR      : s = BITXOR(str1, [str2], [pad])
Return bit-wise exclusive-OR of two strings, padded to equal length



Data conversion


[F] B2C         : s = B2C(binstr)
Return character equivalent of binary string


[F] C2B         : b = C2B(str)
Return binary digit string equivalent to character string


[F] C2D         : n = C2D(str, [len])
Return integer number corresponding to string (of len bytes)


[F] C2X         : h = C2X(str)
Return hexadecimal number corresponding to string


[F] D2C         : s = D2C(num,[count])
Return string equivalent, count bytes long, of num


[F] D2X         : h = D2X(num,[count])
Return hexadecimal string, count bytes long, equivalent to num


[F] X2C         : s = X2C(hex)
Return character equivalent of hex string


[F] X2D         : n = X2D(hex,[n])
Convert n rightmost digits (or all) of hex string to decimal



Values and variables


[F] DATATYPE  : type = DATATYPE(str)
                bool = DATATYPE(str,mode)
Test attributes of string (type = `NUM' or `CHAR')
Modes:   A - Alphanumeric  B - Binary        L - Lower case
         M - Mixed case    N - Numeric       S - Symbol
         U - Upper case    W - Whole number  X - Hexadecimal


[I] DROP      : DROP var [var ...]
Restore a variable to its uninitialized state


[F] SYMBOL    : s = SUBWORD(str)
Determine if a string is a valid ARexx symbol


[F] VALUE     : val = VALUE(str)
Treating str as an ARexx symbol, return its value



Console input/output


[I] ECHO      : ECHO expr
Send the expression result to the standard output


[F] LINES     : n = LINES([file])
Return number of lines queued for interactive stream


[I] PULL      : PULL [template] [,template ...]
Shorthand form of PARSE UPPER PULL


[I] PUSH      : PUSH expr
Pre-load the standard input in `last-in, first-out' order


[I] QUEUE     : QUEUE expr
Pre-load the standard input in `first-in, first-out' order


[I] SAY       : SAY [expr]
Send expression result to standard output (usually console)



File input/output


[F] CLOSE     : bool = CLOSE(file)
Close the file with the given identifier


[F] EOF       : bool = EOF(file)
Return 1 if end of file has been detected; else 0


[F] OPEN      : bool = OPEN(file, name, [mode])
Open a file called name in given mode
Modes: R - Read (default)   W - Write (create)   A - Append


[F] READCH    : s = READCH(file, [count])
Return count characters from file


[F] READLN    : s = READLN(file)
Return a line from file as a string


[F] SEEK      : n = SEEK(file,offset,[mode])
Move file position to offset according to mode
Modes: C - Current (default)  B - Beginning  E - End


[F] WRITECH   : n = WRITECH(file, str)
Write str to file, return count written


[F] WRITELN   : n = WRITELN(file, str)
Write str plus linefeed to file, return count written



Files


[S] DELETE    : bool = DELETE(name)
Delete a file or directory


[F] EXISTS    : bool = EXISTS(name)
Return True if given file or directory exists


[S] MAKEDIR   : bool = MAKEDIR(dirname)
Create a directory of the given name


[S] RENAME    : bool = RENAME(oldname, newname)
Rename a file or directory


[S] SHOWDIR   : filelist = SHOWDIR(dir, [mode], [pad])
List the file and/or directory names in a directory
Modes: A - All (default)    F - Files only  D - Directories only


[S] STATEF    : filestring = STATEF(pathname)
Obtain information about a file or directory
Format: type size blk bits day min tick com



Script environment


[F] DATE      : d = DATE([outmode],[indate],[inmode])
Find today's date, or info about a specified date
Modes:   B - Base (days since 01/01/0000)
         C - Century (days this century)
         D - Days (days since start of year, counting today)
         E - European (dd/mm/yy - e.g. 19/11/76)
         I - Internal (days since 01/01/1978)
         J - Julian (yyddd - 2-digit year, 3-digit days this year)
         M - Month name in English mixed case (e.g. `November')
         N - Normal, the default (dd mmm yyyy, e.g. 01 Jun 1986)
         O - Ordered (yy/mm/dd, e.g. 84/05/24)
         S - Standard (yyyymmdd, e.g. 19921005)
         U - USA (mm/dd/yy, 12/21/88)
         W - Weekday name in English mixed case (e.g. `Thursday')


[F] ERRORTEXT : text = ERRORTEXT(n)
Return a description of syntax error number n


[I] OPTIONS   : OPTIONS
                OPTIONS [NO] RESULTS
                OPTIONS [NO] CACHE
                OPTIONS PROMPT [expr]
                OPTIONS FAILAT expr
Set script options


[F] SOURCELINE: n = SOURCELINE()
                s = SOURCELINE(num)
Read count of source lines, or line num from current script


[F] TIME      : t = TIME([mode])
Find current or elapsed time
Modes:   C - Civil (h:mmAM or h:mmPM, e.g. 3:07AM)
         E - Elapsed (s.cc, seconds and hundredths, in interval)
         H - Completed hours since midnight (e.g. 4)
         M - Completed minutes since midnight (e.g. 243)
         N - Normal, the default (hh:mm:ss, e.g. 17:04:41)
         R - Same as elapsed, but resets timer to 0.00
         S - Completed seconds since midnight (e.g. 17353)


[I] TRACE     : TRACE mode
                TRACE [VALUE] expr
                TRACE num
Set tracing mode
Modes:   A - All clauses  B - Background     C - Commands
         E - Errors       I - Intermediates  L - Labels
         N - Normal       O - Off            R - Results
         S - Scan
Special features: ? - Interactive         +num - skip interactive pauses
                  ! - Command inhibition  -num - trace suppression count


[F] TRACE     : t = TRACE([mode])
Get/set tracing mode (see modes under TRACE instruction)



ARexx environment


[F] ADDLIB    : ADDLIB(name, pri, [offset, version])
Add function library/host name to library list


[I] ADDRESS   : ADDRESS
                ADDRESS name
                ADDRESS VALUE name-expression
                ADDRESS name command-expression
Modify host address; send command to a host


[F] ADDRESS   : host = ADDRESS()
Return host address string


[F] FREESPACE : n = FREESPACE()
                n = FREESPACE(addr, size)
Return size bytes of memory at addr to ARexx's internal memory pool


[F] GETCLIP   : s = GETCLIP(clip)
Return value string associated with clip name


[F] GETSPACE  : addr = GETSPACE(size)
Allocate size bytes of memory in ARexx's internal memory pool


[F] REMLIB    : bool = REMLIB(name)
Remove an entry from the Library List


[F] SETCLIP   : bool = SETCLIP(name, [value])
Set string value for clip name (remove name if value omitted)


[I] SHELL     : SHELL
                SHELL name
                SHELL VALUE name-expression
                SHELL name command-expression
Modify host address; send command to a host


[F] SHOW      : s    = SHOW(mode,,[pad])
                bool = SHOW(mode,name)
Return information about a resource
Modes:   C - Clips               F - Files        I - Internal ports
         L - Function Libraries  P - Public ports



Messages, packets and ports


[S] CLOSEPORT : bool = CLOSEPORT(portname)
Close a message port opened with OPENPORT


[S] GETARG    : arg = GETARG(packet, [whicharg])
Obtain an argument string from a message packet


[S] GETPKT    : pkt = GETPKT(portname)
Pick up a message packet from a message port


[S] OPENPORT  : bool = OPENPORT(portname)
Open a public message port with the given name


[S] REPLY     : 1 = REPLY(pkt, [result], [result2])
Return a message packet to its sender, default results = 0, 0


[S] TYPEPKT   : cmd   = TYPEPKT(pkt)
                count = TYPEPKT(pkt,'a')
                bool  = TYPEPKT(pkt,mode)
Extract information from a message packet
Modes: F - Function    C - Command


[S] WAITPKT   : bool = WAITPKT(portname)
Wait for a message packet to arrive at a port



Operating system


[S] ALLOCMEM  : mem = ALLOCMEM(size, [type])
Allocate size bytes of system memory, with type attributes


[S] BADDR     : addr = BADDR(bptr)
Convert BPTR to address


[S] DELAY     : 0 = DELAY(n)
Pause for n 50ths of a second


[F] EXPORT    : count = EXPORT(addr,[str],[len],[pad])
Copy len bytes of str to memory at addr


[S] FORBID    : count = FORBID()
Turn off multitasking


[S] FREEMEM   : 1 = FREEMEM(addr, size)
Free size bytes of memory at addr allocated by ALLOCMEM


[F] IMPORT    : s = IMPORT(addr,[len])
Return contents of len bytes (or 0-terminated) memory at addr


[S] NEXT      : value = NEXT(addr,[offset])
Return the 4-byte value stored at addr + offset


[S] NULL      : '00000000'x = NULL()
Return a 4-byte string corresponding to a null address


[S] OFFSET    : addr = OFFSET(addr,amount)
Return the address addr + amount


[S] PERMIT    : count = PERMIT()
Re-enable multitasking after FORBID


[F] PRAGMA    :   oldcd = PRAGMA('d', [newcd]) /* Current directory */
                 oldpri = PRAGMA('p', newpri)  /* Task priority     */
                oldsize = PRAGMA('s', size)    /* Stack size        */
                      1 = PRAGMA('w', [mode])  /* DOS requesters    */
                     id = PRAGMA('i')          /* Task ID (address) */
                   bool = PRAGMA('*', [file])  /* Console handler   */
A grouping of system-specific facilities as one function


[S] SHOWLIST  : list = SHOWLIST(mode,,[pad])
                bool = SHOWLIST(mode, name)
                addr = SHOWLIST(mode, name,, 'a')
Return information about a shared system list
Modes:   A - Assigns       D - Devices     H - Handlers
         I - Interrupts    L - Libraries   M - Memory
         P - Ports         R - Resources   S - Semaphore
         T - Ready tasks   V - Volumes     W - Waiting tasks


[F] STORAGE   : n = STORAGE()
                s = STORAGE(addr,[str],[len],[pad])
Copy len bytes of str to memory at addr
