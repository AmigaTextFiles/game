

			SUPERBASE PROFESSIONAL
		     DATABASE MANAGEMENT LANGUAGE
			     USER GUIDE

			       Part I

BEFORE YOU BEGIN...

This Volume presents you with two user guides,one for Superbase's Database
Management Language (DML) and one for the Forms Editor. Although they are
both under the same cover, they can be treated as separate manuals. Each
has its own Contents, Index, chapter numbers and page numbers.

Note that the Forms Editor is a separate program from Superbase
Professional. You will find instructions on how to install and load it on
your computer in the Readme document which is supplied on the demonstration
file disk. If you haven't done so already, you should read this document
now. It also provides details of any features of Superbase Professional
that are not covered in either Volume 1 or 2.

				i

DML USER GUIDE
CONTENTS

CHAPTER 1
INTRODUCTION TO DML						1-1
Using this guide						1-1
CHAPTER 2		
OVERVIEW							2-1
Operating Modes							2-1
Keywords and Reserved Words					2-1
Commands and Statements						2-2
Variables							2-2
File Types							2-4
Fields								2-5
Date and Time							2-6
Functions							2-6
Operators							2-7
Constants							2-13
Expressions							2-14
Line Format and Labels						2-14
Syntax								2-15
CHAPTER 3
THE PROGRAM EDITOR						3-1
Creating a New Program						3-3
Editing a Program						3-4
Using the Command Line						3-6
Loading a Program						3-7
Saving a Program						3-7
Running a Program						3-8
Creating a Start Up Program					3-8
CHAPTER 4
FUNCTION KEYS							4-1
Setting a Function Key						4-1
Function Keys for Commands					4-2
Functions Keys for Text and Program Entry			4-3

				ii

Editing a Function Key String					4-4
Function Key Files						4-5
CHAPTER 5
KEYWORD REFERENCE GUIDE						5-1
Syntax Conventions						5-1
? Commands							5-3
?								5-8
? DIRECTORY							5-9
? LIST								5-9
? MEMORY							5-10
? QUERY								5-10
? STATUS							5-11
? TEXT								5-12
ABS								5-13
ADD								5-14
AFTER GROUP							5-17
AFTER REPORT							5-18
ASC								5-18
ASK								5-19
ATN								5-20
BEFORE GROUP							5-21
BELL								5-22
BLANK								5-22
BREAK								5-23
CALL								5-24
CHAIN								5-24
CHR$								5-24
CLEAR								5-26
CLOSE								5-26
CLOSE FIELDS							5-27
CLOSE FILE							5-28
CLOSE FORM							5-28
CLS								5-29
COL								5-29
COPY								5-30
COS								5-30
CREATE								5-31
CREATE INDEX							5-32
DATA								5-33
DATE$								5-34
DATEBASE							5-35

				iii

DAY								5-36
DAY$								5-37
DAYS								5-38
DELETE								5-39
DIM								5-39
DIRECTORY							5-40
DISKSPACE							5-41
EDIT								5-42
EJECT								5-43
END								5-44
END GROUP							5-44
END HEADING							5-45
END REPORT							5-45
ENTER								5-46
EOF								5-48
ERASE								5-49
ERR$								5-50
ERRNO								5-50
EXECUTE								5-51
EXP								5-52
EXPORT								5-53
FCASE$								5-55
FILE								5-56
FIX								5-57
FOOTING								5-58
FOR TO NEXT							5-58
FORM								5-60
FOUND								5-60
FREE								5-61
GET								5-62
GOSUB								5-62
GOTO								5-63
GROUP								5-64
HEADING								5-65
HOME								5-65
HRS								5-66
IF THEN ELSE							5-66
IMPORT								5-69
INDEX								5-70
INPUT								5-71
INSTR								5-72
INT								5-74

				iv

KEY								5-75
LABELS								5-77
LCASE$								5-78
LEFT$								5-78
LEN								5-80
LET								5-80
LIST								5-82
LOAD								5-83
LOCATE								5-84
LOG								5-85
LOOKUP								5-85
LTRIM$								5-87
MAKE								5-88
MENU								5-89
MENU CLEAR							5-90
MENU ON								5-90
MERGE								5-92
MID$								5-92
MINS								5-94
MOD								5-94
MODIFY								5-95
MONTH								5-96
MONTH$								5-97
NEW								5-98
NEWLINE								5-98
NOW								5-99
NUMBASE								5-100
ON ERROR							5-100
ON GOSUB							5-102
ON GOTO								5-102
OPEN								5-103
OPEN FORM							5-104
OPEN FIELDS							5-104
OPEN FILE							5-105
ORDER								5-106
OUTPUT TO							5-109
PASSWORD							5-110
PCOL								5-110
POSITION							5-111
PRINT								5-112
PROTECT								5-114
PROW								5-114

				v

QUIT								5-115
READ								5-116
RECCOUNT							5-116
REM								5-117
REMOVE FILE							5-118
REMOVE FROM							5-118
REMOVE INDEX							5-119
RENAME								5-120
REORGANIZE							5-120
REPLICATE							5-121
REPORT								5-122
REQUEST								5-123
RESTORE								5-125
RESUME								5-126
RETURN								5-127
RIGHT$								5-127
RND								5-128
ROW								5-129
RUN								5-129
SAVE								5-130
SAVE FILE							5-130
SAY								5-131
SCRDUMP								5-132
SECS								5-132
SELECT commands							5-132
SELECT CURRENT							5-133
SELECT DUPLICATE						5-134
SELECT FIRST							5-134
SELECT KEY							5-135
SELECT LAST							5-136
SELECT NEXT							5-136
SELECT PREVIOUS							5-136
SELECT REMOVE							5-137
SELECT WHERE							5-137
Query Language Commands						5-138
SELECT								5-140
SER								5-142
SET								5-142
SET BUFFERS							5-144
SET PAGING							5-144
SET view mode							5-145
SGN								5-145

				vi

SHOW								5-145
SIN								5-147
SPACE$								5-147
SQR								5-148
STORE								5-148
STR$								5-150
TAN								5-151
THOUSECS							5-151
TIME$								5-152
TIMEVAL								5-152
TODAY								5-153
TRIM$								5-154
UCASE$								5-154
UPDATE								5-155
VAL								5-156
VIEW								5-157
WAIT								5-157
WHERE								5-158
WHILE WEND							5-160
YEAR								5-160
CHAPTER 6
QUICK REFERENCE GUIDE						6-1
INDEX								I-1

				vii

		     CHAPTER 1 - INTRODUCTION TO DML

Welcome to Superbase Professional's Database Management Language (DML). DML
is based on the programming language Basic. It includes most of the
standard Basic commands and functions, but supplements them with a large
number of commands and functions that are specific to database management.

The database commands duplicate the controls that Superbase Professional
provides through its menus and dialogs. This means that almost all of
Superbase's file and record handling facilities are available under program
control. In fact, apart from Fast Forwards, Rewind and Duplicate, you can
now carry out any Superbase operation using a single program command.

Once you have familiarized yourself with Superbase's controls, the
corresponding program, you may find the idea of learning a program language
daunting. But as far as DML is concerned, a little goes long way, and you
do not need to be fully conversant with the language in order to take
advantage of it.

In effect, you are already following a program sequence every time you
perform a task which involves a series of menu operations. Writing a
program that performs the task for you is simply a matter of entering
commands in the same sequence. Generally, you will be able to find a single
command to duplicate each of the menu operations.

As you acquire more expertise, you can move on, building bigger and more
complex programs by combining routines, until you have fully automated your
database system. When you're ready, you can incorporate Superbase forms
into your programs, taking advantage of their built-in facilities for
generating and retrieving records in several files at once.

At the highest level, you can specify your own pull-down menus, replacing
the standard Superbase menus with the options that are relevant to the job
in hand. And you can customize your application to an even more detailed
level by creating your own pop-up selection panels to guide the user's
choices.

				1-1

USING THIS GUIDE

Before reading this guide, you will need to be familiar with Superbase's
menu and keyboard controls. Many of DML's commands provide a program
equivalent of a menu or keyboard option, and the descriptions given here
presume that you already know how to use the corresponding option.

However, once you have mastered Superbase itself, you do not need to read
this book all the way through. As a reference guide, it can be consulted as
and when it is needed.

HOW TO USE THIS GUIDE

Chapter 2, Overview, describes the most basic features of DML. You can
think of it as a grammar book for the language. It sorts DML's 'keywords'
and other components into different groups and, more importantly, sets out
all the rules for using them. For example, it specifies the maximum length
for a program line,  and gives the rules for creating variable names.

Chapter 3 explains how to use the Program Editor. This covers entering and
editing programs, storing them on disk and loading them from disk. It also
explains how to execute programs, and how to create a 'start up' program
which will be executed automatically when you start a session with
Superbase.

Chapter 4 describes Superbase's function key facility. It explains how to
define the function keys and discusses various applications for them.

Chapter 5, Keyword Reference Guide, forms the bulk of the manual. In this
chapter, you will find an entry for each DML keyword, which gives the
keyword's syntax and describes its usage. The entries are in alphabetical
order starting with the ? command. At the front of Chapter 5, there is an
explanation of the conventions used to show a keyword's syntax.

Chapter 6 is a Quick Reference Guide. It gives the syntax for each DML
keyword together with a brief description of its function.

				1-2

			CHAPTER 2 - OVERVIEW

OPERATING MODES

DML has two modes of operation: direct mode and program mode.

DIRECT MODE

In this mode, DML executes instructions as soon as you have typed them in.
First you need to select the Command option from the Program Menu. Then
enter your instructions - a single command or a line of commands separated
by colons - in the command line window; when you select 'OK' or press the
Return key, DML will carry out the instructions straight away. The command
line window is 64 characters long but you can enter up to 255 characters
and move within the window using the cursor keys.

PROGRAM MODE

In program mode, DML does not execute commands as you enter them. Instead
they are stored in memory and executed only when the program is run. The
main difference between this mode and direct mode is that with the latter
you can only enter and execute one line at time; program mode allows you to
enter a series of instruction lines which are carried out in sequence.
Program lines can be up to 255 characters long.

OTHER DML APPLICATIONS

DML's functions, along with its operators and variables, can also be used
in other Superbase operations - such as field definition validations and
calculations, filter conditions, update commands and query derived field
definitions.

KEYWORDS AND RESERVED WORDS

Any word that DML recognizes as a specific instruction, or part of an
instruction, is known as a keyword.

A keyword cannot be used as a variable name, a field name, or a label. In
this context, keywords are also knows as reserved words - DML reserves them
for its own use, and will interpret then as such even if they are in lower
case.

				2-1

A reserved word can, however, from part of a name. For example, you can
incorporate the reserved word TO in any of the following ways:

TOP:		(in a label)
TOTAL%		(a numeric variable)
tot$		(in a string variable)
TOTALS$		(in a field name)

But you cannot use it like this:

TO:
TO%
TO$

COMMANDS AND STATEMENTS

Some programming manuals make a strict division between two kinds of
executable instructions - commands and statements. Commands are those
instructions which are generally executed in direct mode, while statements
are instructions that can only appear in a program line.

In DML there are only a few instructions that cannot be used in both
operating modes and so the two terms are used almost interchangeably. Thus
we refer to a line with more than one instruction on it as a
multi-statement line; but it could equally well be called a multi-command
line.

VARIABLES

There are three types of variables in DML: string variables, numeric
variables,  and arrays. In many circumstances, the fields in a Superbase
file can also be treated in the same way as variables.

VARIABLE NAMES

Numeric variables must end with the '%' character, string variables end
with an '$' character. Apart from this, the names for both types of
variable follow the same rules:

Variable names have a maximum length of 14 characters and a minimum length
of 1 character (excluding '%' or '$').

The first character of the name must be a letter in the range 'a' to 'z'
but the remaining characters can be either alphabetic or numeric.

				2-2

DML is not case sensitive; 'abc%' is the same as 'ABC%', and 'abc$' is the
same as 'ABC$'.

A variable name can contain a reserved word, but cannot consist of just a
reserved word and the variable suffix, % or $. For example, names like
'lef$',  'cos%', 'report$' and 'FILE%' are forbidden. See Appendix A for
the list of reserved words.

Before using a variable, you must define it by assigning a value to it.
This means that the first occurrence of a variable should be in an
assignment statement, with the variable to the left of the equal sign.
Suppose, for example,  you instructed DML to display the value of a$, using
the command

	? a$

If you have not assign a value to a$ beforehand, DML will issue the error
message:

	Can't do this
	Variable not defined

To avoid this error message, you would have to define a$ at an earlier
stage in the program, with line such as

	a$="Hello"

or

	a$=""

The double quotes are known as the 'empty string'. They allow you to define
a string variable without actually assigning a specific value; they are
also used to clear the contents of string variables.

There are, however, a number of exceptions to the rule about defining
variables. Some statements - READ, ASK, WAIT, and INPUT - define variables
implicitly when they are used for the first time. Thus DML would accept the
line:

	READ a$

even if you had not assigned a value to a$ previously.

NUMERIC VARIABLES

DML's numeric variables hold numbers at 13 figure accuracy, but if
displayed or printed, they are shown in the current default numeric format.
Note that there is only one type of numeric variable. In some versions of
Basic, the % suffix indicates that the variable can only store whole
numbers (integers): in DML, the

				2-3

same numeric variable can be used for both whole numbers and floating point
numbers.

STRING VARIABLES

String variables are used to hold ASCII characters - usually alphanumeric
text. The maximum length of data that can be held in a string variable is
255 characters.

ARRAYS

DML supports string and numeric arrays with up to three dimensions. The
maximum number of elements in an array is limited only by the amount of
memory available.

The rules for array names are the same as those for numeric and string
variables. Numeric arrays must end with '%' character, string arrays must
end with '$' character.

SYSTEM VARIABLES

TODAY, NOW and ERRNO are variables which are supplied by DML. TODAY gives
the system date, NOW gives the system time. DML treats these in the same
way as date and time fields; that is, although they are numeric variables,
they are displayed in the current date or time format. If the time of day
is 9:41 and the system clock has been set to this time. NOW would display
it as 9:41. But it stores this as 34919810 - the number of thousandths of a
second from midnight to 9:41. ERRNO returns the number of the last error
that occurred.

You cannot assign a value to a system variable, but otherwise TODAY, NOW
and ERRNO can used in the same way as any other numeric variable.

FILE TYPES

When you save a file using one of the SAVE options, DML automatically adds
one of the following extension names to the file name:

	aaa.sbf is a database file
	aaa.sbd is a file definition for a database file
	aaa.sbk is a function key file
	aaa.sbp is a program file
	aaa.sbq is a Query file
	aaa.sbt is a text file saved from the text editor

				2-4

	aaa.sub is an Update file
	aaa.### is an index (where ### is a number from 001 to 999)

DML stores program files, Text Editor files, database files and index files
in its own format (for example, it tokenizes keywords in program files and
stores formatting information with documents saved in the Text Editor). The
others are all text files and only contain ASCII characters.

FIELDS

With a few exceptions, you can use fields in the same way as variables. For
instance, you can input data directly to fields; you can supply a field
name as the argument for a function; and you can assign values to fields.

Fieldnames must conform to the rules for field names as set out in Volume
1, i.e.:

	The maximum length is 15 characters.
	The minimum length is one character.

They must begin with an alphabetic character, but can thereafter contain
any alphanumeric characters. They can also contain the underscore and space
characters. Superbase will accept a field name with several spaces embedded
in it - i.e., 'a bc d' is a valid name - but this is not recommended.

DML is not case sensitive; 'abc' is the same as 'ABC'.

The file a field belongs to must be open; otherwise the following requester
appears:

	Can't do this....
	'field name'
	Can't find this field

Where more than one file is open and there are two files with the same
field name, the file name must be given as an extension to the field name
and the two must be separated by a full stop. This enables DML to identify
the field you are referring to.

NOTE: FAILING TO SUPPLY FILE EXTENSION NAMES TO FIELDS MAY RESULT IN
INCORRECT DATA, ALTHOUGH IT DOES NOT CAUSE AN ERROR.

				2-5

If the file name contains spaces, it must be included within quotation
marks,  e.g.:

	fielda.filea
	name.Customers
	Lastname."Customer File"

DATE AND TIME

Superbase stores dates as julian date numbers; that is, as the number of
days from 31st December in the year zero. This means that date fields are
numeric fields and hold their dates as numbers. When you display a date
field, however,  Superbase automatically converts it to a more recognizable
format: it takes the format which has been set in the file definition (see
Chapter 2, Volume 1).

The date format only controls the way dates are displayed. You can enter a
date from the keyboard in almost any format. For instance, the date might
be shown on screen as 24/02/87, but you can type in a date like '28
February, 1962' and DML will accept it.

Incidentally, DML does remember that eleven days were lost when the
Gregorian Calendar reform was implemented (September 2nd, 1752 is followed
by September 14th).

As with dates, DML stores the time in time fields as a numeric value, but
displays it in a different format. The time is stored as the number of
thousandths of a second from midnight. When you display the time, it is
given in hours and minutes in either 12 or 24 hour format.

FUNCTIONS

Functions form one of the largest groups of DML keywords. Most of them
perform a calculation on a number or a string, but there are also functions
that give information about some aspect of the system. RECCOUNT, for
example returns the number of records in a file, and FREE returns the
amount of free memory space. Unlike a command, a function cannot be entered
on its own as a statement. Thus:

	? RECCOUNT ("address")

				2-6

	NUMRECS%=RECCOUNT ("address")

are valid statements, but

	RECCOUNT ("address")

produces an error message.

All functions take an argument, which is enclosed in parentheses, and
return a result. If the function calculates a result, the argument is what
it works on. In the example above, "address" is the argument. It tells the
function which file to count.

Depending on the function, the argument (or arguments) may be a field name,
a file name, constant, a variable, or a combination of these connected by
an operator to form an expression. You will find details of what kind of
argument a function expects, in the Keyboard Reference section.

Although functions are usually classed as either string or numeric
functions,  this does not always guarantee that they take a particular kind
of argument. Numeric functions always take numeric arguments, but some
string functions also expect a numeric argument. CHR$, for example, returns
a string result from a numeric argument.

When it comes to finding out what type of result a function returns, there
is a simple rule you can apply. Functions which have a $ character at the
end, return their results as string data; if they do not end in a $, they
return a numeric result. There is one exception to this rule - REPLICATE,
which returns a string result, despite the fact that it does not have a $
at the end.

OPERATORS

DML provides three types of operators: arithmetic, relational and string.

ARITHMETIC OPERATORS

Addition

The plus sign specifies that the operand on the right is added to the
operand on the left, e.g.:

	2 + 2
	a% + b% + c%
	a% + 12.225

				2-7

Subtraction

The minus sign specifies that the operand on the right will be subtracted
from the operand on the left e.g.:

	-3
	-a%

Multiplication

The asterisk is recognised by DML as the multiplication symbol and
specifies that the operand on the left is multiplied by the operand on the
right, e.g.:

	3 * 2
	a% * b%
	a% * 12.225

Division

The slash is recognized by DML as the division symbol and specifies that
the operand on the left is divided by the operand on the right, e.g.:

	3 / 2
	a% / b%
	a% / 12.225

NOTE: UNLIKE IN MANY OTHER PROGRAMMING LANGUAGES, DIVISION BY ZERO DOES NOT
CAUSE AN ERROR MESSAGE AND RETURNS A VALUE OF ZERO. THIS, OF COURSE, IS A
FALSE RESULT,  AND YOU SHOULD CHECK NUMERICAL DATA TO ENSURE IT DOES NOT
OCCUR.

Exponentiation

The up arrow (or caret) is recognized by DML as the exponentiation symbol
and specifies that the operand on the left is raised to the power specified
by the operand on the right (the exponent); that is, the operand on the
left is multiplied by itself the number of times specified by the exponent.
If the exponent is 2, the number is squared; if the exponent is 3, the
number is cubed; if the exponent is 1/2, the square root of the number
results, e.g.:

				2-8

	3 ^ 2			(3 squared)
	a% ^ b%		
	a% ^ 12.225
	a6 ^ 0.5		(the square root of 16)
	27 ^ 0.33333333		(the cuberoot of 27)
	3 ^ -2			(1/3 * 1/3)

Modulo arithmetic

MOD gives the remainder when the operand on the left is divided by the
operand to the right, e.g.:

	17 MOD 7		(returns 3)
	a % MOD b%

Parentheses

Parentheses are used to change the order in which the different parts of an
expression are calculated. Without parentheses, expressions are evaluated
in a certain order which depends on the operators they contain - some
operators have precedence over others (see the Table of Precedence). For
example, multiplication has precedence over addition; so, in the
expression:

	3 + 4 * 2

the 'four times' part is worked out first and then added to 3, giving 11 as
the result. You could alter this by enclosing '3 + 4' in parentheses:

	(3 + 4) * 2

to give a result of 14.

Parentheses must always be paired - each '('should have a matching')'.

Concatenation

When used with strings or string variables, the plus sign causes the string
specified by the right operand to be appended to the string specified by
the left operand, e.g.:

	"ABCD" + "defg"			evaluates as "ABCDefgh"

Used in this way, the plus sign acts as a string operator.

				2-9

RELATIONAL OPERATORS

Relational operators compare the values of two numbers or two strings, and
return a result which is either true or false. They are mainly used with IF
THEN and WHILE WEND statements to make a decision about whether the program
takes a particular action or not. For example:

	IF n% > 30 THEN GOSUB label

The relational operators are:

	>		greater than		   12>55 is false, i.e.0
	=		greater than or equal to	
	<		less than
	<=		less than or equal to	   27<=27 is true, i.e.-1
	<>		not equal to		   1=5-4 is true, i.e.-1
	=		equal to
	LIKE		pattern matching operator for strings.
	CONTAINS	pattern matching operator for text files.

As far as the user is concerned the result of comparison is either true or
false. But when DML comes to evaluate a comparison, it actually assigns a
numeric value to the result. If the result is true, DML assigns it the
value of -1; if false, it assigns the value of 0. This means that if you
enter the statement:

	? 8>5

or

	? "F"=LEFT$ ("FRIDAY", 1)

DML will display -1. If the result of a comparison is false, it will
display 0. For string operands, comparison is character by character from
the left where 'a' is less than 'b' is less than 'c' and uppercase
characters are less than lower case characters ('A" is less than 'a'). Note
that numeric data can only be compared with numeric data and string data
can only be compared with string data. If you attempt to compare numeric
data with string data then the message:

	Can't do this/Data types don't match

appears.

				2-10

LIKE

LIKE is a case insensitive pattern matching relational operator which is
used to compare string data. The question mark '?' and asterisk '*'
characters can be used as wildcards. The question mark matches single
characters and the asterisk '*' matches multiple characters.

For a full explanation of how to use LIKE, see Volume I, Appendix B.

CONTAINS

CONTAINS works in the same way as LIKE, but it used with ASCII files on
disk; for example, you could use the expression:

	CONTAINS "*Smith*"

to search for an ASCII file which contained the name Smith. See Chapter 9, 
Volume 1, for more details.

LOGICAL OR BOOLEAN OPERATORS.

Logical operators are most frequently used to modify the results of
relational operators. An expression that contains a relational operator can
either be true or false. With a logical operator you can create more
complex expressions whose truth or falsity (their 'truth value') depends on
the truth or falsity of one or more relational expressions.

AND

This operator allows you to test whether two comparisons are true at the
same time. For example:

	12 > 5

and

	6 < 16

are both true, so

	12 > 5 AND 6 < 16

is also true.

				2-11

NOT

NOT reverses the truth or falsity of an expression. Thus:

	12 < 5

is false, so

	NOT 12 < 5

is true.

NOT is often used with the EOF function to set up a program loop for
processing all the records in a file, e.g.:

	WHILE NOT EOF ("address")
	SELECT NEXT
	VIEW
	WEND

OR

OR gives a true result if one or the other, or both, of its operands is
true. For example:

	12>5 OR 12<5
	8=2*3 OR 6>5
	8=2*4 OR 6<5

all give true results.

	12>5 OR A$="LONDON"

gives a true result whatever the value of A$.

	8=2*3 OR 12<5

gives a false result.

Logical operators can also be used with numeric expressions to give a
result which depends on the binary digits of the operands. In this context,
they are sometimes known as bitwise operators. Instead of comparing the
truth or falsity of expressions, AND and OR - when used as bitwise
operators - compare the binary digits of two numbers, while NOT takes a
single number, and changes each binary 1 to 0, and vice versa. Thus AND
returns binary 1, if and only if, the corresponding digits in the two
operands are both 1, e.g.:

	85 AND 19

gives a value of 17.

				2-12

	85 in binary is 01010101
	19 in binary is 00010011

The result is 00010001 which is 17

TABLE OF PRECEDENCE

Complex expressions, containing more than one operator and several simple
expressions, are evaluated according to the following table. The higher up
the table an operator is, the higher the precedence it is given. This means
that if there are two simple expressions, the one whose operator has the
highest precedence will be evaluated first.

	^		Exponentiation
	*/		Multiplication and Division
	MOD		Modulo arithmetic
	+-		Addition and Subtraction
	<> <=> =	Relational operators
	LIKE CONTAINS	Relational operators
	NOT		Logical NOT
	AND		Logical AND
	OR		Logical OR

Where identical weighted operators are concerned evaluation will be from
left to right e.g.:

12 + 3-2	is evaluated as	12 + 3=15 : 15-2=13
12 + 3*4	is evaluated as	3 * 4=12 : 12 + 12=24
12 + 3*4-2	is evaluated as	3*4=12 : 12 + 12=12 : 24-2=22

Parentheses can be used to promote expressions up the table, e.g.:

(12+3) * (4-2)  evaluates as   15*2=30

CONSTANTS

The fixed values that you assign to variables or use as part of an
expression are known as constants. There are two types: string constants
and numeric constants. String constants must be enclosed in quotation
marks. DML also provides a ready-defined constant PI, which has the value
of 3.141593265359 and can be used in numeric calculations.

				2-13

EXPRESSIONS

Expressions are formed from any combination of:

Fields
Variables
Constants
Functions
Operators

An expression can consist of a single variable name, a field name, or a
constant,  or it may be more complex, combining these with operators,
constants and functions. The following are examples of expressions:

396
TODAY
a$
"31 Ambleside Drive"
textfielda
numfielda
Firstname.address
LEFT$ (Firstname.address, 1)
3.44*22.8 + 450
"Mr" + A$
A$ + B$
a%<>b%
(a$=b$) AND (c%=1)
INT (RND (1) *26) +1
COS (n%)

LINE FORMAT AND LABELS

There are no line numbers in DML; instead, to provide a reference for GOTO
and GOSUB commands (or ON GOTO and ON GOSUB commands) you can place a label
at the front of a line. Labels can be any combination of alphanumeric
characters but cannot contain spaces.

Labels must end in a colon (':') unless they consist only of numeric
characters. You can use a number as a label without adding a colon, but
this will not have the effect of altering the sequence of program lines.
So, if you enter a line with the label '30' after a line with the label
'50', both lines will remain in that order.

A DML line, whether in direct mode or program mode, can contain more than
one statement, provided the statements are separated by colons.

				2-14

Labels, however, can only be used in program mode.

Any command which is placed at the beginning of a multi-statement line
should be followed by a space. If it is followed by a colon without an
intervening space, DML may interpret it as a label. For example, in the
line:

	CLS: STATUS

the command CLS has no effect, but

	CLS: STATUS

works as intended.

You also need to insert a space before an expression - a variable name or a
field name, for example - if it is preceded by a DML command word. But
otherwise in program mode, DML will accept lines without any spaces in them
(it inserts spaces when it parses a line).

In direct mode, it is generally necessary to insert spaces between the
various elements of a command line.

SYNTAX

The Keyword Reference section gives the exact syntax for each keyword.
However,  there are several rules that apply generally.

FILE NAMES AND FIELD NAMES

Wherever a command is followed by a file name - or takes a file name as one
of its arguments - the file name must be enclosed in quotation marks.
Fieldnames should not be in quotation marks.

For most operations, you should not include the extension name for a file
(the part of the name after the full stop). Superbase automatically looks
for files with the appropriate extension; so, with the command:

	OPEN FILE "Address"

it looks for the file "Address.sbf".

The one exception to this rule is when you are dealing with text files.
OPEN FOR INPUT/OUTPUT, OUTPUT TO, IMPORT and EXPORT all take data to or
from text files, and require that file names are given in full.

If you save a file from Superbase's text editor, it automatically adds an
'.sbf' extension to the file name - and when you open a file from the text
editor, you do not need to supply the '.sbt' extension. But when you make
use of a text

				2-15

editor file in some other applications - with IMPORT, for example - you
must remember to include the .sbt extension. By the same token, you will
not be able to load text files into the text editor unless you give them a
.sbt extension.

UPPER CASE AND LOWER CASE

Certain string functions such as INSTR are case sensitive, but otherwise
DML ignores the difference between lower and upper case letters (small
letters and capital letters). In other words, it does not matter whether
you use lower or upper case letters when you type in a keyword or any of
the following:

	variables
	file names
	field names

It is a good idea, though, to enter program lines and direct command lines
in lower case. Once DML has accepted a line, it converts any reserved words
(that is, any keywords) to upper case. Typing in lower case allows you to
check that you have not used a reserved word by mistake.

				2-16

			CHAPTER 3 - THE PROGRAM EDITOR

THE PROGRAM MENU

Operations relating to programs and programming are controlled from a
single menu at the right of the menu bar, the Program menu. This section
lists the Program menu options, and gives a brief explanation of their
functions. Apart from Print and Remove (which should not require further
explanation), each option is also described in more detail in the sections
that follow.

COMMAND	Opens the Command line window, allowing the user to enter program
	instructions as direct commands.

RUN	Runs the program in memory or, if there is no program in memory,
 	loads a program from disk and runs it.

NEW	Opens the Program Editor window and clears any program that may be
	in memory.

EDIT	Opens the Program Editor window.

OPEN	Loads a program from disk into memory.

CLOSE	Clears the program in memory - the program that is currently in the
	Program Editor - and closes the Program Editor window.

SAVE	Saves the program in memory to disk.

PRINT	Prints the program in memory.

REMOVE	Deletes a program file from disk.

THE PROGRAM EDITOR WINDOW

When you select Edit or New from the Program menu, Superbase opens a window
at the right-hand half of the screen. This is the program window where you
enter and edit programs (see next page).

In most respects, the program window can be treated in the same way as the
text window: you use the same controls for closing, resizing and moving the
window (as explained in Chapter 10, Volume 1); and you also use many of the
same key

				3-1

controls for editing a program. In fact, both the Program Editor and the
Text Editor make use of the same window. The window can only be occupied by
one of them at a time, but any changes you make to the size or location of
the window will apply when you switch to the other editor.

The main difference between the two is that the Program Editor does not
have its own set of menus. The Program menu is available at all times -
except when the Text Editor menus are active - whether the program window
is open or closed.

As with the Text Editor, you can switch between the program window and the
database window simply by moving the mouse pointer to the required window
and clicking in it. Thus, to edit a record after opening the program
window, you would click twice in one of the fields displayed in the
database window - once to make the database window active, and once to
activate the record editing cursor (on the Amiga, you would only need to
click once). If you then wanted to return to the Program Editor, clicking
once in the program window would make the program cursor active again.

Notice that the Close option on the Program menu not only closes the window
but also removes the current program from memory. If you wish to close the
window without clearing the program from memory, click on the close window
gadget at the top left-hand corner.

				3-2

NOTE: Screen output from a Superbase program is displayed in the database
window. If there is a record in view, program data will be output below or
to the right of the bottom line of record data. To clear the database
window before displaying program data on screen, use the CLS command.

CREATING A NEW PROGRAM

Selecting Edit from the Program menu opens the program window and places
the program cursor at the top left-hand corner. When you enter the Program
Editor for the first time in a session, the window will be empty; you can
then start entering program lines straight away. If you have previously
loaded a program into memory and want to start afresh on a new program,
select New to clear the existing program from memory.

Entering program lines is simply a matter of typing them in at the
keyboard. When you have typed in a line, pressing the Return key will take
you to the start of the next line.

Superbase accepts program lines up to 255 characters long. As you type
characters beyond the right-hand edge of the window, the program will be
scrolled to the left. Using the scroll bars enables you to move the window
over any part of a line up to 255 characters.

LINE FORMAT

An explanation of the correct format for a Superbase program line is given
in Chapter 2, Line Format and Labels. However, it is worth repeating th
rule about inserting spaces in a line: you need to insert a space if you
enter an expression - such as a variable name, a field name, or a constant
- after a keyword, or if you enter two adjacent keywords. In the following
example, the space between the two items on the line must be entered by the
user:

	? "Hello"

You should also type a space between a command and a colon if the command
is placed at the start of a multi-statement line. If you do not do this,
DML will interpret the command as a label.

Otherwise, you can ignore spaces as you type in a program. If a line
contains adjacent variables or operators and other elements of an
expression, DML inserts spaces between them when it 'parses' the line.

Parsing refers to the process which takes place when you press Return or
move the cursor away from the current line. DML scans the line and
identifies the various elements in it. As well as inserting spaces between
recognizable

				3-3

elements, it also converts any keywords that are entered in lower case to
upper case. Thus if you typed:

	if a%=3.5+6then goto label1

DML would parse this line as:

	IF a%=3.5+6THEN GOTO label1

You are recommended to enter program lines in lower case as a way of
ensuring that you do not use reserved words as labels or variables. When a
line is parsed, you will be able to see at a glance whether these items are
correct,  because the reserved words will be shown in upper case.

It is unlikely that you will need to create programs with lines over 200
characters long. However, if you do, it is important to bear in mind that
spaces may be inserted in the line. Even though the line you type in is
less than 255 characters, it may exceed this limit when it has been parsed.

EDITING A PROGRAM

The Program Editor uses the same key controls for editing a program and
moving the cursor around the screen as the Text Editor. As you would
expect, it is not possible to specify margins or reformat a program; and the
style setting functions are not available. Otherwise, the only difference
is in the way the Return key works. In the Text Editor, Return either moves
the cursor to the start of the next line or creates a new line, depending
on whether overwrite or inset mode has been selected.

In this section, we only provide a list of the Program Editor key controls
together a brief description of their functions. For a detailed explanation
of these keys, see Chapter 10, Volume 1. The '^' character is used here to
represent the CTRL key (Control on the Atari ST); ^N for instance,
indicates that the CTRL key and the letter N should pressed in combination.

MOVING THE CURSOR

As with the Text Editor, you can move the cursor around the screen and edit
a program at any point on the screen.

The cursor keys are used to move the cursor by one character at a time.
Note that the term character includes the space character.

				3-4

LEFT ARROW		Moves the cursor to next character to the left.

RIGHT ARROW		Moves the cursor to the next character to the
			right.

UP ARROW		Moves the cursor to the character in the same
			column on the line above.

DOWN ARROW		Moves the cursor to the character in the same
			column on the line below.

For larger cursor movements, use the following keys:

^B			Takes the cursor to the first line in the text.
^G			Takes the cursor to the last line in the text.
Home (GEM)		Moves the cursor to the beginning of a line.
Clr Home (GEM Atari)	Moves the cursor to the beginning of a line.
Shift right cursor (Amiga)  Moves the cursor to the beginning of a line.
End (GEM)		Moves the cursor to the end of line.
Insert (GEM Atari)	Moves the cursor to the end of line.
Shift left cursor (Amiga)  Moves the cursor to the end of a line.
Tab			Moves the cursor eight characters to the right.
Shift Tab		Moves the cursor eight characters to the left.
Control T		Moves the cursor eight characters to the left.

DELETING AND INSERTING

The following keys are used for deleting and inserting program lines or
parts of a program line:

BACKSPACE		Delete character to the left of the cursor.
DEL			Delete character to the right of the cursor.
^W			Delete word.
^E			Delete to end of line.
^D			Delete line.
^X			Clear line.
^N			New line.
^S			Split line.
^A			Join line.
^V			Insert mode on/off.
^U			Undo.

Note that Undo works in the same way as in the Text Editor, and can be used
as a 'cut and paste' facility, allowing you to move multiple program lines
to a new position.

				3-5

USING THE COMMAND LINE

Selecting the Command option on the Program menu presents you with the DML
Command Line dialog. Any commands you type in the command line box will be
executed as soon as you click on OK or press Return; that is, they will be
executed as direct commands.

The command line box accepts single or multi-statement lines (with
statements separated by colons) up to 255 characters. You can type in
commands when ever the cursor is present. If the cursor is not shown, click
in the box to activate it.

There is very little restriction on which keywords can be entered as direct
commands. READ (and DATA), GOSUB, and ON GOSUB cannot operate as direct
commands,  and you cannot use labels in the command line. Apart from these,
almost any single or multi-statement line that can be entered in a program
can also be entered in the command line.

Clearly, any statement that refers to another statement in the command line
will not operate, because of the absence of labels. However, it is possible
to enter GOTO statements which refer to labels in the current program. You
may want to do this when you are testing a program. The normal way of
executing a program - using the RUN command or Run option - clears the
program's variables. GOTO allows you to execute a program or part of a
program without destroying any variable assignments that may have already
been made.

You will use the command line for variety of purposes. There are some
operations - such as appending a text or program file to a file in memory -
which can only be performed using commands. You may also want to enter
commands as an alternative to selecting options from the Superbase
menus; but it is generally more practical to do this by assigning the
commands to a function key.

In addition, the command line is valuable tool for developing and testing
programs. Particularly useful are commands such as:

	? MEMORY

and

	? LIST

The first command lists the current program's variables and their
values; the second can be used to display the program listing in the
database window.

				3-6

EDITING THE COMMAND LINE

The cursor keys move the cursor in the command line one character at a
time. Home (Clr Home on the Atari ST) and End (Insert on the Atari ST) take
the cursor to beginning and end of the command line. Del deletes the
character in front of the cursor, Backspace deletes the character before.

If you make a mistake while typing in the command line, you can use these
keys to correct it. Command lines remain in the box after they have been
executed and function key commands are placed in the command line box after
execution, so you may also want to recall the previous command for editing.

LOADING A PROGRAM

To load a program from disk into the Program Editor, select Open from the
Program menu. A file dialog will appear, listing the names of the program
files in the current directory. You can then select a file in the usual
way. If you want to load a program in another directory or on another disk,
type in the file name preceded by the path name.

To append a program on disk to program in memory, select the Command option.
Then enter:

	LOAD "programname", APPEND

where "programname" is the name of the program on disk which is to be
joined to the current program.

Most of the programs you run will have been created in the Program Editor.
However, it also possible to load a program which has been written in a
word processor, or has been created in another program editor. In this
case, there are two requirements: the program file must have an '.sbp'
extension, and it must be an ASCII file.

Note that Open loads a program into the Program Editor, but it does not
open the Program Editor window. If the window is closed and you wish to
edit a program after loading it, select Edit.

SAVING A PROGRAM

Save on the Program menu saves the current program on disk. When you select
this option. Superbase displays a dialog where you type in the name under
which the program is to be saved.

				3-7

Normally, programs are saved on disk in 'tokenized' form; instead of storing
each character in a keyword, Superbase represents keywords using single
character tokens (keywords are represented in this way internally as well
as on disk). To save a program as an ASCII file, enter in the command line:

	SAVE "program name", TEXT

ASCII program files can be loaded back into the Program Editor and run
straight away. Note that all program files, both tokenized and ASCII files,
are given an '.sbp' extension.

RUNNING A PROGRAM

Select Run from the Program menu to run the program in memory. If there
isn't a program in the Program Editor, Run displays the program file
dialog. When a program has been selected, it is loaded into memory and then
executed.

The DML command RUN provides the program equivalent of the menu option. It
is generally entered as a direct command, but it can also be used within a
program. As a program command (rather than a direct command), RUN allows
you to perform a task by linking together a series of programs. When one
stage has been completed, RUN followed by a program file name will load and
execute the program which performs the next stage.

However, the drawback to using RUN for this purpose is that loading and
executing a new program clears the previous program's variables. If you
want to link a number of programs together, it usually preferable to use
the CHAIN command. This provides the same facility as RUN but has the
advantage that it does not clear any existing variable assignments.

CREATING A START UP PROGRAM

One of Superbase's most useful features is the way it lets you specify a
'start up' program, which will be automatically loaded and executed when
you run Superbase. There are many ways in which you can take advantage of
this feature,  especially if you use Superbase on a regular basis for a
specific application. All the tasks that you need to perform at the start
of a session - such as opening files and loading a function key set - can
be taken care of by the start up program.

				3-8

The procedure for creating a start up program is straightforward. There are
two requirements:

The program must be stored in a directory where Superbase will find it:
either the Start directory as specified in Options on the Set menu (see
Chapter 7,  Volume 1) or the directory which is current when Superbase is
loaded; usually this will be the same directory as the Superbase program
file.

The program must be saved under the file name Start (this appears on disk
as Start.sbp).

When you run Superbase, it looks in the current directory for a program
with the name Start. If you have specified a Start directory in the '.par'
file, it then looks for the program in that directory.

EXAMPLES

LOAD KEY "Funkey1"
OPEN FILE "Address"
OPEN FILE "Customers"
SET TABLE
VIEW

This program loads a function file, opens two database files, set Table
View, and then displays the first record in the Customers file.

LOAD KEY "Funkey1"
NUMBASE "z999999."
RUN "Prog2"

After loading a function key file, this program sets the numeric format and
then loads and executes prog2.

				3-9

			CHAPTER 4 - FUNCTION KEYS

With Superbase's function key facility, you can create a new set of key
controls. Each function key may be assigned a string of up to 255
characters. Depending on the context, Superbase will interpret the string
either as a command (or sequence of commands) or as text.

The main applications for this facility are:

Creating command sequences - one line programs - to provide keyboard
equivalents for the Control Panel buttons and menu options.

Creating more complex command sequences which will perform multiple
operations with a single key-stroke.

Inserting often-used words, keywords, phrases, and paragraphs in a text
document or a program.

The number of functions keys you can define depends on which version of
Superbase is used. All versions provide the function keys F1 to F10. In
addition, Amiga and Atari owners can use the Help key, which may be
regarded as key F0. Another set of ten function keys is available when you
use F1 to F10 in combination with the Shift key. On Gem versions of
Superbase running under MS DOS, you can also use the CTRL and Alt keys in
combination with the keys F1 to F10.

To summarize these differences:

21 function keys are available to Amiga and Atari owners; F1 to F10 plus
Help, and Shift F1 to Shift F10.

MS DOS computers have 40 function keys; F1 to F10, and the same keys in
combination with Shift, CTRL or Alt.

SETTING A FUNCTION KEY

There are two ways of setting a function key: using the Set Menu option
Function keys (Function keys Edit on the Amiga), and using the DML command
KEY. With the first method, you select Function keys from the Set menu. You
will then be presented with the Function key dialog (see next page).

This shows the dialog for GEM versions of Superbase running under MS DOS.
Atari versions have three keys at the right: Help, Down arrow and Up arrow.
In both 

				4-1

MS DOS and Atari versions, the Up arrow symbol is used to represent the
Shift key. The Down arrow represents Shift off; clicking on this key
highlights it and turn Shift off.

On the Amiga, the four keys at the right of the panel are replaced by the
HELP and Shift keys.

On entry to the dialog, the F1 key is highlighted (as is the down arrow key
on GEM versions). Clicking on one of the other keys, F2 to F10 (and HELP on
the Amiga and Atari), highlights the key, making it available for setting.
You can then assign a string to the key by typing it in the entry box
below. Click in the box first if the cursor is not shown.

Clicking on Shift (or the Up arrow symbol) highlights it; you can now assign
a string to one of the key combinations Shift F1 to Shift 10. For the Amiga
and the Atari, the Shift key is the only one that can be used in
combination with the keys F1 to F10 - Shift HELP is the same HELP on its
own. On MS DOS  machines, you also have the choice of selecting CTRL and
ALT. This makes available the key ranges CTRL F1 to CTRL F10 and ALT F1 to
F10.

When you have set the functions keys you require, click on OK. This action
will assign the strings you have entered to their respective keys and then
remove the dialog.

The other method of setting the function keys is to use the DML command KEY
- either from the Command Line or from a program. Consult the keyword
reference entry under KEY for an explanation of how to use this command.

FUNCTION KEYS FOR COMMANDS

As we mentioned earlier, Superbase treats function key assignments as
commands or text according to the circumstances. If one of the editing
cursors is active, a function key string is interpreted as text; if a cursor
is not present, 

				4-2

a string is executed as a command. There are three circumstances in which
an editing cursor may be active: when you are editing a document in the
Text Editor, or a program in the Program Editor, and when you are editing a
field in record edit mode.

The rules governing the commands which can assigned to function keys are
the same as for the Command Line (see Chapter 3). If the commands can be
executed as a one line program, they can also be assigned to a function
key. Note that single word commands at the beginning of a function key
string must have a trailing space if followed by a colon.

EXAMPLES

The following function key strings show how you can create keyboard
equivalents for the Control panel buttons:

SELECT FIRST: VIEW

This has the same effect as clicking on the First record button.

SELECT LAST: VIEW

Equivalent to the Last Record button.

a%=0: a$=" ": REQUEST "Locate key", "", 4, a%, a$, 20:
IF a$ <> " " THEN SELECT KEY a$: VIEW

Equivalent to the Key Lookup button. The REQUEST command is not necessary
for this purpose, but it allows you to display a customized dialog, making
the operation of using an index key easier to perform.

It is worth pointing out that the command KEY lists all the current
function key assignments to the current output device. You may find it
useful to assign this command to one of the function keys. Enter the single
KEY as the function key string. Pressing the key will then show you at
glance what the settings are for the other keys.

FUNCTIONS KEYS FOR TEXT AND PROGRAM ENTRY

In text entry, Function keys are useful for entering text strings which
occur many times in the same document or are regularly used in different
documents. They save you the trouble of having to type in the string
yourself every time it is needed. Provided the text cursor is shown on
screen, pressing a function key will insert a string at the point where the
cursor is located.

The same applies to the use of function keys in program entry. You can
define function keys to insert commonly used keywords in a program. For
example, you

				4-3

might want to define the keys F1 to F5 as:

REM
LOAD "
SAVE "
OPEN FILE "
WHILE

Keys F5 to F10 could then be assigned commands which are useful during
program development (you would have to activate the database window before
these could be executed):

MEMORY
RUN
PAGING ON: ? LIST
EDIT
STATUS

If you wish to assign a text string that runs over several lines, you need
to use the carriage return character. However, it is not possible to enter
this character in the Function keys dialog, so you must enter it using the
KEY command in a program or in the Command Line. Thus to assign an address
to F1,  you enter a string like this:

KEY 1, "6 Park Terrace " + CHR$ (13) + "Worcester Park" +
CHR$ (13) + "Surrey KT4 7 JZ" + CHR$ (13)

NOTE: In most cases, function key strings which are intended for text entry
cannot be executed as commands. Pressing a function key of this type when
the cursor is not active may cause an error message.

EDITING A FUNCTION KEY STRING

If a function key has already been set, selecting the Function keys option
(Function keys Edit on the Amiga) from the Set menu displays the contents
of the key in the string entry box. Initially, the setting for the F1 key
will be shown. In Gem versions, when you select another key, Superbase
displays the setting for that key.

If you wish to change the current setting, you can do so using the same
editing controls as for the Command Line: cursor keys, Backspace, Del, Home
and End. Alternatively, click on Clear to remove the current setting and
type in a new function key string.

Remember to press the Return key after editing a function key; otherwise
your alterations will not be registered.

				4-4

FUNCTION KEY FILES

The strings you assign to the functions keys can be saved on disk for use
in other sessions with Superbase. Function key files are saved as ASCII
files with the extension '.sbk'. If you wish to examine a function key
file, you may display it on screen or print it out with the List option on
the System menu. Notice that any keys which have not been assigned a string
are shown as blank lines.

SAVING FUNCTION KEY FILES

Selecting the Function keys Save option saves the current function key
settings on disk. Superbase adds the '.sbk' extension to the file name you
type in. Function keys Save presents you with a file dialog, showing the
existing '.sbk' files in the current directory. This operates in the same
way as any other file dialog. If you select a file name from the list -
instead of typing in a new name - a dialog will appear, asking if you wish
to overwrite the selected file. You can then click on OK to overwrite, or
Cancel to halt the operation.

LOADING FUNCTION KEY FILES

Select Function keys Load from the Set menu to load a function key file
from disk. A file dialog will appear showing the '.sbk' files in the
current directory. After a file has been selected, it is loaded into memory
and sets the current function keys.

The LOAD KEY "file name" command is used to load a function key file under
program control or from the Command Line. Once you have created the
function key set that meets your requirements, you can include this
command, followed by the name of the function key file, in the Start
program (see Creating a Start up program, Chapter 3). This way, the
function keys will be set up for you as soon as Superbase has loaded.

Another way of using the LOAD KEY command is to assign it to a function
key. You will then be able to load a specified function key file with a
single key press.

				4-5

			CHAPTER 5 - KEYWORD REFERENCE GUIDE

SYNTAX CONVENTIONS

This section describes the conventions that have been used in the following
documentation.

The general format used to explain each keyword is as follows:

PURPOSE -a brief description of the keyword.
SYNTAX - the format of the keyword.
COMMENTS - explains the format and function of the keyword in more detail.
EXAMPLES - program examples.
NOTES - explains the program examples and covers any other points not dealt
with under the above headings.

For the syntax of the keyword, the following terms and symbols are used:

nexpr

This can be any valid numeric expression consisting of numeric fields, date
fields, numeric constants and/or numeric results of other keywords. For
example, if a function expects a numeric argument, you could enter any of
the following expressions:

	156		(an integer)
	156.25		(a floating point number)
	num%		(a numeric variable)
	numfield	(the name of a numeric field in a file)
	3 + 6		(the result of an expression)
	SQR (25)	(the result of a keyword)

strexpr

This can be any string or substring from a text field, external field,
string variable, text literal or string result of other keywords. For
example, any of the following expressions would be suitable entries for
strexpr:

	"hello"		(a string constant)
	strfield	(the name of a string field)
	numfield	(the name of a numeric field)
	fielda$		(a string variable)

				5-1

	fielda$		(a string variable)
	Address		(a file name)
	MID$ ("immediately", 3, 2)  (a calculated result)

var

This can be any variable, string or numeric. If the keyword requires
variables of a particular type, strvar or nvar are used for string or
numeric variables. Various other conventions - such as fieldname or just
field - are used to indicate particular data types. These should be
self-explanatory.sbfile, for example, means that you should enter the name
of a database file; on disk,  Superbase identifies database files by an .sbf
extension, but you should not include the extension name when you use it in
a DML command.

Any parameters or arguments contained in parentheses are compulsory
(including any commas), while those within square brackets- '['and']' - are
optional. All other arguments are compulsory. For instance, supposing the
syntax for a keyword is given as:

	XXX (strexpr$, nexpr[.nexpr2])

This means that strexpr and nexpr are required with the keyword XXX and
that they must be separated by a comma. The next argument, nexpr2, is
optional, but if used must be separated from the second argument by a
comma.

The '/' character is used to indicate a number of alternatives. For
example:

	CLOSE ALL/FILE sbfile

The syntax for this statement indicates that CLOSE can be followed by
either ALL or FILE, but not both at the same time.

				5-2

? COMMANDS

? is a general purpose output command. You can use it to display
information on screen, or to send information to the printer, or to create
a file on disk. When ? is followed by a list of expressions - text,
numbers, variables, fields, etc it sends the expressions to the current
output device. It can also be used with the following keywords:

	DIRECTORY
	LIST
	MEMORY
	QUERY
	STATUS
	TEXT

These keywords have a specific function when used with ?, and have been
treated as separate commands. You will find an entry for each of them
further on in this section.

CHANGING THE OUTPUT DEVICE

When you load Superbase, the ? command takes the screen as the default
device and works in the same way as the PRINT command does in other
versions of Basic - it displays information on screen. If you want to
direct output to another device use one of these commands first:

	PARAMETER		PURPOSE
	PRINT			for the printer
	OUTPUT TO		for the disk drive
	DISPLAY			to switch back to the screen

? then continues to output to the device selected by one of these commands.
CLS and HOME do not reset the current output device.

PRINT and DISPLAY can be followed by a list of expressions which will then
be output to the devices associated with these commands. When you use PRINT
and DISPLAY simply to change the current output device, they should be
followed by a semicolon, as in:

	PRINT;

which directs all future output to the printer.

OUTPUT TO needs a filename after it, as in:

	OUTPUT TO "texta"

which directs output to a file on disk named 'texta'.

				5-3

OUTPUT FORMAT PARAMETERS

After outputting a list of expressions, the ? command starts a new line
unless you specify otherwise. This means that it takes the cursor to the
beginning of the next line (if the current output device is the screen).
You can instruct DML to output the next list of expressions on the same
line, by placing a semicolon at the end of an expression list. When it is
used in this way, the semicolon is known as an output format parameter, and
is one of a number of parameters that allow you to specify how output is
formatted.

Apart from the semicolon, you place these parameters in front of the
expressions that you want to format. Thus you can place them at the front
of the line immediately after the ? character, and you can also insert them
in the middle of an expression list.

Some output parameters are keywords such as BF and DOWN, and others are
symbols such as the semicolon itself and the @ sign. If you use keyword
parameters, they must separated from each other by spaces. For example, DML
will accept a line like this:

	? UL BF IT "One", , "TWO' UL OFF @5, 10"Three"

but it will not accept

	? ULBFIT"One", , "Two"ULOFF@5, 10"Three"

The output format parameters for the ? command are:

PARAMETER		PURPOSE

&			Sets length of text string
@			Sets row and column position
, 			Outputs a space
;			Used as a separator and to suppress new line
DOWN			Outputs each item on a new line
ALL			Outputs all the fields in the current record
NEWLINE			Starts a new line
BF[ON]			Sets text to bold face
UL[ON]			Underlines text
IT[ON]			Sets text to italic
BF/UL/IT OFF		Turns selected text attribute off
ATTR OFF		Turns all text attributes off
FG (Amiga only)		Sets foreground color
BF (Amiga only)		Sets background color
SAY (Amiga only)		Speaks output
EJECTnn			Outputs data on a new page if there are less than
			nn lines left at the bottom of the page

				5-4

COMMENTS

The @ sign, followed by a numeric expression, specifies the column and row
position for your output. For example, if the screen is the output device
selected:

	? @12, 7"Smith"

displays the name Smith on the screen at column 12, row 7. As an
alternative to using @, see LOCATE.

DML treats a comma as a space character. For example:

	? "Hello", , , "goodbye"

outputs

	Hello   goodbye

Placing a semicolon after the last expression in the output list prevents
DML from outputting a new line character. For example:

	? "Hello": ? "there"

outputs them on the same line as

	Hello there

Note that when the output device is the screen, DML only outputs the
expressions in a list when it starts a new line. For example, if you enter
the line:

	? "one"; "two"; "three";

nothing will appear on the screen until you enter another line which does
not have a semicolon at the end of it.

If used, DOWN must be placed at the front of a line, before the line's
expressions and after the ? character. It ensures that each expression in
the list is output on a new line. For example:

	? DOWN "one"; "two"; "three"

nothing will appear on the screen until you enter another line which does
not have a semicolon at the end of it.

If used, DOWN must be placed at the front of a line, before the line's
expressions and after the ? character. It ensures that each expression in
the list is output on a new line. For example:

	? DOWN "one"; "two"; "three"

formats the output on screen as

	one
	two
	three

				5-5

When Down is used to format field data, it displays the field names in inverse
video at the left of the data - in same way as Record View displays a record.
ALL outputs the fields in the current record; for example, if the screen is the
current output device:

	? DOWN ALL

would have the same effect as clicking on the current record button when
Record View is selected.

NEWLINE instructs DML to start a new line. Thus

	? "one", "two"NEWLINE "three"

outputs the expressions as

	one two
	three

NEWLINE can also be used on its own - see NEWLINE, Keyword Reference.

BF, UL, and IT set the text style for output.
BF	sets boldface
UL	sets underline
IT 	sets italic

Each of these can be set by ON (which is optional) and cleared by OFF.

ATTR OFF clears all the text style attributes.

For example:

	? BF"Bold face on"; IT "italics on"; BF OFF IT OFF "Bold and italics
off" On the Amiga you can also set the foreground and background colours,
using FG and BG. Each takes a parameter in the range 1 to 4 for the four
colours set by Preferences. For example:

	? FG 2 BF 1 "Foreground colour 2, background colour 1"

SAY, which is only available on the Amiga, uses the Amiga's narrator device
to speak the items in an expression list. Thus if you wanted to speak the
field names and field data for the current record, you would enter:

	? SAY DOWN ALL

EJECT can be used to ensure that a group of data items - the fields in a
record, for example - all appear on the same page. For example:

				5-6

	? DOWN "One"; "Two"; "Three"; "Four" EJECT 4

displays a new page if there is not enough room at the bottom for the four
items in the expression list.

				5-7

?

PURPOSE

Sends information to a device.

SYNTAX

? [@nexpr] [; expr; expr, ....]

COMMENTS

Used to send one or more expressions (an expression list) to the current
output device. ? can also include any of the output format parameters.

When you output numeric, date, and time constants or the results of
functions for these data types, they take the format which has been set
with the Number or Date/Time format options on the Set menu (or with the
commands NUMBASE and DATEBASE). Field data is output in the format set in
the file definition. However, you can force Superbase to output field data
in the current format by enclosing the field name in brackets. Thus:

	? (numfielda), (datefielda)

displays the contents of these fields in the current numeric and date
formats rather than in the formats they have been given in the file
definition.

EXAMPLES

1	? "Hello"
2	? "Hello"; a$
3	? UL BF "Hello"; a$; NEWLINE b$
4	? "The square root of"; n%; "is"; SQR (n%
5	? "One""two""three"

NOTES

Depending on the numeric format that has been set, example 4 would output
the numeric expressions, n% and SQR (n%), with leading spaces. To remove
these, you would have to use the STR$ and LTRIM$ functions.

You will notice that there are no semicolons separating the expressions in

				5-8

example 5. It is not always to place a semicolon between two expressions.
Provided DML has some other way of telling where one expression ends and
the other one starts, you can omit the semicolon. In this example the
quotation marks allow DML to distinguish between the three expressions.

? DIRECTORY

PURPOSE

Lists the current directory to an output device.

SYNTAX

[?] DIRECTORY

COMMENTS

When the screen has been selected as the current output device, the
directory is listed in two columns in alphabetic order. If the output
device is the printer or a disk file, the directory is listed in single
column.

The "?" command is optional - DIRECTORY on its own has the same effect.

? LIST

PURPOSE
List a program in memory to an output device.

SYNTAX
? LIST

COMMENTS

Do not confuse this command with LIST, which displays a text file on
screen. ? LIST has several applications. You can use it to examine a
program listing by displaying it on screen on printing it out; and, when the
current output device is the disk drive, it allows you to save a program as
a text file. In this last application, it has the same effect as:

	SAVE "program name", TEXT

				5-9

? MEMORY
PURPOSE

Sends information about any defined variables to an output device.

SYNTAX

[?] MEMORY

COMMENTS

This outputs the variables in memory as:

	a%=123.46
	b%=12.00
	a1$="aaaaaaaaaaaaaa bbbbbbbb"
	etc.

The variables are output in the order in which they were assigned. If you
specify OUTPUT TO file, the values of the variables can be recovered for a
subsequent program by the SET file command.

The "?" command is optional - MEMORY on its own has the same effect.

? QUERY
PURPOSE

Runs the current Query in memory and sends the results to an output device.

SYNTAX
? QUERY

COMMENTS

Query has four output options (on the Amiga, SAY provides a fifth option).
You can send the output from a Query to the screen, the printer, to disk
(as an ASCII file) or to file (as an '.sbf' file). However, when you save a
Query, the currently selected output option is not saved with the rest of
the Query settings; so if you run a Query under program control, you will
need to select the output device beforehand.

To send output to the printer, either set the Printer option from the Set
menu,  or issue a PRINT; command. To send output to disk, you should use the
OUTPUT TO filename or OPEN filename FOR OUTPUT commands.

				5-10

The Query output will then be stored on disk under file name specified.

EXAMPLES

1	LOAD QUERY "Stockrep"
	PRINT;
	? QUERY
2	LOAD QUERY "Addreport"
	OPEN "Addrep.asc" FOR OUTPUT
	? QUERY

NOTES

In the first example, output from the Stockrep Query is directed to the
printer; in the second example, output from the Addreport query is used to
create an ASCII file on disk under the name Addrep.asc.

? STATUS
PURPOSE
Sends information about the System Status

SYNTAX
[?]STATUS[FILE sbfname]

COMMENTS

? STATUS without the FILE option gives the same output as the menu option
System Status. If no Superbase files ('.sbf' files) are open, it displays
the following information:

	Memory free
	Diskspace Free
	Current Directory Name
	Superbase Files open (as 0)
	Superbase Files available.

If any database files are open, the header information for these files is
also shown.

	? STATUS FILE sbfname

gives the same output as the menu option SYSTEM STATUS FILE, and

				5-11

produces a status report for the file. At the top of the report, it shows
file statistics such as the number of records and the file size. Below this,
it shows the file definition details: for each field, it lists the field
name, its attributes, format, Form View location, and any associated
calculation or validation formula.

If the file is not open, the error message 'Can't do this / File not open'
appears.

The '?' command is optional with STATUS - using STATUS on its own has the
same effect.

? TEXT
PURPOSE
Sends a text file in memory to an output device.

SYNTAX
? TEXT[MERGE]

COMMENTS

This command outputs the current text file in the Text Editor. If the text
file is a form letter and its associated database file has been opened,
adding the MERGE command will merge the data in the current record with the
text file. See also the Keyword Reference entry for MERGE.

EXAMPLES

1 	OPEN FILE "Address"
  	LOAD TEXT "Maillet"
	? TEXT MERGE

NOTES

If the current output device is the screen, this example will insert the
data from the first record (in the Address file) into the Maillet text
file, and display the result in the database window.

				5-12

ABS
PURPOSE

Turns negative numbers into positive numbers but leaves positive numbers
unchanged.

SYNTAX
ABS (nexpr)

COMMENTS

ABS returns the 'absolute' value of a number. In effect, it simply strips
the sign off a negative number, making it positive. One of its common uses
is for calculating the difference between two numbers when you do not know
which is larger. In example 2, which works out the number of days between
two dates, ABS allows you to enter the dates without first knowing which is
the later date.

EXAMPLES

1	numfieldc=ABS (numfielda)
2	numfieldc=ABS (datefielda-datefieldb)
3	numfieldc>ABS (numfielda * numfieldb)
4	x%=ABS (y%)
5	x%=ABS (y% * numfielda * (datefielda-datefieldb))
6	x%=ABS (VAL (RIGHT$ (textfielda, 5)))
7	? ABS (x%)

				5-13

ADD
PURPOSE
Adds a new field to a file definition.

SYNTAX

ADD[FILE sbfname]field-definition-string[formula-string][formula-string]

COMMENTS

This command is used in conjunction with CREATE and MAKE to create a new
Superbase database file. It cannot be used to add a field to an existing
file. To use ADD correctly, you need to understand how a file definition is
set up. The best way to do this is to use the STATUS FILE option in
Superbase's System menu. This will show you the file definition for the
current file. Another way of viewing the same information would be to list
an '.sbd' file on screen using the System menu's LIST option.

With one exception, the parameters used with ADD to define a field are the
same as those used in '.sbd' file definitions. The exception is '>' and
'>>'. These are used in '.sbd' files to indicate that there are one or two
formula lines to follow. You do not need to include these characters in a
field definition string.

From left to right, the field definition string is composed of the
following parameters:

fieldname
fieldtype[other fieldtype parameters]
format[case and multiple response parameter for text fields]
row; col

Each of these parameters must take the same form as it does in an 'sbd'
file. fieldname must conform to the rules for fieldnames. Fieldtype must be
one of the following:

TXT	text
EXT	external
NUM	numeric
DAT	date

				5-14

TIM	timefield
DEL	deleted

The other fieldtype parameters are optional and, if used, are separated
from fieldtype and each other by at least one space. You can specify up to
three of these parameters, selecting one from each of the following groups:

A)
CLC	Calculated
CLV	Calculated and validated
CON	Constant
COV	Constant and validated
VAL	Validated

B)
RDO	Read only
RDQ	Read only required
REQ	Required

C)
IXU	Indexed - Unique
IXD	Indexed - Normal

format specifies the length of a field and the numeric format for numeric
fields, format must be appropriate for the field type. For example, 20 for
TXT, z99999.00 for NUM, ddmmmyy for DAT.

The case parameter can be U, L or C, depending on whether the text data is
to shown in upper case, lower case or with the first letter capitalized.
The multiple response parameter is M followed by the number of elements in
the multiple response field (maximum 9). These parameter are optional and
can only be used with text fields. They must be separated from the field
format by at least one space. For example, to define a text field with
three multiple response fields, each up to 15 characters long, you would
enter these parameters:

	15 M3;

If you also wanted the field data to be in upper case, you would enter:

	15 UM3;

row is the row position for FORM-view (maximum 255).
col is the column position for FORM-view (maximum 255).

				5-15

row and col are optional, but you are strongly recommended to use them. If
they are not used, all the fields will be positioned at the top left of the
screen on top of one another when the record is displayed in Form View.

The field types in group A-CLC, CLV, CON, COV, VAL-must be followed by a
formula or formulas. CLV and COV require two formulas; the formula for
constants or calculations should be come first, followed by the validation
formula. Formulas should be enclosed in quotation marks and must be
separated by commas from the first part of the field definition string and
from each other.

Formula-string must follow the rules (given in Volume 1) for using formulas
for calculations, constants and validations.

Since formulas must be enclosed in quotation marks, DML will be confused if
a formula itself contains quotation marks, as in:

	fielda LIKE "[a-c]*"

The simplest solution here is to use the tilde character '~' in place of
quotation marks. When you execute the ADD command, DML will interpret the
tilde as a quotation mark.

An alternative solution is to use the CHR$ function to insert quotation
marks the ASCII code for quotation marks is 34. Thus the line to set up a
validated field called fielda of length 12 at row 5, column 20 would be:

	ADD"fielda; TXT VAL; 12, 5; 20", "fielda LIKE" + CHR$ (34)
	+ "[a-c]*" + CHR$ (34)

In the unlikely event that your formula actually requires a tilde
character,  you can insert it in a string variable using CHR$ (126).

Note that the maximum length for a program line is 255 characters. Since a
formula can also be up to 255 characters long, you may be unable to enter
the entire field definition on a line. The solution is to assign formulas
to string variables beforehand. For example:

	a$="Price.Orders * Quantity.Orders"
	ADD "Subtotal; NUM; $9999999.00; 5, 20", a$

EXAMPLES

1 ADD "aatext; TXT REQ IXU; 20 M3; 1, 12"
2 ADD "aanumb; NUM; z999999.00; 1, 40"
3 ADD "bbtext; TXT CLC RD0; 10; 2, 12", "UCASE$ (LEFT$ (aatext, 10))"

				5-16

4 ADD "fielda; TXT VAL; 12; 15; 20", "fielda LIKE " + CHR$ (34) + "[a-c]*"
  + CHR$ (34)

NOTES

Creating a file under program control is a three stage process involving
CREATE, ADD, and MAKE. For a description of the process, see CREATE.

AFTER GROUP

PURPOSE
Set after group activity with reports.

SYNTAX
AFTER GROUP fieldname

COMMENTS

When you create a report using the Forms Editor's reporting facility,
Superbase generates a Report program for you. The AFTER GROUP statement is
used within a Report program to mark the start of an AFTER GROUP section.
This consists of a series of "?" statements which specify the information
that is output every time a group changes. Each statement corresponds to a
line in the AFTER GROUP box in the Forms Editor.

fieldname identifies the group and must be name of a field which has
previously been defined as a group with the GROUP statement. An AFTER GROUP
section must end with an END REPORT statement.

EXAMPLES

1 	AFTER GROUP Lastname.Clients
	? BF ?Client", GROUP, "has"; COUNT amount; "Deposits"
	? BF "Total deposits are", @25SUM amount
	? BF "Maximum is", @s5 MAX amount
	? BF "Minimum is", @25 MIN amount
	END REPORT

NOTES

In the second line of this example, the keyword GROUP is used in order to

				5-17

retrieve the name of the last group. At this point, the group has already
changed; so, Lastname.Clients could not be used instead of GROUP because it
would output the name of the current group.

EXAMPLES

1	AFTER REPORT
	?@1, 3; UL "Statistics for the Report", UL OFF: ?
	?"Total amount is", @30 SUM amount
	?"Number of deposits", @30 COUNT amount
	?"Average amount", @30 MEAN amount
	END REPORT

ASC
PURPOSE
Returns the ASCII value of a single character.

SYNTAX
ASC (strexpr)

COMMENTS
ASC gives a numeric value-the ASCII code-for the text character in

				5-18

strexpr. When strexpr is longer than one character ASC returns the ASCII
code of the leftmost character of strexpr. Appendix E, Volume 1, gives the
ASCII characters and their decimal codes. The complementary function of ASC
is CHR$.

EXAMPLES

1	numfieldc=ASC (textfielda)
2	numfieldc=ASC (RIGHT$ (textfielda, 1))
3	ASC (textfielda) > 64 AND ASC (textfielda) < 91
4	x%=ASC ("A")
5	x%=ASC (x$)
6	x%=ASC (UCASE$ (MID$ (nextfield, 3, 1)))
7	?ASC (x$)

NOTES
Example 3 provides one way of validating a text field to ensure that the
first character is uppercase (but see FCASE$).

ASK
PURPOSE
Inputs a character string from the keyboard.

SYNTAX
ASK[pos] [string] [&length]; var/field

COMMENTS

This command allows the user to enter information from the keyboard into
the computer while a program is running. It expects the user to type in one
or more characters, and, as soon as the Return key is pressed, reads them
into a variable or a field.

				5-19

string can be used to include a prompt message.

pos gives the position of the prompt text and input string. It uses the @
output format parameter to specify the column position, followed by the row
position. If pos is not given then the input string appears on the row
where the cursor is currently located.

&length limits the length of the input and shows the maximum length on
screen using an 'end-of-field' marker.

The input can be assigned to a variable or a field (in a currently open
file). If the field is not in the current file, it can be specified with
the filename extension.

var or field can be either string or numeric variables or fields, and they
must match the type of input expected: a string variable will accept
whatever you type in, but a numeric variables when you input non-numeric
data such as letters. The same restriction applies to numeric fields.

EXAMPLES

1	ASK; x$
2	ASK@2, 12"Enter a text string"; x$
3	ASK@2, 14"Enter a 3 character word"&3; x$
4	ASK"Enter data-Customer Code"&8Cuscode.custfile
5	ASK"Enter a number"; n%

ATN
PURPOSE
Calculates an angle whose tangent is known. The result is given in radians.

SYNTAX
ATN (nexpr)

				5-20

COMMENTS

This function works out the angle from the angle's tangent given in nexpr.
For example: TAN (0.7854) is 1.0, so ATN (1.00) returns 0.7854 rads (which
is 45 degrees). To convert radians to degrees multiply by PI/180.

ATN is the complementary function of TAN.

EXAMPLES 

1	numfieldc=ATN (numfielda)
2	x%=ATN (y%)
3	x%=ATN (VAL (x$))
4	?ATN (x%)

BEFORE GROUP
PURPOSE
Set before group activity with reports.

SYNTAX
BEFORE GROUP fieldname

COMMENTS

BEFORE GROUP is used in a Report Program to mark the start of a BEFORE
GROUP section.fieldname identifies the group, and must be the name of a
field which has previously been defined as a group-in the Forms Editor, you
define a group in the SELECT box; Superbase then translates this into a
GROUP statement in a Report program.

The statements in the BEFORE GROUP section ar executed every time the group
changes. Typically, they would be used to display header information for
the group data which follows.

A BEFORE GROUP section must end with an END GROUP statement.

				5-21

EXAMPLES

1	BEFORE GROUP Lastname.Clients
	? "Deposits for client", Lastname.Clients
	?
	?"Firstname Lastname Bank Amount Date"
	"--------------------------------------"
	END GROUP

BELL
PURPOSE
Makes a short beep.

SYNTAX
BELL

COMMENTS

Use this command to signal that a particular process has finished and to
attract the user's attention.

With Gem versions of DML, BELL issues a tone lasting 0.5 seconds. On the
Amiga, BELL does not make a sound but causes the screen to flash.

BLANK
PURPOSE
Creates a blank record in memory.

SYNTAX
BLANK[FILE sbfname]

COMMENTS

When you want to create a new record under program control, issuing a BLANK
statement is the first step in the process. It sets up an empty record
record ready for data entry. There are several ways in which you can then
enter data into the record's fields.

Using BLANK with ENTER, allows the user to type in the data for a new
record

				5-22

from the keyboard. Together these two commands have the same effect as the
RECORD NEW option in the RECORD menu.

Alternatively, you can enter data from within a program, by assigning it
directly to the fields in the new record. Typically, this would be the
method you used to create new records by reading data in from another file
on disk.

EXAMPLES

1	BLANK
2	BLANK FILE"abc"
3	BLANK
	ENTER
	STORE
4	BLANK
	Firstname.address="John"
	Lastname.address="Smith"
	STORE

The first example creates a new record in the current file. Example 2
creates a new record in another open file. Example 3 creates a new record
in the current file, and allows the user to enter in the record; then it
saves the record on disk. Example 4 creates a new record, and enters data
into the fields Firstname and Lastname; then saves the record on disk.

BREAK
PURPOSE

Allows the user to interrupt or halt a program from the keyboard.

SYNTAX
BREAK ON/OFF

COMMENTS

BREAK ON and BREAK OFF enable and disable CTRL C. After BREAK ON (the
default condition), you can stop a program while it is running by pressing
the Control key and C at the same time. This has the same effect as
clicking on the STOP button at the bottom of the screen. CTRL C generates
error 11. If you want to include error handling routines in your programs,
you can use the ON ERROR statement to check for this error number.

				5-23

CALL
PURPOSE
Calls a user supplied function.

SYNTAX
CALL function

COMMENTS

function is string expression containing a command line to be executed by
DOS or Amiga DOS. The expression should duplicate a command line that would
normally be typed at the DOS or CLI prompt. Superbase stays in memory so
there must be enough memory for the specified command to function
correctly.

CHAIN
PURPOSE

Executes another program from within a program but does not clear the first
program's variables.

SYNTAX

CHAIN filename

COMMENTS

CHAIN allows you to carry out a task by linking together a number of
programs. When a program is running, this command loads another program
from disk, and transfers control to it. The second program displaces the
first in memory but any variables that have already been set retain their
values.

EXAMPLES

1	CHAIN "Nextprog"

				5-24

CHR$

PURPOSE
Generates the character associated with an ASCII code.

SYNTAX
CHR$ (nexpr)

COMMENTS

CHR$ works in the opposite way to ASC. Whereas ASC takes a character and
returns its ASCII code, CHR$ generates the character from its associated
code. It is useful for handling characters which are not available from the
keyboard, such as certain characters used to control a printer.

nexpr must have a positive value in the range 0-255 (although not all these
values will give printable characters). A value outside this range will
give the error 'Invalid numeric parameter'. If nexpr is not an integer, the
integer part of the number is used, i.e., 65.999 is treated as 65.

EXAMPLES

1	textfieldc=CHR$ (numfielda)
2	textfieldc=CHR$ (INT (numfielda/256))
3	x$=CHR$ (65)
4	x$=CHR$ (ASC (y$)+32)
5	FOR n%=32 to 127
	? CHR$ (n%); 
	Next

NOTES

Example 3 stores the letter A in x$. Example 4 demonstrates one way of
turning an uppercase character into lowercase - but see LCASE$ and FCASE$.
Example 5 displays the character set on the screen. Note that it does not
display characters are non-printing characters, and some of them have
unexpected effects when you attempt to display or print them.

				5-25

CLEAR
PURPOSE
Clears all user variables.

SYNTAX
CLEAR

COMMENTS

This command clears all variable assignments in memory. Using ? MEMORY
immediately after CLEAR would give no output.

CLOSE
PURPOSE

Closes an input or output channel to a text file or comms line.

SYNTAX
CLOSE INPUT/OUTPUT

COMMENTS

Only one input channel and one output channel can be open at a time, so you
are advised to use the CLOSE command when you have completed an I/O task.
Unless you close the current channel you will not be able to open a new
channel. CLOSE also ensure that all data in the disk buffer is written to
disk. If you have a large disk buffer and a small amount of data, you will
notice that some output commands-? LIST, for example-appear to have no
effect. What happens is that DML places the data in the buffer before
writing it to disk. It remains there until the buffer fills up-or until you
execute a CLOSE OUTPUT command. Associated commands are OPEN and INPUT.

				5-26

EXAMPLES

1	OPEN FILE "aaa" FOR OUTPUT
	FOR i%=1 to 10: ? i%, i%^2: NEXT i%
	CLOSE OUTPUT
	OPEN FILE "aaa" FOR INPUT
	getnext: INPUT LINE a$: ? a$
	IF EOF ("*") THEN GOTO getnext
	CLOSE INPUT

CLOSE FIELDS
PURPOSE
Closes the field list on the current file or another open file.

SYNTAX
CLOSE FIELDS[FILE sbfname]

COMMENTS

CLOSE FIELDS removes any restrictions on which fields are shown. If you
VIEW a record after issuing this command, all its fields will be displayed
on screen. On its own, CLOSE FIELDS closes the field list for the current
file. When FILE sbfname is added, it closes the list for that file.

EXAMPLES

1	CLOSE FIELDS
Close field list on current file.
2	CLOSE FIELDS FILE "abc"
Close field list for file 'abc'.

				5-27

CLOSE FILE
PURPOSE
Closes all files or a specified file.

SYNTAX
CLOSE[ALL]/[FILE sbfname]

COMMENTS

CLOSE FILE works in the same way as the equivalent option in the PROJECT
menu,  but unlike the menu option it also allows you to close all the open
files in one go.

EXAMPLES

1	CLOSE
Closes the current file.
2	CLOSE FILE "aaa"
Closes the database file 'aaa'.
3	CLOSE ALL
Closes all open database files.

CLOSE FORM
PURPOSE
Closes the current Form

SYNTAX
CLOSE FORM

COMMENTS

This command works in the same way as the Close Form option on the Project
Menu: it clears the current Form from memory and displays the current file
using one of the view modes.

				5-28

CLS
PURPOSE
Clears the screen.

SYNTAX
CLS

COMMENTS

CLS makes the output part of the screen-the output window-blank and takes
the cursor to the top left-hand corner.

EXAMPLES

1	CLS: ? "Now at top of cleared screen"

COL
PURPOSE
Returns the cursor's position across the screen.

SYNTAX
COL (0)

COMMENTS

Use this command to find out the column position of the screen cursor. For
the row position, see ROW

EXAMPLES

1	x%=COL (0)
2	? COL (0)

NOTES

In practise, Example 2 would be pointless because the statement changes the
cursor position in the course of printing it.

				5-29

COPY
PURPOSE
Makes a copy of a file on disk.

SYNTAX
COPY from.filename[, ]/[TO]to.filename

COMMENTS

Use this command either to copy a file to the same disk under a different
name, or to copy it to another disk. In the latter case, you can give the
file the same name or a new name.

EXAMPLES

1	COPY "aaa", "bbb"
Copies 'aaa' to 'bbb'.
2	COPY "A: aaa" TO "B: bbb"
Copies 'aaa' to drive B under the name 'bbb'.

COS
PURPOSE
Returns the cosine of an angle measured in radians.

SYNTAX
COS (nexpr)

COMMENTS

To convert an angle in degrees to radians, multiply by PI/180. Associated
functions are ATN, SIN and TAN.

EXAMPLES

1	numfieldc=COS (numfielda)
2	x%=COS (y%)

				5-30

2	x%=COS (VAL (x$))
4	? COS (x%)

CREATE
PURPOSE
Creates a new database file in memory.

SYNTAX
CREATE sbfname[: passwords]

COMMENTS

CREATE is only the first step in the process of building a new file. To
define the file and store it on disk you also need to use ADD and MAKE. The
whole process involves the following steps:

1. CREATE sbfname
2. ADD field
At this point the file is held in memory and you can check it with ? STATUS
sbfname.
3. MAKE sbfname
Writes the file to disk.

EXAMPLES

1	CREATE "Address"
	ADD "Recon; NUM CON IXU; 999999.; 0, 0", "SER (~Address~)"
	ADD "Title; TXT; 10; 1, 34"
	ADD "Firstname; TXT; 15; 3, 6"
	ADD "Lastname; TXT IXD; 20; 3, 34"
	ADD "Street; TXT; 30; 6, 6"
	ADD "City; TXT IXD; 15; 7, 6"
	ADD "Code; TXT; 12; 7, 31"
	ADD "Country; TEXT IXD; 15; 9, 6"
	MAKE "Address"

				5-31

NOTES

This example shows how to set up a simple address file under program
control. The first ADD statement defines a numeric field which is
automatically assigned a record number by means of the SER function. Note
the use of the tilde character to enter the filename Address within
quotation marks. Following this,  the ADD statements define eight text
fields which will hold the name and address. Once you have defined the file
in this way, you could then enter its data under program control, using the
commands BLANK and STORE.

CREATE INDEX
PURPOSE
Creates a new index file.

SYNTAX
CREATE INDEX ON exp[FILE sbfname][TO index][UNIQUE]

COMMENTS

This command is the program equivalent of the New Index option on the
Project menu.

EXAMPLES

1	CREATE INDEX ON aaa
2	CREATE INDEX ON aaa.bbb UNIQUE
'bbb' does not need to be the current file, but it must be open.

				5-32

DATA
PURPOSE

Holds the data (numeric and string constants) that is accessed by a READ
statement.

SYNTAX
DATA constant[, constant][, ......]

COMMENTS

The values (constants) following a DATA statement must be separated by
commas and text constants must be in quotation marks.

Because commas are used to separate the constants in a DATA statement, they
cannot be included in a constant. If you need to insert a comma in your
DATA items, you can use CHR$ (44).

To insert quotation marks in a string constant, use CHR$ (34). Date values
which are to be read into date fields must be in the correct format (e.g.,
"ddmmyy" or "mmddyy") and should be enclosed in quotation marks.

If you intend to use the RESTORE statement, you need to place a label in
front of the DATA statement.

EXAMPLES

1	DATA "abcde", 1.04, 2.46, "uvwxyz"
	data1: DATA 12.2, 12.4, 12.97, 13.4, 9.2, -1

				5-33

DATE$
PURPOSE
Returns a string from a julian date number.

SYNTAX
DATE$ (nexpr[, format-string])

COMMENTS

This function expresses a date number as a text string showing the day,
month and year. The format-string option is used to specify the date format
for the text string. It must be a valid Superbase format as shown in the
entry for DATEBASE.

If the format is given, the text string takes the date format as set with
the Date Format option on the Set menu, or as specified with the DATEBASE
command. The complementary function to DATE$ is DAYS. Associated date
functions are DAY DAYS DAY$ MONTH MONTH$ YEAR.

EXAMPLES

1	textfieldc=DATE$ (datefielda, "ddmmyy")
2	textfieldc=DATE$ (datefielda + 90)
3	textfieldc=DATE$ (TODAY)
4	x$=DATE$ (y%)
5	? DATE$ (datefielda + 30)

NOTES

Example 3 provides a calculation to insert the system date into a
textfield. Example 2 gives the date 90 days after the date in datefielda.
The Calendar adjustment of 1752 has been accounted for.

Unless you are sure that the date supplied in nexpr will always fall within
this century, you should set the date format to allow four figures for the
year; otherwise you will not be able to distinguish between 1901 and 2001.
With dates before AD 1000, the four figure year default option does not
insert

				5-34

zeroes. AD 55, for example, is shown as 55 and not 0055. If you wish to
have four figure years-say, to line up output-add 3653048 to nexpr. As well
as ensuring that the date is always expressed as four figures, this is the
only way to access AD 0. However, early calendars were not particularly
accurate and accurate day counts between two dates cannot be relied on with
dates before AD 1400. (Superbase always gives the same answer; history,
though, is less consistent).

DATEBASE
PURPOSE
Sets the DATE format and TIME format.

SYNTAX
DATEBASE string

COMMENTS

DATEBASE allows you to specify the format with which Superbase displays the
date and time. Normally, this format only applies when you use the system
variables, TODAY and NOW. It does not affect the format of date and time
fields,  as set in the file definition. This means that if you define a
date field with the format "dd-mmm-yy", the command

	? datefield

will display it in this format, irrespective of what the DATEBASE format
is. However, you can force Superbase to display a date field in the current
date format by enclosing the field name in parentheses, as in:

	? (datefield)

string must have a valid date or time format, as shown in the examples
below.

EXAMPLES

1	DATEBASE "dd mmmm, yyyy"
Displays the date like this as 10 June 1987
2	DATEBASE "dd/mm/yy"
Display the date as 10/6/87

				5-35

3	DATEBASE "mm-dd-yy"
Displays the date as 6-10-87
4	DATEBASE "dd.mm.yy"
Displays the date as 6.10.87
5	DATEBASE "dd mm yy"
Displays the date as 6 10 87
6	DATEBASE "hh:mm"
Displays the time as 14:35
7	DATEBASE "hh:mm:ss"
Displays the timeas 14:35:08
8	DATEBASE "hh:mm:ss.s"
Displays the time as 14:35:08.36
9	DATEBASE "hh:mm am"
Displays the time as 2:35 pm

DAY
PURPOSE

Returns the day of the month as a numeric value from a date field or a date
string.

SYNTAX
DAY (nexpr)

COMMENTS

The number which DAY returns takes the numeric format as set in the SET-
NUMERIC FORMAT Superbase menu, or as set with the command DATEBASE.
Associated date functions are DATE$ DAY DAY$ MONTH MONTH$ YEAR.

EXAMPLES

1	numfieldc=DAY (datefielda)

				5-36

2	numfieldc=DAY (datefielda + 90)
3	numfieldc=DAY (TODAY)
4	x%=DAY (datefielda + VAL (textfielda))
5	x%=DAY (DAYS ("11 Jan 85")
6	?DAY (datefielda + 30)

NOTES

Examples 3 provides a calculation to insert the day number of the system
date into a numeric field.

DAY$
PURPOSE
Returns the day of the week as a text string from a julian date number.

SYNTAX
DAY$ (nexpr)

COMMENTS

Associated date functions are DATE$ DAY DAY$ MONTH MONTH$ YEAR.

EXAMPLES

1	textfieldc=DAY$ (datefielda)
2	textfieldc=DAY$ (datefileda + 90)
3	textfieldc=DAY$ (TODAY)
4	x$=DAY$ (DAYS ("11 January 1985"))
5	x$=DAYS (y%)
6	?DAYS (datefielda + 30)

				5-37

NOTES

Example 3 provides a calculation to insert the weekday of the system date
into a textfield. Example 4 provides a weekday for the date shown in
quotation marks.

DAYS
PURPOSE

Returns the date as a julian date number from a text string or text field.

SYNTAX
DAYS (strexpr) or DAYS (nexpr)

COMMENTS

This function returns a number which is the julian day number of the date
in strexpr (31 December AD 0 has a julian date value of zero). It takes the
1752 Gregorian reform of the calendar into account.

strexpr must be in a valid date format.

A text expression which is not in one of the valid date formats will
produce a message 'invalid date format'.

Associated date functions are: DATE$ DAY DAY$ MONTH MONTH$ YEAR.

EXAMPLES

1	numfieldc=DAYS (textfielda)
2	numfieldc=DAYS (datefielda + 90)
3	numfieldc=DAYS ("11 jan 85")
4	x%=DAYS (a$) + 90

NOTES

In example 2, the use of DAYS is redundant.

				5-38

DELETE
PURPOSE
Deletes a file stored on disk.

SYNTAX
DELETE filename

COMMENTS

This command has the same effect as the ERASE command in MS DOS and DELETE
in Amiga DOS. To delete a file on a drive or directory other than the
current one,  you need to place the path name in front of the file name.

EXAMPLES

1	DELETE "aaa"
2	DELETE "b: aaa"
3	DELETE "DF0: aaa"

DIM
PURPOSE
Defines array variables

SYNTAX
DIM variablename (nexpr[, nexpr][, nexpr])

COMMENTS

Arrays can have up to three dimensions. nexpr specifies the number of
elements in each dimension of an array. The maximum number of elements is
limited only by the amount of available memory.

A single DIM statement can be used to define more than one array. If DIM is
used in this way, each array definiton should be separated by commas. Note
that the first element in an array dimension has the subscript 0.

				5-39

EXAMPLES

1	DIM x% (20)
Defines a one dimensional numeric array with 21 elements.
2	DIM b$ (10)
3	DIM x% (3, 10)
4	DIM b$ (2, 12)
5	DIM a$ (20), n% (2, 3, 10), c$ (2, 10)

DIRECTORY
PURPOSE
Changes the current directory.

SYNTAX
DIRECTORY "path"

COMMENTS

Directory can be used to switch to a directory on another drive or to a
different directory in the same drive.

EXAMPLES

1	DIRECTORY "dh0: mydir/testdir"
2	x$="a: ": DIRECTORY x$
3	C: /Images

				5-40

DISKSPACE
PURPOSE
Shows the amount of space remaining on a disk.

SYNTAX
DISKSPACE (strexpr)

COMMENTS

This function gives the number of unused bytes on a disk. On the Amiga, the
disk name given in strexpr can be either a drive name or a volume name
(i.e.,  a diskname such as Mydisk: ). Gem systems only support drive names.
On the Amiga, the diskname must end in a colon. Note also that the free
block given by the CLI are 488 byte blocks.

EXAMPLES

1	Diskspace "df0:"
2	DISKSPACE ("Mydisk:")
3	x$="df1:":x%=DISKSPACE (x$)
4	? "Remaining diskspace is: ";  DISKSPACE ("a:"); "bytes"

				5-41

EDIT
PURPOSE
Allows the user to edit a program, a text file, a Query, or an Update.

SYNTAX
EDIT [TEXT]/[QUERY]/[UPDATE]

COMMENTS

Depending on which option has been selected, EDIT displays a window or a
dialog. EDIT QUERY displays the query dialog. EDIT UPDATE displays the
update filter dialog. EDIT TEXT opens the text editor window. If none of
the three options has been selected, EDIT opens the program window. After
EDIT has opened a window or dialog, you can edit the information, just as
you would if you had selected one of the Edit options from the Superbase
menus for example, Edit Program from the Advanced menu, or Edit Query from
the Process menu. The difference is that when you exit from the window or
dialog, control returns to the program.

To exit from a window, close the window by clicking on the close gadget in
the top left-hand corner. You exit from a dialog by clicking on OK or
Cancel. In Superbase itself, clicking on OK takes the user out of the
dialog, and then runs the query or update; clicking on OK after EDIT returns
control to the program without executing a query or an update. (To run a
query, use ? QUERY, and use UPDATE to carry out an update.)

				5-42

EJECT
PURPOSE

Ejects the current page on the printer or feeds in a new page when the
number of lines remaining is less than the number specified.

SYNTAX
EJECT[nexp]

COMMENTS

EJECT on its own has the same effect as pressing the Form Feed button on
the printer. It sends a Form Feed character to the printer, which then
moves the current page on and feeds in the next. If nexp is used, the page
is ejected when the number of lines at the bottom of the page is less than
nexp.

EXAMPLES

1	EJECT
2	EJECT 3
Feeds in a new page if there are less than three lines left at the bottom
of the current page.

				5-43

END
PURPOSE
Terminates program execution.

SYNTAX
END

COMMENTS

This command brings a program to a halt and returns control to the
Superbase Menu system. END is optional and if you do not include it, DML
will return control to Superbase when it reaches the last statement in a
program.

EXAMPLES

1	IF EOF ("aaa") THEN END

END GROUP
SYNTAX
END GROUP

PURPOSE
Marks the end of a BEFORE GROUP or AFTER GROUP section.

COMMENTS

A BEFORE GROUP or AFTER GROUP section in a Report program must end with an
END GROUP statement. If it doesn't, Superbase will be unable to tell which
statements below to which section.

				5-44

END HEADING
PURPOSE
Marks the end of a HEADING section in a Report program.

SYNTAX
END HEADING

COMMENTS

A HEADING section defines the headings for a report. It must start with the
keyword HEADING, followed by one or more '?' statements which specify the
heading information. END HEADING must be placed at the end of the section.

END REPORT
PURPOSE
Marks the end of an AFTER REPORT or BEFORE REPORT section.

SYNTAX
END REPORT

COMMENTS

END REPORT must be placed at the end of the set of statements that
constitute an AFTER REPORT or BEFORE REPORT section in a Report program.
Superbase automatically generates END REPORT statements at the end of these
sections when you create a report using the Forms Editor's reporting
facility.

				5-45

ENTER
PURPOSE

Allows the user to enter data in the current file or to edit the data in a
record.

SYNTAX
ENTER[field]/[nexpr][, nexpr2]

COMMENTS

ENTER works on the current file. Used on its own, it is equivalent to the
Record menu option Edit. It displays the current record and allows you to
edit it field by field, starting with the first field. In effect, ENTER
temporarily hands over control from DML to Superbase itself. When you press
Return after the last field in a record or when you move the cursor down to
the bottom of the record,  control is transferred back to DML. If field or
nexpr is used, Superbase restricts the editing to just one field. You can
supply either a field name or a field number where the number corresponds
to the field's position in the field list; i.e., if there are six fields in
a record, the number for the first field is 1 and the number for the last
field in 6. When you enter the record, Superbase makes the editing cursor
active in the field specified and transfers control back to DML when you
press Return. With the second numeric parameter, nexpr2, you can specify
that a range of fields is available for editing, field or nexpr1 gives the
starting point, nexpr2 gives the number of fields that can be edited - from
the first field after field on nexpr1 onwards. For example, if the command
was:

	ENTER 3, 5

you would be able to edit fields 3 to 8.

You may want to specify a starting point without restricting the yourself
to a given number of fields. To do this, enter 0 as the second numeric
parameter; e.g.:

	ENTER Lastname, 3

would make the cursor active in Lastname and would allow you to edit

				5-46

Lastname and the next three fields.

ENTER works with the current view mode or Form. Note that if you have set
the Field Order on the Form, Superbase will take the first record (in the
order you have specified) as the starting point for data entry and editing.
When used in conjunction with BLANK, ENTER is equivalent to the Record menu
option New, and allows you to enter data into a new record. This command
does not save a record; to save a new or edited record use the command
STORE.

EXAMPLES

1	OPEN FILE "aaa"
	ASK "Record to edit"; x$
	SELECT KEY x$
	ENTER
	STORE
2	OPEN FILE "aaa"
	BLANK
	ENTER
	STORE
3	ENTER Lastname
4	ENTER 4, 2

Example 1 shows how to enter an existing record in order to edit it.
Example 2 creates a new record. Example 3 restricts editing to the Lastname
field. In the last example, fields 4 to 6 can be edited.

				5-47

EOF
PURPOSE

Detects the end of a database file when reading through it under program
control.

SYNTAX
EOF (strexpr)

COMMENTS

strexpr should contain the name of a currently open file. If DML reaches
the end of a file, EOF is set to -1 (true); otherwise it is set to 0
(false). EOF is only used under program control. Supplying the empty string
as an argument-EOF ("") -allows you to refer to the current file without
giving the file name. For example, to define a function key which was
equivalent to the Fast Forward button, you would enter:

	WHILE NOT EOF (""): SELECT NEXT: VIEW: WEND

EOF can also be used to detect the end of a text file. For this purpose it
takes the string "*" as an argument, and not the file name; that is, EOF
("*") is set to 'true' when the end of a text file is found. EOF is only
set and unset by the SELECT record selection commands excluding SELECT KEY
(which only set the FOUND function). In other words it is possible to
search through a file with a filter, and set EOF to 'true' by not finding a
record, and then to use the 'key-lookup' (SELECT KEY) to look for a record
outside the filter. If you do this, FOUND will reflect the success of the
'key-lookup' operation, while EOF will show that you are at the end of the
file.

EXAMPLES

1	? EOF (x$)
	OPEN FILE "aaa"; SELECT FIRST:
	IF EOF ("aaa") THEN GOTO fempty
	loop1: SELECT NEXT: IF EOF ("aaa") THEN GOTO fend
	....
	GOTO loop1
	fempty: ? "FILE 'aaa' has no records"; END
	fend: ? "Process completed"; END

				5-48

ERASE
PURPOSE
Clears a variable assignment from memory.

SYNTAX
ERASE varlist

COMMENTS

This command clears a variable or a list of variables from memory. If
several variables are to be cleared, varlist should contain a list of
variable names separated by commas. If you specify the name of an array,
ERASE clears all the elements in the array (it also clears any other
variable with the same name as the array).

EXAMPLES

1	ERASE x$
2	ERASE a%, b%, c%, d%, a$, b$
3	a$="Fred"
	a%=2.35
	MEMORY
	ERASE a$
	MEMORY

NOTES

The most obvious use for this command is to tidy up the variables in memory
before CHAINing another program or before OUTPUT TO "aaa" MEMORY. You could
then use SET "aaa" to pass some values to variables in the new program.

				5-49

ERR$
PURPOSE
Returns the text message associated with an error number.

SYNTAX
ERR$ (nexpr)

COMMENTS

This function returns a text string containing the error message associated
with the error number given in nexpr. Use this function in conjunction with
the control flow commands ON ERROR and RESUME, and the system variable
ERRNO.

EXAMPLES

1	? ERR$ (ERRNO)
	CLS: NUMBASE "z9999"
	FOR i%=1 to 130
	? "Error number"; i%, " "; ERR$ (i%)
	NEXT i%
3	x$=ERR$ (14)

Example 2 displays a list of error numbers with their associated error
messages.

ERRNO
PURPOSE
Returns the number of the last error that occurred.

SYNTAX
ERRNO

COMMENTS

ERRNO is used in conjunction with the error handling commands ON ERROR and
RESUME and with the function ERR$ which gives the error message associated
with

				5-50

an error number.

EXAMPLES

1	x%=ERRNO
2	? ERR$ (ERRNO)

NOTES
Example 2 displays the error message associated with the last error which
occurred.

EXECUTE
PURPOSE
Executes a text string as though it were a command.

SYNTAX
EXECUTE string

COMMENTS

Any set of commands, statements, and functions that can be carried out as a
single program line can be placed in a string and then executed.

EXAMPLES

1	EXECUTE "SELECT CURRENT: VIEW: WAIT FOR 5"
	y$="REQUEST ~ OK/CANCEL Requestor ~, ~~, 1"
	EXECUTE y$

NOTES

Example 2 suggests a way of using this function to set up a user-defined
dialog which can be called from different points in a program. Note the use
of the tilde character to embed quotation marks in a string.

				5-51

EXP
PURPOSE
Returns the value of the mathematical constant 'e' raised to a power.

SYNTAX
EXP (nexpr)

COMMENTS

EXP gives the value of 'e' to the power of expr.
nexpr has a maximum absolute value of 709.7827128934, and a range of
-709.7827128934 to + 709.7827128934. This in turn gives the largest number
that Superbase can hold - 1.797693134862 times 10 to the power 308.

EXAMPLES

1	numfieldc=EXP (numfielda)
2	numfieldc=EXP (datefielda-datefield)
3	numfieldc > EXP (numfielda & numfield)
4	x%=EXP (y%)
5	x%=EXP (y% * numfielda * (datefielda-datefield))
6	x%=EXP (VAL (RIGHT$ (textfielda, 5)))
7	? EXP (x%)

				5-52

EXPORT
PURPOSE
Exports data to an external text file from the current file.

SYNTAX
EXPORT[FILE sbfname[INDEXindex][TO]filename
[WHEREconditions] [USINGparams]

COMMENTS

This command is the program equivalent of the EXPORT option in the PROCESS
menu. It creates a text file on disk using the data from an sbf file. The
only compulsory parameter is filename, which gives the name of the text
file. If FILE sbfname is not specified, EXPORT takes data from the current
open file. Similarly, unless INDEX indexname is given, the command exports
records in the order of the current index. WHERE conditions allows you to
creates a filter to determine which records are copied to the text
file.conditions is set up in the same way as the command string in the
Filter requestor. USING parameters allows you to change the Export/Import
parameters as specified by SET-OPTIONS. These determine what characters
Superbase uses to separate fields and records in the text file. You can
also specify whether text fields are exported with or without quotation
marks around them. USING takes three parameters, each enclosed by quotation
marks and separated by commas. For example:

	USING "&", "$$", "0"

The first two parameters specify the field separation characters and the
record separation characters. As in SET-OPTIONS, you can define a separator
using one character or two characters. The third parameter must be either 0
or 1; 0 for no quotation marks,  1 to include quotation marks.

				5-53

If you want to use a non-printing character-the carriage return character
or the line feed character, for example-as a separator, you need to enter
its ASCII code with the CHR$ function. For example:

	USING "&", CHR$ (13) + CHR$ (10), "0"

defines the record separator as the carriage return character followed by
the line feed character.

EXAMPLES

1	EXPORT "aaa.exp"
2	EXPORT FILE "aaa" INDEX fielda TO "aaa.exp" WHERE
	(datefield) < DAYS ("29 Apr 87")
3	EXPORT FILE "aaa" TO "aaa.exp" USING "&", "##", "1"

				5-54

FCASE$
PURPOSE
Converts the first letter of a string to upper case, leaving the rest of
the string in lower case.

SYNTAX
FCASE$ (strexpr)

COMMENTS

FCASE$ takes a word and makes the first letter a capital letter. Associated
functions are LCASE$ and UCASE$.

EXAMPLES

1	textfielda=FCASE$ (textfielda)
2	x$=FCASE$ (y$)
3	x$=FCASE$ ("ABCDEF")
4	? FCASE$ (x$)

				5-55

FILE
PURPOSE
Marks an open file the current file.

SYNTAX
FILE sbfnam

COMMENTS

When several files have been opened, you can use FILE to make one of them
the current file.

EXAMPLES

1	FILE "aaa"
2	x$="bbb": FILE x$
3	a$="address": b$="bank"
	OPEN FILE a$: SELECT FIRST
	OPEN FILE b$: SELECT FIRST
	PAGING OFF
	f$=b$
	lab1: VIEW: WAIT x$
	IF EOF (a$) OR EOF (b$) THEN END
	IF f$=b$ THEN f$=a$ ELSE f$=b$
	FILE f$: SELECT NEXT
	GOTO lab1

NOTES

The third example shows how you can display records from two (or more)
files at the same time. It displays one record after another, alternating
between two files until it reaches the end of the shorter file.

				5-56

FIX
PURPOSE

Sets the accuracy with which DML stores a number and performs calculations
on it.

SYNTAX
FIX (nexpr1, nexpr2)

COMMENTS

FIX allows you to limit a numeric expression to a specified number of
decimal places. nexpr2 is the number of decimal places that nexpr1 is
evaluated at. Superbase stores numeric variables at 13 figure accuracy, so
the fraction 1/3 is stored as 0.3333333333333. Adding two of these together
gives 0.6666666666667. If you set the numeric format to two decimal places
in a file definition,  Superbase would show this result as: 0.33 +
0.33=0.67. This is not incorrect, especially if you are a scientist or
engineer, but it is not very helpful if you are using a Query to produce an
invoice. FIX (1/3, 2) stores the fraction 1/3 as 0.330000000000, so FIX
(1/3, 2) + FIX (1/3, 2) gives result as 0.66. Note that numeric fields with
two decimal places are automatically FIXed.

EXAMPLES

1	numfieldc=FIX (numfielda, 3)
2	numfieldc=FIX (datefielda-datefieldb, 0)
3	numfieldc > FIX (numfielda * numfieldb, 4)
4	$x=FIX ($y, 2)
5	$x=FIX ($y * numfielda * (datefielda-datefieldb), 2)
6	$x=FIX (VAL (RIGHT$ (textfielda, 5)), 2)
7	? FIX ($x)

				5-57

FOOTING
PURPOSE
Sets the Report footing for every page.

SYNTAX
FOOTING nexpr

COMMENTS

FOOTING is followed by a number of ? statements specifying the information
that will appear at the bottom of every page in a report. These must be
followed by an END FOOTING statement. nexpr specifies the number of lines
required for the report footing. Make sure that the number of lines output
by your ? statements is the same as the number specified by nexpr.

EXAMPLES

1	FOOTING 1
	? "Page"; PG
	END FOOTING

NOTES
This examples uses the system variable PG to print the page number. See the
entry HEADING for more details.

FOR TO NEXT
PURPOSE
Repeats a series of program statements a specified number of times.

SYNTAX
FOR var=nexp1 TO nexp2[STEP nexp3]statements NEXT[var][, var]...

COMMENTS

This command sets up a program loop in which the statements between FOR TO
and NEXT are executed a given number of times, using var as a counter.
nexp1 sets the initial value of the counter and nexp2 sets the final value.

				5-58

If STEP nexp3 is not included, the counter is increased by one every time
the program executes the statements inside the loop; that is, every time it
passes from FOR to NEXT. When the counter reaches the value set in nexp3,
the program moves on to the next statement after NEXT. When STEP nexp3 is
included, the program increases the counter by the amount specified in
nexp3. var must be a numeric variable; nexp1, nexp2, nexp3 can be any
numeric expression,  including other numeric variables. You can use FOR TO
NEXT on the same line with multiple statements, or on multiple lines. But
if there is more than one statement between FOR and NEXT, it is advisable
to put each on a separate line. If a number of FOR NEXT loops end at the
same point, you can use a single NEXT statement for all of them.

	NEXT n%, y%, z%

is the same as

	NEXT n%
	NEXT y%
	NEXT z%

EXAMPLES

1	FOR i%=1 to 10: ? i%, i% ^ 2: NEXT
2	weekcount%=1
	FOR i%=DAYS ("01/01/87") TO DAYS ("31/03/87") STEP 7
	FOR j%=0 to 6: k%=i% + j%
	? DAY (k%); " "; MONTH$ (k%), DAY$ (k%)
	NEXT j%
	weekcount%=weekcount% + 1
	NEXT i%

Example 2 prints out the weekdays for the first quarter of 1987 in weeks.

				5-59

FORM
PURPOSE
Specifies which part of a Form is displayed in the database window.

SYNTAX
FORM page[, row, col]

COMMENTS

This command is used to select a particular page within a multi-page form
or to bring part of a page that is outside the database window into view.
page must be a numeric expression specifying the page number.row and col
must be numeric expressions which give a row and column position within the
page. Form will then move the page so that the specified position is at the
top left-hand corner of the database window.

EXAMPLES

1	FORM 2
Selects page 2 in the Form currently displayed.
2	FORM 1, 24, 1
Makes row 24, column 1 of page 1 appear at the top left-hand corner of the
database window.

FOUND
PURPOSE
Detects whether a key lookup has been successful or not.

SYNTAX
FOUND (strexpr)

COMMENTS

After you have issued a SELECT KEY command to search for a particular
record,  FOUND will tell you whether the record has been found. If the
search is successful, FOUND returns a value of -1 (true); if the search is
unsuccessful, 

				5-60

FOUND returns 0.
strexpr should contain the file name of '.sbf' file which has already been
opened. However, you can use the empty string-as in FOUND ("") -to refer to
the current file. FOUND is only set and cleared by the SELECT KEY and
LOOKUP commands.

EXAMPLES

1	SELECT KEY "London"
	? FOUND ("")
2	a$="Clients": SELECT KEY "Smith" FILE a$
	IF FOUND (a$) THEN ? "Smith found" ELSE ? "No Smiths"

FREE
PURPOSE
Returns the amount of free memory.

SYNTAX
FREE (nexpr)

COMMENTS

This function returns a number showing how much free memory there is. On
the Amiga, nexpr determines whether the figure refers to chip, contiguous
or fast memory.

0=total free memory
2=chip memory
4=fast memory

Adding 2^17 to one of these parameters gives the largest block of memory in
its respective memory area. So, 2^17 + 2 gives the maximum area of
contiguous chip memory.

EXAMPLES

1	? FREE (0)
2	x%=FREE (i%)

				5-61

GET
PURPOSE
Gets a character from the keyboard.

SYNTAX
GET strvar/field

COMMENTS

This command reads a character from the keyboard into a string variable or
a text field. It does not wait for a keystroke, and if no key is pressed it
returns an empty string. If you want GET to wait until a key is pressed,
you need to place it in a loop, as in:

	LABEL: GET A$: IF A$=: ""  GOTO LABEL

Alternatively, use the WAIT command.

GOSUB
PURPOSE
Calls a procedure or subroutine.

SYNTAX
GOSUB label

COMMENTS

Like the GOTO statement, GOSUB transfers control to a different part of the
program: it causes the program to branch to the label specified. But unlike
GOTO, it remembers where it branched from. When the program meets a RETURN
statement, it jumps back to the line following the GOSUB statement. GOSUB
is used to call a subroutine; that is, one or more program lines which
perform a specific task and can be called from different places within the
main program. Subroutines are useful if the same task needs to be performed
at several different stages in the program. Instead of repeating a group of
lines,  it saves space and is more convenient to put them in a subroutine.

				5-62

In DML, a subroutine is defined by a label at the beginning and a RETURN
statement at the end.

EXAMPLES

1	GOSUB sub1
2	x$=Address (1): GOSUB label1
	x$=Address (2): GOSUB label1
	.....
	.....
	.....
	label1:
	? "This subroutine outputs x$ to the printer"
	PRINT x$
	DISPLAY;
	RETURN

GOTO
PURPOSE
Transfers control to another part of the program.

SYNTAX
GOTO label

COMMENTS

This statement makes the program jump to the label specified, instead of
continuing to the next line in the program. It alters the order in which
DML executes a program. This kind of control transfer is called an
unconditional jump. For conditional jumps, see the ON GOTO and the IF THEN
ELSE statement.

EXAMPLES

1	GOTO fred
	....
	....
	fred:....

				5-63

GROUP
PURPOSE

Specifies the field on which a report is grouped and the field (s) for
which subtotal reporting is required.

SYNTAX
GROUP fieldname [, fieldname] [.....]

COMMENTS

Superbase insets a GROUP statement in a report program when you specify
fields with the GROUP option on the Forms Editor's Report menu. GROUP has
two main functions. First, it defines the field on which Superbase groups
data in a report. Second, it specifies any other fields for which
subtotals-or other reporting features such as MAX and MEAN-are required. If
you wish to specify several levels of grouping, you should enter a separate
GROUP statement for each level. GROUP can also be used in an AFTER GROUP
section as a reference for the field which defines the group. Since the
group has already changed, entering the field name would output the data
for the next group; GROUP allows you to retrieve the data for the previous
group-i.e., the group for which the AFTER GROUP section provides reporting
information such as subtotals and record counts.

EXAMPLES

1	GROUP City, amount
'City' is field on which the report is grouped, 'amount' is a field for
which subtotals are required-the AFTER GROUP section may include the
statement:
	SUM amount
2	GROUP Country
	GROUP City, amount

In this example, record data is grouped at two levels: City within Country.

				5-64

HEADING
PURPOSE
Sets the Report heading for each page.

SYNTAX
HEADING

COMMENTS

Superbase generates a HEADING statement when you specify a report heading
using the Heading option on the Forms Editor's Report menu. This statement
marks the start of a HEADING section and is followed by one or more
statements which define the heading for a report. The section must end with
an END HEADING statement. If you wish to include the page number in a
heading, use the system variable PG, as in:

	? @32, "Page"; PG

PG is set to one when the Report Select command is executed and incremented
by one after each page.

EXAMPLES

1	HEADING
	? @22; BF; U; "DEPOSITS REPORT on", TODAY, "at", NOW; ATTR
	OFF
	END HEADING

HOME
PURPOSE
Takes the cursor to the top left-hand corner of the screen.

SYNTAX
HOME

COMMENTS

Home moves the cursor to the top of the screen without clearing the screen.
The next screen output will now appear at that position.

				5-65

HOME is useful when you want to overwrite something you have previously
displayed on screen, or when you want to move the cursor up the screen or
backwards. Normally, if you attempt to do this with LOCATE or using the @
parameter with the ? command, DML displays the next page. HOME allows you
to display text and numbers anywhere on screen, no matter what has been
displayed previously.

EXAMPLES

1	CLS
	FOR r%=1 to 18
	FOR c%=1 to 80
	HOME: LOCATE c%, r%: ? "Hello"
	NEXT
	NEXT

HRS
PURPOSE

Extracts the number of hours from a numeric expression containing the time
in thousandths of a second.

SYNTAX
HRS (nexpr)

COMMENTS

nexpr will usually be a time field or the result of a TIMEVAL expression.

EXAMPLES

1 hr%=HRS (timefield)

IF THEN ELSE
PURPOSE
Executes a statement if a condition is true.

SYNTAX
IF exp THEN statements[END IF][ELSE statements][END IF]

				5-66

COMMENTS

exp can be any expression-string, numeric or logical-which is capable of
being true or false. For example, A$="Smith" is either true or false, so:

	IF A$="Smith" THEN...

is a valid statement, but

	IF A$ THEN...

is not.

If exp is true, DML executes the statement or statements after THEN.
Otherwise it proceeds to the next statement after the IF THEN statement.
THEN can be omitted when it is followed by GOTO. For example:

	IF exp GOTO label

is the same as

	IF exp THEN GOTO label

By including the ELSE option, you can instruct DML to choose between two
courses of action. It executes the statements after THEN if exp is true; if
exp is false, it executes the statements after ELSE. An IF THEN ELSE
statement can be split up so that it is placed on several lines. If you do
this, the statements after THEN must start on a new line, and ELSE must
also start on a new line. For example:

	IF x% > y% THEN ? "Greater than" ELSE ? "Less than or equal"

can be written as:

	IF x% > y% THEN
	? "Greater than"
	ELSE
	? "Less than or equal"
	END IF

END IF marks the end of the IF THEN ELSE statement. It should always be
used when ELSE is placed on a separate line. If it is not used, DML assumes
that all the separate line statements in the rest of the program belong to
ELSE.

				5-67

END IF is also used when the ELSE option has not been selected, but the
statements following THEN are placed on separate lines. For example:

	IF b$="Yes" THEN n%=1: z%=2: GOSUB label

can be written:

	IF b$="Yes" THEN
	n%=1
	z%=2
	GOSUB label
	END IF
	.....
	.....

Here too, END IF is used to tell DML where the statements belonging to THEN
finish. exp does not always need to contain an operator. Remember that DML
assigns a value of 0 to false expressions and -1 to true expressions. With
IF THEN commands, though, DML treats a numeric expression with any value
other than zero as true. And it treats a numeric expression with any value
other than -1 as false.

	IF EOF ("") THEN .....

implies:

	IF EOF ("") <> 0 THEN...

Likewise, 

	IF NOT EOF ("") THEN...

implies

	IF EOF ("") <> -1 THEN

EXAMPLES

1	IF exp THEN x%=x% + 1
	IF exp THEN x$="TRUE"
	IF exp THEN x%=x% + 1: x$="TRUE"
	IF exp THEN labltrue
	IF exp THEN GOTO labltrue
2	IF exp THEN x$="TRUE" ELSE x$="FALSE"
	IF exp THEN x$="TRUE": x% + 1 ELSE x$="FALSE"
	IF exp THEN labltrue ELSE lablfalse

				5-68

	IF exp THEN GOTO labltrue ELSE GOTO lablfalse
3	IF b$=MID$ (a$, 3, 1)THEN
	x%=1
	GOSUB label1
	ELSE
	x%=2
	GOSUB label2
	END IF
4	IF a$="Y" or a$="y" THEN
	? "Yes"
	ELSE
	IF a$="N" or a$'"n" THEN
	? "No"
	ELSE
	? "Other"
	END IF

NOTES

Example 4 shows how IF THEN statements can be nested. In this case, the
second IF THEN statement is only executed if the condition in the first
statement gives a false result.

IMPORT
PURPOSE
Imports an external text file into an open file.

SYNTAX
IMPORT filename [TO FILEsbname] [WHERE conditions] [USING parameters]

COMMENTS

This command imports the ASCII text file specified by filename into the
current file or into the file specified by sbfname. It works in the same
way the IMPORT option in the PROCESS menu. IFTOFILE sbfname is not
specified, the text file is imported into the current open file. If it is
specified, sbfname must be an open file.

				5-69


End Of Part 1

