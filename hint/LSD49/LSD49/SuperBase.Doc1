
			SUPERBASE


			 PART 1

WELCOME TO SUPERBASE   

This Introductory session with Superbase will give you an understanding of
how to perform some of the basic database operations of the Superbase system.  
Some more complex functions are explained in the section Working with Superbase.

OPENING A FILE

If you look at the top left-hand corner of the screen you will see a
message that reads "Superbase:  Please open a file".  You always see this
message when you start Superbase up, or when there is no file open.  Since
you can't do any work without a file, let's open one and take a look at it.

Files can only be opened from the Project menu.  This is the first menu on
the menu bar.

SUPERBASE REQUESTERS

Superbase now requestes the name of the file you wish to open.

Requesters like this one (some are more complicated) are used in most
Superbase operations.  They also communicate messages to the user.  They
are known as requesters because their function is to request specific
action from the user.  Usually the action involves making selections by
clicking the mouse or typing in a number of a text value of some kind.

Many requesters show a panel that contains a list of items such as file
name or field names.  The panel may be only a few lines long, so there may
be more files or fields than can be shown at one time.  If there's a gap at 
the bottom of the scroll bar there are more items to be viewed. You can show 
them by dragging down the scroll bar at the right of the panel, or by clicking 
on the downwards pointing arrow gadget below the scroll bar.

Many Superbase requesters include a Clear button.  This has the effect of
removing anything that's in the Selection Box, and can be used at any time.

CHOOSING THE ADDRESSES FILE

Move the pointer into the panel which contains a list of file names.  Move
it over the file name Addresses.  This is the demonstration file you'll be
using for the rest of this session.  Using the left-hand button, click once 
on the name Addresses.  Superbase copies the name of the file you've
selected into the Selection Box -- that's the box underneathe the panel of
tile names.  (If you see the wrong file name in the box, move the pointer
carefully onto the right file name, and click again.) Once you've selected
the file, move the pointer onto the OK button and click once.  Superbase
now opens the Addresses file.

THE MAIN DISPLAY

When Superbase opens a file from the start up screen, it automatically
reads the first record in the file and shows it on the Main Display screen. 
You'll see the name of the file appear on the title bar at the top of the 
window, followed by the name of the field on which the file is currently 
indexed.

The Main Display is Superbase's permanent window onto your database.  It's
like a large worksheet, 273 colulmns across; the number of lines you can
see depends on the size of your window.  Surperbase uses the Main Display
to show you the records in the current file, as well as the results of some 
other operations.  At the bottom of the Main Display is the Control Panel, 
which we'll be looking at in a minute.

On the Main Display, the field names for each record in the Addresses file
appear down the left-hand side of the screen.  The data for each filed is
displayed to the right of its field name.  If the data for a filed is wider 
than the window, it extends off to the right.  You can bring it into view 
using the scroll bar at the bottom of the window.

Remember that if there were more fields in the record than you could see,
you could view them by dragging the scroll bar at the right of the window
downwards, or by clicking on the downward pointing arrow.

RECORD VIEW, FORM VIEW AND TABLE VIEW

The record format you're looking at now is only one of the three possible
ways of looking at your file.  It's called Record View.  This view shows
the records one at a time, restricting the format by keeping the field
names on the left and limiting you to one field per line.  This restriction 
allows records to be scrolled up and down the screen with the Control Panel 
buttons.

In Form View, you also see one record at a time.  Each record is like a
form or page and, as you'll see later, you can drag the fields around to
create a worksheet desinged to suit your application.

The third display format is Table View.  This displays the field names
across the top of the screen with the data appearing in rows and columns,
each record occupying one line.

SWITCHING TO TABLE VIEW

Select Table View from the Set Menu.  You will see the field names appear
across the top of the screen.  The same record is shown, but each item of
data appears underneath its field name.  As with Form View, there are ways
of changing this row and colulmn display to suit your own preferences which 
we'll explain later.

SCROLLING THE SCREEN

While you are viewing your record in Table View you will notice that the
field names do not all fit onto the screen.  The fileds to the right can be 
viewed using the arrow at the right of the bottom scroll bar.  Move the
pointer onto this arrow, and click on it once.  The display shifts five
columns to the left.  Click once on the left-hand arrow to shift right and
restore the display.  If you want to shift the display by larger areas,
drag the bottom scroll bar with the mouse.

CONTROL PANEL

Now that you've opened a file, and discovered how to change the way in
which records are displayed on the screen, let's look at the Control Panel. 
This is your means of controlling the main display.  As you can see there 
are 12 buttons, most of them modelled on the controls for a video cassette 
or tape recorder, so you should find these conventions easy to learn and 
remember.

Each button has a special purpose, and together they fall into three
groups.  On the left are the Pause and Stop buttons.  Followed by seven
buttons for browsing through the file.  On the right are three special
purpose buttons which we'll examine later.  The functions of some controls
are more intuitively obvious than others, so we'll take a look at the first 
nine now, one by one.  Make sure you've set Table View for this exercise.

	^       Current Record:  This button is used to display the current
record.  When Table View has put a lot of records on the screen it can be
helpful to select the current record as the top record in the display.
Also, you can only Edit the current reacord, and this button is a useful
way of ensuring that you've got the right record.  If you click on this
button you will notice that Superbase clears the screen and then displays
the current record.

	>	Next Record:  Allows you to view the next record in the file. 
The order in which the records appear is dicided by the current index,
which is shown by the message on the title bar of the main display window.
Try this now, and you'll see the data for the next record come onto the
screen.  In Table View it appears underneath the previous record.  In Form
View it replaces the previous record.

	<	Previous Record:  This gets the previous record in the file, 
relative to the current record.

	>>	Fast Forward:  Instead of moving forwards through the file one
record at a time by pressing the Next button, you can move much quicker
using the Fast Forward button.  Click on this button, and Superbase gets
the next records in the file, displaying them row by row until the screen
is full, when it selects the Pause button.

	||	Pause:  When the Pause button is selected, you cannot select 
any menu item until you either release it or click on the Stop button next
to it.  You can, however, use the other Control Panel buttons.  So, to view 
the next screen of records, release the pause by clicking on the Pause button.  
Superbase continues with the Fast Forward display of records, stopping when the 
next screen is full, or when it reaches the end of the file.  Pause is useful 
when you're searching for a record and you want to stop from time to time to 
read the screen.

	<<	Rewind:  This does the opposite of the Fast Forward button.  
You will see the data appear from the top of the screen,in reverse index
order.  If you do this immediately after Fast Forward there will be an
apparent delay while Superbase displays records over the text of the
existing display.

	|<	First:  Pressing this button automatically displays the first 
record in the file, according to current index order.

	>|	Last:  Pressing this button automatically displays the last 
record in the file, according to current index order.

	|	Stop:  If you want to stop the Fast Forward or Rewind display,
click on Stop.  You must also click on Stop if you want to interrupt Pause
when it's selected.

OPENING FIELD TO VIEW

As Superbase imposes no limit on the number of fields per record, you need
to have a way of restricting the fields that actually appear on the Main
Display.  You can do this with the Open Field option on the Project Menu.

Display the Project Menu, and select Open Fields.  The basic procedure for
selecting fields is very simple:

1.  Click on a field name in the left-hand panel.  Superbase copies it into 
the right-hand panel.  

2.  Repeat until the selection of fields you want is in the right-hand
panel.  
3.  Click on OK.

The list of fields in the right-hand panel is called the Open Fields List.
Let's make one now.  Move the pointer onto the list of fields names, and
click on City.  Nitice how Superbase copies it across.  Now click on
Lastname.  When you have both names in the list, click on OK.  (If you make 
a mistake, DEL romoves the current field from the right-hand panel; Clear 
removes the whole list.)

Superbase immediately returns to the Main Display showing the data for the
two open fields.  Try out the Control Panel buttons to see their effect.
Experiment with Record View as well as Table View.

When you've finished, restore the full set of fields by selecting Close
Fields from the Project menu.

PAGING

This is another feature which gives you control over the Main Display:
the Paging option.

If Record View is not set, select it now from the Set Menu.  Then go back
to the Set menu, and move the pointer down to the Paging item, which should 
have a check mark against it.  Release the mouse button while Paging is 
highlighted.  You've now turned the paging option off.  (You can check this 
by looking at the Set menu again; there should be no check mark against the 
Paging item.)

Now, select the first record in the file by clicking on the First Record
button.  Then click on Fast Forward, and watch the display.  You'll see
that Superbase down't pause when the screen is full -- It just goes on
displaying records.  You can still use pause to halt the display, but the
automatic pausing at the end of each "page" of data no longer occurs.  The
same applies when Rewind is in use, except that the records appear at the
top of the screen.

If you now switch back to Table View and try out some of the Control Panel
buttons, you'll see that with Paging off the difference is similar to that
in Record View.  Each record appears below the last, without clearing the
screen.  Rewind displays records from the top down, as in Record View.

MOVING COLUMNS

For this exercise you need to be able to see all the fields on the screen,
not just those in the Open Fields list, so if you have an open Fields list
in use, close it now by selecting Close Fields from the Project Menu.

You can see that if you have all the fields open in Table View, some of the 
field data is very likely to be hidden from view.  Normally, to see hidden 
fields you have to scroll the screen to the right.  However, Superbase 
provides a way of closing up columns to get more data on the screen.

Assuming you're in Table View -- set it if you're not -- click on the
First button, then the First Record button on the Control Panel in order to 
get the first record of the Addresses file on your screen.

MOVING A COLUMN TO THE LEFT

Now move the pointer so that it is on the space to the right of "M" in the
Title Field.  Once you have done that press and hold down the left-hand
button of the mouse.  As you do this you will see two vertical lines
appear, forming a column beneath the Title field.  There are also lines
extending off to the right of the screen.

Keeping the left button depressed, drag the pointer a little to the left,
then release the mouse.  You will see that the column moves, and when you
release the mouse the data beneath the field name has shifted to the left.
All columns to the right have also moved leftwards.

Now try the same with the Forename field.  This time ove the column so
that it is just to the right of the "e" in Title.  If you also try this
with Lastname and Street you will see that as you move the columns over to
the left the field name City appears on the right of the screen.

If you now move the City column to the left, the Code field will appear on
the screen.  Finally, if you move the Code field, Country will appear on
the right- hand side.  So by moving the columns you've got all the fields
on one screen instead of two.

Notice that you can move a column so that it overlaps the column to its
left, truncating the data.  This can be useful.

MOVING A COLUMN TO THE RIGHT

If you move a column back to the right, the truncated field name and data
are not automatically restored to their full length.  A quick way of
restoring the length of a fiels is to double click in its column.  Then if
you click on the Current Record button the full field name and data will
reappear.  But as this only displays one record you will have to use Fast
Forward if you want to redisplay a screen of Record data.

FORM VIEW DESIGN

Superbase allows you to rearrange the positions of the fields in Form
View, setting more than one field on a line, creating columns of field to
resemble invoices or other business forms, and generally talloring the
system to suit your own application.  The full 273 column woeksheet is
available for Form View, and you can vary the depth by dragging fields
downwards, creating new lines.

You can use Form View for creating new records and editing them, as well 
as for display.  By setting the Printer option on, you can copy the visible 
portion of the worksheet to the printer.

Select Form View now from the Set Menu.
 
Make sure you've got the Addresses file open, and that the current record
is the first record in the file.

DEFAULT FORM VIEW

If you look at the screen you can see that the fields names already appear
in a Form View.  This is the default Form, which we have predefined for
this demonstration file.  You can change it, and then save it with Project
Save File.  Once a Form has been saved, the fields will appear in that
layout every time you open the file.

MOVING FIELDS

Let's move the Lastname field to another position on the screen.

Move the pointer so that it's on the field name Lastname.  Then press and
hold down the left-hand button of the mouse.  Superbase outlines the field
name and its data area.  (If you see a cursor instead, you've started
editing by mistake.  Carefully click again on the field name itself.) Now
drag the outlined box to a new position two lines above its present
position.  Release the mouse button.  As you can see, the field name and
data have moved to this new position.

Now, if you want to, you can arrange the Form View for Addresses in any
way you like.  This can be just an experiment, but if you want to save the
present arrangement, you can do so.  Select Save File from the Project
Menu.  Superbase stores the File Definition, which contains the Form View
location of each field, on disk.

Although you have freedom to drag fields to any position on the screen,
there are as usual a few limits to what you can do.

	You cannot place a field on top of either the name or the data area
of another field.  If you try this, Superbase leaves the field you tried to 
drag in its original position.

	Superbase won't let you move a field off the right or left-hand end
of the worksheet.

	To gain more lines, move a field down into the Control Panel.  Then
use the vertical scroll bar on the Main Display window to bring it back
into view.  Move it down again if you still need more lines.

	To move a field over to the right of the worksheet, position it
near the right-hand edge of the screen, then shift the display with the
scroll bar, and drag the field further over.

	Only the open fields are shown, so close the Open Fields List if
you want to see all the fields in Form View.

Finally, a small but entertaining feature.  Select Fast Forward, and drag
the fields around as described above.  No problem.

SUMMARY

Time for a check list of what you should know before we proceed.


*	How to open a file
*	How to switch betgween Form View, Table View, and Record View
*	How to switch Paging off and on
*	How to drag columns around in Table View
*	How to Open and Close a list of fields
*	How to select the Current record
*	How to move to the First record
*	How to move to the Last record
*	How to move to the Next record
*	How to go to the Previous record
*	How to use the Fast Forward to move forwards through the records
*	How to Rewind to move backwards through the file
*	How to Pause
*	How to Stop

Understanding all these actions is essential if you wnat to be able to
work easily with Superbase.  If you do not understand them or are uncertain 
then take a little time to go back and re-read the appropriate sections 
before continuing.

THE KEY LOOKUP BUTTON

	?	Key Lookup:  This is for the retrieval of individual records.
You enter a value for the field on which the file is currently indexed, and 
Superbase uses the index to find and display the record.  You can only use 
one index field at a time -- the Filter button is used for multiple value 
searching.

When you click on the Key Lookup button you'll see a requester for the
entry of a key value.

TYPING IN YOUR KEY

To be able to type in the box, you must move the pointer into it and click
the mouse once.  This produces the cursor, and you can then type in your
Index Key.  Suppose you want to find the record for Julie Kasper.  The file 
is indexed on the Number field, so we can use the current index to search for 
individuals by their Reference Numbers.  Click in the box and then type in 
"KAS0001" (omit the quotation marks).  This is the Index Key.


RETRIEVING THE RECORD

When you press Return or click on OK, Superbase looks up the first record
for which the Number field has the value "KAS0001".  If there were more
than one with this value, you would have to browse through the file with
the Next Record or Fast Forward button to find the exact record you wanted.

KEY LOOKUP WITH A DIFFERENT INDEX

You're not restricted to one index.  Superbase allows you to have up to 999 
indexes for each file, all automatically updated when you add or modify 
records.  We've provided indexes on the other fileds besides the number field:  
Lastname, City and Country.  Let's try one of these.  Select Open index from 
the Project Menu.

Click on the field name Lastname; this is copied into the Selection Box.
When you're ready, click on OK.  You've selected the Lastname index, and if 
you look at the title bar at the top of the window you'll see that the
message now reads "Superbase:  Addresses Indexed on Lastname".

The record on the main display has not changed.  Click on the Key Lookup
button, and Superbase produces the Record Key requester.  As you did above, 
click in the box and type in a key value, only this time type in "Forge". 
Press Return or click on OK, and Superbase looks up the first record with 
Forge in the Lastname field.

ENTERING PARTIAL VALUES 

You don't even need to type the full index key in many cases.  Try Key
Lookup once more, but type in "Hut" and press Return.  Superbase finds the
first record for Huttermann.  For your information, Superbase tells you
that it didn't find the exact match.

THE FILTER BUTTON

	=	Filter:  This is a very powerful feature.  You may have 
thousands of records in a database file, yet you may often want to review
them (or print them out) on a selective basis.  The Filter allows you to
enter a set of values, as simple or a comprehensive as you like, to
restrict the display to only the records that match those values.

THE FILTER REQUESTER

Move the pointer and click on the Filter button on the Control Panel.

This requester looks more complex than the ones you have seen so far, but
after a little practice with the demonstration file you'll find that you
can remember how to use it easily.  It's important that you learn how to
use the Filter, because Superbase uses filters in several other functions.

The requester has four main parts:  the Field Name Panel, the Operators,
the Value Box, and the Main Box.  A Filter is created by a combination of
clicking on field names and operators and typing in values.  These actions
produce the Filter Command Line in the Main Box.  Let's look at each
component of the Filter Requester in turn.

FIELD NAME PANEL

This appears on the left-hand side of the requester.  You can scroll the
list of field names up and down in the usual way, using the scroll bar and
arrows at the right of the Field Name Panel.  You specify that a field is
to be used in the Filter by clicking on its name in this panel.

The list of field names is complete.  It's not affected by whether you have 
an Open Fields List, so the fields that specify the Filter neen not be the 
same as the ones that are shown in the Main Display.

OPERATORS

These appear to the right of the Field Name Panel, and can be divided into
the Relational Operators, Logical Operators and Mathematical Operators.
We'll see how these are used below.

VALUE BOX

This is the box with the word "Value" next to it.  You use it for typing
in values such as names, numbers, and dates, which will form part of the
Filter.

Always remember to press Return after typing in the Value Box.  You must 
do this to ensure that the contents are copied to the Main Box.

MAIN BOX

This is the long box that appears below the Field Name Panel and extends
across the whole requester.  When you make selections with the mouse or
type values into the Value Box, Superbase copies them into the Main Box,
building up the Filter Command Line.  In this way you get immediate
feedback about the results of your selections.  The maximum length of the
Filter Command Line is much greater than the apparent length of the box --
up to 255 characters are allowed.  You can type directly into the Main Box, 
but in these exercises we'll stick to making selections with the mouse.

USING THE OPERATORS

The Operators are the most complex aspect of the requester.  They are used
to relate field names to other fields or values.  For example, if we wanted 
to set up a Filter to show only the addresses in West Germany, we would need 
the expression:  Country LIKE "West Germany".  Here, Country is a field name 
obtained by clicking in the Field Name Panel; LIKE is selected by clicking on 
the LIKE Operator button; and "West Germany" is typed into the Value Box.

TEXT STRING AND PATTERN MATCHING:  LIKE

When you're searching for names or text strings, uyou should avoid using
the equals sign operator, and use LIKE instead.  This is because only LIKE
accepts matches on either upper or lower case characters; it's said to be
"case insensitive".  The equals sign operator, on the other hand, requires
exact matches for what you type in:  It is "case sensitive".

LIKE also permits searches for text strings that include pattern matching
characters.  these allow you to enter incomplete words for the Filter.  For 
example, to find all the records where the Lastname begins with "C" you need 
the Filter Command Line:  Lastname LIKE "C".  To specify a range add square 
brackets to the value:  Lastname LIKE"[A-D]*"; this finds all the records 
where the Lastname begins with "A", "B", "C", or "D".  Note that the Asterisk 
is placed outside the brackets.

There are several other things you can do with the LIKE operator.  You'll
find a complete list and a number of examples in Appendix B.

THE RELATIONAL OPERATORS

=	This specifies that the field is to be EXACTLY EQUAL TO the following 
	value or field:  Balance = 2000.

<>	The field is to be NOT EQUAL TO the following value or field: 
	Country <> "France".

>	The field is to be GREATER THAN the following value or field: 
	Balance > 1000.

<	The field is to be LESS THAN the following value or field: 
	Balance < 1000.

>=	The field is to be GREATER THAN OR EQUAL TO the following value 
	or field:  Balance >= 1000.

<=	The field is to be LESS THAN OR EQUAL TO the following value 
	or field:  Balance <= 1000.

THE LOGICAL OPERATORS AND, OR AND NOT

Thes provide links between different expressions like the ones given above. 
You use them to specify alternatives and ranges for the Filter, either for 
a single field or for a number of interrelated fields:

AND	Both of the conditions linked by AND must be satisfied for the 
	record to be accepted by the Filter:  Country "West Germany" 
	AND Balance >= 5000.

OR	Either of the conditions linked by OR is sufficient to make the 
	record aceptable to the Filter:  Country LIKE "West Germany" OR 
	City LIKE "Geneva".

NOT	NOT is slightly different.  It negates the effect of an expression:  
	NOT (Country LIKE "West Germany" AND Balance > 5000).  This will 
	find all the records other than the ones where the country is West 
	Germany and the balance is greater than 5000.  Note the use made 
	of Parentheses with NOT.

PARENTHESES

The ( and ) operators are used in the normal way, to give priority to one
part of the expression over another.

	(	The following expression has a higher priority for evaluation 
than the preceding expression.

	)	Required to end a higher priority expression.

The numbers of opening and closing parentheses must be equal.


THE MATHEMATICAL OPERATORS

	+	This is used to express addition:  Balance > Amount + 1000.

	-	The minus sign expresses subraction:  Balance >  Amount - 1000.

	*	The asterisk is used for multiplication: Balance > Amount * 
		1.15.

	/	The slash represents division:  Balance < Limit / 10.

TYPING IN THE MAIN BOX

The great power and flexibility of the Filter system is only achieved by
giving the user control of every aspect of the operation.  Because you type 
into the Main Box you include all kinds of expressions which are not
available from the buttons on the requester itself, and all kinds of text
and numeric values.

The price you pay for this flexibility is an increased risk of making
mistakes.  This is not too serious, as you cannot harm your data by using 
a Filter (although you can discard records using the Remove Records Filter). 
However, you may see a Superbase "Can't do this" message concerning an error 
in the Filter Command Line in two possible situations:

When you click an OK after creating or editing a Filter Command Line.

When you use a Filter after changing the definition of a field with Project 
Edit.

If you see a "Can't do this" message you must either change the Filter
Command Line or change the file definition.  Here's a summary of the
editing facilities available when typing inside the Main Box:

FILTER COMMAND LINE EDITING

You can remove everything from the Main Box by clicking on the Clear button.

If you have clicked in the box, hold down the right-hand Amiga Key (next to 
the space bar) and press X to delete its contents.  (Note:  we refer to this 
key combination as Amiga-X).

	Provided you have not left the box -- the cursor is still visible
-- Amiga-Q will restore the contents you deleted with the Amiga-X.  This
does not work after clicking on Clear.

	If Superbase won't let you make an Operator selection when you
return to modify an existing Filter Command Line, click in the Main Box and 
press Return.  Now you can go ahead.

	Shift key and cursor right arrow and shift key and cursor left
arrow move the cursor to the end and beginning of the Filter Command Line
respectively.

	The DEL key romoves the character to the left of the cursor.
Backspace repeats its action if held down.


USING A FILTER

The Filter Command Line is made active by clicking on OK.  Whenever a
Filter is in use, Superbase highlights the Flter button on the Control
Panel.  You can perform all but one of the Control Panel record selection
operations we've discussed, and Superbase will restrict the records
displayed to the ones that match the Filter values.  For example, if you
have specified the Country LIKE "West Germany" and you click on the First
Record button, Superbase will go and find the first record in the file,
according to the current index, which has the value "West Germany" in the
Country field.

The Key Lookup button is an exception to the filter effect.  You can still
recall individual records by entering an index key value, whether or not
they match the Filter.

SUSPENDING A FILTER

There wil be times when you want to remove the Filter effect so that you
can review all the records in the file again.  To do this, just click on
the highlighted Filter button.  It reverts to normal, and you'll find that
when you use the Control Panel Superbase acts as if there were no Filter.

MODIFYING OR RE-ACTIVIATING A FILTER

If you've set up a Filter and then suspended it, you can bring it back into 
operation by clicking once more on the Filter button.  Superbase displays the 
Filter requester, with the Filter Command Line in the Main Box just as you 
left it.

If you want to, you can add to the Filter Command Line by clicking on more
field names and oeprators (you may need to click in the Main Box and press
Return first), or edit it after clicking in the Main Box, as described
above.

Whether you've made any changes or not, just click on OK to use the Filter
again.

FIFTEEN MINUTE TUTORIAL

Make sure you've got the Addresses file open, indexed on Lastname.  Set
Table View with Paging off.  Go into Project Open Fields and open these
fields:

	Forename
	Lastname
	Street
	City
	Country

In Table View, drag the Lastname column a few columns to the left, and then 
do the same for City, overlapping the Street column if necessary, until the 
Country column comes into view.

Click on the Filter button.

We are going to search for those name and address records where the person
lives in the USA or West Germany.  So we'll use the Country field, and LIKE 
operator, and the Value Box.  You'll see the results of your selections 
appear as a Filter Command Line in the Main Box.

Move the pointer into the Field Names Panel, and click once on the down
arrow to bring Country into view.  Then click on Country.  The name appears 
in the Main Box.  Next, move the pointer to the right and click on the LIKE 
button.  This also appears in the Main Box.  Now you must type in "USA". 
This goes in the Value Box.  Move the pointer into the Value Box and click 
on the mouse to produce the cursor.  Type in "USA" (no quotation marks). 
Press Return -- this is essential, or the contents of the Value Box will not 
be copied into the Main Box.  Your Filter Command Line should read:

Country LIKE "USA"

Next, you need the OR operator.  Click on it and Superbase copies it into
the Main Box.  Now you must click on the Country field name again.  This is 
important.  A Filter Command Line like this is not allowed:

Country LIKE "USA" OR "West Germany"

So, click on Country, as before, followed by LIKE.  Then, as before, click
in the Value Box, and type in "West Germany".  Press Return.  Your Filter
Command Line should look like this:

Country LIKE "USA" OR Country LIKE "West Germany"

If there are any mistakes click on Clear and repeat the steps above until
you get it right.

You have built your Filter Command Line, so now you can put it into action. 
Click on the OK button.  Superbase activates your Filter and displays the 
first record in the file that matches the Filter.  Click on Fast Forward. 
Superbase shows all the records that match the Filter.

Now de-activate the Filter.  Click on the Filter button so that it's not
highlighted.  Now click on Rewind.  You'll see all the records in the file
appear as normal.

Let's go back and add another condition.  Click on the Filter button to
recall the requester.  Click on the OR operator, then on Country, then on
LIKE, then in the Value Box, type in "France", and press Return.  Your line 
should read:

Country LIKE "USA" OR Country LIKE "West Germany" OR Country LIKE
"France".

Now click on OK and when Superbase shows the first record, click on Fast
Forward.  You will see that Superbase has added the addresses in France to
the display.

That concludes our short tutorial.

OTHER FILTER BASED OPTIONS

You should have acquired a feel for the way the Filter requester works,
and you can experiment freely with the Addresses file to deepen your
knowledge.  When you're ready, you can start using the Process options, 
all of which are selected from the Process menu.

SUPERBASE PROFESSIONAL DATABASE MANAGEMENT LANGUAGE USER GUIDE

BEFORE YOU BEGIN...

This Volume presents you with two user guids, one for Superbase's Database
Management Language(DML)and one for the Forms Editor. Although they are both 
under the same cover, they can be treated as separate manuals. Each has its 
own Contents, Index, chapter numbers and page numbers.
Note that the Forms Editor is a separate program from Superbase Professional.
You will find instructions on how to install and load it on your computer in
the Readme document which is supplied on the demonstration file disk. If you
haven't done so already, you should read this document now. It also provides
details of any features of Superbase Professional that are not covered in
either Volume 1 or 2.

		     CHAPTER 1 - INTRODUCTION TO DML

Welcome to Superbase Professional's Database Management Language(DML). DML is
based on the programming language Basic. It includes most of the standard 
Basic commands and functions, but supplements them with a large number of 
commands and functions that are specific to database management.
The database commands duplicate the controls that Superbase Professional
provides through its menus and dialogs. This means that almost all of
Superbase's file and record handling facilities are available under program
control. In fact, apart from Fast Forwards, Rewind and Duplicate, you can now
carry out any Superbase operation using a single program command.
Once you have familiarized yourself with Superbase's controls,the corresponding 
program, you may find the idea of learning a program language daunting. But as 
far as DML is concerned, a little goes long way,and you do not need to be fully 
conversant with the language in order to take advantage of it. In effect, you 
are already following a program sequence every time you perform a task which 
involves a series of menu operations. Writing a program that performs the 
task for you is simply a matter of entering commands in the same sequence. 
Generally, you will be able to find a single command to duplicate each of 
the menu operations.
As you acquire more expertise, you can move on, building bigger and more 
complex programs by combining routines, until you have fully automated your 
database system. When you're ready, you can incorporate Superbase forms into 
your programs, taking advantage of their built-in facilities for generating 
and retrieving records in several files at once.
At the highest level, you can specify your own pull-down menus, replacing the
standard Superbase menus with the options that are relevant to the job in hand. 
And you can customize your application to an even more detailed level by 
creating your own pop-up selection panels to guide the user's choices.

USING THIS GUIDE
Before reading this guide, you will need to be familiar with Superbase's menu
and keyboard controls. Many of DML's commands provide a program equivalent of 
a menu or keyboard option, and the descriptions given here presume that you
already know how to use the corresponding option. However, once you have 
mastered Superbase itself, you do not need to read this book all the way 
through. As a reference guide, it can be consulted as and when it is needed.

			CHAPTER 2 - OVERVIEW

OPERATING MODES
DML has two modes of operation:direct mode and program mode.

DIRECT MODE
In this mode, DML executes instructions as soon as you have typed them in. 
First you need to select the Command option from the Program Menu. Then enter 
your instructions - a single command or a line of commands separated by colons 
- in the command line window;when you select 'OK' or press the Return key, DML 
will carry out the instructions straight away. The command line window is 64 
characters long but you can enter up to 255 characters and move within the 
window using the cursor keys.

PROGRAM MODE
In program mode, DML does not execute commands as you enter them. Instead they 
are stored in memory and executed only when the program is run. The main
difference between this mode and direct mode is that with the latter you can
only enter and execute one line at time;program mode allows you to enter a
series of instruction lines which are carried out in sequence. Program lines
can be up to 255 characters long.

OTHER DML APPLICATIONS
DML's functions, along with its operators and variables, can also be used in
other Superbase operations - such as field definition validations and
calculations, filter conditions, update commands and query derived field
definitions.

KEYWORDS AND RESERVED WORDS
Any word that DML recognises as a specific instruction, or part of an
instruction, is known as a keyword. A keyword cannot be used as a 
variable name,  a field name,  or a label. In this context, keywords 
are also knows as reserved words - DML reserves them for its own use, 
and will interpret then as such even if they are in lower case. A 
reserved word can, however, from part of a name. For example,  you 
can incorporate the reserved word TO in any of the following ways:
TOP:		(in a label)
TOTAL%		(a numeric variable)
tot$		(in a string variable)
TOTALS$		(in a field name)

But you cannot use it like this:
TO:
TO%
TO$

COMMANDS AND STATEMENTS
Some programming manuals make a strict division between two kinds of 
executable instructions - commands and statements. Commands are those 
instructions which are generally executed in direct mode, while statements 
are instructions that can only appear in a program line.
In DML there are only a few instructions that cannot be used in both 
operating modes and so the two terms are used almost interchangeably. 
Thus we refer to a line with more than one instuction on it as a multi-
statement line; but it could equally well be called a multi-command line.

VARIABLES
There are three types of variables in DML:string ve menu(or menus)on. You 
also use MENU to specify a numeric variable which will return a value showing 
which item, if any, has been selected. Column must be a numeric expression 
with a value in the range 1 to 10 giving the column number for the menu. To 
set up a menu in the first column on the left at the same position as the 
Superbase Project menu, you would enter a value of one. item must be a 
numeric expression with a value in the range 0 to 12, giving the number of 
the menu item. Item 0 is the menu heading, the text that appears on the menu 
bar. State can take a value of 0, 1 or 2.0 disables the item so that it appears
on the menu as a ghosted option.1 enables it, 2 places a check mark against it.
strexpr supplies the text for the item. For example, if you wished to define a 
menu in the first column which contained the option Deposits, you could enter:
	MENU 1, 3, 1, "Deposits"
This would make Deposits the third item in the menu list. To disable the
Deposits option, you would enter:
	MENU 1, 3, 0
Note that you do not need to specify the text a second time.

EXAMPLES
1	MENU 1, 0, 1, "Transactions"
	MENU 1, 1, 1, "Deposits"
	MENU 1, 2, 1, "Withdrawal"
	MENU 1, 3, 1, "Direct debit"
	MENU 1, 4, 1, "Standing orders"
	MENU 1, 5, 1, "Credit card"
	MENU ON a%, b%

NOTES
This example defines a menu in the first column with five options(items), all 
of them enabled.(The heading for the menu is Transactions.) MENU ON then 
turns the menu on. When the user selects an item, Superbase will place 
its column and item numbers in the variables a% and b%.

MENU CLEAR
PURPOSE
Turns off all user-defined menus and clears their definitions from memory.

SYNTAX
MEMORY CLEAR

COMMENTS
If you want to define a new set of menus, you can use this command to clear 
any menus which have been defined previously. You may also use it when your 
menus are no longer required, in order to make the memory space they occupy 
available for other purposes.

MENU ON
PURPOSE
Turns user-defined menus on and specifies the variables which return the 
    result of efault 
    New Line sequence is CHR$(13) CHR$(10) (carriage return,  line 
    feed). The CHR$(13) may be suppressed,  for example to achieve 
    compatibility with the ED editor,  by setting RETURN=OFF in 
    the Tool Types list of the Superbase icon,  which may be 
    modified using the Workbench Info option.

*   GET and WAIT (1). Control characters can be returned in GET 
    and WAIT statements. If these are saved in a file which is 
    subsequently LISTed,  they will generate the "File contains 
    non-text characters" error. Note also that CONTROL-C,  the 
    standard interrupt key,  does not stop program execution if 
    returned in GET or WAIT. It is up to the program to detect 
    the value and act appropriately.

*   GET and WAIT (2). WAIT makes the window active before it 
    starts waiting for input,  so if the window becomes inactive 
    for any reason you cannot reactivate it. If this is a problem 
    for your application,  use GET instead; however,  you will not 
    be able to input into any other window,  such as a CLI window,  
    because GET continually reactivates the Superbase window.

*   The CLEAR statement must be placed last on a program line.

*   You may want to convert Superbase text files (`.sbt' files) 
    to ASCII files. The technique for doing this is:

     1. Rename the `.sbt' file,  giving it a different extension. 
        E.g.,  rename `Merge.sbt' as `Merge.asc'.  
     
     2. Load the file into the Text Editor. Its name will not 
        appear in the list peration.
Although Merge is the program equivalent of the Mail Merge option on the
Process menu, it does not allow you to preview letters on screen before 
printing them. To do this, use ? TEXT with the MERGE parameter.

EXAMPLES
1	OPEN FILE "Address"
	MERGE TEXT "Mailshot1" WHERE Country LIKE "USA"

MID$
PURPOSE
Returns one or more characters from within a text string or text field.

SYNTAX
MID$(strexpr, nexpr1[, nexpr2])

COMMENTS
MID$ is more flexible than LEFT$ and RIGHT$ as it can extract characters from
any point in a string.strexpr holds the string, and nexpr1 gives the starting
point in the string.nexpr2 specifies the length of the substring to be
extracted; if nexpr2 is not given, MID$ takes all the characters from the
starting point to the end.

EXAMPLES
1	textfieldc=MID$(textfielda, 10, 10)
2	textfieldc=LCASE$(MID$(textfielda, 8))
3	MID$(textfielda, 12, 1)LIKE[a-c]
4	x$-MID$(textfieldc, 19, 2)
5	x$=(x$, 4)
6	? MID$(x$, 4, 2)
7	ASK;A$:
	I%=LEN(A$)
	FOR n%=I% TO 1 STEP -1
	B$=B$ + MID$(A$, n%, 1)
	NEXT
	? B$

NOTES
Example 7 inputs a word into A$ and turns it back to front.

MINS
PURPOSE
Extracts the number of minutes from a numeric value which holds the time in
thousandths of a second.

SYNTAX
MINS(nexpr)

COMMENTS
Usually, nexpr will be a timefield or the result of a TIMEVAL calculation.

EXAMPLES
1	mnts%=MINS(timefield)
2	? MINS(NOW - start%);"minutes have elapsed"

MOD
PURPOSE
Gives the remainder of a numeric expression after it has been divided.

SYNTAX
nexpr1 MOD nexpr2

COMMENTS
nexpr1 is the number to be divided, nexpr2 is the number that divides into it
(the divisor). MOD returns the remainder when nexpr1 has been divided by
nexpr2. For example:
	14 MOD 3
gives 2 as a result. It is equivalent to:
	14-INT(14/3) * 3

EXAMPLES
1	?(2.53 * 100) MOD 100

NOTES
The example line strips off the integer part of a number and displays the 
first two figures after the decimal place.

MODIFY
PURPOSE
Modifies a field definition.

SYNTAX
MODIFY field[, ] [field definition string] [, formula] [, formula]

COMMENTS
MODIFY is the program equivalent of the EDIT FILE option in PROJECT. It 
allows you to alter a field's parameters;for example, the field name or 
its length.
The field definition and formula strings take the same form as they do with 
the ADD command.

EXAMPLES
1	MODIFY Forename "Firstname;TXT REQ IXU;15 U;1, 12"

MONTH$
PURPOSE
Takes a julian date number and returns the month of the year as a text string.

SYNTAX
MONTH$(nexpr)

COMMENTS
The same limitations on which julian dates are acceptable apply to this
function as they do to other date functions.
The format of the text string is the full month name regardless of what 
current date format is - i.e., January, not Jan).
Associated date functions are DAY DAYS DAY$ MONTH MONTH$ YEAR.

EXAMPLES
1	textfieldc=MONTHS$(datefielda)
2	textfieldc=MONTH$(datefielda + 90)
3	textfieldc=MONTH$(TODAY)
4	x$=MONTH$(datefielda + VAL(textfielda))
5	x$=MONTH$(DAYS ("11 Jan 85")
6	? MONTH$(datefielda + 30)

NEW
PURPOSE
Clears the program area or text area.

SYNTAX
NEW [TEXT/QUERY/UPDATE]

COMMENTS
On its own, NEW erases any program that is currently in the computer's memory.
When followed by TEXT, it clears the current text editor area of memory.
Following it by or QUERY or UPDATE, clears their respective dialogs.
Unlike the menu options Program New(and Text New)this command does not put you 
into the program(or text)editor.

NEWLINE
PURPOSE
Sends a new line character(or characters)to an output device.

SYNTAX
NEWLINE[nexp]

COMMENTS
This command prints a new line at the current output device;i.e. with the
screen display, it takes the cursor onto the start of the next line.nexp 
can be used to specify more than one new line.
If nexp is not an integer, only the integer part will be taken.

EXAMPLES
1	NEWLINE 2
2	FOR i%=1 to 20
	? i%:if i% MOD 5=0 THEN NEWLINE i%/5
	NEXT i%

NOTES
Example 2 outputs the numbers 1 to 5 with single line spacing, 6 to 10 with
double spacing, and so on up to 20.

NOW
PURPOSE
Gives the system time.

SYNTAX
NOW

COMMENTS
NOW shows the time of day in hours and minutes, using the current time format.
If you have a real-time clock in your computer or you have set the system time,
this will be the current time.
Note that NOW actually holds the time in thousandths of a second. When you
display the time, Superbase automatically translates it into hours and minutes.

EXAMPLES
1	? NOW
2	? MINS(NOW)
3	timefield=NOW

NUMBASE
PURPOSE
Sets the numeric format in which numbers are displayed.

SYNTAX
NUMBASE string

COMMENTS
NUMBASE is the program equivalent of the Number Format option in the SET menu.
string must be one of Superbase's valid numeric formats, as listed Chapter 2, 
Volume 1. For example, "z99999.00" or "z(+$, 000000.00".

EXAMPLES
1	NUMBASE "z99999."
Integer only format.
2	NUMBASE "+*****.00"
Numbers displayed with a sign and leading cheque-protect.

ON ERROR
PURPOSE
Tells DML to branch to another part of the program when an error occurs.

SYNTAX 
ON ERROR [[GOTO]label]

COMMENTS
Normally, DML halts program execution and displays an error message when it
detects an error. ON ERROR enables error trapping, and prevents the program 
from halting. Once an error has been detected, it causes the program to jump 
to the error handling routine specified with label.
You can use ERRNO in your error handling routine to check on which error has
occurred, and take appropriate action. In many cases, you will want the program
to resume execution after detecting an error. You can do this with the RESUME 
statement.

To disable error trapping, use ON ERROR without a following label.

EXAMPLES
1	ON ERROR GOTO check
	......
	......
	......
	check:IF ERRNO 11 THEN
	RESUME
	ELSE? "Are you sure you want to exit from this program?"
	? "Press Y to exit, any another key to resume"
	WAIT a$
	IF a$="Y" OR a$="y" THEN END ELSE RESUME
	ENDIF

NOTES
In this example, ON ERROR is used to check whether the Stop button has been
clicked on or CTRL C has been pressed. Both these events generate error number 
11, so the error handling routine(which starts at label 'check')first tests 
for this error number. If it finds that another error event has occurred, 
program execution is resumed at the line which caused the error. The error 
handling routine then asks if the user wishes to exit or not. Depending on 
the answer it receives, it either resumes execution at the line which caused 
the error (the line being executed when the user pressed STOP or CTRL C)or 
terminates the program.

ON GOSUB
PURPOSE
Calls one of a number of subroutines from a list of subroutines.

SYNTAX
ON nexp GOSUB label1 [, label2, label3, ...]

COMMENTS
This statement transfers program control to one of the subroutines given 
in the list. The value of nexp determines which subroutine the program 
jumps to. If nexp has valued at 1 the program branches to the subroutine 
at the first label, if nexp has a value of 2, it branches to the subroutine 
at the second label, and so on.
Once the program has branched to a subroutine, it executes each statement in
turn until it meets a RETURN statement. Then it jumps back to the line
following the ON GOSUB statement.
Any label can be repeated.
If nexp is 0 or greater than the number of supplied labels, program control
drops to the next statement after the ON GOSUB statement.

EXAMPLES
1	ON x% GOSUB lab1, lab2, lab3
2	ON x% GOSUB lab1, lab2, lab1, lab2, lab1

ON GOTO
PURPOSE
Branches to one of a list of labels.

SYNTAX
ON nexp GOTO label [, label, ....]

COMMENTS
This command transfers program control to one of the program lines given in the 
list. The value of nexp determines which label the program jumps to.
If nexp has valued at 1 the program branches to the first label, if nexp has a 
value of 2, it branches to the second label, and so on. For a general 
description of GOTO refer to GOTO itself.
nexp should be a positive integer. If it is not an integer, the whole number
part will be taken.
Any label can be repeated.
If nexp is 0 or greater than the number of supplied labels, program control
drops to the next statement after ON GOTO.

EXAMPLES
1	ON x% GOTO lab1, lab2, lab3
2	ON x% GOTO lab1, lab2, lab1, lab2, lab1
	? "Reached here only when x% is 0 or greater than 5

OPEN
PURPOSE
Opens a text file on disk or Comms channel for input/output.

SYNTAX
OPEN filename FOR[INPUT/OUTPUT/APPEND]

COMMENTS
When used for output to a file, OPEN has the same effect as OUTPUT TO file.
There is only one channel for INPUT, and one for OUTPUT, so you cannot have 
two output channels, or two input channels. However, you can have one of each 
open at the same time.
APPEND is an output channel and specifies that file is to be appended to. You
must not try to specify OPEN "aaa" FOR OUTPUT APPEND.
If using OPEN, file is overwritten without warning.
If using APPEND, file need not exist.
If using INPUT, file must exist.

EXAMPLES
1	OPEN "aaa" FOR OUTPUT
2	OPEN "aaa" FOR APPEND
3	OPEN "bbb" FOR INPUT:OPEN "aaa" APPEND
	lab1:INPUT LINE a$:? a$
	IF NOT EOF ("*")THEN GOTO lab1
	CLOSE INPUT:CLOSE OUTPUT

NOTES
Example 3 appends the contents of file 'bbb' to file 'aaa'. Notice that the
last line of the program CLOSEs the files that OPEN has opened. This practise
is strongly recommended:you should always close a file when you have finished
writing to it.

OPEN FORM
PURPOSE
Loads a form from disk and displays it in the database window.

SYNTAX
OPEN FORM form

COMMENTS
form must be a string expression giving the file name of a form. Superbase 
will also open any database files associated with the form.

EXAMPLES
1	OPEN FORM "Invoice"

OPEN FIELDS
PURPOSE
Specifies which fields are displayed.

SYNTAX
OPEN FIELDS [FILE sbfname] fieldlist
COMMENTS
This command is the program equivalent of the Open Fields option on the Project
Menu. fieldlist consists of the list of fields required to be open. To remove 
any restrictions on which fields are shown, use the CLOSE FIELDS command.

EXAMPLES
1	OPEN FIELDS FILE "Address" Firstname, Lastname, Country, City

OPEN FILE
PURPOSE
Opens a database file and its default index.

SYNTAX
OPEN FILE sbfname [;password]

COMMENTS
Note the distinction between OPEN FILE "aaa" which opens a database file, and
OPEN "aaa"(FOR INPUT)which opens a text file.
sbfname is compulsory, and if a password is required to access the file, then 
it is also compulsory (use a semicolon to separate the filename from the 
password).
INDEX followed by a field name may be added to the end of an OPEN FILE command,
allowing you to select an index other than the default index. But it can only 
be used if the file has already been opened by a direct command or an earlier 
program line. As explained in the entry for the INDEX command, DML parses the 
whole line before executing it;so if you refer to a field, it must be a field 
in a file that already been opened. Otherwise an error will result.

EXAMPLES
1	OPEN FILE "aaa"
2	x$="bbb":OPEN FILE x$
3 	OPEN FILE "aaa";"John"

NOTES
In example 3, 'John' is the password for the file 'aaa'.

ORDER
PURPOSE
Sets the order for Query output.

SYNTAX
ORDER [&nexpr]field[ASCENDING/DESCENDING] [, field]
                ASCENDING/DESCENDING] [, .....]

COMMENTS
ORDER is a Query Language command and can only be entered in a query section 
-i.e., it works in conjunction with the Query Language command Select.
This command is the program equivalent of the Order command line in the query
definition dialog: it takes the same syntax and serves the same purpose. The
field specified with the ORDER command determines the order in which the field 
in the SELECT line are output. If you are familiar with the concept of sorting,
you can think of ORDER as setting the sort 'key' for query output.
field must be a field in an open file, but it does not need to be an indexed
field; nor does it have to be one of the fields in the SELECT line.
ASCENDING and DESCENDING allow you to specify whether data is sorted in
ascending or descending order. If you specify a text field with the ORDER
command - i.e., if you specify it as the sort key-Supervase outputs record data
according to the alphabetical order of the sort field. DESCENDING reverses the 
order and sorts the field from Z to A.
With numeric, date and time fields, ASCENDING sorts data in numeric, date or 
time order; and DESCENDING reverses the order.
By default, fields are sorted in ascending order;so it not strickly necessary 
to include the ASCENDING parameter.
You can also specify more than one field in the ORDER line, separating each 
with a comma. If enter two fields, the first field takes precedence as a sort 
key over the second field; i.e., records are first sorted according to the 
first field, and then any duplicate data items are sorted according to the 
second key.
The same applies if there are more than two fields:the second key has priority 
over the third, the third has over the fourth, and so on.

EXAMPLES
The examples illustrate how ORDER works by taking a limited set of records and 
showing some of the different ways in which they may be sorted. Each record 
contains data from three fields, Firstname, Lastname, and Country.

1	SELECT Firstname, Lastname, Country
	ORDER Lastname
This examples takes Lastname as the sort key and produces the following output:

FIRSTNAME		LASTNAME		COUNTRY
Pierre			Arnauld			France
William			Carter			USA
Gerde			Hemrich			West Germany
John			Miles			England
Anne			Richardson		USA
Peter			Smith			England
Robert			Brown			England

2	SELECT Firstname, Lastname, Country
	ORDER Country
The output from this query would be as follows:

FIRSTNAME		LASTNAME		COUNTRY
Robert			Brown			England
John			Miles			England
Peter			Smith			England
Pierre			Arnauld			France
William			Carter			USA
Anne			Richardson		USA
Gerde			Hemrich			West Germany

					5-107

3	SELECT Firstname, Lastname
	ORDER Country DESCENDING, Lastname ASCENDING
The output from this query is:

FIRSTNAME		LASTNAME
Gerde			Hemrich
William			Carter
Anne			Richardson
Pierre			Arnauld
Robert			Brown
John			Miles
Peter			Smith

4	SELECT Firstname, Lastname, Country
	ORDER Country, Firstname
This example uses Country as the primary sort key and Firstname as the
secondary key to produce the following output:

FIRSTNAME		LASTNAME		COUNTRY
John			Miles			England
Peter			Smith			England
Robert			Brown			England
Pierre			Arnauld			France
Anne			Richardson		USA
William			Carter			USA
Gerde			Hemrich			West Germany

NOTES
The default length for sorting is 15 characters per field. Superbase gives
equal weighting to upper case, lower case and accented instances of characters.
The & character followed by a value up to the length of the field may precede
any field, specifying the number of characters that will be used in sorting.

OUTPUT TO
PURPOSE
Opens a text file on disk for output.

SYNTAX
OUTPUT TO filename

COMMENTS
This command makes the disk the current output device and sends any future
output to filename. It has the same effect as OPEN filename FOR OUTPUT.
If the text file already exists on disk, any output command issued after 
OUTPUT TO, will overwrite the file. If you want to add data to an existing 
text file, use OPEN filename FOR APPEND.

EXAMPLES
1	OUTPUT TO "Names"
	? Lastname
	CLOSE OUTPUT
2	OUTPUT TO a$

NOTES Example 1 stores the contents of the Lastname field(in the current
record)on disk in the text file Names.

PASSWORD
PURPOSE
Sets new password(or none)for a specified file.

SYNTAX
PASSWORD sbfname [;passwords]

COMMENTS
sbfname must be an open file and, as usual with filenames, must be included 
in quotation marks.
If no password is given, the existing password for the specified file is
removed.

EXAMPLES
1	OPEN FILE "aaa;John"
	PASSWORD "aaa"
Removes passwords.
2	PASSWORD "aaa;Rosebud"
Sets a password for the file 'aaa'.
3	OPEN FILE "aaa;John"
	PASSWORD "aaa;John;Paul;George"
Adds passwords for read/write and read only access privileges.

PCOL
PURPOSE
Return the column position of the print head on the current output printer or
resets the print head's position.

SYNTAX
PCOL(nexpr)

COMMENTS
If nexpr is zero, the function returns the column position of the print head
on the current printer. For the Row position, see PROW. See also LOCATE.
You can also use this function to set the counter Superbase uses to keep track
of the print head's position. Giving nexpr a positive value, sets the counter 
to that value. The print head itself is not moved. This feature is used to 
reset the internal count after issuing a series of printer commands which have 
not in fact moved the print head, for example, after switching to high density 
graphics mode.

EXAMPLES
1	x%=PCOL(0)
2	? PCOL(0)

POSITION
PURPOSE
Sets the data pointer to a new position in an ASCII file.

SYNTAX
POSITION nexp

COMMENTS
When you read data from an ASCII file on disk, Superbase uses an internal
pointer to keep track of it. The OPEN file FOR INPUT command sets the pointer
to zero, the position of the first character in the file. Thereafter it is
incremented by one for each character that is input using the INPUT command.
POSITION sets the pointer to the character position specified by nexpr.
Normally, the data in an ASCII file is read into the computer sequentially. 
With Position, you can input character data on a more selective basis.
You will only be able to take advantage of this command if you know where the
data is stored in a file. Superbase stores data in variable length fields(as
opposed to fixed length fields):when you create an ASCII file from an '.sbf'
file by exporting it, the amount of space occupied on disk by field data may
vary from record to record. This means that there is no simple way of knowing
the position of any particular field or record.
One solution to this problem is to create an ASCII file from a database file
using the query option Output to Disk. When you do this, Superbase stores
the data in fixed length fields-each field takes the length set in the file
definition. You can then work out the number of characters occupied by a 
record in the ASCII and use this figure to retrieve specific records or fields.
For example, if the record length was 49 characters, you would enter:
	POSITION 49 * 5 + 1:INPUT LINE a$
to retrieve the fifth record in the file(you need to add one because the first 
character position is zero).

EXAMPLES
1	OPEN "Cust.asc" FOR INPUT
	FOR n%=0 to 76 * 12 STEP 77
	POSITION n%
	INPUT & 15, a$
	? a$
	NEXT
	CLOSE INPUT

NOTES
This example inputs the first field from the first twelve records in the 
ASCII file Cust.asc. It assumes that the record length is 77 characters 
and that the length of the first field is 15 characters.

PRINT
PURPOSE
Sends information to the printer.

SYNTAX
PRINT[expressionlist]

COMMENT
PRINT, followed by a semicolon and nothing else, selects the printer as the
current output device. The ? command can then be used to send information to
the printer. You can also use PRINT to output information directly to the
printer, by following the command with one or more expressions. But note that
any use of PRINT makes the printer the current output device.
The items in the expression list following the Print command may be separated
by a semicolon or a comma. If a semicolon is used, Superbase will print the
expressions one after the another without any spaces in between; a comma has 
the effect of inserting a space between items. In some circumstances, you may 
also dispense with separators altogether. Thus, provided it can distinguish 
between different items, Superbase will accept a list of expressions which 
are entered on the line head to tail; for example:
	PRINT a$b$c%"Hello"

EXAMPLES
1	PRINT;
	? MEMORY
	DISPLAY;
2	PRINT BF "The items in the following list will be printed in bold face"
	PRINT "One", "Two", "Three";CHR$(12)
	DISPLAY;

NOTES
The first example prints the current program's variables and their contents.
Example 2 prints a list of items, and then sends the form feed character -
CHR$(12)-to the printer. Both examples use the DISPLAY command to make the
screen the current output device after the print operation is finished.

PROTECT
PURPOSE
Saves the current program in an encrypted form.

SYNTAX
PROTECT filename

COMMENTS
Use this command to ensure that program files are not seen by anyone else. It
stores a file on disk in an encrypted(scrambled)form so that it can be run but 
not edited.
If the first line of a program is a REM statement, PROTECT displays that line, 
but hides the rest of the program from any attempt to edit or LIST it.

EXAMPLES
1	PROTECT "myprog"

PROW
PURPOSE
Returns the row position of the print head on the current output printer.

SYNTAX
PROW(nexpr)

COMMENTS
If nexpr is zero, the function returns the row position of the print head on 
the current printer. For the Column position, see PCOL. See also LOCATE.
Giving nexpr a positive value resets Superbase's internal row counter. See
PCOL.

EXAMPLES
1	x%=PROW(0)
2	? PROW(0)

QUIT
PURPOSE
Exits from Superbase.

SYNTAX
QUIT

COMMENTS
This has same effect as selecting the Quit option from the Project menu. It
exits from Superbase and returns the user to the desktop interface.

READ
PURPOSE
Reads the data given in a DATA statement and assigns it to a variable or field.

SYNTAX
READ var/field[, var/field] [, .....]

COMMENT
The types of variables or fields used with a READ command must match the 
types of data expected-numeric variables or numeric fields for numeric data 
and string variables or string fields for string data.
DML uses a pointer to keep track of where it is in the list of DATA items; 
that is, each time a data item is read, DML moves the pointer on to the next 
item in the list. If you wish to read the same data again, you can place a 
label in front of a DATA statement and use RESTORE.

EXAMPLES
1	READ a%, b$, fielda.filea, fielda.fileb

RECCOUNT
PURPOSE
Counts the number of records in a file.

SYNTAX
RECCOUNT(sbfname)

COMMENTS
This function returns a number showing how many records there are in the file
specified. You can use the empty string as an argument-RECCOUNT("")-to refer to
the current file.

EXAMPLES
1	? RECCOUNT("Orders")

				5-116

2	x%=RECCOUNT(x$)
3	OPEN FILE("address")
	SELECT FIRST
	FOR n%=1 to RECCOUNT("address")
	VIEW
	SELECT NEXT
	NEXT n%

NOTES
Example 3 displays all the records in the file "address" in turn.

REM
PURPOSE
Inserts a non-executable comment(a remark)into a program.

SYNTAX
REM[text]

COMMENTS
REM has the effect of cancelling any statements after it. This makes it useful 
when you are testing a program-placing it at the start of a multi-statement line
puts the following statements temporarily out of action. More generally,use 
REM to annotate a program in order to explain how it works or what it does.
A single quotation mark after a command without an intervening colon also acts 
as a REM statement.

EXAMPLES
1	REM this is a remark
2	....:FILE "aaa" open aaa
3	....:FILE "aaa":REM open aaa
4	FILE "aaa":REM eliminate next commands:INDEX abc:SELECT 
	FIRST


NOTES
Examples 2 and 3 have identical effects and demonstrate the two different 
ways of entering a comment. In example 4, the REM statement means that the 
INDEX and SELECT FIRST commands are not executed.

REMOVE FILE
PURPOSE
Removes a database file from disk, along with its associated definition and
index files.

SYNTAX
REMOVE sbfname

COMMENT
This command operates in the same way as the Remove File menu option.
Note that you are not asked for confirmation-the file is just removed.

EXAMPLES
1	REMOVE FILE "aaa"
2	REMOVE FILE "DF1:aaa"
3	REMOVE FILE "GEM\SBASE\aaa"

REMOVE FROM
PURPOSE
Removes records which match the conditions specified.

SYNTAX
REMOVE FROM FILE sbfname[WHERE conditions]

COMMENTS
This command works in the same way as the equivalent PROJECT-REMOVE-FILE menu
option. It deletes records from a file on disk.
FILE sbfname has to be open, and if  the  file requires a password, you must 
have  full access to it.
WHERE conditions is optional and is set up in the same way as a filter. If it
is not included, the command acts on all the records in a file.

EXAMPLES
1	REMOVE FROM FILE "aaa" WHERE Lastname LIKE "[a-c]*"
2	REMOVE FROM FILE "aaa"
This empties the file of all its data.

REMOVE INDEX
PURPOSE
Removes an index on the current file from disk.

SYNTAX
REMOVE INDEX index

COMMENT
This command works in the same way as the Remove Index option on the Project
menu. The file must be open, and, if it requires a password, you must have full
access privileges.
index is the name of an indexed field. It can be entered with a file extention.

EXAMPLES
1    REMOVE fielda
2    REMOVE fieldb.aaa

RENAME
PURPOSE
Renames a file on disk.

SYNTAX
RENAME old.filename[, /TO]new.filename

COMMENT
This command works in the same way as the RENAME command in MS DOS or Amiga
DOS, but allows you to rename a file without exiting from Superbase. You have
the option of using either a comma or the keyword TO as the separator between
the two file names.

EXAMPLES
1    RENAME "aaa", "bbb"
2    RENAME "aaa" TO "bbb"

REORGANIZE
PURPOSE
Reorganizes the current file or a specified file.

SYNTAX
REORGANIZE [FILE sbfname] [TO]sbfnameb

COMMENTS
This command is the program equivalent of the Reorganize option on the System
menu(see Chapter 8, Volume 1). It takes a file on disk, reorganizes it, and 
stores it as sbfnameb.IF the FILE option is not used, the current file is 
reorganized.
sbfnameb can include the pathname for another directory or disk. If you enter a 
pathname without a file name following it,the file will be reorganized under the 
same name.
Note that you cannot reorganize a file under the same name in the same
directory;i.e. if a pathname is not supplied, sbfnameb must not be the same as 
sbfnamea.

EXAMPLES
1    FILE "aaa":REORGANIZE TO "copy"
2    REORGANIZE "aaa" TO "a:mydir\"
3    REORGANIZE "aaa" TO "DF1:Mydir/"
Example 1 creates a reorganized file  'copy' in the current directory, Example 2
creates a reorganized file 'aaa' in directory  mydir  on the disk in drive a (or, 
in example 3, drive DF1 on the Amiga).

REPLICATE
PURPOSE
Replicates a character a given number of times.

SYNTAX
REPLICATE(strexp, nexp)

COMMENTS
REPLICATE repeats the character in strexpr the number of times given in nexp.

EXAMPLES
1    textfieldc=REPLICATE("*", 10)
2    x$=REPLICATE(textfieldc, 4)
3    x$=REPLICATE(MID$(x$, 4, 2), 6)
4    x$=REPLICATE (" ", 25)

NOTES
Example 4 fills x$ with 25 spaces, but see function SPACE$.

REPORT
PURPOSE
Specifies the field or fields on  which totals(and other report statistics) will 
be produced for the report as a whole.

SYNTAX
REPORT [SUMMARIZE] [params]fieldname[, fieldname][, ....]

COMMENT
Report has two uses. When you create a Report with the Forms Editor, Superbase 
generates a Report statement by noting the fields which have been specified in 
an AFTER REPORT section;i.e., if the AFTER REPORT section in a Report program 
contains the statements:
     ? SUM amount
     ? COUNT deposits
Superbase will generate the following line in the program:
     REPORT amount, deposits
If you are writing a Report program yourself (as opposed to modifying a program 
generated by  Superbase), you should remember to enter a Report statement 
including the names of any fields for which you wish totals and other report 
statistics to appear.
The second application for REPORT is a query language command. In this context, 
it allows you to create a program line which is equivalent to the REPORT command 
line in the query definition dialog.
REPORT is used here to specify the fields for which totals and other
statistical.
When you use the SUMMARIZE option,  Superbase  suppresses  the main detail of the 
report and prints just the summary information.

REQUEST
PURPOSE
Displays a Superbase dialog.

SYNTAX
REQUEST text1, text2, type[, nvar[, strvar[, len]]]

COMMENT
REQUEST allows you to select one of Superbase's dialogs and display it on
screen. To some extent you can also customise a dialog to your own
requirements. Thus you can place a title in box, and you can specify the text
string that initially appears in the dialog's command line or selection box.
For certain dialogs, it also possible to specify the length of the box.
text 1 and text2 are the first and second line of the dialog title. They must
be included although they can be "". The maximum length for each line is 50
characters.
type is the dialog type. It defines the type of dialog according to the table
shown below.
nvar is a numeric variable. It returns a value of 1 if OK is selected and there 
is an entry into the string dialog. If CANCEL is selected or there is no entry 
into the string dialog, it returns 0.
strvar can be used with dialogs which have a string entry box and has two
functions:
It is used to place a default value into the string box, i.e.,the text string in 
strvar is entered into the string box when the dialog is displayed.
It returns the string which the user enters in the box.
len specifies the length of the string box(where appropriate). This is
particularly useful for the information dialogs. For dialog types 5-16 it is
not need as Superbase sets the box to the maximum file name length of 50
characters. For dialog type 4 len must be specified.

Types of Dialogs available:

TYPE	DIALOG			BUTTONS
0	string			OK
1	string			OK CANCEL
2	string			OK
3	string			OK CANCEL
4	string			OK CLEAR CANCEL
5	Database Files		OK CLEAR CANCEL
6	Open Fields List	OK CLEAR CANCEL
7	Indexed fields		OK CLEAR CANCEL
8	Non indexed fields	OK CLEAR CANCEL
9	Field Info		OK CLEAR CANCEL 
10	Open Database Files	OK CLEAR CANCEL
11	Database Files		OK CLEAR CANCEL
12	Program Files		OK CLEAR CANCEL
13	Text Files		OK CLEAR CANCEL
14	Query Files		OK CLEAR CANCEL
15	Update Files		OK CLEAR CANCEL
16	Function Key Files	OK CLEAR CANCEL
17	Directory listing	OK CLEAR CANCEL
18	Subdirectory List	OK CLEAR CANCEL

Note that a database file must be open before dialogs 5 to 9 can be selected.

EXAMPLES
1	REQUEST "", "", 2, 
2	a%=0:a$="":REM initialize nvar and strvar
	REQUEST "Select a program", "", 5, a%, a$, 32
	IF a%=0 THEN ? "OK so you do not want to run a program":END
	CHAIN a$
3	a%=0:a$=":OPEN FILE "aaa"
	REQUEST "Select an Index", "", 7, a%, a$
	IF a%=0 THEN END
	INDEX a$
	lablook:a$="":REQUEST "Enter a key", "", 1, a%, a$, 15
	IF a%=0 THEN END
	SELECT KEY a$
	IF FOUND ("aaa") THEN GOTO lablook2
	REQUEST "No Record with key" + a$, "See Nearest ?", 1a%
	IF a%=0 THEN GOTO lablook
	lablook2:VIEW:WAIT FOR 5:GOTO lablook

NOTES
Example 1 puts an "OK" dialog up for 2 seconds. Example 2 allows the user to
select a program to run. Example 3 in essence duplicates the key lookup
function from the ? button on the Superbase Control Panel. Note the
concatenation of the first title line of the dialog on the third from last
line.

RESTORE
PURPOSE
Moves the data pointer back to the first DATA statement, or to a specified
label.

SYNTAX
RESTORE[label]

COMMENTS
The data pointer is the internal pointer that Superbase uses to keep track of
which DATA statements have been read. Initially it has a value of zero and
points to the first DATA statement. As you READ data into variables or fields, 
the d the box. len specifies the length of the string box(where appropriate). 
This is particularly useful for the information dialogs. For dialog types 5-16 
it is not need as Superbase sets the box to the maximum file name length of 50
characters. For dialog type 4 len must be specified.

Types of Dialogs available:

TYPE	DIALOG			BUTTONS
0	string			OK
1	string			OK CANCEL
2	string			OK
3	string			OK CANCEL
4	string			OK CLEAR CANCEL
5	Database Files		OK CLEAR CANCEL
6	Open Fields List	OK CLEAR CANCEL
7	Indexed fields		OK CLEAR CANCEL
8	Non indexed fields	OK CLEAR CANCEL
9	Field Info		OK CLEAR CANCEL 
10	Open Database Files	OK CLEAR CANCEL
11	Database Files		OK CLEAR CANCEL
12	Program Files		OK CLEAR CANCEL
13	Text Files		OK CLEAR CANCEL
14	Query Files		OK CLEAR CANCEL
15	Update Files		OK CLEAR CANCEL
16	Function Key Files	OK CLEAR CANCEL
17	Directory listing	OK CLEAR CANCEL
18	Subdirectory List	OK CLEAR CANCEL

Note that a database file must be open before dialogs 5 to 9 can be selected.

EXAMPLES
1	REQUEST "", "", 2, 
2	a%=0:a$="":REM initialize nvar and strvar
	REQUEST "Select a program", "", 5, a%, a$, 32
	IF a%=0 THEN ? "OK so you do not want to run a program":END
	CHAIN a$
3	a%=0:a$=":OPEN FILE "aaa"
	REQUEST "Select an Index", "", 7, a%, a$
	IF a%=0 THEN END
	INDEX a$
	lablook:a$="":REQUEST "Enter a key", "", 1, a%, a$, 15
	IF a%=0 THEN END
	SELECT KEY a$
	IF FOUND ("aaa") THEN GOTO lablook2
	REQUEST "No Record with key" + a$, "See Nearest ?", 1a%
	IF a%=0 THEN GOTO lablook
	lablook2:VIEW:WAIT FOR 5:GOTO lablook

NOTES
Example 1 puts an "OK" dialog up for 2 seconds. Example 2 allows the user to
select a program to run. Example 3 in essence duplicates the key lookup
function from the ? button on the Superbase Control Panel. Note the
concatenation of the first title line of the dialog on the third from last
line.

RESTORE
PURPOSE
Moves the data pointer back to the first DATA statement, or to a specified
label.

SYNTAX
RESTORE[label]

COMMENTS
The data pointer is the internal pointer that Superbase uses to keep track of
which DATA statements have been read. Initially it has a value of zero and
points to the first DATA statement. As you READ data into variables or fields, 
the data pointer is increased by one for every data item read.
This command resets the data pointer. If you do not specify label, the data
pointer is reset to the beginning of the first DATA statement. If you specify
label, the data pointer is reset to the data statement following the label.

EXAMPLES
1	RESTORE
2	RESTORE datalabel1

RESUME
PURPOSE
Resumes execution after an error.

SYNTAX
RESUME[NEXT/label]

COMMENTS
The RESUME command works in conjunction with the ON ERROR GOTO command which 
is used to trap program errors.
RESUME, on its own, returns program control to the statement that caused the
error. When NEXT is included, the statement returns program control to the
statement after the one which caused the error.
label transfers program control to the label specified.

EXAMPLES
1	REM Top of program
	ON ERROR GOTO errlab1
	SELECT FIRST:? fieldname
	.....
	.....
	errlab1:IF ERRNO=44 THEN OPEN FILE "aaa":REM file not open
	RESUME
2	REM read data
	ON ERROR GOTO errlab2
	.....
	READ x$
	.....
	endread:.....
	.....
	.....
	errlab2:IF ERRNO=18 THEN RESUME endread:REM out of data

RETURN
PURPOSE
Returns from a subroutine.

SYNTAX
RETURN

COMMENTS
The RETURN command is used to mark the end of a subroutine. It instructs the
computer to transfer prgram control to the statement immediately following the 
GOSUB or ON GOSUB statement which initially called the subroutine. See GOSUB.

RIGHT$
PURPOSE
Extracts one or more characters from a text string or text field, starting from 
the right-hand end of the string.

SYNTAX
RIGHT$(strexpr, nexpr)

COMMENTS
This function starts at the right of a string given in strexpr and extracts
nexpr characters.

EXAMPLES
1	textfieldc=RIGHT$(textfielda, 10)
2	textfieldc=LCASE$(RIGHT$(textfielda, 1))
3	IF RIGHT$(textfielda, 1)="s" THEN....
4	x$=RIGHT$("ABCD", 2)
5	x$=RIGHT$(x$, 4)

RND
PURPOSE
Returns a random number.

SYNTAX
RND(nexpr)

COMMENTS
What the function returns depends on the value of nexpr.
It nexpr is less than zero, the random number generator is reseeded. This 
means that a new series of random numbers will be generated, completely 
unrelated to the last series. It also allows you to generate the same series 
again for testing purposes, by entering the same seed.
If nexpr is zero, the number returned is the same as the previous one.
If nexpr is positive, a new random number is generated.
The random number returned is in the range 0 to 1. Technically, it is never 
zero and never unity, but all values between 0 and one will be randomly 
generated and the distribution of numbers will be relatively flat.

EXAMPLES
1	numfieldc=RND(numfielda)
2	numfieldc=RND(2) * 12
3	textfieldc=MID$(x$, RND(2) * 6 + 1, RND(2) * 12 + 1)
4	$x=RND($y)
5	? RND($x)

ROW
PURPOSE
Returns the row position of the cursor on the screen.

SYNTAX
ROW(0)

COMMENTS
This function shows how far down the screen the cursor is. For the column
position, see COL.

EXAMPLES
1	x%=ROW(0)
2	? ROW(0)

NOTES
In practise, example 2 would be pointless, because it changes the position of
the cursor in the course of printing it.

RUN
PURPOSE
Executes a program from memory, or loads it from disk and then runs it.

SYNTAX
RUN[filename]

COMMENTS
This will run the program currently in memory when used as a command or as a
program statement without the filename option. If filename is used to specify 
a program, Superbase loads the program from disk and then runs it.
If filename is specified, it must be a string variable or a string constant 
in quotation marks.

SAVE
PURPOSE
Saves any of the following types of file:program, text, function key, query, 
and update files.

SYNTAX
SAVE [TEXT/KEY/QUERY/UPDATE]filename[, TEXT]

COMMENTS
filename is required. Superbase detects files of different types as follows:
	aaa.sbk is a saved function key set
	aaa.sbp is a saved program
	aaa.sbq is a saved query
	aaa.sbt is a saved document(text)
	aaa.sbu is a saved update
If none of the options TEXT, KEY, QUERY or UPDATE is used, Superbase assumes 
that filename refers to an '.sbp' file and attempt to save a program file. If 
you include TEXT as the last parameter, DML saves a program file as a text file.
Only one of the options, TEXT, KEY, QUERY or UPDATE, can be used at a time.

SAVE FILE
PURPOSE
Saves the current file definition.

SYNTAX
SAVE FILE sbfname

COMMENTS
When you create a new file, you can use MAKE to save the file definition. 
SAVE FILE, however, must be used after you have edited a file definition 
with MODIFY.

SAY
PURPOSE
Converts a text string into speech, using the Amiga's speech synthesis facility.

SYNTAX
SAY [USING parameters]exprlist

COMMENTS
SAY is only available on the Amiga. The parameters for the USING option are in 
this order:
	Pitch, Inflection, Rate(wpm), Sex, Phonemic
The following table gives the range of each parameter and its default value:

PARAMETER	RANGE		DEFAULT		NOTES
Pitch		65-320		110
Inflection	0-1		0		0 is expressive, 1 is monotone
Rate in wpm	40-400		150
Sex		0-10		0		0 is male, 1 is female
Phonemic	0-1		0		0 translates to phonemes, 
							1 assumes phonemes

SAY only works with string expressions. To hear an external sound field use 
the SHOW command.

EXAMPLES
1	OPEN FILE "Address"
	SELECT FIRST
	WHILE NOT EOF("Address")
	SAY Forename;Lastname;"comes from";City;Country
	SELECT NEXT
	WEND
2	SAY USING 280, 1, 200, 1, 0"Hello there", USING 140, 1, 200, 0, 0
	"Well, hello there"

SCRDUMP
PURPOSE
Outputs a copy of the screen to the printer-carries out a screen dump.

SYNTAX
SCRDUMP

COMMENTS
Only available on the Amiga.

SECS
PURPOSE
Returns the numbers of seconds from a time field.

SYNTAX
SECS(nexpr)

COMMENTS
nexpr will usually contain a time in milliseconds(thousandths of a second)
from a time field or from the result of a TIMEVAL calculation.

EXAMPLES
1	scnds%=SECS(timefield)
2	scnds%=SECS(TIMEVAL("10:22AM"))

SELECT COMMANDS
The following SELECT commands relate to Record selection:
	SELECT CURRENT
	SELECT DUPLICATE
	SELECT FIRST
	SELECT KEY
	SELECT LAST
	SELECT NEXT
	SELECT PREVIOUS
	SELECT REMOVE
	SELECT WHERE

SELECT commands can only be used on an open database file, although this does
not have to be the current file.
These commands do not display records on screen. To do this, you need to use
VIEW. Similarly, although they can be used with any open file, the SELECT
commands do not automatically make an open file the current file.
For example, SELECT LAST selects the last record in a file(on index)even if 
the file is not current. If the file is current, executing the VIEW command 
will be enough to display the last record. But with any other open file, you 
will also need to use the FILE command(as opposed to the FILE parameter)before 
you can display the record(FILE makes an open file the current file).

SELECT CURRENT
PURPOSE
Selects the current record.

SYNTAX
SELECT CURRENT [FILE sbfname] [INDEX index]

COMMENT
This command has the same effect as the Current Record button on the Control
Panel at the bottom of the screen. Use INDEX to select the current record using 
a different index.

SELECT DUPLICATE
PURPOSE
Selects the next record with the same key.

SYNTAX
SELECT DUPLICATE [INDEX index]

COMMENTS
This command finds the next record with the same key as the current key. The
key is the field on which the file is currently indexed. If SELECT DUPLICATE
fails to find a record with the same key, the EOF function is set to true.

1	SELECT FIRST:VIEW:x%=1
	lab1:SELECT DUPLICATE
	IF NOT EOF("aaa")THEN VIEW:x%=x% + 1:GOTO lab1
	? "End of ";x%; "duplicates-strike key"
	lab2:SELECT PREVIOUS:SELECT NEXT:IF EOF("aaa")THEN END
	CLS:VIEW:GOTO lab1
Example 1 displays duplicate entries on an index. In Table view, it shows a 
set of records at a time.

SELECT FIRST
PURPOSE
Selects the first record in the current or specified index sequence.

SYNTAX
SELECT[FILE sbfname] [INDEX index]

COMMENTS
This command has the same effect as the First Record button on the Control
Panel. Use the INDEX parameter to alter the current index.

EXAMPLES
1	SELECT FIRST
2	SELECT FIRST "Stock" INDEX Prodcode

NOTES
Example 1 selects the first record in the current file according to the 
current index. Example 2 selects the first record in the Stock file 
according to the Procode index.

SELECT KEY
PURPOSE
Selects the first record with matching string.

SYNTAX
SELECT KEY string [FILE sbfname] [INDEX index]

COMMENTS
This command has the same effect as the Key Lookup button on the Control Panel.
It searches the file for the first record whose index field matches the string 
specified.
Unlike the other SELECT commands, this command does not affect the EOF 
function, but instead sets the FOUND Function(see the example given for 
FOUND).

EXAMPLES
1	SELECT KEY "Zollinger"
	VIEW
2	SELECT KEY "Johnson" FILE "Customer" INDEX Lastname
	IF FOUND("Customer")THEN FILE "Customer":VIEW

NOTES
Example 1 selects the record in the current file whose Lastname field contains 
the name Zollinger. It assumes that the current file is indexed on Lastname.
The program in example 2 selects the record in the Customer file whose 
Lastname field contains the name Johnson. The Customer file must have already 
been opened, but it does not have to be the current file. If the program finds 
a record with a matching key, it uses the FILE command to make the Customer 
file current and then displays the record.

SELECT LAST
PURPOSE
Selects the last record in the current or specified index sequence.

SYNTAX
SELECT [FILE sbfname] [INDEX index]

COMMENTS
Has the same effect as the Last Record button on the Control Panel.

SELECT NEXT
PURPOSE
Selects the next record in the current or specified index sequence.

SYNTAX
SELECT NEXT [FILE sbfname] [INDEX index]

COMMENT
Has the same effect as the Next Record button on the Control Panel.

SELECT PREVIOUS
PURPOSE
Selects the previous record in the current or specified index sequence.

SYNTAX
[FILE sbfname] [INDEX index]

COMMENTS
This command has the same effect as the Previous button on the Control Panel.

SELECT REMOVE
PURPOSE
Removes the current record in the current file or another open file.

SYNTAX
SELECT [FILE sbfname]

COMMENTS
This command has the same effect as the Remove option on the Record menu.

SELECT WHERE
PURPOSE
Selects first record that matches the filter conditions or removes the filter.

SYNTAX
SELECT WHERE[[FILE sbfname] [conditions]]

COMMENTS
This command has the same effect as the Filter button on the Control Panel.
conditions is set up in the same way as the string gadget in the Filter
requestor. If not specified, the current filter conditions are cleared.
SELECT WHERE can only be used to set a single file filter. If you enter the
name of a field which also occurs in another open file, you should include 
the file the file name as an extension. Otherwise, Superbase may assume you 
are attempting to use this command in a multi-file operation, and will issue 
the error message:
	Can't do this
	This Where statement must be single file
If you wish to set a multi-file filter - to select records whose field data
matches the data in another file - use the LOOKUP function or the query
language command WHERE.

EXAMPLE
1	SELECT WHERE fielda LIKE "[a-c]"
2	SELECT WHERE "Stock" fieldb LIKE "[a-c]"
3	SELECT WHERE

NOTES
Once set, the Control Panel filters remains active until it is cleared. 
Example 3 clears the filter which may have been set by a previous SELECT 
WHERE command or by direct entry in the filter dialog.

QUERY LANGUAGE COMMANDS
DML's Query Language commans allow you to create a program which duplicates a
Superbase query. These commands are used in report programs created by the
Forms Editor; but they can also be used for any of the query applications
described in Chapter 11, Volume 1 - sorting records, creating complex multi-
file filters, merging files, and so on.
In Superbase a query is defined by the four command lines in the query
definition dialog(Chapter 5, Volume 1, introduces this dialog;Chapter 11 
explains it in more detail). These command lines can be reproduced in a 
program by using the query language commands. SELECT is used to define the 
Fields command line;
REPORT defines the Report command line;WHERE corresponds to the FILTER line; 
and ORDER is used for the Order line.
You will find a explanation of these commands under their respective keyword
entries. Here, we will describe how they work together to form a query section.
A query section must start with the SELECT command and it should end with END
SELECT. Any other query language commands are optional;you will include them
according to your requirements. Thus, if you wish to use a filter, you will
include a WHERE command within the query section.
Likewise, if you wish to use reporting functions such as SUM and COUNT, you 
will need to insert a REPORT command after the SELECT command and before END 
SELECT. You can think of REPORT, WHERE and ORDER as modifying the query output 
which is specified with the SELECT command. When SELECT is used on its own - 
to form a single line query section - it outputs data from each record in a 
specified file(or files)in turn. For example:
	SELECT Lastname.Address, Country.Address:
	END SELECT
This outputs a line showing the contents of the fields Lastname and Country 
for each of the records in the Address file. As such, SELECT works in the same 
way as the ? command except that it acts on all the records in a file.
If you inserted TO PRINTER after Country.Address in the example above, SELECT
would output data to the printer. The TO device parameter provides an
equivalent to the Output options in the query definition dialog. You can use 
to specify an output device other than the screen:the printer, an ASCII file, 
or a new '.sbf' file.

A QUERY LANGUAGE EXAMPLE
Any query created with the query definition dialog can be reproduced under
program control. We can illustrate this by converting a query file(an '.sbq'
file)into a program, taking the Deptran file supplied with the demonstration
file disk as an example.
Deptran can be displayed on screen using the LIST option from the System menu.
It looks like this:
	SB
	CLIENTS
	DEPOSITS
	Deposit Transaction Report
	ON "Clients" Firstname.Clients, Lastname.Clients, ON "Deposits"
	@24 Bank, Amount, Deposits
	REPORT SUM Amount COUNT GROUP Lastname.Clients SUM
	Amount
	Lastname.Clients=Lastname.Deposits
	Lastname.Clients
SB on the first line indicates that this is a Superbase Professional query 
file as opposed to one created in Superbase Personal. The next two lines 
contain the names of the database files which are associated with this query. 
'Deposit Transaction Report' is the query title, and the remaining lines 
represent the four query command lines.
Before we can load this file into the Program Editor, we need to change 
its name to Deptran.sbp. To do this, select COPY from the System menu and, 
after selecting Deptran.sbq as the file to be copied, enter then name 
Deptran.sbp.
You can now load the file into the Program Editor using the Program open
option. Coverting it to a program is just a matter of deleting two lines and
inserting keywords in the others. Once you have made these changes, the 
program should look like this:
	OPEN FILES "CLIENTS"
	OPEN FILE "DEPOSITS"
	SELECT ON "Clients" Firstname.Clients, Lastname.Clients, ON
	"Deposits" @24 Bank, Amount, Deposits
	REPORT SUM Amount COUNT GROUP Lastname.Clients SUM
	Amount
	WHERE Lastname.Clients=Lastname.Deposits
	ORDER Lastname.Clients
Note that the report line is the same as in the query file and does not need
to be altered. If you now run this program, it will have the same effect as
running Deptran from the query definition dialog(by clicking on OK).

SELECT
PURPOSE
Specifies which are to be output from a query.

SYNTAX
SELECT [params]firlds[TO device]:[statements]:END SELECT

COMMENTS
SELECT is a Query Language command and can used on its own or with other Query
Language commands to form a query section. fields can be one or more field 
names from one or multiple files.params can be any of the output format 
parameters as listed in the section which describes the ? commands.
In addition, there are three format parameters which can only be used with 
the SELECT command:ON file, AS heading and FIELD. The syntax and function 
of these parameters in described in their respective sections in Chapter 11, 
Volume 1.
TO device specifies the device to which the query output will be sent. If it 
is not included output is to the screen. The device options are:
	TO PRINTER
Outputs to the printer.
	TO FILE file
Creates a new '.sbf' file on disk under the file name specified, using the query
output.
	TO file
Outputs to the ASCII file on disk specified by file.
statements can be other query language statements formed with the commands
REPORT, WHERE, and ORDER.
END SELECT is used to indicate the end of a query section. It is not always
necessary to include END SELECT, but you must provide Superbase with some
indication of where the query section finishes and where the rest of the
program starts. Otherwise, the statements following the last line in the query 
section will be interpreted as part of a multi-line SELECT statement. As an 
alternative to END SELECT, you could use a blank line.

SER
PURPOSE
Returns the total number of records that have been created in a file.

SYNTAX
SER(filename)

COMMENTS
You can use the SER function to assign a serial number to each record in a
file. To do this, you need to define a field which will hold the serial number.
It should be defined as a constant field and should have SER("filename")as its
constant formula. When you create the first record, it will be given the value 
1. This value will then be incremented by one for each record you add to the 
file.
The difference between SER and RECCOUNT is that SER gives the total number of
records that have been created, irrespective of whether they have been deleted 
later. RECCOUNT returns the number of records currently in the file.

1	? SER("Stock")
2	BLANK
	Recno.Stock=SER("STOCK")
	Price.Stock=14.95
	Description.Stock="Widget"
	STORE

SET
PURPOSE
Reads a text file and executes any commands in the file, or assigns variables
from a text file.

SYNTAX
SET filename

COMMENTS
This command reads in a text file and executes it as if it were a sequence of
command. The file, therefore, must contain valid DML commands. If the file 
holds a set of variables-which have previously been saved to disk by ? MEMORY
-the variable assignments are executed. This provides a way of transferring 
variables between different programs when CHAIN is not appropriate. For 
example, Program 'a' can set up variables for Program 'c', but Program 'a' 
CHAINs to Program 'b'. Another application would be to communicate variables 
between different programs which are run on different days.


.

EXAMPLES
1	......
	process a
	......
	OPEN "aaa" FOR OUTPUT:? MEMORY:CLOSE OUTPUT:DISPLAY
	another program
	SET "aaa"
	......
	process b
2	SET "abc"
'abc' could be ASCII file which contains a set of function key assignments.

SET BUFFERS
PURPOSE
Sets the number of buffers Superbase uses as a disk cache.

SYNTAX
SET BUFFERS nexp

COMMENTS
Operates in the same way as the Buffers option in Set Menu Options, and
allocates 512 bytes memory space for each buffer.
nexp can have a value from 1 to 99.

EXAMPLES
1	SET BUFFERS 24

SET PAGING
PURPOSE
Sets paging on or off.

SYNTAX
SET PAGING[ON/OFF]

COMMENTS
When used without ON/OFF, it acts as toggle and operates in the same way as the
SET-PAGING menu options. With ON or OFF, it sets paging accordingly.

EXAMPLES
1	SET PAGING OFF

SET VIEW MODE
PURPOSE
Sets the view mode or switches between one of the view modes and a Form.

SYNTAX
SET [TABLE]/[FORM]/[RECORD]

COMMENTS
Works in the same way as the equivalent Set Menu option, except that it does 
not automatically display a record(use VIEW).
If a Form(as opposed to Form view)is displayed, the SET command switches the
Form off and selects the specified view mode. The Form remains in memory and
can be switched on again by repeating the SET command for the same view mode.
In other words, when a Form has been opened, the SET command toggles the 
current view mode on and off.

EXAMPLES
1	SET FORM
2	SET TABLE:VIEW

SGN
PURPOSE
Finds the sign of a number.

SYNTAX
SGN(nexpr)

COMMENTS
This function returns the positive value of 1 if nexpr is positive and returns
the negative value -1 if nexpr is negative.

EXAMPLES
1	numfieldc=SGN(numfielda)
2	IF SGN(datefielda-datefieldb)THEN GOTO lab1
3	x%=SGN(y%)
4	x%=SGN(y% * numfielda * (datefielda-datefieldb))
5	x%=SGN(VAL(RIGHT$(textfielda, 5)))
6	? SGN(x%)

NOTES
Example 2 tests whether datefieldb is later than datefielda

SHOW
PURPOSE
Shows an external file.

SYNTAX
SHOW [field]/[strexpr]

COMMENTS
SHOW is the program equivalent of the camera button at the bottom of the
screen. It displays a picture or text from an external file.field must be a
field which holds the name of the external file, but it does not have to be a
field in the current file:if you add a file name extension to the field name, 
you can display pictures using other open database files.
As an alternative to specifying an external field, strexpr allows you to 
specify the name of an external file.
When field or strexpr is not given, SHOW removes the picture from the screen.

SIN
PURPOSE
Returns the sine of an angle measured in radians.

SYNTAX
SIN(nexpr)

COMMENTS
This function returns the sine of the angle in nexpr, where the angle is
measured in radians. To convert degrees to radians, multiply by 180/PI.

EXAMPLES
1	numfieldc=SIN(numfielda)
2	x%=SIN(y%)
3	x%=SIN(VAL(x$))
4	? SIN(x%)

SPACE$
PURPOSE
Fills a string with a specified number of spaces.

SYNTAX
SPACE$(nexpr)

COMMENTS
nexpr must be in the range 0 to 255.

EXAMPLES
1	textfieldc=SPACE$(10)
2	x$=SPACE$(4)

SQR
PURPOSE
Returns the square root of a number

SYNTAX
SQR(nexpr)

COMMENTS
The function returns the square root of the number specified by nexpr. If 
nexpr is less than zero, the function returns the error message 'ivalid 
umber'.

EXAMPLES
1	numfieldc=SQR(numfielda)
2	numfieldc=SQR(2 * numfirlda)
3	textfieldc=STR$(SQR(VAL(x$)))
4	x%=SQR(y%)

STORE
PURPOSE
Stores the current record in the current file or in the file specified.

SYNTAX
STORE[, 0/1/2] [FILE sbfname]

COMMENTS
This command stores the record in memory for the current file, or for the 
file specified with sbfname.
It is equivalent to the Save option on the Record menu.

The numeric parameters - 0, 1 or 2 - allow you to specify whether the record
is stored in batch mode or in the normal way(see the section on Batch in 
Chapter 5, Volume 1).
STORE, 1 stores the current record in batch mode. The time taken to save the
record on disk will be reduced, but the data will not yet be secure:if you
suffer a power loss, you will lose any record data which has been saved(in 
the current session)using this option. Note that STORE, 1 only turns on batch 
mode for the current record.STORE, 2 does not store a record but makes the 
file secure. Any records th
at have been saved previously with the STORE, 1 command will now be made safe 
on disk. You should always execute a STORE, 2 command after storing records 
in batch mode.
STORE, 0 is optional and is the same as STORE on its own:Superbase makes each
record secure as it is stored. If you were to turn the computer off
accidentally, the most you would lose would be the data in memory.

EXAMPLES
1	BLANK
	Firstname="John"
	Lastname="Roberts"
	Street="15 Richmond Way"
	......
	......
	......
	STORE
2	FOR n%=1 to 10
	BLANK
	Firstname=Recdata$(n%, 1)
	Lastname=Recadata$(n%, 2)
	Street=Recdata$(n%, 3)
	......
	......
	......
	STORE, 1
	NEXT
	STORE, 2

NOTES
The first example creates a new record and stores it in the normal way. 
Example 2 creates ten new records, reading data into the fields for each 
record from the array Recdata$ and storing them in batch mode. When all 
the records have been stored, it makes
 the file secure with the STORE, 2 command.

STR$
PURPOSE
Returns the text equivalent of a numeric expression.

SYNTAX
STR$(nexpr [[, nexpri [, nexprd]]/[, numeric-format-string]])

COMMENTS
STR$ converts data which is held in a numeric variable or numeric field into 
a text string.
nexpri specifies the number of integers before the decimal point and should 
be set large enough to avoid overflow display. nexprd specifies the number of
integers after the decimal point. The maximum numeric format in Superbase is 
a total of 13 integers, so nexpri plus nexprd must be less than 14. As an
alternative to using nexpri and nexprd, you can specify the numeric format 
as a string(see NUMBASE). If these parameters are not used, the default numeric
format set by Numeric Format on the Set menu or by the most recent use of
NUMBASE will be taken. The complementary function to STR$ is VAL.

EXAMPLES
1	textfieldc=STR$(numfielda)
2	textfieldc-STR$(numfielda, 5, 0)
3	x$=STR$(165.4444, "z999999.00")

TAN
PURPOSE
Returns the tangent of an angle measured in radians.

SYNTAX
TAN(nexpr)

COMMENTS
The function returns the tangent of the angle in nexpr measured in radians. 
The complementary function of TAN is ATN.

EXAMPLES
1	numfieldc=TAN(numfielda)
2	x%=TAN(y%)
3	x%=TAN(VAL(x$))
4	? TAN(x%)

THOUSECS
PURPOSE
Takes a numeric value and returns the number of thousandths of a second left
over after subtracting the number of seconds.

SYNTAX
THOUSECS(nexpr)

COMMENTS
nexpr will usually contain a time in milliseconds from a time field or the
result of a TIMEVAL calculation. THOUSECS returns the same result as nexpr 
MOD 1000.

1	x%=THOUSECS(timefield)

TIME$
PURPOSE
Returns the time in string format from a numeric value which gives the time
in thousandths of a second.

SYNTAX
TIME$(nexpr [, timeformat])

COMMENTS
The second argument for this function, timeformat, allows you to specify the
format the time string will have. It must conform to the rules for Superbase
time formats given in the keyword entry for DATEBASE.

EXAMPLES
1	x$=TIME$(timefield)
2	? TIME$(NOW, "hh:mm:ssam")

TIMEVAL
PURPOSE
Returns the value of a time string in thousandths of a second.

SYNTAX
TIMEVAL(strexpr)

COMMENTS
strexpr must contain the time in a valid time format. See the keyword entry for 
DATEBASE for a list of acceptable time formats.

EXAMPLES
1	t%=TIMEVAL("10:22am")
2	t%=TIMEVAL("14:03:12.201")

TODAY
PURPOSE
Gives the system date.

SYNTAX
TODAY

End Of Part 1

