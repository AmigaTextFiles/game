
PuzzleBOBS graphic guide
------------------------

 Welcome to PuzzleBOBS graphic guide. This is a reference guide to make graphic elements for 
the PuzzleBOBS game.
 I hope to be clear in my words, however if you have some problems or if you find some
imperfections in this guide report them to me.
 Because i referr a lot of time to the same words, i have enclosed near the first used, between
parenthesis, an abbreviation of the term.  



1) Introduction
----------------

 PuzzleBOBS (PB) is a deeply configurable game in a lot of its aspects but the most important
is the graphical look because is able to change totally its parts and phases.
 The "graphic" of PB is the union of a group of graphical objects with several type of forms
and sizes which are linked into a sort of file, a "PuzzleBOBS ConfigFile" (CF) which contains
informations to define all these elements.
 A graphical object inserted, can deeply modify the behaviour of PB game by its form, own
characteristics and the time needed to be moved.

 The graphic could be draw in several ways. You could choose 3D rendered graphic, 2D graphic
or hand drawed graphic, but it has to be insert in game in the chunky format, because actually 
PB is able to manage planar data only.

 You can choose the size of all objects but you have to consider the screen you want for them,
so is better to choose its Width (W) and Height (H) before, even if they can be used in future
in a screen bigger than the your (for example if the user uses your set in a bigger screen's 
window).
 You have also to choose the depth of your screen (number of colours) even if this value could
be in future modifed.
 Actually PB has a bad approach with graphic source data, because uses the chunky format 1 byte
per pixel for data with depth <= of 256 colours and the chunky format 4 bytes per pixel (ARGB) 
for data with depth > of 256 colours.
 This is a limit but considering that is useless to use a 256 colours data in a 24 bit screen,
or use 16 Millions colours data in a 4 bit screen, it could be acceptable because allows to save
a lot of memory on disks and is usefull to maintain compatibility with Aga and Ecs bitmaps
(limited by 8 and 6 bitplanes maximum).
 So actually you have to choose a range of colours you want support, from 1 to 8 (from 2 to 256
colours) or from 9 to 24 bit (2 to 16 millions colours), converting your graphic in the relative 
chunky format.
 To convert data in the right chunky format you can use several type of programs that allow to
save in these three formats:

-the normal Chunky 1 byte per pixel.
-the ARGB 4 bytes per pixel (one of alpha channel).
-the palette format for LoadRGB32() system function.

If you use a <= 256 colours screen you have to save the palette in the LoadRGB32() format,
if you use a > 256 colours you don't need the palette.


 If you don't assign a palette to a screen with depth > 8, could happens that Intuition draws
wrongly the screen's requesters, as the Asl or errors reqs, in which the inscriptions aren't
readable.
 This could happens both on screens with depth > of 8, and on the other screens (<=8) in which
there is the same tonality in the first two colours registers, the 0 and 1.
 To allow the readable of inscriptions on 16 and 24 bit screens you can use a palette saved
from a 256 colours picture in which the colours registers 0 and 1 have two different and far
colour tonalities.
  


			/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\



2) Graphical Elements
----------------------

PB needs some elements to be played, these are:

-Bobs
-Columns
-Beam
-Principal Rotating Pointer
-Satellite Rotating Pointer(s)	   (optional)
-Support of Rotating Pointer	   (optional)
-Backgrounds
-Fonts
-Aim line
-Timer
-Level limit
-Explosion 			   (optional)
-Palette
-Clock
-Additional graphic elements (optional)

 These are the principal objects needed by PB (you can see them all in PIC0), in future probably
they will grow (bonus for example).
 An object with the "optional" label can be not done because isn't foundamental for game.
 Remember that when you draw an object, where you use the 0 colour (the first of all colours of
your palette) you will see the background accross, looks like a genlock action with colour 0 as
lock (in screens with > 256 colours the 0 coincides with black, [red,green,blu,alpha]=[0,0,0,0]).
 When you have done an object you have to declare its sizes W and H, sometimes for some of them 
the center of rotation or the number of frames or other values that i will explain you later.
 These values have to be inserted in your CF, so i will put each times for each objects the 
relative piece of CF in which you have to insert them.
 The sizes of them are free but i have inserted a paragraph in which i explain how find the 
optimal sizes considering a particular screen.




 /////////////////////////////////////////////////////////////////////\
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/

****
BOBS
****

 A BOB ([B]litter [OB]ject) is an element of a level in which we play and PB can manage a big
number of them.
 The Bobs are of two types: normal (NBobs) or special (SBobs).
 A NBob when goes near others of the same colour or aspect explodes with them (they have to 
be 3 minimum).
 A SBob looks like a NBob but has an unlike function, and PB foresees a large number of them.
 You can insert 12 NBobs maximum and all the foresee SBobs (actually are 8 types).
 This means that you can do a CF with only 8 NBobs without SBobs or one with 12 NBobs and 3
different types of SBobs.
 You can choose several type of levels sets to play with, they are "PuzzleBOBS LevelSet Files"
(LSF) and could be characterizated by a variable usage of NBobs and Sbobs in number, dependig
on its author.
 So the better way is to do a CF which has all the Nbobs and Sbobs foresees by PB, to have a
total compatibility with all LSF which could be done in future, but this aspect is based on
your choice.
 Because a SBobs has a particular function is better to try to draw its pointing at its usage,
while a Nbob have to be distinguished well from other NBobs.

 I list all SBobs foresees now, note that could grow in future.


-NORM=This is the normal ball. You can have a lot of them (max 12).
-BOMB=This is the bomb that is able to cause explosion of all its tangents.
-BOMBX=This is the bomb that cause explosion of no interrupted orizzontal lines.
-BOMBY=This is the bomb that cause explosion of no interrupted vertical lines.
-INERM=This is a ball unarmed that only bombs could eliminate.
-GAS=This is a ball that when free goes to the top of level and when arrives there explodes.
-ARCOB=This is able to explodes all balls in level that have the same color of the first ball
       collides with.
-SUBSTAIN=This is able to carry balls and only if becomes free from its tangents explodes.
-AIM=This when arrives to the final position, explodes and give to the player the aim line.

 A bob can have the size you want and can have different size and form respect others CF's bobs.
 You have only to define the size W and H of the bigger bobs of CF, this coincides with the
module of CF's bobs graphic data. (PIC 2)
 PB detects collisions not considering the size of module but considering the bob's real form,
which can influences deeply the playing look of game.
 You can use the 0 colour to see the background accross, where you have the 0 will not be 
detected a collision.
 Using this system you can apply the "hardware trasparency", a method by which you can give 
trasparency to a graphic element without lose speed in moving its.
 You have only to put a lot of 0 pixels in its surface, as you can see in PIC 1.
 Be careful because using this method you risk to lose the precision of collisions detection
so be sure to draw this bob with its perimetral surface without interruptions (PIC 1).
 This can be a very good effect but is better using this only in high resolutions, in 800*600 
on a 17" monitor is bad, for example.

 When you have done all bobs, you have to organize them in the right form for PB, this means
to put bobs vertically considering the module (PIC1).
 As i said before you can give to a bob the size you want, but pay attention that this could 
modify the game's behaviour.
 Infact if you have the bigger bob of set of 43*43 size and you have an other one of 20*20,
during game this bob will have different collision behaviour.
 This isn't a problem but choose this moderately.

 Finally the last characteristic is the animated set of bobs, which is optional. You can give
to your bobs a number < 256 of animation frames.
 If you want to make statically them you have to do as in PIC2, if you want give them some
animation frames do as in PIC3, putting anim frames orizzontally.

 This is the CF's piece in which you have to put values of your bobs set.

; -----
; Balls
; -----
6		;NUMBER (1-50) of balls in the graphic array.
1		;FRAMES (1-255) of anim of balls. If 1 you have only a frame.  Remember that all balls in graphic chunky file  must have the same number of anim frames.
55		;WIDTH (+) of bigger ball of set in graphic chunky array.
55		;HEIGHT (+) of bigger ball of set.
28		;WIDTH (+) of space between balls when near. If you have four tangs this value is not consider and tha game uses the WIDTH of a ball.If you have six tangs you can decide here which value to use as shift to right.
48		;HEIGHT (+) os space between balls when near.



 Here you have put six bobs only, with no animations (1 frame), The module is 55*55.
 After you have two values, 28 and 48. These are the distance between balls when near in 6
tangents mode. (PIC4)
 With these you have defined totally the bobs.




 /////////////////////////////////////////////////////////////////////\
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/

*******
Columns
*******

 A column circumscribes the level orizzontally and there the bobs rebound againsts.
 You have only to draw the left column because PB automatically does the right simmetric one.
 So there, where you use the 0 colour, you see the background across.
 The size is free, if it's too big vertically in fitting the screen is automatically cut in the 
bottom part, while orizzontally is not modified.
 For this reason is better don't make too big the W size, and because bobs in level are tangent
to its is better to do the internal side flat, moreover PB allows you to define a value which
moves columns to the center of the level. (PIC5)

CF's values:

; -------
; Columns
; -------
18		;WIDTH (+) of graphic chunky array that define the left column. The game will calculate with this the right column.
724		;HEIGHT (+) of graphic chunky array taht define the left column.
18		;WIDTH (+) of column that is out of array of balls. If it is as the WIDTH of column, the column is all out the ring.Else you can shift the column to the level.
6		;Y (+)	of start position of columns, Here you can define where columns have to be positioned from the top of screen.


 Here you have a 28*724 column. As you see you have a "18" value after, this means that the 
column has to respect its W size against the level.
 If you set this to 15, for example, means that you want columns to move to the level of 
18-15= 3 pixels. (PIC5)
 The last value is the start Y position from the top of screen.


 /////////////////////////////////////////////////////////////////////\
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/

****
Beam
****

 The beam (i named this as "beam" but i don't know is the right name) is the top rectangular
block that after some time moves to the bottom the entire level. You can do its with several 
sizes vertically and orizzontally because PB uses only the needed part.
 If it's too big orizzontally PB cuts its, if it's too small PB centers its.
 Because the Beam stays, during the game, in video ram is better draw its in the needed
size to save video ram, and because can took a lot of time to be moved orizzontally is better
to test its size in report with the need of speed.
 So here the 0 colour will pass background across (PIC6).

CF.s values.

; ----
; Beam
; ----
448		;WIDTH (+) of grapich chunky array that define beam over balls.
46		;HEIGHT (+) of graphic chunky array that define	 beam over balls.
4		;VALUE (+) of lateral movement of beam that push the balls array when it tremble.

 The last value defines the orizzontally movement to left and to right from the center position.


 /////////////////////////////////////////////////////////////////////\
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/

*****************************
Principal rotating pointer
Satellite Rotating Pointer(s) (optional)
*****************************


 The pointer (PO) is a group of rotating objects or of only one object, that helps the player to 
take the aim before fire his bob from the bottom of screen.
 For this reason has a very foundamental function and needs to be drawn very well to allow to 
the player to take the aim well and easily.
 The PO can be done with only one object, the principal rotating pointer (PRP) or with a group
of satellite objects, satellite rotating objects (SRP), which can have rotating centers and 
velocity different from the principal pointer.
 The rotating center of PRP is C_PRP(0,0), while a SRP can have a different center that can be
positioned for example at C_SRP(-10,30) from the 0,0.
 The velocity of PRP is always 1 and a SRP can have a velocity which is a moltiplier of 1, as *1 
(the same speed),*2,*3,*4,*8 time faster.
 A PRP can have several type of forms but must point to the direction that the bobs will take.
 A SRP can have several forms without restrictions but while the PRP has a range X,  0°<=X<=180° 
a SRP has a range Y 0°<=Y<=360° of rotation.
 Finally a SRP can have a draw priority respect the PRP, can be drawn before (under) or after 
(upon) the PRP.
 Bigger is the surface of a PRP or a SRP, bigger is the time needed by the CPU  to rotate its.
 Even in this case 0 colour leaves background to be seen across, and when you draw a PRP in the 
data file you have to do its orientating to 90° trigonometric degrees while a SRP can be drawn
in several orientations.
 Because i had adopt a very fast system to do rotations i have lose precision so in a range x   
between 30°<x<60° and 120°<x<150° could be seen the background trought the PRP's and SRP's 
surface. 
 For this reason is possible to activate the ZOOM option that allows to do smaller the final 
surface's size condensing pixels in a smaller region (PIC7).

CF's part.

; ----------------
; Rotation objects
; ----------------
1		;NUMBER (1-5) that define how many rotating objects have you. If you have only the principal pointer you must set this to 1.If you add some geares to your pointer you have to add them.
35		;WIDTH (+) of chunky rectangle of principal pointer.
100		;HEIGHT (+) of chunky rectangle of principal pointer.
18		;X of rotation center in chunky rectangular of principal pointer.
66		;Y of rotation center in chunky rectangular of principal pointer.
14		;VALUE (1-16) of precision of rotations.
0		;VALUE (0-255) of zoom of all rotation pointers. If you use zero it has no zoom and has dimensions defined in rectangular chunky array.
0		;FLAG (0-1) If you set it to 1 you want rotation procedures to be optimized else no optimizations.
1		;PRI (0-4) of principal pointer. If you set to 0 the principal pointer has lower pri than pri of other gears the second has pri 1 the third 2 etc. Consider that if you have two gears and principal pointer to have principal pointer over geares you have to set its pri to 2. if you set this to 3 you will have pri 0.
; first gear.
51		;WIDTH (+) of graphic chunky array that define the first gear of pointer.
51		;HEIGHT (+) of graphic chunky array that define the first gear of pointer.
25		;X of rotation center of first gear in the rectangular array from 0,0.
25		;Y of rotation center of first gear in the rectangular array from 0,0.
10		;X of distance of the rotation center of this gear from the rotation center of the pointer.
10		;Y of distance of the rotation center of this gear from the rotation center of the pointer.
-5		;MOLTIPLIER of the variation in degree of principal pointer. If you set this to 0 this gear will not move.
; second gear.
49		;WIDTH (+) of graphic chunky array that define the second gear of pointer.
49		;HEIGHT (+) of graphic chunky array that define the second gear of pointer.
24		;X of rotation center of second gear in the rectangular array from 0,0.
24		;Y of rotation center of second gear in the rectangular array from 0,0.
-10		;X of distance of the rotation center of this gear from the rotation center of the pointer.
10		;Y of distance of the rotation center of this gear from the rotation center of the pointer.
2		;MOLTIPLIER of the variation in degree of second gear. If you set this to 0 this gear will not move.


 If you set to 0 the value of zoom's factor you don't alter its size. With 1 you get the smallest 
size possible, while by 255 the second bigger one, 0 is the default size.
 Actualy CF allows to use only 1 PRP and 2 SRP, in future i will expand the number to 1 PRP and 
4 SRP.
 A rotating center of a rotating object have to be taken in its surface. The 0,0 stay to the left 
top corner of image.

 This is the rectangle of a rotating object of size 11 W and 7 H . The (0,0) stay to the left top 
corner.

0---.-----
|  /|\	  | The rotating center C is in position (3,4) from (0,0).
|   |	  | The x grows to the right and y grows to the bottom.
| --C--	  |
|   |	  |
|  _|_	  |
 ---------

 When you want set the rotating center of a SRP you use as (0,0) the rotating center of PRP.


	   |		A(-8,3), B(-3,2), C(10,0)
	   .
   A	  /|\		 A,B,C are 3 SRP,in 0 there is PRP's rotating center.
	   |
	   |
-----------0---------C-
	   |
	B _|_
	   |
	   |
	   |


 /////////////////////////////////////////////////////////////////////\
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/


***************************
Support of Rotating Pointer
***************************

 This support stay under the Pointer. Its dimension is free and the colour 0 leaves background
to be seen across.
 When you draw its you have to declare in CF the center which will have to coincide with the 
rotating center of PRP (See PIC7).



CF's part.

; -------------------
; Pointer Support
; -------------------
51		;WIDTH (+) of graphic chunky array that define the support that is under the principal poiner and substain it.
83		;HEIGHT (+) of graphic chunky array that define the support that is under the principal poiner and substain it.
26		;X of center that coincides with the rotating center of principal pointer.
26		;Y of center that coincides with the rotating center of principal pointer.


 /////////////////////////////////////////////////////////////////////\
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/

***********
Backgrounds
***********

 PB allows to use a lot of backgrounds, and they are placed under all other graphical objects of 
game.
 Could be drew how you want but its dimension has to coincide with the size W and H you have 
choose for your screen.



 /////////////////////////////////////////////////////////////////////\
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/

*****
Fonts
*****

 PB allows to insert in game two different fonts. One of them is used in the menu stage and to
draw all small word in the game phase, as the score and the level counter.
 The second is used to write the words at the beginning and at the end of a single level stage.
 For this reason the second font can have bigger sizes because when used we need to write few
words.
 Is also possible to insert only one font which is used in all phases, writing the same path of
the data file in all two string places in the CF. This allows to save some video memory.
 A font set (FS) is very different from the AmigaOs fonts system, because is organized in an
other way and are coloured.
 These keep the same palette of the screen (if colours are <= 256) and have to be positioned in
a particular array (PIC8).
 A FS uses only a part of ASCII set,letters from the value 32 (the space) to the value 126 
( the ~).
 These have to be organized in a rectangular array done of 6(x)*16(y) modules (PIC8).
 To find the module you have to consider all the letters, you have to find the max surface which
is occupied by all 6*16 letters when placed all in the same position.
 This rectangle coincides with the module and you have to declare its W and H in the CF.
 PB then will be able to find the right space that is needed between two letters of FS when
written.
 So there the colour 0 has the same function.


CF's values.
; -----
; Fonts
; -----
32		;WIDTH (+) in pixel of the bigger letter (module) of the large font set.The bigger letter is a form of the set and this value represent the max size.
25		;HEIGHT (+) in pixel of the bigger letter of the large font set.
22		;WIDTH (+) in pixel of the bigger letter (module) of the small font set.
15		;HEIGHT (+) in pixel of the bigger letter of the small font set.
1		;X in pixel between two letters of large font set when written.
2		;Y in pixel between two letters of large font set when written.
1		;X in pixel between two letters of small font set when written.
2		;Y in pixel between two letters of small font set when written.
1		;FLAG (0-1) if you set this to 1 you don't want to have the exact distance between letters but use the value of maximum width of a letter.

 /////////////////////////////////////////////////////////////////////\
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/

********
Aim Line
********

 PB allows the usage of an aim line which is very usefull to take better the aim before firing
a bob.
 This is characterizated by a single object (AOB) that is reuses a lot of times to draw a
continue line.
 This object looks like the bobs and all i explain for them is now valid for an AOB.
 An AOB can be animated with max 255 frames, can have several forms and sizes but because the 
aim line could be done by a large number of them is better to draw them small.
 If you use a lot of animation frames you don't slow down performances, the only disadvantage 
is a larger amount of video memomery needed.
 However you can use a lot of frames because the mem used is very small. (PIC9)

CF's values.

; --------
; Aim Line
; --------
5		;WIDTH (+) of graphic chunky array that define an element of aim line.
5		;HEIGHT (+) of graphic chunky array that define an element of aim line.
100		;NUMBER (1-255) of frames in graphic chunky array of aim line.
40		;VALUE (0-255) of distance of the first element of aim line from the rotation center of pointer.
13		;VALUE (0-16) that define speed of aim line elements.If you set this to zero you will have not linear movement of aim line element.I advise you to use values from 10 to 15.
13		;VALUE (0-16) that define the distance between two elements of aim line.
20		;NUMBER (+) of elements that define the aim line.More elements you have, slower is the speed of aim line. I advise you to not ask too many aim objects and use other method as to increase the distance between elements.
13		;SPEED (0-16) of an element of aim line.An Other value.???

 The first three values are important to define the AOB, while the rimanent values are used
to decide how many objects have to be repeat in the line, if they have to be in movement etc.

 /////////////////////////////////////////////////////////////////////\
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/

*****
Timer
*****


 In PB during the game if you don't fire your bob after some time it's automatically launched.
 For this reason, before this happens, a timer will count the time you still have.
 This time value is written in the LSF so it can change for each levelset.
 You have only to define an animation (a clock, a sandglass) with the number of frames you want 
(255 frames maximum).
 If the time is 10 seconds and you have done an animation with 20 frames a timer frame will be 
drawn every 10/2= (the game waits always the half of the time is passed) 5/20=0.25 seconds.
 You need to pay attention to the timer because can happens that the time needed by the 
machine to draw each frame exceed the time lapse, so it results expanded.
 This depends upon the performances of your machines.
 Draw its with at least 10 frames. (PIC10)



CF's values.

; -----
; Timer
; -----
37		;WIDTH (+) of grapich chunky array that define a frame of timer.
37		;HEIGHT (+) of grapich chunky array that define a frame of timer.
16		;NUMBER (1-255) of frames of timer animation.



 /////////////////////////////////////////////////////////////////////\
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/

***********
Level Limit
***********

 This is a stripe that is placed in the bottom of level and points to the gameover zone (that is
under).
 We can applix the same considerations done for the beam.
 Do that not too big vertically and so there the colour 0 system is valid. (PIC11)

CF's values.

; ---------------
; Game Over Limit
; ---------------
380		;WIDTH (+) of graphic chunky rectangle of stripe that define gameover limit.
2		;HEIGHT (+) of graphic chunky rectangle of stripe that define gameover limit.

*******
Palette
*******

 The palette defines the value of screen's colours. You have to draw and make a palette which 
is used for all elements of set, because all objects in game share the same palette source.
 You have to save its with a program able in saving the LoadRGB32() system function palette 
format. You will get a file of 3080 bytes of size.
 This when you save from a 256 colours data source, the size of a generic palette file is, with:
 n=number of colours of your screen (is a multplie of 2).

palette_bytes_size=4+2+2+n*(4+4+4)

 This because you have a triplets (RGB) of three longs for each colour plus 8 bytes which format
the structure.
 If your screen has more of 256 (>) colours the palette is not needed and PB will not read its 
from CF.
 For this reason you can put a 0 in the CF's palette string place.

**********
Explosions
**********


 PB allows actually two type of explosion looks. 
 One is totally done by the CPU which calculates pixel for pixel a movement which simulates a 
deflagration, reading BOB's pixels and colours from its own graphic data.
 The second is done by the blitter but needs a number of animation frames drew to this purpose.
 The first method is slower than the second one but saves a lot of video memory because works
on coordinates which stay in fast memory (public memory).
 The second is much faster but needs video memory where to place its animation frames.
 If you choose to use the first method you have only to put a "0" in the CF's string place about the 
explosion's graphic data (you can also enable its in the main game's menu).
 If you use the second method you have to put the string of your graphic file and to fill some 
values in CF.

These are:
  
; ---------------------------
; Graphic explosion extension  
; ---------------------------
0		;WIDTH (+) of an explosion's set frame in graphic data which defines explosion's animation.
0		;HEIGHT (+) of an explosion's set frame in graphic data which defines explosion's animation.
0		;X (+) from the top left corner of pixel in a single explosion frame which coincides with the left top corner of a bob's module. With this you can center the explosion animation.
0		;Y (+) from the top left corner of pixel in a single explosion frame which coincides with the left top corner of a bob's module. With this you can center the explosion animation.
1		;FRAMES (1-255) of animation frames.
0		;NUMBER (+) of animation sequences done. If you have 8 bobs in your set and you have done an animation for each you have to set this to 8. If you do only 4 animations you will have 8 bobs using them only (bob1->fr1,bob2->fr1,bob3->fr2,bob4->fr2,..).You can do only one animation to be used by each bob, putting 1 there. 

 The first and the second define the module of your explosion's bigger frame.
 The third and the fourth are coordinates with which you can center your animation defining
the distance in plane from the BOB's left top corner.
 Then you have a value which coincides with the number of frames done in the stripe and then a 
value which defines how many sequences you have done.
 If you have 8 BOBS and you have done 8 sequences you will have a sequence for each bob.
 If you set that value to 6 these will be recycled for the 7° and 8° bobs which will use the 
first and the second sequence.
 If you do only one sequence PB will use this for all bobs in game, allowing you to save a lot 
of video memory and time doing them. See PIC11.

*****
Clock
*****

 The clock is used by PB when the player chooses a LSF in which a level is time limited.
 This is done by a background and by a hand which stay on its.
 The background is a picture which represents the clock's body, can have the size you want but
considering that PB will place its on the screen's right side is better draw its not too big.
 See the "6) Optimal sizes and formules" chapter of this guide to find the best clock's sizes.
 Using the 0 colour in clock's or in hand's surface you will have the background pass through.
 The hand has the same behaviour of a rotating pointer, but can move itself in a range of
360°, and you have to draw its in the graphic data, oriented to 90 trigonometric degrees.
 All i wrote for rotating pointers as PRP and SRP is now valid for the Clock's hand.
 In the configuration file you have to put WIDTH, HEIGHT of clock's body, then the rotating
center (X,Y) in which will be positioned the hand, and the font used (small 0 or large 1) to 
write the number of seconds left to time finish (are written over the clock centered in its 
surface).
 The hand needs the WIDTH, HEIGHT, the rotating center (X,Y) in its rectangular graphic data
which will coincide with the clock's rotating center.
 Finally you have the hand's ZOOM value, so you can put a big hand to solve the approximation 
of game's rotation routines. See PIC12.   



CF's values.

; -----
; Clock
; -----
89		;WIDTH (+) of grapich chunky array that define the clock.
91		;HEIGHT (+) of grapich chunky array that define the clock.
44		;(+) X of rotation center that coincides with the rotating center of hand, from 0,0.
46		;(+) Y of rotation center that coincides with the rotating center of hand, from 0,0.
1		;FLAG (0-1) If you set 1 you have the clock respects the second, else with 0 divides the total time in 360 equal parts. 
60		;VALUE (0-360) Here you can choose how many seconds before the time finish, the clock must have written in letters, seconds left (with 0 never, with 360 all the time). 
0		;FLAG (0-1) If you set this to 0 you will have the SMALL FONT (0) for the numbers over the clock, else with 1 you will have the BIG FONT (1).
25		;PERCENTAGE (0-100) of screen's height that define the clock's y position.
; ------------
; Clock's Hand	
; ------------
15		;WIDTH (+) of grapich chunky array that define the clock's hand.
53		;HEIGHT (+) of grapich chunky array that define the clock's hand.
7		;(+) X of rotation center of hand in  the rectangular array from 0,0.
42		;(+) Y of rotation center of hand in  the rectangular array from 0,0.
0		;VALUE (0-255) of zoom of hand. If you use zero it has no zoom and has dimensions defined in rectangular chunky array.	
			/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\

**************************************
Additional graphic elements (optional)
**************************************

 PuzzleBOBS foresees the adoption of extra graphic elements to change the graphic look during
the game, at levels passage.
 You can insert 20 additionals groups of elements, in which for each one you can include a
new background, a new palette, a beam and a columns, writing their files path in the CF.
 When you want to change the background the beam or the column you need to change all them
in the same time, however you can change the background only writing again the name of
other elements file you have putted above in the CF.
 If you want to change the palette you have not limits, is needed to change the palette's path
only, leaving to "0" the others champs.
 When you change the background, the palette, or the beam you have to respect the original 
sizes you point to before in the CF, otherwise they will be bad drew on screen.
 The 20° element has a special function, it will be loaded only when the player arrives to
the LSF's last level.
 To activate an object you have to show its path, to disable one you can use "0".

The strings stay in the bottom of CF.   


;
;Others backgrounds, beams, columns and palettes (strings of).
;
;1°
PuzzleBOBS:gfx/sfondo1		;Background
0				;palette
PuzzleBOBS:gfx/beam		;beam
PuzzleBOBS:gfx/columns		;columns
;2°
0		;Background
0		;palette
0		;beam
0		;columns
;3°
0		;Background
0		;palette
0		;beam
0		;columns
;4°
0		;Background
0		;palette
0		;beam
0		;columns
;5°
0		;Background
0		;palette
0		;beam
0		;columns
;6°
0		;Background
0		;palette
0		;beam
0		;columns
;7°
0		;Background
0		;palette
0		;beam
0		;columns
;8°
0		;Background
0		;palette
0		;beam
0		;columns
;9°
0		;Background
0		;palette
0		;beam
0		;columns
;10°
0		;Background
0		;palette
0		;beam
0		;columns

.........................

 The first is an example, it changes the three graphic elements, and leaves the old palette.  



3) CF's other values.
----------------------

 In the config file you can see a lot of other variables with which you can modify deeply the
game's behaviour.
 Most of them can be changed after you have done all graphical elements, as the value of bobs 
speed in the system.
 But there are other very important values you have to insert before try the game.


SCREEN ID= This is the first value you see in CF and it's a code which identify the screen you
have choosen for game.
 I enclose in this guide a little program that is able to say you the Id, running its on the
Workbench's screen, with the size and the number of colours you want for game.
 You can use also some monitors or other programs able in, but if you get the ID in esadecimal, 
with the dollar "$" at the number's beginning, you have to convert its in decimal and write its 
directly in CF (in decimal, is a ten digits number).
 However you can also put a "-1" instead of the id, so PB will open an Asl Screen Mode Requester,
before opening the screen, by which you will be able to find the one you need for that.
 The requester's window has in the title a string with the dimensions written in the CF. The 
form is "ConfigFile= WIDTH,HEIGHT,DEPTH".

 SCREENDEPTH=Here you have to put the depth of screen choosen. The depth is the exponent 
with which you raise 2 to find the number of colours (2³=8). 3 is the depth, while 8 is the 
number of colours got.

SCREENW=Here you have to insert the Width of the screen or window.

SCREENH=Here you have to insert the Height of the screen or window.




; --------------------
; Screen confuguration
; --------------------
;
1342312448	;DISPALYID of screen. You must insert this as a decimal value. Normally IDS are written in esadecimal. If you use a window the game uses ID of WorkBench Screen.
800		;WIDTH (+) of window or screen.
600		;HEIGHT (+) of window or screen.
8		;DEPTH (+) of screen. If you use a window the game uses depth of Workbench screen.If you use non-amiga graphic devices you can not define this value becouse depth is in ID.
0		;FLAG (0-2) if set to (0) you use a screen, if you set to (1) you want a window and if you set to (2) you want a PIP window (Picture in Picture) but now only with Picasso96 and PicassoIV.
0		;FLAG (0-1) If 1 you want closeworkbench else 0 you don't want. If you use a window for game this flag is no consider. If you close workbench you get a lot of video memory.
0		;FLAG (0-1) With 1 you can have screen forcing the ratio as in 640*256 that is not 16:9,and with 0 you disable this choice.
1		;FLAG (0-1) Here you can choose if the main titles have to be done by Blitter (1) or faster by copper (0) (On Aga machines is better 0, and with a graphic board is better 1).
800		;WIDTH (+) of the area that you want dedicate to the array of balls. With this value you can limit the size of rectangle that cointains the array of balls and limit the need of video memory. This could activate the zoom of balls. PAY ATTENTION TO THIS VALUE because if balls become smaller is more difficult to play.
600		;HEIGHT (+) of the area that you want dedicate to the array of balls.
1		;FLAG (0-4) Here you can choose the mode of blitting. See the docs to choose method you want.
50		;PERCENTAGE (0-100) When you use the cooperative method between cpu and blitter, here you can set the percentage in blit height done by cpu. The rimanent will be done by amiga custom blitter.





			/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\

4) CF's strings.

 In the CF there is a part, the bottom part, in which you have to write the strings of all graphical 
objects of game.
 If you have an optional object as a SRP you can put 0 in the string place, and this will never read
 and used.
 This is the string block.


PuzzleBOBS:gfx/Hurricane			;STRING of background.
PuzzleBOBS:gfx/Bobs_8_43-43			;STRING of balls.
PuzzleBOBS:gfx/Colonna_26x516_8			;STRING of column.
PuzzleBOBS:gfx/Dolmen_464x198_8			;STRING beam.
PuzzleBOBS:gfx/Font_GEMINIblu_22_15		;STRING font set SMALL.
PuzzleBOBS:gfx/HurrPalette			;STRING palette of background.
PuzzleBOBS:gfx/Traie_5x5x100_8			;STRING aim objects.
PuzzleBOBS:gfx/limite_380x2_8			;STRING graphic limit of level.
PuzzleBOBS:gfx/fr_35x100_8			;STRING principal pointer.
PuzzleBOBS:gfx/fr_51x51_8			;STRING first gear.
PuzzleBOBS:gfx/ing_49x49_256			;STRING second gear.
PuzzleBOBS:gfx/Sostegno_51x83_8			;STRING object under the pointer.
PuzzleBOBS:gfx//ploing				;STRING Audio file.
PuzzleBOBS:gfx/Font_GEMINIblu_22_15		;STRING font set SMALL.
PuzzleBOBS:gfx/Timer2_37x37_16f_8		;STRING Timer.


			/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\


5) Final considerations.
------------------------

 One of the most important thing to say is that this game needs a lot of video ram because a lot
of graphical objects stay always in video mem to be used fastly when needed.
 You can try to minimize their dimension and sizes but consider how are structured the AmigaOS's 
bitmaps.
 A bitmap has always the Width as a multiple of 16 pixels. Even if you want allocate a bitmap
which has not the width as 16's multiple, when AmigaOS allocates its always rounds its width to
a multiple of 16 pixels.
 For this reason is better don't use values as 17-18 or 33-34 pixels width because for only one
or two pixels more, the amount of video mem needed doubles.
 Unsfortunately bigger is an element bigger is the time needed to be drawn by a blitter or cpu
chips, but this is real only on VGA chips, because for example the Amiga own Blitter when does a
blit (a single blitter operation) manages areas which are multiple of 16 (works on a word minimum).
 On a VGA blitter chip if you blit an area of 3 pixel this blitter works only on them three pixels
without works on a 16 multiple area.

 I told you that PB is able to accept a lot of LevelSetFiles (LSF). They can be variable because
in one of them we can have for example levels that have 8 bobs maximum orizzontally.
 For example others of them can have 12 bobs or more orizzontally, so the space needed 
orizzontally could grow a lot.
 This is not a problem for bobs, columns, rotating pointers and support, aim line, fonts, etc.
 We could get some problems only for the beam and for the gameover limit which can be not 
sufficient to fit the new bigger area.
 To solve this, you have two choices: one is to do very big the beam and the gameover's limit 
doing them for example of the same screen's width size.
 Infact PB is able to use only the needed part of the beam and of the gameover's limit.
 Unsfortunately this system needed a bigger amount of video memory.
The second possibility is using two values in the CF. These are in the screen's part.

; --------------------
; Screen confuguration
; --------------------
;
167940		;1  DISPALYID of screen. You must insert this as a decimal value. Normally IDS are written in esadecimal. If you use a window the game uses ID of WorkBench Screen.
640		;2  WIDTH (+) of window or screen.
512		;3  HEIGHT	(+) of window or screen.
8		;4  DEPTH (+) of screen. If you use a window the game uses depth of Workbench screen.If you use non-amiga graphic devices you can not define this value becouse depth is in ID.
0		;5  FLAG (0-2) if set to (0) you use a screen, if you set to (1) you want a window and if you set to (2) you want a PIP window (Picture in Picture) but now only with Picasso96 and PicassoIV.
0		;6  FLAG (0-1) If 1 you want closeworkbench else 0 you don't want. If you use a window for game this flag is no consider. If you close workbench you get a lot of video memory.
0		;7  FLAG (0-1) With 1 you can have screen forcing the ratio as in 640*256 that is not 16:9,and with 0 you disable this choice.
1		;8  FLAG (0-1) Here you can choose if the main titles have to be done by Blitter (1) or faster by copper (0) (On Aga machines is better 0, and with a graphic board is better 1).
640		;9  WIDTH (+) of the area that you want dedicate to the array of balls. With this value you can limit the size of rectangle that cointains the array of balls and limit the need of video memory. This could activate the zoom of balls. PAY ATTENTION TO THIS VALUE because if balls become smaller is more difficult to play.
512		;10 HEIGHT (+) of the area that you want dedicate to the array of balls.
3		;11 FLAG (0-4) Here you can choose the mode of blitting. See the docs to choose method you want.
50		;12 PERCENTAGE (0-100) When you use the cooperative method between cpu and blitter, here you can set the percentage in blit height done by blitter. The rimanent will be done by cpu.


 These are the 10° and 11° items. Here you can choose the maximum size of the area which will
contains the level.
 If you have for example 12 bobs orizzontally with 40 pixels of width you need 40*12=480 pixels 
orizzontally.
 But if you set the 10° value to 400 you force bobs to fit themselves into 400 pixels of size 
only, zooming them.
 Thanks to this method you are able to know the maximum size of level's width and automatically 
fix the beam's and the gameover's limit width.



6) Optimal sizes. Formules.
---------------------------

 Here i give you formules to find the best size of objects in game but you are free doing them
as you think better.
 I based my calculations considering a frequently situation, when we have two players playing 
at the same time in two levels with 8 bobs orizzontally and 11 vertically.
 Are valid only in screens with 1:1 of aspect ratio. For example if you want have a circle in a
640*256 screen it must have the height as a half of its width.


-scrx=Width of your screen.
-scry=Height of your screen.
-bobw=Width of bigger bob of a set.
-bobh=Height of bigger bob of a set.
-colonh=Width of column.
-colonw=
-beamw=Width of the beam.
-beamh=
-limitw=Width of gameover's limit stripe.
-limith=
-pointerw=Width of rectangule which contains rotating pointer in all its rotation's angles.
-pointerh=
-fontbigw=Width of the module of the bigger font.
-fontbigh=
-fontsmallw=Width of the module of the smaller font.
-fontsmallh=
-timerw=Width of timer's frame.
-timerh=
-suppw=Width of the pointer's support.
-supph=
-aimw=Width of an element in the aim line.
-aimh
-intw=This is the space between two players and screen sides.


See this drawing, the "|" is a column the "o" is a bob and "s" is a space (intw).

 s|oooooooo|s|oooooooo|s
 s|oooooooo|s|oooooooo|s
 s|oooooooo|s|oooooooo|s
 s|oooooooo|s|oooooooo|s
 s|oooooooo|s|oooooooo|s

The variable's values.
The "!" means a free value, but consider the time needed to move its.


beamw=bobw*8
beamh=!
limitw=beamw=bobw*8
limith=!
columnw=scrx/40
columnh=scry
intw=scrw/80
bobw=(scrw-3*intw-4*columnw)/16
bobh=bobw
pointerh=scrh/6
pointerw=? (depends from pointerh, rotating centers etc)
timerw=!
timerh=!
suppw=!
supph=!
fontsmallw=scrw/35
fontsmallh=scrh/40
fontbigw=2*fontsmallw
fontbigh=2*fontsmallh
aimw=scrw/160
aimh=aimw
clockw=scrw/8
clockh=clockw

